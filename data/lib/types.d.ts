
    /**
 * Contains PDFNetJS classes and functions
 */
declare namespace Core.PDFNet {
    /**
     * Converter is a utility class used to convert documents and files to PDF.
    Conversion of XPS, EMF and image files to PDF documents is performed internally.
    Other document formats are converted via native application and printing.
     */
    class Convert {
        /**
         * Method to create an AdvancedImagingConvertOptions object
         * @returns A promise that resolves to a PDFNet.Convert.AdvancedImagingConvertOptions.
         */
        static createAdvancedImagingConvertOptions(): Promise<PDFNet.Convert.AdvancedImagingConvertOptions>;
        /**
         * Method to create an OfficeToPDFOptions object
         * @param [json] - options in JSON format.
         * @returns A promise that resolves to a PDFNet.Convert.OfficeToPDFOptions.
         */
        static createOfficeToPDFOptions(json?: string): Promise<PDFNet.Convert.OfficeToPDFOptions>;
        /**
         * Method to create an XPSOutputOptions object
         * @returns A promise that resolves to a PDFNet.Convert.XPSOutputOptions.
         */
        static createXPSOutputOptions(): Promise<PDFNet.Convert.XPSOutputOptions>;
        /**
         * Method to create an XODOutputOptions object
         * @returns A promise that resolves to a PDFNet.Convert.XODOutputOptions.
         */
        static createXODOutputOptions(): Promise<PDFNet.Convert.XODOutputOptions>;
        /**
         * Method to create an TiffOutputOptions object
         * @returns A promise that resolves to a PDFNet.Convert.TiffOutputOptions.
         */
        static createTiffOutputOptions(): Promise<PDFNet.Convert.TiffOutputOptions>;
        /**
         * Method to create an HTMLOutputOptions object
         * @returns A promise that resolves to a PDFNet.Convert.HTMLOutputOptions.
         */
        static createHTMLOutputOptions(): Promise<PDFNet.Convert.HTMLOutputOptions>;
        /**
         * Method to create an EPUBOutputOptions object
         * @returns A promise that resolves to a PDFNet.Convert.EPUBOutputOptions.
         */
        static createEPUBOutputOptions(): Promise<PDFNet.Convert.EPUBOutputOptions>;
        /**
         * Method to create an SVGOutputOptions object
         * @returns A promise that resolves to a PDFNet.Convert.SVGOutputOptions.
         */
        static createSVGOutputOptions(): Promise<PDFNet.Convert.SVGOutputOptions>;
        /**
         * Convert the specified XPS document contained in memory to PDF
         * and append converted pages to the specified PDF document.
         * @param in_pdfdoc - the PDFDoc to append to
         * @param buf - the buffer containing the xps document
         */
        static fromXpsMem(in_pdfdoc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, buf: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray): Promise<void>;
        /**
         * @returns A promise that resolves to an object of type: "PDFNet.Reflow"
         */
        static createReflow(in_page: PDFNet.Page, json_zones: string): Promise<PDFNet.Reflow>;
        /**
         * Convert the specified plain text file contained in a buffer to PDF and append converted
         * pages to the specified PDF document.
         * @param in_pdfdoc - the PDFDoc to append to
         * @param fileData - the buffer containing the plain text document to convert
         * @param [options] - the conversion options. The available options are:
         *
         * | Option Name             | Type    | Note                                                    |
         * |-------------------------|---------|---------------------------------------------------------|
         * | BytesPerBite            | Integer | In bytes. Use for streaming conversion only.            |
         * | FontFace                | String  | Set the font face used for the conversion.              |
         * | FontSize                | Integer | Set the font size used for the conversion.              |
         * | LineHeightMultiplier    | Double  | Set the line height multiplier used for the conversion. |
         * | MarginBottom            | Double  | In inches. Set the bottom margin of the page.           |
         * | MarginLeft              | Double  | In inches. Set the left margin of the page.             |
         * | MarginRight             | Double  | In inches. Set the right margin of the page.            |
         * | MarginTop               | Double  | In inches. Set the top margin of the page.              |
         * | PageHeight              | Double  | In inches. Set the page height.                         |
         * | PageWidth               | Double  | In inches. Set the page width.                          |
         * | UseSourceCodeFormatting | Boolean | Set whether to use mono font for the conversion.        |
         */
        static fromTextWithBuffer(in_pdfdoc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, fileData: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray, options?: PDFNet.Obj): Promise<void>;
        /**
         * Convert the PDFDoc to XPS and save to a buffer
         * @param in_pdfdoc - the PDFDoc to convert to XPS
         * @param [options] - the conversion
         * @returns A promise that resolves to the XPS file in a buffer
         */
        static toXpsBuffer(in_pdfdoc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, options?: PDFNet.Obj | PDFNet.Convert.XPSOutputOptions): Promise<Uint8Array>;
        /**
         * Convert the input file to XPS format and save to a buffer
         * @param fileData - the file to convert to XPS
         * @param fileType - the filename extension of the file.
         * @param [options] - the conversion options
         * @returns A promise that resolves to the XPS file in a buffer
         *
         * Note: Requires the Convert::Printer class for all file formats
         * that ToPdf also requires.
         */
        static fileToXpsWithBuffer(fileData: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray, fileType: string, options?: PDFNet.Obj | PDFNet.Convert.XPSOutputOptions): Promise<Uint8Array>;
        /**
         * Convert the input file to XOD format and save to a buffer
         * @param fileData - the file to convert to XOD
         * @param fileType - the filename extension of the file.
         * @param [options] - the conversion options
         * @returns A promise that resolves to the XOD file in a buffer
         *
         * Note: Requires the Convert::Printer class for all file formats
         * that ToPdf also requires.
         */
        static fileToXodWithBuffer(fileData: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray, fileType: string, options?: PDFNet.Obj | PDFNet.Convert.XODOutputOptions): Promise<Uint8Array>;
        /**
         * Convert the input file to XOD format and save to a buffer
         * @param in_pdfdoc - the PDFDoc to convert to XOD
         * @param [options] - the conversion options
         * @returns A promise that resolves to the XOD file in a buffer
         */
        static toXodBuffer(in_pdfdoc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, options?: PDFNet.Obj | PDFNet.Convert.XODOutputOptions): Promise<Uint8Array>;
        static officeToPdfWithFilter(in_pdfdoc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, in_stream: PDFNet.Filter, options?: PDFNet.Obj | PDFNet.Convert.ConversionOptions): Promise<void>;
        /**
         * Convert the file or document to PDF and append to the specified PDF document
         * @param in_pdfdoc - the PDFDoc to append the converted document to. The
         * PDFDoc can then be converted to XPS, EMF or SVG using the other functions
         * in this class.
         * @param fileData - the buffer containing the document to be converted to pdf
         * @param fileType - the filename extension of the document.
         *
         * Note: Internally formats include BMP, EMF, JPEG, PNG, TIF, XPS.
         *
         * Note: Formats that require external applications for conversion use the
         * Convert::Printer class and the PDFNet printer to be installed. This is
         * only supported on Windows platforms.  Document formats in this category
         * include RTF(MS Word or Wordpad), TXT (Notepad or Wordpad), DOC and DOCX
         * (MS Word), PPT and PPTX (MS PowerPoint), XLS and XLSX (MS Excel),
         * OpenOffice documents, HTML and MHT (Internet Explorer), PUB (MS Publisher),
         * MSG (MS Outlook).
         */
        static toPdfWithBuffer(in_pdfdoc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, fileData: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray, fileType: string): Promise<void>;
        /**
         * Convert the specified TIFF filter to PDF and append converted pages to the specified PDF document.
         * @param in_pdfdoc - the PDFDoc to append to
         * @param in_data - the source TIFF data.
         */
        static fromTiff(in_pdfdoc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, in_data: PDFNet.Filter): Promise<void>;
        /**
         * Convert a page to HTML and return a string of the html
         * @param page - the page to convert to HTML
         * @returns A promise that resolves to a string containing the page's html
         */
        static pageToHtml(page: PDFNet.Page): Promise<string>;
        /**
         * Convert a page to HTML and return a string of the html
         * @param page - the page to convert to HTML
         * @returns A promise that resolves to a string containing the page's html
         */
        static pageToHtmlZoned(page: PDFNet.Page, json_zones: string): Promise<string>;
        /**
         * Convert a file in a buffer to multipage TIFF
         * @param fileData - buffer containing the file to convert to multipage TIFF
         * @param fileType - the filename extension of the file.
         * @param [options] - the conversion options
         * @returns A promise that resolves to the TIFF file in an buffer
         */
        static fileToTiffWithBuffer(fileData: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray, fileType: string, options?: PDFNet.Obj | PDFNet.Convert.TiffOutputOptions): Promise<Uint8Array>;
        /**
         * Convert the PDF to multipage TIFF
         * @param in_pdfdoc - the PDF doc to convert to multipage
         * @param [options] - the conversion options
         * @returns A promise that resolves to the TIFF file in an buffer
         */
        static toTiffBuffer(in_pdfdoc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, options?: PDFNet.Obj | PDFNet.Convert.TiffOutputOptions): Promise<Uint8Array>;
        /**
         * Convert the an office document (in .docx, .xlsx, pptx, or .doc format) to pdf.
         * @param input - Either a url from which to download the file or an ArrayBuffer containing the file data.
         * @param options - An object containing conversion options
         * @returns A promise that resolves to a "PDFDoc".
         */
        static office2PDF(input: string | ArrayBuffer, options: any): Promise<PDFNet.PDFDoc>;
    }
    /**
     * The Optimizer class provides functionality for optimizing/shrinking
    output PDF files.
    
    'pdftron.PDF.Optimizer' is an optional PDFNet Add-On utility class that can be
    used to optimize PDF documents by reducing the file size, removing redundant
    information, and compressing data streams using the latest in image compression
    technology. PDF Optimizer can compress and shrink PDF file size with the
    following operations:
    - Remove duplicated fonts, images, ICC profiles, and any other data stream.
    - Optionally convert high-quality or print-ready PDF files to small, efficient and web-ready PDF.
    - Optionally down-sample large images to a given resolution.
    - Optionally compress or recompress PDF images using JBIG2 and JPEG2000 compression formats.
    - Compress uncompressed streams and remove unused PDF objects.
    
    Note: 'Optimizer' is available as a separately licensable add-on to PDFNet
    core license.
    
    Note: See 'pdftron.PDF.Flattener' for alternate approach to optimize PDFs for fast
    viewing on mobile devices and the Web.
     */
    class Optimizer {
        /**
         * Method to create an ImageSettings object
         * @returns A promise that resolves to a PDFNet.Optimizer.ImageSettings.
         */
        static createImageSettings(): Promise<PDFNet.Optimizer.ImageSettings>;
        /**
         * Method to create an MonoImageSettings object
         * @returns A promise that resolves to a PDFNet.Optimizer.MonoImageSettings.
         */
        static createMonoImageSettings(): Promise<PDFNet.Optimizer.MonoImageSettings>;
        /**
         * Method to create an TextSettings object
         * @returns A promise that resolves to a PDFNet.Optimizer.TextSettings.
         */
        static createTextSettings(): Promise<PDFNet.Optimizer.TextSettings>;
        /**
         * Method to create an OptimizerSettings object
         * @returns A promise that resolves to a PDFNet.Optimizer.OptimizerSettings.
         */
        static createOptimizerSettings(): Promise<PDFNet.Optimizer.OptimizerSettings>;
        /**
         * Optimize the given document using the optimizers settings
         * @param doc - the document to optimize
         * @param [optimizerSettings] - the settings for the optimizer
         */
        static optimize(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, optimizerSettings?: any): Promise<void>;
    }
    /**
     * An abstract class containing utility functions for destroyable classes.
     */
    class Destroyable {
        /**
         * Take the ownership of this object, so that PDFNet.runWithCleanup won't destroy this object.
         */
        takeOwnership(): void;
        /**
         * Destructor
         */
        destroy(): Promise<void>;
    }
    /**
     * Actions are typically what happens when a user clicks on a link or bookmark.
     *
     * Instead of simply jumping to a destination in the document, an annotation or
     * outline item can specify an action for the viewer application to perform, such
     * as launching an application, playing a sound, or changing an annotation's
     * appearance state.
     *
     * Note: Although the Action class provides utility functions for most commonly used
     * action types, it is possible to read, write, and edit any action type using SDF API
     * and dictionary entries described in Section 8.5 in the PDF Reference Manual.
     */
    class Action {
        /**
         * creates a new 'GoTo'action. GoTo action takes the user to the
         * specified Destination view located in the same document.
         * @param dest - A Destination for the new Action.
         *
         * Note: This method can only be used for destinations in the same
         * document as the source document. For cross-document links use
         * Action::CreateGotoRemote().
         * @returns A promise that resolves to an object of type: "PDFNet.Action"
         */
        static createGoto(dest: PDFNet.Destination): Promise<PDFNet.Action>;
        /**
         * @returns A promise that resolves to an object of type: "PDFNet.Action"
         */
        static createGotoWithKey(key: string, dest: PDFNet.Destination): Promise<PDFNet.Action>;
        /**
         * creates a new 'GoToR'action. A remote go-to action is similar to an
         * ordinary go-to action but jumps to a destination in another PDF file
         * instead of the current file.
         * @param file - The file referred to by the action.
         * @param page_num - A page number within the remote document. The first page is
         * numbered 0.
         * @returns A promise that resolves to an object of type: "PDFNet.Action"
         */
        static createGotoRemote(file: PDFNet.FileSpec, page_num: number): Promise<PDFNet.Action>;
        /**
         * Creates a new 'GoToR'action. See the above method for details.
         * @param file - The file referred to by the action.
         * @param page_num - A page number within the remote document. The first page is
         * numbered 0.
         * @param new_window - A flag specifying whether to open the destination document
         * in a new window. If new_window is false, the destination document replaces
         * the current document in the same window, otherwise the viewer application
         * should behave in accordance with the current user preference.
         * @returns A promise that resolves to an object of type: "PDFNet.Action"
         */
        static createGotoRemoteSetNewWindow(file: PDFNet.FileSpec, page_num: number, new_window: boolean): Promise<PDFNet.Action>;
        /**
         * Create a new URI action. The URI action is typically resolved by opening a URL in
         * the default web browser.
         * @param sdfdoc - The document in which to create the action.
         * @param uri - The uniform resource identifier to resolve, encoded in 7-bit ASCII.
         * A uniform resource identifier (URI) is a string that identifies (resolves to) a resource
         * on the Internet; typically a file that is the destination of a hypertext link, although
         * it can also resolve to a query or other entity. (URIs are described in Internet RFC 2396,
         * Uniform Resource Identifiers (URI).
         * @returns A promise that resolves to an object of type: "PDFNet.Action"
         */
        static createURI(sdfdoc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, uri: string): Promise<PDFNet.Action>;
        /**
         * Create a new URI action. The URI action is typically resolved by opening a URL in
         * the default web browser.
         * @param sdfdoc - The document in which to create the action.
         * @param uri - The uniform resource identifier to resolve, encoded in UTF-8.
         * A uniform resource identifier (URI) is a string that identifies (resolves to) a resource
         * on the Internet; typically a file that is the destination of a hypertext link, although
         * it can also resolve to a query or other entity. (URIs are described in Internet RFC 2396,
         * Uniform Resource Identifiers (URI).
         * @returns A promise that resolves to an object of type: "PDFNet.Action"
         */
        static createURIWithUString(sdfdoc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, uri: string): Promise<PDFNet.Action>;
        /**
         * creates a new 'SubmitForm'action. A submit-form action transmits the names
         * and values of selected interactive form fields to a specified uniform
         * resource locator (URL), presumably the address of a Web server that will
         * process them and send back a response.
         * @param url - A URL file specification giving the uniform resource locator (URL)
         * of the script at the Web server that will process the submission.
         * @returns A promise that resolves to an object of type: "PDFNet.Action"
         */
        static createSubmitForm(url: PDFNet.FileSpec): Promise<PDFNet.Action>;
        /**
         * Creates a new 'Launch' action. A launch action opens up a file using the
         * most appropriate program.
         * @param sdfdoc - the document in which to create the action
         * @param path - the full path of the file to be opened
         * @returns A promise that resolves to an object of type: "PDFNet.Action"
         */
        static createLaunch(sdfdoc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, path: string): Promise<PDFNet.Action>;
        /**
         * Creates a new 'Show/Hide Field' action. A show/hide field action shows
         * or hide certain fields when it's invoked.
         * @param sdfdoc - the document in which to create the action
         * @param field_names_list - the list of fields to hide
         * @returns A promise that resolves to an object of type: "PDFNet.Action"
         */
        static createHideField(sdfdoc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, field_names_list: string[]): Promise<PDFNet.Action>;
        /**
         * Creates a new 'Import Data' action. An import data action imports
         * form data from a FDF file into a PDF document.
         * @param sdfdoc - the document in which to create the action
         * @param path - the full path of the FDF file
         * @returns A promise that resolves to an object of type: "PDFNet.Action"
         */
        static createImportData(sdfdoc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, path: string): Promise<PDFNet.Action>;
        /**
         * Creates a new 'Reset Form' action. A reset form action reset chosen
         * form fields to their default value.
         * @param sdfdoc - the document in which to create the action
         * @returns A promise that resolves to an object of type: "PDFNet.Action"
         */
        static createResetForm(sdfdoc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc): Promise<PDFNet.Action>;
        /**
         * Creates a new 'JavaScript' action. A javascript action executes a JavaScript
         * script when it's invoked.
         * @param sdfdoc - the document in which to create the action
         * @param script - the JavaScript script to be executed
         * @returns A promise that resolves to an object of type: "PDFNet.Action"
         */
        static createJavaScript(sdfdoc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, script: string): Promise<PDFNet.Action>;
        /**
         * A constructor. Creates an Action and initializes it using given Cos/SDF object.
         * @param [in_obj] - Pointer to the Cos/SDF object.
         *
         * Note: The constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @returns A promise that resolves to an object of type: "PDFNet.Action"
         */
        static create(in_obj?: PDFNet.Obj): Promise<PDFNet.Action>;
        /**
         * Copy Constructor
         * @returns A promise that resolves to an object of type: "PDFNet.Action"
         */
        copy(): Promise<PDFNet.Action>;
        /**
         * Compares two Action objects for equality.
         * @param in_action - A reference to an existing Action object.
         * @returns A promise that resolves to true if the both Actions share the same underlying SDF/Cos object; otherwise false.
         */
        compare(in_action: PDFNet.Action): Promise<boolean>;
        /**
         * Indicates whether the Action is valid (non-null).
         * @returns A promise that resolves to true if this is a valid (non-null) Action; otherwise false.
         *
         * Note: If this method returns false the underlying SDF/Cos object is null and
         * the Action object should be treated as null as well.
         */
        isValid(): Promise<boolean>;
        /**
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.Action.Type = {
         * 	e_GoTo : 0
         * 	e_GoToR : 1
         * 	e_GoToE : 2
         * 	e_Launch : 3
         * 	e_Thread : 4
         * 	e_URI : 5
         * 	e_Sound : 6
         * 	e_Movie : 7
         * 	e_Hide : 8
         * 	e_Named : 9
         * 	e_SubmitForm : 10
         * 	e_ResetForm : 11
         * 	e_ImportData : 12
         * 	e_JavaScript : 13
         * 	e_SetOCGState : 14
         * 	e_Rendition : 15
         * 	e_Trans : 16
         * 	e_GoTo3DView : 17
         * 	e_RichMediaExecute : 18
         * 	e_Unknown : 19
         * }
         * </pre>
         * @returns A promise that resolves to the type of this Action.
         */
        getType(): Promise<number>;
        /**
         * @returns A promise that resolves to the Action's Destination view.
         *
         * Note: This only works for Actions whose subtype is "GoTo".
         *
         * Note: All named destinations are automatically resolved to the
         * explicit destination so you can access destination members directly.
         */
        getDest(): Promise<PDFNet.Destination>;
        /**
         * @returns A promise that resolves to the next action dictionary, an array of action dictionaries,
         * or NULL if there are no additional actions.
         *
         * Sequences of actions can be chained together. For example, the effect
         * of clicking a link annotation with the mouse might be to play a sound,
         * jump to a new page, and start up a movie. Note that the Next entry is
         * not restricted to a single action but may contain an array of actions,
         * each of which in turn may have a Next entry of its own. The actions may
         * thus form a tree instead of a simple linked list. Actions within each
         * Next array are executed in order, each followed in turn by any actions
         * specified in its Next entry, and so on recursively.
         */
        getNext(): Promise<PDFNet.Obj>;
        /**
         * @returns A promise that resolves to pointer to the underlying SDF/Cos object.
         */
        getSDFObj(): Promise<PDFNet.Obj>;
        /**
         * @param flag - <pre>
         * PDFNet.Action.FormActionFlag = {
         * 	e_exclude : 0
         * 	e_include_no_value_fields : 1
         * 	e_export_format : 2
         * 	e_get_method : 3
         * 	e_submit_coordinates : 4
         * 	e_xfdf : 5
         * 	e_include_append_saves : 6
         * 	e_include_annotations : 7
         * 	e_submit_pdf : 8
         * 	e_canonical_format : 9
         * 	e_excl_non_user_annots : 10
         * 	e_excl_F_key : 11
         * 	e_embed_form : 13
         * }
         * </pre>
         * Action flag to get the value from.
         * @returns A promise that resolves to boolean value of the given action flag.
         * Note: Action flags are currently only used by submit and reset form actions.
         */
        getFormActionFlag(flag: number): Promise<boolean>;
        /**
         * Set the value of a given field flag.
         * @param flag - <pre>
         * PDFNet.Action.FormActionFlag = {
         * 	e_exclude : 0
         * 	e_include_no_value_fields : 1
         * 	e_export_format : 2
         * 	e_get_method : 3
         * 	e_submit_coordinates : 4
         * 	e_xfdf : 5
         * 	e_include_append_saves : 6
         * 	e_include_annotations : 7
         * 	e_submit_pdf : 8
         * 	e_canonical_format : 9
         * 	e_excl_non_user_annots : 10
         * 	e_excl_F_key : 11
         * 	e_embed_form : 13
         * }
         * </pre>
         * Action flag to get the value from.
         * @param value - Boolean to set the value of the flag to.
         * Action flags are currently only used by submit and reset form actions.
         */
        setFormActionFlag(flag: number, value: boolean): Promise<void>;
        /**
         * Test if the action needs writeLock
         * @returns A promise that resolves to ture if needs, otherwise false
         */
        needsWriteLock(): Promise<boolean>;
        /**
         * Executes current action; this will only work for some action types that can be executed
         * only using the information contained in the action object or the associated PDF doc.
         * See also PDFViewCtrl::ExecuteAction()
         */
        execute(): Promise<void>;
        /**
         * Executes KeyStrokeAction, this shall be performed when the user modifies a character in a text field
         * or combo box or modifies the selecton in a scrollable list box. This action checks the added text for
         * validity and reject or modify it.
         * @param data - Data that contains previous text, added text,and added position information.
         * @returns A promise that resolves to an object of type: "PDFNet.KeyStrokeActionResult"
         */
        executeKeyStrokeAction(data: PDFNet.KeyStrokeEventData): Promise<PDFNet.KeyStrokeActionResult>;
        /**
         * @returns A promise that resolves to an object of type: "PDFNet.ActionParameter"
         */
        parameterCreateWithField(field: PDFNet.Field): Promise<PDFNet.ActionParameter>;
        /**
         * @returns A promise that resolves to an object of type: "PDFNet.ActionParameter"
         */
        parameterCreateWithAnnot(annot: PDFNet.Annot): Promise<PDFNet.ActionParameter>;
        /**
         * @returns A promise that resolves to an object of type: "PDFNet.ActionParameter"
         */
        parameterCreateWithPage(page: PDFNet.Page): Promise<PDFNet.ActionParameter>;
    }
    /**
     * ActionParameter is a class used to describe all the information needed to
     * execute an action. In most cases only the action itself is necessary since
     * the document can be inferred from associated SDF::Obj, however some actions
     * particularly JavaScript actions on Field or Annot objects need access to
     * the associated Field or Annot object.
     */
    class ActionParameter extends PDFNet.Destroyable {
        /**
         * Constructor
         * @returns A promise that resolves to an object of type: "PDFNet.ActionParameter"
         */
        static create(action: PDFNet.Action): Promise<PDFNet.ActionParameter>;
        /**
         * @returns A promise that resolves to an object of type: "PDFNet.Action"
         */
        getAction(): Promise<PDFNet.Action>;
    }
    /**
     * Annot is a base class for different types of annotations. For annotation
     * specific properties, please refer to derived classes.
     *
     * An annotation is an interactive object placed on a page, such as a text note, a link,
     * or an embedded file. PDF includes a wide variety of standard annotation types.
     * An annotation associates an object such as a widget, note, or movie with a location
     * on a page of a PDF document, or provides a means of interacting with the user
     * via the mouse and keyboard. For more details on PDF annotations please refer to
     * section 12.5 in the PDF Reference Manual and the documentation in derived classes.
     */
    class Annot {
        /**
         * Creates a new annotation of a given type, in the specified document.
         * The newly created annotation does not contain any properties specific
         * to a given annotation type, which means an invalid annotation object could be created.
         * It is therefore recommended to always create an annotation using type specific methods,
         * such as Annots::Line::Create() or Annots::FileAttachment::Create().
         * Users should only call Annot::Create() to create annotations of non-standard types
         * that are not recognized by PDFTron software (by using Annot::e_Unknown as a type).
         * @param doc - A document to which the annotation is added.
         * @param type - <pre>
         * PDFNet.Annot.Type = {
         * 	e_Text : 0
         * 	e_Link : 1
         * 	e_FreeText : 2
         * 	e_Line : 3
         * 	e_Square : 4
         * 	e_Circle : 5
         * 	e_Polygon : 6
         * 	e_Polyline : 7
         * 	e_Highlight : 8
         * 	e_Underline : 9
         * 	e_Squiggly : 10
         * 	e_StrikeOut : 11
         * 	e_Stamp : 12
         * 	e_Caret : 13
         * 	e_Ink : 14
         * 	e_Popup : 15
         * 	e_FileAttachment : 16
         * 	e_Sound : 17
         * 	e_Movie : 18
         * 	e_Widget : 19
         * 	e_Screen : 20
         * 	e_PrinterMark : 21
         * 	e_TrapNet : 22
         * 	e_Watermark : 23
         * 	e_3D : 24
         * 	e_Redact : 25
         * 	e_Projection : 26
         * 	e_RichMedia : 27
         * 	e_Unknown : 28
         * }
         * </pre>
         * Subtype of annotation to create.
         * @param pos - A rectangle specifying the annotation's bounds, specified in
         * user space coordinates.
         * @returns A promise that resolves to a newly created blank annotation for the given annotation type.
         */
        static create(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, type: number, pos: PDFNet.Rect): Promise<PDFNet.Annot>;
        /**
         * Create an annotation and initialize it using given Cos/SDF object.
         * @param [d] - The Cos/SDF object to initialze the annotation with.
         * Note: The constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @returns A promise that resolves to an object of type: "PDFNet.Annot"
         */
        static createFromObj(d?: PDFNet.Obj): Promise<PDFNet.Annot>;
        /**
         * Copy Constructor
         * @returns A promise that resolves to an object of type: "PDFNet.Annot"
         */
        copy(): Promise<PDFNet.Annot>;
        /**
         * Compares two annotations for equality. The comparison will return true
         * only if both annotations share the same underlying SDF/Cos object.
         * @param d - Annotation to compare to
         * @returns A promise that resolves to an object of type: "boolean"
         */
        compare(d: PDFNet.Annot): Promise<boolean>;
        /**
         * @returns A promise that resolves to true if this is a valid (non-null) annotation, false otherwise.
         * If the function returns false the underlying SDF/Cos object is null or is
         * not valid and the annotation object should be treated as a null object.
         */
        isValid(): Promise<boolean>;
        /**
         * @returns A promise that resolves to the underlying SDF/Cos object.
         */
        getSDFObj(): Promise<PDFNet.Obj>;
        /**
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.Annot.Type = {
         * 	e_Text : 0
         * 	e_Link : 1
         * 	e_FreeText : 2
         * 	e_Line : 3
         * 	e_Square : 4
         * 	e_Circle : 5
         * 	e_Polygon : 6
         * 	e_Polyline : 7
         * 	e_Highlight : 8
         * 	e_Underline : 9
         * 	e_Squiggly : 10
         * 	e_StrikeOut : 11
         * 	e_Stamp : 12
         * 	e_Caret : 13
         * 	e_Ink : 14
         * 	e_Popup : 15
         * 	e_FileAttachment : 16
         * 	e_Sound : 17
         * 	e_Movie : 18
         * 	e_Widget : 19
         * 	e_Screen : 20
         * 	e_PrinterMark : 21
         * 	e_TrapNet : 22
         * 	e_Watermark : 23
         * 	e_3D : 24
         * 	e_Redact : 25
         * 	e_Projection : 26
         * 	e_RichMedia : 27
         * 	e_Unknown : 28
         * }
         * </pre>
         * @returns A promise that resolves to the type of this annotation. Corresponds to the "Subtype" entry of annotation
         * dictionary, as per PDF Reference Manual section 12.5.2
         */
        getType(): Promise<number>;
        /**
         * Return true if this annotation is classified as a markup annotation.
         * @returns A promise that resolves to boolean value, true if this annotation is classified as a markup annotation.
         */
        isMarkup(): Promise<boolean>;
        /**
         * @returns A promise that resolves to annotation's bounding rectangle, specified in user space coordinates.
         *
         * The meaning of the rectangle depends on the annotation type. For Link and RubberStamp
         * annotations, the rectangle specifies the area containing the hyperlink area or stamp.
         * For Note annotations, the rectangle is describing the popup window when it's opened.
         * When it's closed, the icon is positioned at lower left corner.
         */
        getRect(): Promise<PDFNet.Rect>;
        /**
         * It is possible during viewing that GetRect does not return the most accurate bounding box
         * of what is actually rendered. This method calculates the bounding box, rather than relying
         * on what is specified in the PDF document. The bounding box is defined as the smallest
         * rectangle that includes all the visible content on the annotation.
         * @returns A promise that resolves to the bounding box for this annotation. The dimensions are specified in user space
         * coordinates.
         */
        getVisibleContentBox(): Promise<PDFNet.Rect>;
        /**
         * Sets the size and location of an annotation on its page.
         * @param pos - Annotation's bounding rectangle, specified in user space coordinates.
         *
         * The meaning of the rectangle depends on the annotation type. For Link and RubberStamp
         * annotations, the rectangle specifies the area containing the hyperlink area or stamp.
         * For Note annotations, the rectangle is describing the popup window when it's opened.
         * When it's closed, the icon is positioned at lower left corner.
         */
        setRect(pos: PDFNet.Rect): Promise<void>;
        /**
         * Scales the geometry of the annotation so that its appearance would now fit a new
         * rectangle on the page, in user units. Users still have to call RefreshAppearance() later
         * if they want a corresponding appearance stream to be generated for the new rectangle.
         * The main reason for not combining the two operations together is to be able to resize
         * annotations that do not have an appearance stream.
         * @param newrect - A reference to the new rectangle to which this annotation has to be resized.
         */
        resize(newrect: PDFNet.Rect): Promise<void>;
        /**
         * Sets the content of this annotation. (Optional).
         * @param contents - A reference to unicode string object with the text that will be associated with
         * this annotation. This is the text that annotation displays on user interaction, if the annotation
         * type supports it.
         */
        setContents(contents: string): Promise<void>;
        /**
         * Extract the content of this annotation. (Optional).
         * @returns A promise that resolves to  A unicode string object with the text that is associated with
         * this annotation. This is the text that annotation displays on user interaction,
         * if the annotation type supports it.
         */
        getContents(): Promise<string>;
        /**
         * Get the Action associated with the selected Annot Trigger event.
         * @param trigger - <pre>
         * PDFNet.Annot.EventType = {
         * 	e_action_trigger_activate : 0
         * 	e_action_trigger_annot_enter : 1
         * 	e_action_trigger_annot_exit : 2
         * 	e_action_trigger_annot_down : 3
         * 	e_action_trigger_annot_up : 4
         * 	e_action_trigger_annot_focus : 5
         * 	e_action_trigger_annot_blur : 6
         * 	e_action_trigger_annot_page_open : 7
         * 	e_action_trigger_annot_page_close : 8
         * 	e_action_trigger_annot_page_visible : 9
         * 	e_action_trigger_annot_page_invisible : 10
         * }
         * </pre>
         * the type of trigger event to get
         * @returns A promise that resolves to the Action Obj if present, otherwise NULL
         */
        getTriggerAction(trigger: number): Promise<PDFNet.Obj>;
        /**
         * Returns custom data associated with the given key.
         * @param key - The key for which to retrieve the associated data.
         * @returns A promise that resolves to the custom data string. If no data is available an empty string is returned.
         */
        getCustomData(key: string): Promise<string>;
        /**
         * Sets the custom data associated with the specified key.
         * @param key - The key under which to store this custom data
         * @param value - The custom data string to store
         */
        setCustomData(key: string, value: string): Promise<void>;
        /**
         * Deletes custom data associated with the given key.
         * @param key - The key for which to delete the associated data.
         */
        deleteCustomData(key: string): Promise<void>;
        /**
         * Gets the page the annotation is associated with.
         * @returns A promise that resolves to a Page object or null page object if the page reference is not available.
         * The page object returned is an indirect reference to the page object with which
         * this annotation is associated.
         * This entry shall be present in screen annotations associated with rendition actions.
         *
         * Optional. PDF 1.3 PDF 1.4 PDF 1.5 not used in FDF files.
         */
        getPage(): Promise<PDFNet.Page>;
        /**
         * sets the reference to a page the annotation is associated with.
         * (Optional PDF 1.3; not used in FDF files)
         * @param page - The page object user wants the annotation to be associated with.
         *
         * Note: The parameter should be an indirect reference to the page object with
         * which this annotation is associated. This entry shall be present in screen
         * annotations associated with rendition actions
         */
        setPage(page: PDFNet.Page): Promise<void>;
        /**
         * @returns A promise that resolves to the unique identifier for this annotation, or NULL if the identifier is not
         * available. The returned value is a String object and is the value of the "NM"
         * field, which was added as an optional attribute in PDF 1.4.
         */
        getUniqueID(): Promise<PDFNet.Obj>;
        /**
         * Sets the unique identifier for this annotation.
         * @param id - A buffer containing a unique identifier for this annotation.
         * Note: It is necessary to ensure that the unique ID generated is actually unique.
         */
        setUniqueID(id: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray): Promise<void>;
        /**
         * Gets an annotation's last modified date.
         * @returns A promise that resolves to the annotation's last modified time and date. If the annotation has no associated
         * date structure, the returned date is not valid (date.IsValid() returns false). Corresponds
         * to the "M" entry of the annotation dictionary.
         */
        getDate(): Promise<PDFNet.Date>;
        /**
         * Sets an annotation's last modified date.
         * @param date - The annotation's last modified time and date. Corresponds to the "M" entry of the
         * annotation dictionary.
         */
        setDate(date: PDFNet.Date): Promise<void>;
        /**
         * @param flag - <pre>
         * PDFNet.Annot.Flag = {
         * 	e_invisible : 0
         * 	e_hidden : 1
         * 	e_print : 2
         * 	e_no_zoom : 3
         * 	e_no_rotate : 4
         * 	e_no_view : 5
         * 	e_annot_read_only : 6
         * 	e_locked : 7
         * 	e_toggle_no_view : 8
         * 	e_locked_contents : 9
         * }
         * </pre>
         * The Flag property to query.
         * @returns A promise that resolves to the value of given Flag
         */
        getFlag(flag: number): Promise<boolean>;
        /**
         * sets the value of given Flag.
         * @param flag - <pre>
         * PDFNet.Annot.Flag = {
         * 	e_invisible : 0
         * 	e_hidden : 1
         * 	e_print : 2
         * 	e_no_zoom : 3
         * 	e_no_rotate : 4
         * 	e_no_view : 5
         * 	e_annot_read_only : 6
         * 	e_locked : 7
         * 	e_toggle_no_view : 8
         * 	e_locked_contents : 9
         * }
         * </pre>
         * The Flag property to modify.
         * @param value - The new value for the property.
         */
        setFlag(flag: number, value: boolean): Promise<void>;
        /**
         * Gets the annotation's appearance for the given combination of annotation
         * and appearance states.
         * @param [annot_state] - <pre>
         * PDFNet.Annot.State = {
         * 	e_normal : 0
         * 	e_rollover : 1
         * 	e_down : 2
         * }
         * </pre>
         * the annotation's appearance state, which selects the applicable
         * appearance stream from the appearance sub-dictionary. An annotation can define as many
         * as three separate appearances: The normal, rollover, and down appearance.
         * @param [app_state] - is an optional parameter specifying the appearance state
         * to look for (e.g. "Off", "On", etc). If appearance_state is NULL, the choice
         * between different appearance states is determined by the AS (Appearance State)
         * entry in the annotation dictionary.
         * @returns A promise that resolves to the appearance stream for this annotation, or NULL if the annotation
         * does not have an appearance for the given combination of annotation and
         * appearance states.
         */
        getAppearance(annot_state?: number, app_state?: string): Promise<PDFNet.Obj>;
        /**
         * Sets the annotation's appearance for the given combination of annotation
         * and appearance states.
         * (Optional; PDF 1.2)
         * @param app_stream - a content stream defining the new appearance.
         * @param [annot_state] - <pre>
         * PDFNet.Annot.State = {
         * 	e_normal : 0
         * 	e_rollover : 1
         * 	e_down : 2
         * }
         * </pre>
         * the annotation's appearance state, which selects the applicable
         * appearance stream from the appearance sub-dictionary. An annotation can define as many
         * as three separate appearances: The normal, rollover, and down appearance.
         * @param [app_state] - is an optional parameter specifying the appearance state
         * (e.g. "Off", "On", etc) under which the new appearance should be stored. If
         * appearance_state is NULL, the annotation will have only one annotation state.
         */
        setAppearance(app_stream: PDFNet.Obj, annot_state?: number, app_state?: string): Promise<void>;
        /**
         * Removes the annotation's appearance for the given combination of annotation
         * and appearance states.
         * @param [annot_state] - <pre>
         * PDFNet.Annot.State = {
         * 	e_normal : 0
         * 	e_rollover : 1
         * 	e_down : 2
         * }
         * </pre>
         * the annotation's appearance state, which selects the applicable
         * appearance stream from the appearance sub-dictionary. An annotation can define as many
         * as three separate appearances: The normal, rollover, and down appearance.
         * @param [app_state] - is an optional parameter specifying the appearance state
         * (e.g. "Off", "On", etc) under which the new appearance should be stored. If
         * appearance_state is NULL, the annotation will have only one annotation state.
         */
        removeAppearance(annot_state?: number, app_state?: string): Promise<void>;
        /**
         * Flatten/Merge the existing annotation appearances with the page content and
         * delete this annotation from a given page.
         *
         * Annotation 'flattening' refers to the operation that changes active annotations
         * (such as markup, widgets, 3D models, etc.) into a static area that is part of the
         * PDF document, just like the other text and images in the document.
         *
         * Note: an alternative approach to set the annotation as read only is using
         * Annot.SetFlag(Annot::e_read_only, true) method. Unlike Annot.SetFlag(...),
         * the result of Flatten() operation can not be programatically reversed.
         */
        flatten(page: PDFNet.Page): Promise<void>;
        /**
         * Gets the annotation's active appearance state.
         * @returns A promise that resolves to the name of the active state.
         * The annotation's appearance state, which
         * selects the applicable appearance stream from an appearance subdictionary.
         */
        getActiveAppearanceState(): Promise<string>;
        /**
         * Sets the annotation's active appearance state.
         * (Required if the appearance dictionary AP contains one or more subdictionaries; PDF 1.2)
         * @param astate - Character string representing the name of the active appearance state.
         * The string used to select the annotation's appearance state, which
         * selects the applicable appearance stream from an appearance subdictionary.
         */
        setActiveAppearanceState(astate: string): Promise<void>;
        /**
         * Gets an annotation's color without any specified color space. It is generally recommended
         * to use getColorAsRGB(), getColorAsCMYK() or getColorAsGray() for more predictable behavior
         * @returns A promise that resolves to a ColorPt object containing an array of numbers in the
         * range 0.0 to 1.0.
         */
        getColor(): Promise<PDFNet.ColorPt>;
        /**
         * Gets an annotation's color in RGB color space.
         * @returns A promise that resolves to a ColorPt object containing an array of three numbers in the range 0.0 to 1.0,
         * representing an RGB colour used for the following purposes:
         *   The background of the annotation's icon when closed
         *   The title bar of the annotation's pop-up window
         *   The border of a link annotation
         *
         *  If the annotation does not specify an explicit color, a default color is returned.
         *  Text annotations return 'default yellow;' all others return black.
         */
        getColorAsRGB(): Promise<PDFNet.ColorPt>;
        /**
         * Returns the annotation's color in CMYK color space.
         * @returns A promise that resolves to a ColorPt object containing an array of four numbers in the range 0.0 to 1.0,
         * representing a CMYK color used for the following purposes:
         *   The background of the annotation's icon when closed
         *   The title bar of the annotation's pop-up window
         *   The border of a link annotation
         *
         * If the annotation does not specify an explicit color, a default color is returned.
         * Text annotations return 'default yellow;' all others return black.
         */
        getColorAsCMYK(): Promise<PDFNet.ColorPt>;
        /**
         * Returns the annotation's color in Gray color space.
         * @returns A promise that resolves to a ColorPt object containing a number in the range 0.0 to 1.0,
         * representing a Gray Scale color used for the following purposes:
         * The background of the annotation's icon when closed
         * The title bar of the annotation's pop-up window
         * The border of a link annotation
         * If the annotation does not specify an explicit color, black color is returned.
         */
        getColorAsGray(): Promise<PDFNet.ColorPt>;
        /**
         * Returns the color space the annotation's color is represented in.
         * @returns A promise that resolves to an integer that is either 1(for DeviceGray), 3(DeviceRGB), or 4(DeviceCMYK).
         * If the annotation has no color, i.e. is transparent, 0 will be returned.
         */
        getColorCompNum(): Promise<number>;
        setColorDefault(col: PDFNet.ColorPt): Promise<void>;
        /**
         * Sets an annotation's color.
         * (Optional; PDF 1.1)
         * @param col - A ColorPt object in RGB or Gray or CMYK color space representing the annotation's color.
         * The ColorPt contains an array of numbers in the range 0.0 to 1.0, representing a color used for the following purposes:
         *    The background of the annotation's icon when closed
         *     The title bar of the annotation's pop-up window
         *     The border of a link annotation
         *
         * The number of array elements determines the color space in which the color shall be defined:
         * 0 No color; transparent
         * 1 DeviceGray
         * 3 DeviceRGB
         * 4 DeviceCMYK
         * @param [numcomp] - The number of color components used to represent the color (i.e. 1, 3, 4).
         */
        setColor(col: PDFNet.ColorPt, numcomp?: number): Promise<void>;
        /**
         * Returns the struct parent of an annotation.
         * (Required if the annotation is a structural content item; PDF 1.3)
         * @returns A promise that resolves to an integer which is the integer key of the annotation's entry
         * in the structural parent tree.
         * Note: The StructParent is the integer key of the annotation's entry
         * in the structural parent tree.
         */
        getStructParent(): Promise<number>;
        /**
         * sets the struct parent of an annotation.
         * (Required if the annotation is a structural content item; PDF 1.3)
         * @param parkeyval - An integer which is the integer key of the
         * annotation's entry in the structural parent tree.
         * Note: The StructParent is the integer key of the annotation's entry
         * in the structural parent tree.
         */
        setStructParent(parkeyval: number): Promise<void>;
        /**
         * Returns optional content associated with this annotation.
         * @returns A promise that resolves to a SDF object corresponding to the group of optional properties.
         * Note: The return value is an Optional Content Group (OCG) or Optional Content Membership
         * Dictionary (PDF::OCG::OCMD) specifying the optional content properties for the annotation.
         * Before the annotation is drawn, its visibility shall be determined based on this entry
         * as well as the annotation flags specified in the Flag entry. If it is determined to be
         * invisible, the annotation shall be skipped, as if it were not in the document.
         */
        getOptionalContent(): Promise<PDFNet.Obj>;
        /**
         * Associates optional content with this annotation. (Optional, PDF1.5).
         * @param content - A pointer to an SDF object corresponding to the optional content,
         * a PDF::OCG::Group or membership dictionary specifying the PDF::OCG::Group properties for
         * the annotation. Before the annotation is drawn, its visibility
         * shall be determined based on this entry as well as the annotation
         * flags specified in the Flag entry . If it is determined to be invisible,
         * the annotation shall be skipped, as if it were not in the document.
         */
        setOptionalContent(content: PDFNet.Obj): Promise<void>;
        /**
         * Regenerates the appearance stream for the annotation.
         * This method can be used to auto-generate the annotation appearance after creating
         * or modifying the annotation without providing an explicit appearance or
         * setting the "NeedAppearances" flag in the AcroForm dictionary.
         *
         * Note: If this annotation contains text, and has been added to a rotated page, the text in
         * the annotation may be rotated. If RefreshAppearance is called *after* the annotation is added
         * to a rotated page, then any text will be rotated in the opposite direction of the page
         * rotation. If this method is called *before* the annotation is added to any rotated page, then
         * no counter rotation will be applied. If you wish to call RefreshAppearance on an annotation
         * already added to a rotated page, but you don't want the text to be rotated, you can do one
         * of the following; temporarily un-rotate the page, or, temporarily remove the "Rotate" object
         * from the annotation. To support users adding text annotations while using a PDF viewer,
         * you can also add any viewer rotation to the annotations Rotate object, to have text always
         * rotated correctly, from the users perspective.
         */
        refreshAppearance(): Promise<void>;
        /**
         * A version of RefreshAppearance allowing custom options to make slight tweaks in behaviour.
         * @param [options] - The RefreshOptions.
         */
        refreshAppearanceRefreshOptions(options?: PDFNet.PDFDoc.RefreshOptions): Promise<void>;
        /**
         * Returns the rotation value of the annotation. The Rotation specifies the number of degrees by which the
         * annotation shall be rotated counterclockwise relative to the page.
         * The value shall be a multiple of 90.
         * @returns A promise that resolves to an integer representing the rotation value of the annotation.
         * Note: This property is part of the appearance characteristics dictionary, this dictionary
         * that shall be used in constructing a dynamic appearance stream specifying the annotation's visual
         * presentation on the page.
         */
        getRotation(): Promise<number>;
        /**
         * Sets the rotation value of the annotation. The Rotation specifies the number of degrees by which the
         * annotation shall be rotated counterclockwise relative to the page.
         * The value shall be a multiple of 90.
         * (Optional)
         * @param angle - An integer representing the rotation value of the annotation.
         * Note: This property is part of the appearance characteristics dictionary, this dictionary
         * that shall be used in constructing a dynamic appearance stream specifying the annotation's visual
         * presentation on the page.
         */
        setRotation(angle: number): Promise<void>;
        /**
         * Gets the border style for the annotation. Typically used for Link annotations.
         * @returns A promise that resolves to annotation's border style.
         */
        getBorderStyle(): Promise<PDFNet.AnnotBorderStyle>;
        /**
         * Sets the border style for the annotation.
         * @param bs - New border style for this annotation.
         * @param [oldStyleOnly] - PDF manual specifies two ways to add border information to an annotation object,
         * either through an array named 'Border' (PDF 1.0), or a dictionary called 'BS' (PDF 1.2) the latter
         * taking precedence over the former. However, if you want to create a border with rounded corners, you can only
         * do that using PDF 1.0 Border specification, in which case if you call SetBorderStyle() set the parameter
         * oldStyleOnly to true. This parameter has a default value of false in the API and does not need to be used otherwise.
         */
        setBorderStyle(bs: PDFNet.AnnotBorderStyle, oldStyleOnly?: boolean): Promise<void>;
        /**
         * @returns A promise that resolves to an object of type: "number"
         * <pre>
         * PDFNet.AnnotBorderStyle.Style = {
         * 	e_solid : 0
         * 	e_dashed : 1
         * 	e_beveled : 2
         * 	e_inset : 3
         * 	e_underline : 4
         * }
         * </pre>
         */
        static getBorderStyleStyle(bs: PDFNet.AnnotBorderStyle): Promise<number>;
        static setBorderStyleStyle(bs: PDFNet.AnnotBorderStyle, bst: number): Promise<void>;
    }
    /**
     * AnnotBorderStyle structure specifies the characteristics of the annotation's border.
     * The border is specified as a rounded rectangle.
     */
    class AnnotBorderStyle extends PDFNet.Destroyable {
        /**
         * Creates a new border style with given parameters.
         * @param s - <pre>
         * PDFNet.AnnotBorderStyle.Style = {
         * 	e_solid : 0
         * 	e_dashed : 1
         * 	e_beveled : 2
         * 	e_inset : 3
         * 	e_underline : 4
         * }
         * </pre>
         * The border style.
         * @param b_width - The border width expressed in the default user space.
         * @param [b_hr] - The horizontal corner radius expressed in the default user space.
         * @param [b_vr] - The vertical corner radius expressed in the default user space.
         *
         * Note: If the corner radii are 0, the border has square (not rounded) corners; if
         * the border width is 0, no border is drawn.
         * @returns A promise that resolves to an object of type: "PDFNet.AnnotBorderStyle"
         */
        static create(s: number, b_width: number, b_hr?: number, b_vr?: number): Promise<PDFNet.AnnotBorderStyle>;
        /**
         * Creates a new border style with given parameters.
         * @param s - <pre>
         * PDFNet.AnnotBorderStyle.Style = {
         * 	e_solid : 0
         * 	e_dashed : 1
         * 	e_beveled : 2
         * 	e_inset : 3
         * 	e_underline : 4
         * }
         * </pre>
         * The border style.
         * @param b_width - The border width expressed in the default user space.
         * @param b_hr - The horizontal corner radius expressed in the default user space.
         * @param b_vr - The vertical corner radius expressed in the default user space.
         * @param b_dash - An array of numbers defining a pattern of dashes and gaps to be used
         * in drawing the border. The dash array is specified in the same format as in the line
         * dash pattern parameter of the graphics state except that the phase is assumed to be 0.
         *
         * Note: If the corner radii are 0, the border has square (not rounded) corners; if
         * the border width is 0, no border is drawn.
         * @returns A promise that resolves to an object of type: "PDFNet.AnnotBorderStyle"
         */
        static createWithDashPattern(s: number, b_width: number, b_hr: number, b_vr: number, b_dash: number[]): Promise<PDFNet.AnnotBorderStyle>;
        /**
         * Copy Constructor
         * @returns A promise that resolves to an object of type: "PDFNet.AnnotBorderStyle"
         */
        copy(): Promise<PDFNet.AnnotBorderStyle>;
        /**
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.AnnotBorderStyle.Style = {
         * 	e_solid : 0
         * 	e_dashed : 1
         * 	e_beveled : 2
         * 	e_inset : 3
         * 	e_underline : 4
         * }
         * </pre>
         * @returns A promise that resolves to the border style.
         */
        getStyle(): Promise<number>;
        /**
         * Sets the border style.
         * @param style - <pre>
         * PDFNet.AnnotBorderStyle.Style = {
         * 	e_solid : 0
         * 	e_dashed : 1
         * 	e_beveled : 2
         * 	e_inset : 3
         * 	e_underline : 4
         * }
         * </pre>
         */
        setStyle(style: number): Promise<void>;
        /**
         * @returns A promise that resolves to the border width.
         */
        getWidth(): Promise<number>;
        /**
         * Sets the border width
         * @param width - A number representing the width value to set the annotation to.
         */
        setWidth(width: number): Promise<void>;
        /**
         * @returns A promise that resolves to horizontal corner radius.
         */
        getHR(): Promise<number>;
        /**
         * Sets horizontal corner radius.
         * @param horizontal_radius - A number representing the value of the horizontal radius to set the annotation to.
         */
        setHR(horizontal_radius: number): Promise<void>;
        /**
         * @returns A promise that resolves to vertical corner radius.
         */
        getVR(): Promise<number>;
        /**
         * Sets vertical corner radius.
         * @param vertical_radius - A number representing the value of the vertical radius to set the annotation to.
         */
        setVR(vertical_radius: number): Promise<void>;
        /**
         * @returns A promise that resolves to the border dash pattern.
         */
        getDashPattern(): Promise<Float64Array>;
        /**
         * Comparison function.
         * Determines if parameter object is equal to current object.
         * @returns A promise that resolves to True if the two objects are equivalent, False otherwise
         */
        compare(b: PDFNet.AnnotBorderStyle): Promise<boolean>;
    }
    /**
     * An application or plug-in extension that processes logical structure can attach
     * additional information, called attributes, to any structure element.
     * The attribute information is held in one or more attribute objects associated
     * with the structure element. An attribute object is a dictionary or stream
     * that includes an entry identifying the application or plug-in that owns the
     * attribute information. Other entries represent the attributes: the keys are
     * attribute names, and values are the corresponding attribute values.
     */
    class AttrObj {
        /**
         * Initialize a AttrObj using an existing low-level Cos/SDF object.
         * @param [dict] - a low-level (SDF/Cos) dictionary representing the attribute object.
         *
         * Note: This constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @returns A promise that resolves to an object of type: "PDFNet.AttrObj"
         */
        static create(dict?: PDFNet.Obj): Promise<PDFNet.AttrObj>;
        /**
         * Copy Constructor
         * @returns A promise that resolves to an object of type: "PDFNet.AttrObj"
         */
        copy(): Promise<PDFNet.AttrObj>;
        /**
         * @returns A promise that resolves to the name of the application or plug-in extension owning the
         * attribute data.
         */
        getOwner(): Promise<string>;
        /**
         * @returns A promise that resolves to pointer to the underlying SDF/Cos object.
         */
        getSDFObj(): Promise<PDFNet.Obj>;
    }
    /**
     * A %PDF document may optionally display a document outline on the screen, allowing
     * the user to navigate interactively from one part of the document to another.
     * The outline consists of a tree-structured hierarchy of Bookmarks (sometimes
     * called outline items), which serve as a 'visual table of contents' to display the
     * document's structure to the user.
     *
     * Each Bookmark has a title that appears on screen, and an Action that specifies
     * what happens when a user clicks on the Bookmark. The typical action for a
     * user-created Bookmark is to move to another location in the current document,
     * although any action (see PDF::Action) can be specified.
     *
     * Bookmark is a utility class used to simplify work with %PDF bookmarks (or
     * outlines; see section 8.2.2 'Document Outline' in %PDF Reference Manual for
     * more details).
     */
    class Bookmark {
        /**
         * Creates a new valid Bookmark with given title in the
         * specified document.
         * @param in_doc - The document in which a Bookmark is to be created.
         * @param in_title - The title string value of the new Bookmark.
         * @returns A promise that resolves to the new Bookmark.
         *
         * Note: The new Bookmark is not linked to the outline tree.
         * Use AddChild()/AddNext()/AddPrev() methods in order to link the Bookmark
         * to the outline tree
         */
        static create(in_doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, in_title: string): Promise<PDFNet.Bookmark>;
        /**
         * A constructor. Creates a Bookmark and initialize it using given Cos/SDF object.
         * @param in_bookmark_dict - Pointer to the Cos/SDF object (outline item dictionary).
         * @returns A promise that resolves to the new Bookmark.
         *
         * Note: The constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         */
        static createFromObj(in_bookmark_dict: PDFNet.Obj): Promise<PDFNet.Bookmark>;
        /**
         * Copy Constructor. Creates a new Bookmark object equal to the existing Bookmark object.
         * @returns A promise that resolves to a new Bookmark object.
         */
        copy(): Promise<PDFNet.Bookmark>;
        /**
         * Compares two Bookmark objects for equality.
         * @param in_bookmark - A reference to an existing Bookmark object.
         * @returns A promise that resolves to true if the both Bookmarks share the same underlying SDF/Cos object; otherwise false.
         */
        compare(in_bookmark: PDFNet.Bookmark): Promise<boolean>;
        /**
         * Indicates whether the Bookmark is valid (non-null).
         * @returns A promise that resolves to true if this is a valid (non-null) Bookmark; otherwise false.
         *
         * Note: If this method returns false the underlying SDF/Cos object is null and
         * the Bookmark object should be treated as null as well.
         */
        isValid(): Promise<boolean>;
        /**
         * Indicates whether the Bookmark has children.
         * @returns A promise that resolves to true if the Bookmark has children; otherwise false.
         */
        hasChildren(): Promise<boolean>;
        /**
         * Returns the Bookmark's next (right) sibling.
         * @returns A promise that resolves to the Bookmark's next (right) sibling.
         */
        getNext(): Promise<PDFNet.Bookmark>;
        /**
         * Returns the Bookmark's previous (left) sibling.
         * @returns A promise that resolves to the Bookmark's previous (left) sibling.
         */
        getPrev(): Promise<PDFNet.Bookmark>;
        /**
         * Returns the Bookmark's first child.
         * @returns A promise that resolves to the Bookmark's first child.
         */
        getFirstChild(): Promise<PDFNet.Bookmark>;
        /**
         * Returns the Bookmark's last child.
         * @returns A promise that resolves to the Bookmark's last child.
         */
        getLastChild(): Promise<PDFNet.Bookmark>;
        /**
         * Returns the Bookmark's parent Bookmark.
         * @returns A promise that resolves to the Bookmark's parent Bookmark.
         */
        getParent(): Promise<PDFNet.Bookmark>;
        /**
         * Returns the Bookmark specified by the given title string.
         * @param in_title - The title string value of the Bookmark to find.
         * @returns A promise that resolves to a Bookmark matching the title string value specified.
         */
        find(in_title: string): Promise<PDFNet.Bookmark>;
        /**
         * Adds a new Bookmark as the new last child of this Bookmark.
         * @param in_title - The title string value of the new Bookmark.
         * @returns A promise that resolves to the newly created child Bookmark.
         *
         * Note: If this Bookmark previously had no children, it will be open
         * after the child is added.
         */
        addNewChild(in_title: string): Promise<PDFNet.Bookmark>;
        /**
         * adds the specified Bookmark as the new last child of this Bookmark.
         * @param in_bookmark - The Bookmark object to be added as a last child of this Bookmark.
         *
         * Note: Parameter in_bookmark must not be linked to a bookmark tree.
         * Note: If this Bookmark previously had no children, it will be open
         * after the child is added.
         */
        addChild(in_bookmark: PDFNet.Bookmark): Promise<void>;
        /**
         * Adds a new Bookmark to the tree containing this Bookmark, as the
         * new right sibling.
         * @param in_title - The title string value of the new Bookmark.
         * @returns A promise that resolves to the newly created sibling Bookmark.
         */
        addNewNext(in_title: string): Promise<PDFNet.Bookmark>;
        /**
         * adds the specified Bookmark as the new right sibling to this Bookmark,
         * adjusting the tree containing this Bookmark appropriately.
         * @param in_bookmark - The Bookmark object to be added to this Bookmark.
         *
         * Note: Parameter in_bookmark must not be linked to a bookmark tree.
         */
        addNext(in_bookmark: PDFNet.Bookmark): Promise<void>;
        /**
         * Adds a new Bookmark to the tree containing this Bookmark, as the
         * new left sibling.
         * @param in_title - The title string value of the new Bookmark.
         * @returns A promise that resolves to the newly created sibling Bookmark.
         */
        addNewPrev(in_title: string): Promise<PDFNet.Bookmark>;
        /**
         * adds the specified Bookmark as the new left sibling to this Bookmark,
         * adjusting the tree containing this Bookmark appropriately.
         * @param in_bookmark - The Bookmark object to be added to this Bookmark.
         *
         * Note: Parameter in_bookmark must not be linked to a bookmark tree.
         */
        addPrev(in_bookmark: PDFNet.Bookmark): Promise<void>;
        /**
         * removes the Bookmark's subtree from the bookmark tree containing it.
         */
        delete(): Promise<void>;
        /**
         * unlinks this Bookmark from the bookmark tree that contains it, and
         * adjusts the tree appropriately.
         *
         * Note: After the bookmark is unlinked is can be moved to another place
         * in the bookmark tree located in the same document.
         */
        unlink(): Promise<void>;
        /**
         * Returns the indentation level of the Bookmark in its containing tree.
         * @returns A promise that resolves to the indentation level of the Bookmark in its containing tree.
         *
         * Note: The root level has an indentation level of zero.
         */
        getIndent(): Promise<number>;
        /**
         * Indicates whether the Bookmark is open.
         * @returns A promise that resolves to true if this Bookmark is open; otherwise false.
         *
         * Note: An open Bookmark shows all its children.
         */
        isOpen(): Promise<boolean>;
        /**
         * Opens or closes the Bookmark.
         * @param in_open - Boolean value that contains the status.
         * If true, the Bookmark is opened. Otherwise the Bookmark is closed.
         *
         * Note: An opened Bookmark shows its children, while a closed Bookmark does not.
         */
        setOpen(in_open: boolean): Promise<void>;
        /**
         * Returns the number of opened bookmarks in this subtree.
         * @returns A promise that resolves to the number of opened bookmarks in this subtree (not including
         * this Bookmark). If the item is closed, a negative integer whose
         * absolute value specifies how many descendants would appear if the
         * item were reopened.
         */
        getOpenCount(): Promise<number>;
        /**
         * Returns the Bookmark's title string.
         * @returns A promise that resolves to the Bookmark's title string).
         */
        getTitle(): Promise<string>;
        /**
         * Returns the Bookmark's title string object.
         * @returns A promise that resolves to the Bookmark's title string object.
         */
        getTitleObj(): Promise<PDFNet.Obj>;
        /**
         * Sets the Bookmark's title string.
         * @param title - The new title string for the bookmark.
         */
        setTitle(title: string): Promise<void>;
        /**
         * Returns the Bookmark's action.
         * @returns A promise that resolves to the Bookmark's action.
         */
        getAction(): Promise<PDFNet.Action>;
        /**
         * sets the Bookmark's action.
         * @param in_action - The new Action for the Bookmark.
         */
        setAction(in_action: PDFNet.Action): Promise<void>;
        /**
         * removes the Bookmark's action.
         */
        removeAction(): Promise<void>;
        /**
         * Returns the Bookmark's flags.
         * @returns A promise that resolves to the flags of the Bookmark object.
         * Bit 1 (least-significant bit) indicates italic font whereas
         * bit 2 indicates bold font.
         * Therefore, 0 indicates normal, 1 is italic, 2 is bold, and 3 is bold-italic.
         */
        getFlags(): Promise<number>;
        /**
         * Sets the Bookmark's flags.
         * @param in_flags - The new bookmark flags.
         * Bit 1 (the least-significant bit) indicates italic font whereas
         * bit 2 indicates bold font.
         * Therefore, 0 indicates normal, 1 is italic, 2 is bold, and 3 is bold-italic.
         */
        setFlags(in_flags: number): Promise<void>;
        /**
         * Returns the Bookmark's RGB color value.
         *
         * Note: The three numbers  \a out_r, \a out_g, and \a out_b are in the range 0.0 to 1.0,
         * representing the components in the DeviceRGB color space of the color
         * to be used for the Bookmark's text.
         *
         * <b>Example:</b>
         * \code
         *   double red, green, blue;
         *   bookmark.GetColor(red, green, blue);
         * \endcode
         * @returns A promise that resolves to an object of type: "Object"
         */
        getColor(): Promise<object>;
        /**
         * Sets the Bookmark's color value.
         * @param [in_r] - The red component of the color.
         * @param [in_g] - The green component of the color.
         * @param [in_b] - The blue component of the color.
         *
         * Note: The three numbers \a in_r, \a in_g, and \a in_b are in the range 0.0 to 1.0, representing
         * the components in the DeviceRGB color space of the color to be used
         * for the Bookmark's text.
         * Default color value is black, [0.0 0.0 0.0].
         */
        setColor(in_r?: number, in_g?: number, in_b?: number): Promise<void>;
        /**
         * Returns the underlying SDF/Cos object.
         * @returns A promise that resolves to the underlying SDF/Cos object.
         *
         * Note: A null (non-valid) bookmark returns a null object.
         */
        getSDFObj(): Promise<PDFNet.Obj>;
    }
    /**
     * This class represents a Byte Range.
     */
    class ByteRange {
        constructor(m_offset?: number, m_size?: number);
        /**
         * Retrieves the start offset of the byte range.
         * @returns A promise that resolves to an unsigned integer.
         */
        getStartOffset(): Promise<number>;
        /**
         * Retrieves the end offset of the byte range.
         * @returns A promise that resolves to an unsigned integer.
         */
        getEndOffset(): Promise<number>;
        /**
         * Retrieves the size of the byte range.
         * @returns A promise that resolves to an unsigned integer.
         */
        getSize(): Promise<number>;
        m_offset: number;
        m_size: number;
    }
    /**
     * A Caret annotation (PDF 1.5) is a visual symbol that indicates
     * the presence of text edits.
     */
    class CaretAnnot extends PDFNet.MarkupAnnot {
        /**
         * creates an Caret annotation and initializes it using given Cos/SDF object.
         * @param [d] - The Cos/SDF object to initialze the annotation with.
         * Note: The constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @returns A promise that resolves to an object of type: "PDFNet.CaretAnnot"
         */
        static createFromObj(d?: PDFNet.Obj): Promise<PDFNet.CaretAnnot>;
        /**
         * creates an Caret annotation and initializes it using given annotation object.
         * @param ann - Annot object used to initialize the Caret annotation.
         * Note: The constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @returns A promise that resolves to an object of type: "PDFNet.CaretAnnot"
         */
        static createFromAnnot(ann: PDFNet.Annot): Promise<PDFNet.CaretAnnot>;
        /**
         * Creates a new Caret annotation in the specified document.
         * @param doc - A document to which the Caret annotation is added.
         * @param pos - A rectangle specifying the Caret annotation's bounds in default user space units.
         * @returns A promise that resolves to a newly created blank Caret annotation.
         */
        static create(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, pos: PDFNet.Rect): Promise<PDFNet.CaretAnnot>;
        static create(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, type: number, pos: PDFNet.Rect): Promise<PDFNet.Annot>;
        /**
         * Returns the paragraph symbol associated with the caret.
         * @returns A promise that resolves to the name of the symbol. This can be either "P" (Use a new
         * paragraph symbol) or "None" (Don't use any symbol).
         * Default value: None.
         */
        getSymbol(): Promise<string>;
        /**
         * sets the caret symbol.
         * @param symbol - The name of the symbol. This can be either "P" (Use a new
         * paragraph symbol) or "None" (Don't use any symbol).
         * Default value: None.
         */
        setSymbol(symbol: string): Promise<void>;
    }
    /**
     * An object representing a check box used in a PDF Form.
     */
    class CheckBoxWidget extends PDFNet.WidgetAnnot {
        /**
         * Creates a new Check Box Widget annotation, in the specified document.
         * @param doc - The document to which the annotation is to be added.
         * @param pos - A rectangle specifying the annotation's bounds, specified in
         * user space coordinates.
         * @param [field_name] - The name of the field for which to create a CheckBox widget.
         * @returns A promise that resolves to a newly created blank Check Box Widget annotation.
         */
        static create(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, pos: PDFNet.Rect, field_name?: string): Promise<PDFNet.CheckBoxWidget>;
        static create(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, pos: PDFNet.Rect, field: PDFNet.Field): Promise<PDFNet.WidgetAnnot>;
        static create(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, type: number, pos: PDFNet.Rect): Promise<PDFNet.Annot>;
        /**
         * Creates a new Check Box Widget annotation, in the specified document.
         * @param doc - The document to which the annotation is to be added.
         * @param pos - A rectangle specifying the annotation's bounds, specified in
         * user space coordinates.
         * @param field - the field for which to create a CheckBox widget
         * @returns A promise that resolves to a newly created blank Check Box Widget annotation.
         */
        static createWithField(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, pos: PDFNet.Rect, field: PDFNet.Field): Promise<PDFNet.CheckBoxWidget>;
        /**
         * Creates a Check Box Widget annotation and initialize it using given Cos/SDF object.
         *
         * <p>
         * <b> Note: </b> The constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @param [d] - the object to use to initialize the Check Box Widget
         * @returns A promise that resolves to an object of type: "PDFNet.CheckBoxWidget"
         */
        static createFromObj(d?: PDFNet.Obj): Promise<PDFNet.CheckBoxWidget>;
        /**
         * Creates a Check Box Widget annotation and initialize it using given annotation object.
         *
         * <p>
         * <b> Note: </b>  The constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @param annot - The annotation object to use.
         * @returns A promise that resolves to an object of type: "PDFNet.CheckBoxWidget"
         */
        static createFromAnnot(annot: PDFNet.Annot): Promise<PDFNet.CheckBoxWidget>;
        /**
         * Returns whether the checkbox is checked.
         * @returns A promise that resolves to  A boolean value indicating whether the checkbox is checked.
         */
        isChecked(): Promise<boolean>;
        /**
         * Check or uncheck the Check Box Widget
         * @param checked - If true, the annotation should be checked. Otherwise it should be unchecked.
         */
        setChecked(checked: boolean): Promise<void>;
    }
    /**
     * [Not Yet Documented]
     */
    class ChunkRenderer {
    }
    /**
     * A Circle annotation is a type of markup annotation that displays an ellipse on
     * the page. When opened, it can display a pop-up window containing the text of
     * the associated note. The ellipse may be inscribed and possibly padded within the
     * annotation rectangle defined by the annotation dictionary's Rect entry.
     */
    class CircleAnnot extends PDFNet.MarkupAnnot {
        /**
         * creates an Circle annotation and initializes it using given Cos/SDF object.
         * @param [d] - The Cos/SDF object to initialze the annotation with.
         * Note: The constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @returns A promise that resolves to an object of type: "PDFNet.CircleAnnot"
         */
        static createFromObj(d?: PDFNet.Obj): Promise<PDFNet.CircleAnnot>;
        /**
         * creates a Circle annotation and initializes it using given annotation object.
         * @param circle - Annot object used to initialize the Circle annotation.
         * Note: The constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @returns A promise that resolves to an object of type: "PDFNet.CircleAnnot"
         */
        static createFromAnnot(circle: PDFNet.Annot): Promise<PDFNet.CircleAnnot>;
        /**
         * Creates a new Circle annotation in the specified document.
         * @param doc - A document to which the annotation is added.
         * @param pos - A rectangle specifying the annotation's bounds in default user space units.
         * @returns A promise that resolves to a newly created blank Circle annotation.
         */
        static create(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, pos: PDFNet.Rect): Promise<PDFNet.CircleAnnot>;
        static create(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, type: number, pos: PDFNet.Rect): Promise<PDFNet.Annot>;
        /**
         * @returns A promise that resolves to an object of type: "PDFNet.ColorPt"
         */
        getInteriorColor(): Promise<PDFNet.ColorPt>;
        /**
         * @returns A promise that resolves to an object of type: "number"
         */
        getInteriorColorCompNum(): Promise<number>;
        setInteriorColorDefault(col: PDFNet.ColorPt): Promise<void>;
        setInteriorColor(col: PDFNet.ColorPt, numcomp: number): Promise<void>;
        /**
         * @returns A promise that resolves to an object of type: "PDFNet.Rect"
         */
        getContentRect(): Promise<PDFNet.Rect>;
        setContentRect(cr: PDFNet.Rect): Promise<void>;
        /**
         * @returns A promise that resolves to an object of type: "PDFNet.Rect"
         */
        getPadding(): Promise<PDFNet.Rect>;
        setPadding(cr: PDFNet.Rect): Promise<void>;
    }
    class ClassMap {
        /**
         * Initialize a ClassMap using an existing low-level Cos/SDF ClassMap object.
         * @param [dict] - a low-level (SDF/Cos) ClassMap dictionary.
         *
         * Note: This constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @returns A promise that resolves to an object of type: "PDFNet.ClassMap"
         */
        static create(dict?: PDFNet.Obj): Promise<PDFNet.ClassMap>;
        /**
         * Copy Constructor
         * @returns A promise that resolves to an object of type: "PDFNet.ClassMap"
         */
        copy(): Promise<PDFNet.ClassMap>;
        /**
         * @returns A promise that resolves to true if this is a valid (non-null) ClassMap, false otherwise.
         * If the function returns false the underlying SDF/Cos object is null or is
         * not valid and the ClassMap object should be treated as a null object.
         */
        isValid(): Promise<boolean>;
        /**
         * Returns the ClassMap dictionary.
         * @returns A promise that resolves to the object to the underlying SDF/Cos object.
         */
        getSDFObj(): Promise<PDFNet.Obj>;
    }
    /**
     * ColorPt is an array of colorants (or tint values) representing a color point
     * in an associated color space.
     */
    class ColorPt extends PDFNet.Destroyable {
        /**
         * Constructor
         * @param [x] - initialized value of first color value (eg. red for rgb colorspace);
         * @param [y] - initialized value of second color value (eg. green for rgb colorspace);
         * @param [z] - initialized value of third color value (eg. blue for rgb colorspace);
         * @param [w] - initialized value of fourth color value (eg. when using CMYK);
         * Note: All colorants should be in the range [0..1], so colors in the range [0..255]
         * should be divided by 255.0 first.
         * @returns A promise that resolves to an object of type: "PDFNet.ColorPt"
         */
        static init(x?: number, y?: number, z?: number, w?: number): Promise<PDFNet.ColorPt>;
        /**
         * Comparison function.
         * Determines if parameter object is equal to current object.
         * @returns A promise that resolves to True if the two objects are equivalent, False otherwise
         */
        compare(right: PDFNet.ColorPt): Promise<boolean>;
        /**
         * A utility method to set the first 4 tint values. For example,
         * color.Set(red, green, blue) will initialize the ColorPt to given
         * tint values.
         * @param [x] - initialized value of first color value (eg. red for rgb colorspace);
         * @param [y] - initialized value of second color value (eg. green for rgb colorspace);
         * @param [z] - initialized value of third color value (eg. blue for rgb colorspace);
         * @param [w] - initialized value of fourth color value (eg. when using CMYK);
         * Note: color.Set(gray) is equivalent to Set(0, gray);
         * Note: All colorants should be in the range [0..1], so colors in the range [0..255]
         * should be divided by 255.0 first.
         */
        set(x?: number, y?: number, z?: number, w?: number): Promise<void>;
        /**
         * Sets a tint value at a given colorant index.
         * @param colorant_index - the color index. For example, for a color point
         * associated with a Gray color space the only allowed value for index
         * is 0. For a color point associated with a CMYK color space, the color_index
         * can range from 0 (cyan) to 4 (black).
         * @param colorant_value - The new tint value.
         *
         * For example, the following snippet will initialize the color point
         * to [red, green, blue]:
         * <pre>
         * color.SetColorantNum(3);
         * color.Set(0, red);
         * color.Set(1, green);
         * color.Set(2, blue);
         * </pre>
         *
         * The above code snippet is equivalent to the following line:
         *   color.Set(red, green, blue)
         *
         * Note: If a color point has more than 4 colorants, SetColorantNum(num_colorants)
         * must be called before getting or setting tint values.
         * Note: All colorants should be in the range [0..1], so colors in the range [0..255]
         * should be divided by 255.0 first.
         */
        setByIndex(colorant_index: number, colorant_value: number): Promise<void>;
        /**
         * The number of colorants depends on the associated color space. To find
         * how many colorant are associated with a given color space use
         * color_space.GetComponentNum().
         *
         * For example, if you have a color point in the RGB color space you can
         * extract its colorants as follows:
         * <pre>
         * UInt8 rgb[3] = { UInt8(c.Get(0)*255), UInt8(c.Get(1)*255), UInt8(c.Get(2)*255) };
         * </pre>
         * @param colorant_index - number representing the index of the color space to get the tint from
         * @returns A promise that resolves to the tint value at a given colorant index.
         */
        get(colorant_index: number): Promise<number>;
        /**
         * If a color point has more than 4 colorants, SetColorantNum(num_colorants)
         * must be called before getting or setting tint values.
         * The number of colorants depends on the associated color space. To find
         * how many colorant are associated with a given color space use
         * color_space.GetComponentNum().
         */
        setColorantNum(num: number): Promise<void>;
    }
    /**
     * This abstract class is used to serve as a color space tag to identify the specific
     * color space of a Color object. It contains methods that transform colors in a specific
     * color space to/from several color space such as DeviceRGB and DeviceCMYK.
     *
     * For purposes of the methods in this class, colors are represented as arrays of color
     * components represented as doubles in a normalized range defined by each ColorSpace.
     * For many ColorSpaces (e.g. DeviceRGB), this range is 0.0 to 1.0. However, some ColorSpaces
     * have components whose values have a different range. Methods are provided to inquire per
     * component minimum and maximum normalized values.
     *
     * Note: Note that in Pattern color space (i.e. for PDFNet.ColorSpace.Type.e_pattern) 'color values'
     * are PDFNet.PatternColor objects instead of the numeric component values (i.e. ColorPt)
     * used with other spaces.
     */
    class ColorSpace extends PDFNet.Destroyable {
        /**
         * Create a new DeviceGray ColorSpace object
         * @returns A promise that resolves to an object of type: "PDFNet.ColorSpace"
         */
        static createDeviceGray(): Promise<PDFNet.ColorSpace>;
        /**
         * Create a new DeviceRGB ColorSpace object
         * @returns A promise that resolves to an object of type: "PDFNet.ColorSpace"
         */
        static createDeviceRGB(): Promise<PDFNet.ColorSpace>;
        /**
         * Create a new DeviceCMYK ColorSpace object
         * @returns A promise that resolves to an object of type: "PDFNet.ColorSpace"
         */
        static createDeviceCMYK(): Promise<PDFNet.ColorSpace>;
        /**
         * Create a new Pattern ColorSpace object
         * @returns A promise that resolves to an object of type: "PDFNet.ColorSpace"
         */
        static createPattern(): Promise<PDFNet.ColorSpace>;
        /**
         * Create a ColorSpace from the given SDF/Cos object listed under ColorSpaces entry
         * in page Resource dictionary. If color_space dictionary is null, a non valid ColorSpace
         * object is created.
         * @param [color_space] - The Cos/SDF object to initialze the ColorSpace object with.
         * @returns A promise that resolves to an object of type: "PDFNet.ColorSpace"
         */
        static create(color_space?: PDFNet.Obj): Promise<PDFNet.ColorSpace>;
        /**
         * @returns A promise that resolves to an object of type: "PDFNet.ColorSpace"
         */
        static createICCFromFilter(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, filter: PDFNet.Filter): Promise<PDFNet.ColorSpace>;
        /**
         * @returns A promise that resolves to an object of type: "PDFNet.ColorSpace"
         */
        static createICCFromBuffer(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, buf: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray): Promise<PDFNet.ColorSpace>;
        /**
         * @param cs_type - <pre>
         * PDFNet.ColorSpace.Type = {
         * 	e_device_gray : 0
         * 	e_device_rgb : 1
         * 	e_device_cmyk : 2
         * 	e_cal_gray : 3
         * 	e_cal_rgb : 4
         * 	e_lab : 5
         * 	e_icc : 6
         * 	e_indexed : 7
         * 	e_pattern : 8
         * 	e_separation : 9
         * 	e_device_n : 10
         * 	e_null : 11
         * }
         * </pre>
         * @param cs_obj - Cos/SDF color space object.
         * @returns A promise that resolves to the number of components (tint components) used to represent color
         * point for this color space
         */
        static getComponentNumFromObj(cs_type: number, cs_obj: PDFNet.Obj): Promise<number>;
        /**
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.ColorSpace.Type = {
         * 	e_device_gray : 0
         * 	e_device_rgb : 1
         * 	e_device_cmyk : 2
         * 	e_cal_gray : 3
         * 	e_cal_rgb : 4
         * 	e_lab : 5
         * 	e_icc : 6
         * 	e_indexed : 7
         * 	e_pattern : 8
         * 	e_separation : 9
         * 	e_device_n : 10
         * 	e_null : 11
         * }
         * </pre>
         * @param cs_obj - Cos/SDF color space object.
         * @returns A promise that resolves to the Type of a given SDF/Cos color space, or e_null for if
         * SDF object is not a valid color space
         */
        static getTypeFromObj(cs_obj: PDFNet.Obj): Promise<number>;
        /**
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.ColorSpace.Type = {
         * 	e_device_gray : 0
         * 	e_device_rgb : 1
         * 	e_device_cmyk : 2
         * 	e_cal_gray : 3
         * 	e_cal_rgb : 4
         * 	e_lab : 5
         * 	e_icc : 6
         * 	e_indexed : 7
         * 	e_pattern : 8
         * 	e_separation : 9
         * 	e_device_n : 10
         * 	e_null : 11
         * }
         * </pre>
         * @returns A promise that resolves to the type of this color space
         */
        getType(): Promise<number>;
        /**
         * @returns A promise that resolves to the underlying SDF/Cos object
         */
        getSDFObj(): Promise<PDFNet.Obj>;
        /**
         * @returns A promise that resolves to the number of colorants (tint components) used to represent color
         *  point in this color space
         */
        getComponentNum(): Promise<number>;
        /**
         * Set color to the initial value used for this color space.
         * The initial value depends on the color space (see 4.5.7 in PDF Ref. Manual).
         * @returns A promise that resolves to an object of type: "PDFNet.ColorPt"
         */
        initColor(): Promise<PDFNet.ColorPt>;
        /**
         * @returns A promise that resolves to an object of type: "Object"
         */
        initComponentRanges(num_comps: number): Promise<object>;
        /**
         * A convenience function used to convert color points from the current
         * color space to DeviceGray color space.
         * @param in_color - input color point in the current color space
         * Note: the number to input colorants must match the number of colorants
         * expected by the current color space.
         * @returns A promise that resolves to an object of type: "PDFNet.ColorPt"
         */
        convert2Gray(in_color: PDFNet.ColorPt): Promise<PDFNet.ColorPt>;
        /**
         * A convenience function used to convert color points from the current
         * color space to DeviceRGB color space.
         * @param in_color - input color point in the current color space
         * Note: the number to input colorants must match the number of colorants
         * expected by the current color space.
         * @returns A promise that resolves to an object of type: "PDFNet.ColorPt"
         */
        convert2RGB(in_color: PDFNet.ColorPt): Promise<PDFNet.ColorPt>;
        /**
         * A convenience function used to convert color points from the current
         * color space to DeviceCMYK color space.
         * @param in_color - input color point in the current color space
         * Note: the number to input colorants must match the number of colorants
         * expected by the current color space.
         * @returns A promise that resolves to an object of type: "PDFNet.ColorPt"
         */
        convert2CMYK(in_color: PDFNet.ColorPt): Promise<PDFNet.ColorPt>;
        /**
         * @returns A promise that resolves to the alternate color space if it is available or NULL otherwise.
         * Color spaces that include alternate color space are e_separation, e_device_n,
         * and e_icc.
         */
        getAlternateColorSpace(): Promise<PDFNet.ColorSpace>;
        /**
         * @returns A promise that resolves to the base color space if this is an e_indexed or e_pattern with
         * associated base color space; NULL otherwise.
         */
        getBaseColorSpace(): Promise<PDFNet.ColorSpace>;
        /**
         * @returns A promise that resolves to the highest index for the color lookup table for Indexed color space.
         * Since the color table is indexed from zero to highval, the actual number of entries is
         * highval + 1. For color spaces other than indexed the method returns 0.
         *
         * Note: for color spaces other than Indexed this method throws an exception.
         */
        getHighVal(): Promise<number>;
        /**
         * @returns A promise that resolves to the color lookup table for Indexed color space. for color spaces other
         * than indexed the method returns NULL.
         *
         * Note: for color spaces other than Indexed this method throws an exception.
         */
        getLookupTable(): Promise<number>;
        /**
         * Get the base color given a component value (index) in Indexed color space.
         * @param color_idx - color value represented in the index color space
         * Note: for color spaces other than Indexed this method throws an exception.
         * @returns A promise that resolves to an object of type: "PDFNet.ColorPt"
         */
        getBaseColor(color_idx: number): Promise<PDFNet.ColorPt>;
        /**
         * @returns A promise that resolves to the function that transforms tint values into color component
         * values in the alternate color space.
         *
         * Note: for color spaces other than Separation this method throws an exception.
         */
        getTintFunction(): Promise<PDFNet.Function>;
        /**
         * @returns A promise that resolves to true if Separation color space contains the colorant All.
         *
         * Note: for color spaces other than Separation this method throws an exception.
         */
        isAll(): Promise<boolean>;
        /**
         * @returns A promise that resolves to true if Separation or DeviceN color space contains None colorants.
         * For DeviceN the function returns true only if component colorant names are all None.
         *
         * Note: for color spaces other than Separation or DeviceN this method throws
         * an exception.
         */
        isNone(): Promise<boolean>;
    }
    /**
     * An object representing a combo box used in a PDF Form.
     */
    class ComboBoxWidget extends PDFNet.WidgetAnnot {
        /**
         * Creates a new Combo Box Widget annotation, in the specified document.
         * @param doc - The document to which the annotation is added.
         * @param pos - A rectangle specifying the annotation's bounds, specified in
         * user space coordinates.
         * @param [field_name] - The name of the field for which to create a ComboBox widget
         * @returns A promise that resolves to a newly created blank Combo Box Widget annotation.
         */
        static create(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, pos: PDFNet.Rect, field_name?: string): Promise<PDFNet.ComboBoxWidget>;
        static create(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, pos: PDFNet.Rect, field: PDFNet.Field): Promise<PDFNet.WidgetAnnot>;
        static create(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, type: number, pos: PDFNet.Rect): Promise<PDFNet.Annot>;
        /**
         * Creates a new Widget annotation, in the specified document.
         * @param doc - The document to which the annotation is added.
         * @param pos - A rectangle specifying the annotation's bounds, specified in
         * user space coordinates.
         * @param field - The field for which to create a Text widget
         * @returns A promise that resolves to a newly created blank Widget annotation.
         */
        static createWithField(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, pos: PDFNet.Rect, field: PDFNet.Field): Promise<PDFNet.ComboBoxWidget>;
        /**
         * Creates a Combo Box Widget annotation and initialize it using given Cos/SDF object.
         *
         * <p>
         * <b> Note: </b> The constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @param [d] - the object to use to initialize the ComboBoxWidget
         * @returns A promise that resolves to an object of type: "PDFNet.ComboBoxWidget"
         */
        static createFromObj(d?: PDFNet.Obj): Promise<PDFNet.ComboBoxWidget>;
        /**
         * Creates a Combo Box Widget annotation and initialize it using given annotation object.
         *
         * <p>
         * <b> Note: </b>  The constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @param annot - The annotation to use.
         * @returns A promise that resolves to an object of type: "PDFNet.ComboBoxWidget"
         */
        static createFromAnnot(annot: PDFNet.Annot): Promise<PDFNet.ComboBoxWidget>;
        /**
         * Adds an option to Combo Box widget.
         * @param value - The option to add
         */
        addOption(value: string): Promise<void>;
        /**
         * Adds multiple options to Combo Box widget.
         * @param opts - The options to add
         */
        addOptions(opts: string[]): Promise<void>;
        /**
         * selects the given option in the Combo Box widget
         * @param value - The option to select
         */
        setSelectedOption(value: string): Promise<void>;
        /**
         * Retrieves the option selected in the ComboBox widget
         * @returns A promise that resolves to the option selected in the ComboBox widget
         */
        getSelectedOption(): Promise<string>;
        /**
         * Replaces the current Combo Box widget options with a new set.
         * @param new_opts - The new set of options to use.
         */
        replaceOptions(new_opts: string[]): Promise<void>;
        /**
         * Removes the option from Combo Box widget.
         * @param value - The option to remove
         */
        removeOption(value: string): Promise<void>;
    }
    /**
     * Content items are graphical objects that exist in the document independently
     * of the structure tree but are associated with structure elements.
     *
     * Content items are leaf nodes of the structure tree.
     */
    class ContentItem {
        constructor(o?: PDFNet.Obj, p?: PDFNet.Obj);
        /**
         * Copy Constructor
         * @returns A promise that resolves to an object of type: "PDFNet.ContentItem"
         */
        copy(): Promise<PDFNet.ContentItem>;
        /**
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.ContentItem.Type = {
         * 	e_MCR : 0
         * 	e_MCID : 1
         * 	e_OBJR : 2
         * 	e_Unknown : 3
         * }
         * </pre>
         * @returns A promise that resolves to the content item type.
         */
        getType(): Promise<number>;
        /**
         * find the parent structure element.
         * @returns A promise that resolves to an object of type: "PDFNet.SElement"
         */
        getParent(): Promise<PDFNet.SElement>;
        /**
         * the page on which the marked content is drawn, whether directly as part of
         * page content or indirectly by being in a Form XObject or annotation drawn
         * on that page.
         * @returns A promise that resolves to an object of type: "PDFNet.Page"
         */
        getPage(): Promise<PDFNet.Page>;
        /**
         * @returns A promise that resolves to pointer to the underlying SDF/Cos object.
         */
        getSDFObj(): Promise<PDFNet.Obj>;
        /**
         * @returns A promise that resolves to mcid (marked-content identifier).
         *
         * Note: this method only applies to content items with types e_MCR or e_MCID.
         */
        getMCID(): Promise<number>;
        /**
         * @returns A promise that resolves to the stream object that contains the marked-content sequence.
         * The function will return a non-NULL object only if the marked-content
         * sequence resides in a content stream other than the content stream for the
         * page (e.g. in a form XObject).
         *
         * Note: this method only applies to content items with type e_MCR.
         */
        getContainingStm(): Promise<PDFNet.Obj>;
        /**
         * @returns A promise that resolves to nULL or the PDF object owning the stream returned by
         * GetContainingStm() (e.g. the annotation to which an appearance stream
         * belongs).
         *
         * Note: this method only applies to content items with type e_MCR.
         */
        getStmOwner(): Promise<PDFNet.Obj>;
        /**
         * @returns A promise that resolves to the referenced object.
         * Note: this method only applies to content items with type e_OBJR.
         */
        getRefObj(): Promise<PDFNet.Obj>;
        o: PDFNet.Obj;
        p: PDFNet.Obj;
    }
    /**
     * ContentReplacer is a utility class for replacing content (text and images)
     * in existing PDF (template) documents.
     *
     * Users can replace content in a PDF page using the following operations:
     * - Replace an image that exists in a target rectangle with a replacement image.
     * - Replace text that exists in a target rectangle with replacement text.
     * - Replace all instances of a specially marked string with replacement string.
     *
     * The following code replaces an image in a target region. This code also
     * replaces the text "[NAME]" and "[JOB_TITLE]" with "John Smith"
     * and "Software Developer" respectively. Notice the square braces ('[' and ']') on
     * the target strings in the original PDFDoc. These square braces are not included in
     * the actual function calls below, as they're implicitly added.
     *
     * <pre>
     * PDFDoc doc("../../TestFiles/BusinessCardTemplate.pdf");
     * doc.InitSecurityHandler();
     * ContentReplacer replacer;
     * Page page = doc.GetPage(1);
     * Image img = Image::Create(doc, "../../TestFiles/peppers.jpg");
     * replacer.AddImage(page.GetMediaBox(), img.GetSDFObj());
     * replacer.AddString("NAME", "John Smith");
     * replacer.AddString("JOB_TITLE", "Software Developer");
     * replacer.Process(page);
     * </pre>
     */
    class ContentReplacer extends PDFNet.Destroyable {
        /**
         * Create a new ContentReplacer object, to which replacement rules will be added.
         * The same object can be used to 'Process' multiple pages.
         * @returns A promise that resolves to an object of type: "PDFNet.ContentReplacer"
         */
        static create(): Promise<PDFNet.ContentReplacer>;
        /**
         * Replace the image that best fits into 'target_region' with 'replacement_image'.
         * @param target_region - The rectangle defining the area in which an image
         * that best fits the rectangle will be replaced by 'replacement_image'.
         * @param replacement_image - The 'SDF.Obj' of a 'PDF.Image' object.
         *
         * Note: The best fit is the image that closest matches 'target_region'. For example if
         * there are two images on the page, one taking up all of the page, and the other
         * smaller, and the smaller one has similar dimensions and position of
         * 'target_region', then the smaller image would be replaced, not the larger.
         * Furthermore, if 'target_region' encloses multiple images, then only the image
         * with the largest area in 'target_region' will be replaced.
         */
        addImage(target_region: PDFNet.Rect, replacement_image: PDFNet.Obj): Promise<void>;
        /**
         * All text inside 'target_region' will be deleted and replaced with 'replacement_text'.
         * @param target_region - The rectangle defining the area in which all text will
         * be replaced by 'replacement_text'.
         * @param replacement_text - The new text that will replace the existing text
         * in 'target_region'.
         *
         * Note: The 'replacement_text' will be styled in the same font/color/style that is used
         * by the original text. If there are multiple font styles, the most prevalent style will
         * be used. Also, the 'replacement_text' will wrap within the 'target_region',
         * but if it is too long, the overflow text will not be visible, and no surrounding
         * content will be affected.
         */
        addText(target_region: PDFNet.Rect, replacement_text: string): Promise<void>;
        /**
         * Any text of the form "[template_text]" will be replaced by "replacement_text".
         * @param template_text - The text to remove.
         * @param replacement_text - The new text that will appear in place of 'template_text'.
         *
         * Note: Only text wrapped in '[' and ']' will be checked, and if it matches 'template_text',
         * then 'template_text' and the surrounding square braces will be replaced
         * by 'replacement_text'. For example AddString("TITLE", "Doctor") will replace any
         * text consisting of "[TITLE]" with "Doctor".
         */
        addString(template_text: string, replacement_text: string): Promise<void>;
        /**
         * Change the delimiters from '[' and ']' to arbitary strings.
         * @param start_str - The starting delimiter string.
         * @param end_str - The ending delimiter string.
         *
         * Note: While empty strings are allowed as delimiters, a warning is displayed.
         * Otherwise there are no restrictions.  For example, after SetMatchStrings("<<", ">>"),
         * AddString("TITLE", "Doctor") will replace any text consisting of "<<TITLE>>" with
         * "Doctor".  Similarly, after SetMatchStrings("Beginning...", "...ending."),
         * AddString("TITLE", "Doctor") will replace "Beginning...TITLE...ending." with
         * "Doctor".
         */
        setMatchStrings(start_str: string, end_str: string): Promise<void>;
        /**
         * Apply the replacement instructions to the target page. Subsequent calls
         * to 'Process' can be made on other pages, and it will apply the same rules.
         * @param page - The page to apply the content replacement instructions to.
         */
        process(page: PDFNet.Page): Promise<void>;
    }
    /**
     * Experimental. Developer use only.
     */
    class ConversionMonitor extends PDFNet.Destroyable {
        /**
         * @returns A promise that resolves to an object of type: "boolean"
         */
        next(): Promise<boolean>;
        /**
         * @returns A promise that resolves to an object of type: "boolean"
         */
        ready(): Promise<boolean>;
        /**
         * @returns A promise that resolves to an object of type: "number"
         */
        progress(): Promise<number>;
        /**
         * @returns A promise that resolves to an object of type: "PDFNet.Filter"
         */
        filter(): Promise<PDFNet.Filter>;
    }
    /**
     * The Date class is a utility class used to simplify work with PDF date objects.
     *
     * PDF defines a standard date format, which closely follows international
     * standard ASN.1 (Abstract Syntax Notation One), A date is a string of the form
     * (D:YYYYMMDDHHmmSSOHH'mm'); See PDF Reference Manual for details.
     *
     * Date can be associated with a SDF/Cos date string using Date(Obj*) constructor
     * or later using Date::Attach(Obj*) or Date::Update(Obj*) methods.
     *
     * Date keeps a local date/time cache so it is necessary to call Date::Update()
     * method if the changes to the Date should be saved in the attached Cos/SDF string.
     */
    class Date {
        constructor(year?: number, month?: number, day?: number, hour?: number, minute?: number, second?: number, UT?: number, UT_hour?: number, UT_minutes?: number, mp_obj?: PDFNet.Obj);
        /**
         * Create a Date and initialize it using specified parameters.
         * The Date is not attached to any Cos/SDF object.
         * @param year - number representing the year to initialize the Date object to.
         * @param month - number representing the month to initialize the Date object to.
         * @param day - number representing the day to initialize the Date object to.
         * @param hour - number representing the hour to initialize the Date object to.
         * @param minute - number representing the minute to initialize the Date object to.
         * @param second - number representing the second to initialize the Date object to.
         * @returns A promise that resolves to an object of type: "PDFNet.Date"
         */
        static init(year: number, month: number, day: number, hour: number, minute: number, second: number): Promise<PDFNet.Date>;
        /**
         * Indicates whether the Date is valid (non-null).
         * @returns A promise that resolves to true if this is a valid (non-null) Date; otherwise false.
         *
         * Note: If this method returns false the underlying SDF/Cos object is null and
         * the Date object should be treated as null as well.
         */
        isValid(): Promise<boolean>;
        /**
         * attach the Cos/SDF object to the Date.
         * @param d - underlying Cos/SDF object. Must be an SDF::Str containing
         *  a PDF date object.
         */
        attach(d: PDFNet.Obj): Promise<void>;
        /**
         * Saves changes made to the Date object in the attached (or specified) SDF/Cos string.
         * @param [d] - an optional parameter indicating a SDF string that should be
         *  updated and attached to this Date. If parameter d is NULL or is omitted, update
         *  is performed on previously attached Cos/SDF date.
         * @returns A promise that resolves to true if the attached Cos/SDF string was successfully updated, false otherwise.
         */
        update(d?: PDFNet.Obj): Promise<boolean>;
        /**
         * Sets the date object to the current date and time. The method also updates
         * associated SDF object.
         */
        setCurrentTime(): Promise<void>;
        year: number;
        month: number;
        day: number;
        hour: number;
        minute: number;
        second: number;
        UT: number;
        UT_hour: number;
        UT_minutes: number;
        mp_obj: PDFNet.Obj;
    }
    /**
     * A destination defines a particular view of a document, consisting of the
     * following:
     *
     * - The page of the document to be displayed
     * - The location of the document window on that page
     * - The magnification (zoom) factor to use when displaying the page
     *
     * Destinations may be associated with Bookmarks, Annotations, and Remote Go-To Actions.
     *
     * Destination is a utility class used to simplify work with PDF Destinations;
     * Please refer to section 8.2.1 'Destinations' in PDF Reference Manual for details.
     */
    class Destination {
        /**
         * Create a new 'XYZ' Destination.
         *
         * The new Destination displays the page designated by 'page', with the
         * coordinates ('left', 'top') positioned at the top-left corner of the
         * window and the contents of the page magnified by the factor 'zoom'.
         * A null value for any of the parameters 'left', 'top', or 'zoom' specifies
         * that the current value of that parameter is to be retained unchanged.
         * A 'zoom' value of 0 has the same meaning as a null value.
         * the page within the window in the other dimension.
         * @param page - Page object to display
         * @param left - horizontal coordinate of the left edge of the window
         * @param top - vertical coordinate of the top edge of the window
         * @param zoom - amount to zoom the page by
         * @returns A promise that resolves to an object of type: "PDFNet.Destination"
         */
        static createXYZ(page: PDFNet.Page, left: number, top: number, zoom: number): Promise<PDFNet.Destination>;
        /**
         * Create a new 'Fit' Destination.
         *
         * The new Destination displays the page designated by 'page', with its contents
         * magnified just enough to fit the entire page within the window both
         * horizontally and vertically. If the required horizontal and vertical
         * magnification factors are different, use the smaller of the two, centering
         * the page within the window in the other dimension.
         * @param page - Page object to display
         * @returns A promise that resolves to an object of type: "PDFNet.Destination"
         */
        static createFit(page: PDFNet.Page): Promise<PDFNet.Destination>;
        /**
         * Create a new 'FitH' Destination.
         *
         * The new Destination displays the page designated by 'page', with the
         * vertical coordinate 'top' positioned at the top edge of the window and
         * the contents of the page magnified just enough to fit the entire width
         * of the page within the window.
         * @param page - Page object to display
         * @param top - vertical coordinate of the top edge of the window
         * @returns A promise that resolves to an object of type: "PDFNet.Destination"
         */
        static createFitH(page: PDFNet.Page, top: number): Promise<PDFNet.Destination>;
        /**
         * Create a new 'FitV' Destination.
         *
         * The new Destination displays the page designated by 'page', with the
         * horizontal coordinate 'left' positioned at the left edge of the window
         * and the contents of the page magnified just enough to fit the entire
         * height of the page within the window.
         * @param page - Page object to display
         * @param left - horizontal coordinate of the left edge of the window
         * @returns A promise that resolves to an object of type: "PDFNet.Destination"
         */
        static createFitV(page: PDFNet.Page, left: number): Promise<PDFNet.Destination>;
        /**
         * Create a new 'FitR' Destination.
         *
         * The new Destination displays the page designated by 'page', with its
         * contents magnified just enough to fit the rectangle specified by the
         * coordinates 'left', 'bottom', 'right', and 'top' entirely within the
         * window both horizontally and vertically. If the required horizontal
         * and vertical magnification factors are different, use the smaller of
         * the two, centering the rectangle within the window in the other
         * dimension.
         * @param page - Page object to display
         * @param left - horizontal coordinate of the left edge of the window
         * @param bottom - vertical coordinate of the bottom edge of the window
         * @param right - horizontal coordinate of the right edge of the window
         * @param top - vertical coordinate of the top edge of the window
         * @returns A promise that resolves to an object of type: "PDFNet.Destination"
         */
        static createFitR(page: PDFNet.Page, left: number, bottom: number, right: number, top: number): Promise<PDFNet.Destination>;
        /**
         * Create a new 'FitB' Destination.
         *
         * The new Destination displays the page designated by 'page', with its
         * contents magnified just enough to fit its bounding box entirely within
         * the window both horizontally and vertically. If the required
         * horizontal and vertical magnification factors are different, use the
         * smaller of the two, centering the bounding box within the window in
         * the other dimension.
         * @param page - Page object to display
         * @returns A promise that resolves to an object of type: "PDFNet.Destination"
         */
        static createFitB(page: PDFNet.Page): Promise<PDFNet.Destination>;
        /**
         * Create a new 'FitBH' Destination.
         *
         * The new Destination displays the page designated by 'page', with
         * the vertical coordinate 'top' positioned at the top edge of the window
         * and the contents of the page magnified just enough to fit the entire
         * width of its bounding box within the window.
         * @param page - Page object to display
         * @param top - vertical coordinate of the top edge of the window
         * @returns A promise that resolves to an object of type: "PDFNet.Destination"
         */
        static createFitBH(page: PDFNet.Page, top: number): Promise<PDFNet.Destination>;
        /**
         * Create a new 'FitBV' Destination.
         *
         * The new Destination displays Display the page designated by 'page',
         * with the horizontal coordinate 'left' positioned at the left edge of
         * the window and the contents of the page magnified just enough to fit
         * the entire height of its bounding box within the window.
         * @param page - Page object to display
         * @param left - horizontal coordinate of the left edge of the window
         * @returns A promise that resolves to an object of type: "PDFNet.Destination"
         */
        static createFitBV(page: PDFNet.Page, left: number): Promise<PDFNet.Destination>;
        /**
         * Create a Destination and initialize it using given Cos/SDF object.
         * @param dest - a low-level (SDF/Cos) destination object. The low-level
         * destination can be either a named destination (i.e. a Name or a String)
         * or an explicit destination (i.e. an Array Obj). Please refer to section
         * 8.2.1 'Destinations' in PDF Reference Manual for more details.
         *
         * Note: The constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         *
         * Note: Named destinations (in case 'dest' is a Name or a String) are
         * automatically resolved to the explicit destination. If the name can't
         * be resolved to the explicit destination dest.IsValid() will return false.
         * @returns A promise that resolves to an object of type: "PDFNet.Destination"
         */
        static create(dest: PDFNet.Obj): Promise<PDFNet.Destination>;
        /**
         * Copy Constructor
         * @returns A promise that resolves to an object of type: "PDFNet.Destination"
         */
        copy(): Promise<PDFNet.Destination>;
        /**
         * @returns A promise that resolves to true if this is a valid Destination and can be resolved, false otherwise.
         *
         * Note: If this method returns false the underlying SDF/Cos object is null and
         * the Action object should be treated as null as well.
         */
        isValid(): Promise<boolean>;
        /**
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.Destination.FitType = {
         * 	e_XYZ : 0
         * 	e_Fit : 1
         * 	e_FitH : 2
         * 	e_FitV : 3
         * 	e_FitR : 4
         * 	e_FitB : 5
         * 	e_FitBH : 6
         * 	e_FitBV : 7
         * }
         * </pre>
         * @returns A promise that resolves to destination's FitType.
         */
        getFitType(): Promise<number>;
        /**
         * @returns A promise that resolves to the Page that this destination refers to.
         */
        getPage(): Promise<PDFNet.Page>;
        /**
         * Modify the destination so that it refers to the new 'page' as the destination page.
         * @param page - The new page associated with this Destination.
         */
        setPage(page: PDFNet.Page): Promise<void>;
        /**
         * @returns A promise that resolves to the object to the underlying SDF/Cos object.
         * The returned SDF/Cos object is an explicit destination (i.e. the Obj is either
         * an array defining the destination, using the syntax shown in Table 8.2 in PDF
         * Reference Manual), or a dictionary with a 'D' entry whose value is such an
         * array. The latter form allows additional attributes to be associated with
         * the destination
         */
        getSDFObj(): Promise<PDFNet.Obj>;
        /**
         * @returns A promise that resolves to the explicit destination SDF/Cos object. This is always an Array
         * as shown in Table 8.2 in PDF Reference Manual.
         */
        getExplicitDestObj(): Promise<PDFNet.Obj>;
    }
    /**
     * DictIterator is used to traverse key/value pairs in a dictionary.
     * For example a DictIterator can be used to print out all the entries
     * in a given Obj dictionary as follows:
     * <pre>
     *  DictIterator itr = dict.GetDictIterator();
     *  while (itr.HasNext()) {
     *      Obj key = itr.Key();
     * 	    cout << key.GetName() << endl;
     *      Obj value = itr.Value();
     *      // ...
     *      itr.Next()
     *   }
     * </pre>
     */
    class DictIterator extends PDFNet.Destroyable {
        /**
         * @returns A promise that resolves to true if the iterator can be successfully advanced to the
         * next element; false if the end collection is reached.
         */
        hasNext(): Promise<boolean>;
        /**
         * @returns A promise that resolves to the key of the current dictionary entry.
         */
        key(): Promise<PDFNet.Obj>;
        /**
         * @returns A promise that resolves to the value of the current dictionary entry.
         */
        value(): Promise<PDFNet.Obj>;
        /**
         * Advances the iterator to the next element of the collection.
         */
        next(): Promise<void>;
    }
    /**
     * [Missing documentation]
     */
    class DigestAlgorithm {
        /**
         * @param in_algorithm - <pre>
         * PDFNet.DigestAlgorithm.Type = {
         * 	e_SHA1 : 0
         * 	e_SHA256 : 1
         * 	e_SHA384 : 2
         * 	e_SHA512 : 3
         * 	e_RIPEMD160 : 4
         * 	e_unknown_digest_algorithm : 5
         * }
         * </pre>
         * @returns A promise that resolves to an object of type: "Uint8Array"
         */
        static calculateDigest(in_algorithm: number, in_buffer: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray): Promise<Uint8Array>;
    }
    /**
     * A class representing a digital signature form field.
     */
    class DigitalSignatureField {
        constructor(mp_field_dict_obj?: PDFNet.Obj);
        /**
         * Returns whether the digital signature field has been cryptographically signed. Checks whether there is a digital signature dictionary in the field and whether it has a Contents entry. Must be called before using various digital signature dictionary-related functions. Does not check validity will return true even if a valid hash has not yet been generated (which will be the case after [Certify/Sign]OnNextSave[WithCustomHandler] has been called on the signature but even before Save is called on the document).
         * @returns A promise that resolves to a boolean value representing whether the digital signature field has a digital signature dictionary with a Contents entry.
         */
        hasCryptographicSignature(): Promise<boolean>;
        /**
         * Returns the SubFilter type of the digital signature. Specification says that one must check the SubFilter before using various getters. Must call HasCryptographicSignature first and use it to check whether the signature is signed.
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.DigitalSignatureField.SubFilterType = {
         * 	e_adbe_x509_rsa_sha1 : 0
         * 	e_adbe_pkcs7_detached : 1
         * 	e_adbe_pkcs7_sha1 : 2
         * 	e_ETSI_CAdES_detached : 3
         * 	e_ETSI_RFC3161 : 4
         * 	e_unknown : 5
         * 	e_absent : 6
         * }
         * </pre>
         * @returns A promise that resolves to an enumeration describing what the SubFilter of the digital signature is from within the digital signature dictionary.
         */
        getSubFilter(): Promise<number>;
        /**
         * Should not be called when SubFilter is ETSI.RFC3161 (i.e. on a DocTimeStamp). Returns the name of the signer of the signature from the digital signature dictionary. Must call HasCryptographicSignature first and use it to check whether the signature is signed.
         * @returns A promise that resolves to a unicode string containing the name of the signer from within the digital signature dictionary. Empty if Name entry not present.
         */
        getSignatureName(): Promise<string>;
        /**
         * Should not be called when SubFilter is ETSI.RFC3161 (i.e. on a DocTimeStamp). Returns the Location of the signature from the digital signature dictionary. Must call HasCryptographicSignature first and use it to check whether the signature is signed.
         * @returns A promise that resolves to a unicode string containing the signing location from within the digital signature dictionary. Empty if Location entry not present.
         */
        getLocation(): Promise<string>;
        /**
         * Should not be called when SubFilter is ETSI.RFC3161 (i.e. on a DocTimeStamp). Returns the Reason for the signature from the digital signature dictionary. Must call HasCryptographicSignature first and use it to check whether the signature is signed.
         * @returns A promise that resolves to a unicode string containing the reason for the signature from within the digital signature dictionary. Empty if Reason entry not present.
         */
        getReason(): Promise<string>;
        /**
         * Should not be called when SubFilter is ETSI.RFC3161 (i.e. on a DocTimeStamp). Returns the contact information of the signer from the digital signature dictionary. Must call HasCryptographicSignature first and use it to check whether the signature is signed.
         * @returns A promise that resolves to a unicode string containing the contact information of the signer from within the digital signature dictionary. Empty if ContactInfo entry not present.
         */
        getContactInfo(): Promise<string>;
        /**
         * Gets number of certificates in certificate chain (Cert entry of digital signature dictionary). Must call HasCryptographicSignature first and use it to check whether the signature is signed. Only to be used for old-style adbe.x509.rsa_sha1 signatures; for other signatures, use CMS getter functions instead.
         * @returns A promise that resolves to an integer value the number of certificates in the Cert entry of the digital signature dictionary.
         */
        getCertCount(): Promise<number>;
        /**
         * Returns whether the field has a visible appearance. Can be called without checking HasCryptographicSignature first, since it operates on the surrounding Field dictionary, not the "V" entry (i.e. digital signature dictionary). Performs the zero-width+height check, the Hidden bit check, and the NoView bit check as described by the PDF 2.0 specification, section 12.7.5.5 "Signature fields".
         * @returns A promise that resolves to a boolean representing whether or not the signature field has a visible signature.
         */
        hasVisibleAppearance(): Promise<boolean>;
        /**
         * Should not be called when SubFilter is ETSI.RFC3161 (i.e. on a DocTimeStamp). Sets the ContactInfo entry in the digital signature dictionary. Must create a digital signature dictionary first using [Certify/Sign]OnNextSave[WithCustomHandler]. If this function is called on a digital signature field that has already been cryptographically signed with a valid hash, the hash will no longer be valid, so do not call Save (to sign/create the hash) until after you call this function, if you need to call this function in the first place. Essentially, call this function after [Certify/Sign]OnNextSave[WithCustomHandler] and before Save.
         * @param in_contact_info - - A string containing the ContactInfo to be set.
         */
        setContactInfo(in_contact_info: string): Promise<void>;
        /**
         * Should not be called when SubFilter is ETSI.RFC3161 (i.e. on a DocTimeStamp). Sets the Location entry in the digital signature dictionary. Must create a digital signature dictionary first using [Certify/Sign]OnNextSave[WithCustomHandler]. If this function is called on a digital signature field that has already been cryptographically signed with a valid hash, the hash will no longer be valid, so do not call Save (to sign/create the hash) until after you call this function, if you need to call this function in the first place. Essentially, call this function after [Certify/Sign]OnNextSave[WithCustomHandler] and before Save.
         * @param in_location - - A string containing the Location to be set.
         */
        setLocation(in_location: string): Promise<void>;
        /**
         * Should not be called when SubFilter is ETSI.RFC3161 (i.e. on a DocTimeStamp). Sets the Reason entry in the digital signature dictionary. Must create a digital signature dictionary first using [Certify/Sign]OnNextSave[WithCustomHandler]. If this function is called on a digital signature field that has already been cryptographically signed with a valid hash, the hash will no longer be valid, so do not call Save (to sign/create the hash) until after you call this function, if you need to call this function in the first place. Essentially, call this function after [Certify/Sign]OnNextSave[WithCustomHandler] and before Save.
         * @param in_reason - - A string containing the Reason to be set.
         */
        setReason(in_reason: string): Promise<void>;
        /**
         * Sets the document locking permission level for this digital signature field. Call only on unsigned signatures, otherwise a valid hash will be invalidated.
         * @param in_perms - <pre>
         * PDFNet.DigitalSignatureField.DocumentPermissions = {
         * 	e_no_changes_allowed : 1
         * 	e_formfilling_signing_allowed : 2
         * 	e_annotating_formfilling_signing_allowed : 3
         * 	e_unrestricted : 4
         * }
         * </pre>
         * -- An enumerated value representing the document locking permission level to set.
         */
        setDocumentPermissions(in_perms: number): Promise<void>;
        /**
         * Must be called to prepare a signature for signing, which is done afterwards by calling Save. Cannot sign two signatures during one save (throws). Default document permission level is e_annotating_formfilling_signing_allowed. Throws if signature field already has a digital signature dictionary.
         * @param in_pkcs12_keyfile_path - - The path to the PKCS #12 private keyfile to use to sign this digital signature.
         * @param in_password - - The password to use to parse the PKCS #12 keyfile.
         */
        signOnNextSave(in_pkcs12_keyfile_path: string, in_password: string): Promise<void>;
        /**
         * Must be called to prepare a signature for certification, which is done afterwards by calling Save. Throws if document already certified. Default document permission level is e_annotating_formfilling_signing_allowed. Throws if signature field already has a digital signature dictionary.
         * @param in_pkcs12_keyfile_path - - The path to the PKCS #12 private keyfile to use to certify this digital signature.
         * @param in_password - - The password to use to parse the PKCS #12 keyfile.
         */
        certifyOnNextSave(in_pkcs12_keyfile_path: string, in_password: string): Promise<void>;
        /**
         * Returns whether this digital signature field is locked against modifications by any digital signatures. Can be called when this field is unsigned.
         * @returns A promise that resolves to a boolean representing whether this digital signature field is locked against modifications by any digital signatures in the document.
         */
        isLockedByDigitalSignature(): Promise<boolean>;
        /**
         * If HasCryptographicSignature, returns most restrictive permissions found in any reference entries in this digital signature. Returns Lock-resident (i.e. tentative) permissions otherwise. Throws if invalid permission value is found.
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.DigitalSignatureField.DocumentPermissions = {
         * 	e_no_changes_allowed : 1
         * 	e_formfilling_signing_allowed : 2
         * 	e_annotating_formfilling_signing_allowed : 3
         * 	e_unrestricted : 4
         * }
         * </pre>
         * @returns A promise that resolves to an enumeration value representing the level of restrictions (potentially) placed on the document by this signature.
         */
        getDocumentPermissions(): Promise<number>;
        /**
         * Clears cryptographic signature, if present. Otherwise, does nothing. Do not need to call HasCryptographicSignature before calling this. After clearing, other signatures should still pass validation if saving after clearing was done incrementally. Clears the appearance as well.
         */
        clearSignature(): Promise<void>;
        /**
         * Constructs a PDF::DigitalSignatureField from a PDF::Field.
         * @param in_field - - the PDF::Field to construct the DigitalSignatureField from.
         * @returns A promise that resolves to an object of type: "PDFNet.DigitalSignatureField"
         */
        static createFromField(in_field: PDFNet.Field): Promise<PDFNet.DigitalSignatureField>;
        /**
         * Should not be called when SubFilter is ETSI.RFC3161 (i.e. on a DocTimeStamp).
         * Returns the "M" entry from the digital signature dictionary, which represents the
         * signing date/time. Must call HasCryptographicSignature first and use it to check whether the
         * signature is signed.
         * @returns A promise that resolves to a PDF::Date object holding the signing date/time from within the digital signature dictionary. Returns a default-constructed PDF::Date if no date is present.
         */
        getSigningTime(): Promise<PDFNet.Date>;
        /**
         * Gets a certificate in the certificate chain (Cert entry) of the digital signature dictionary by index. Throws if Cert is not Array or String, throws if index is out of range and Cert is Array, throws if index is > 1 and Cert is string, otherwise retrieves the certificate. Only to be used for old-style adbe.x509.rsa_sha1 signatures; for other signatures, use CMS getter functions instead.
         * @param in_index - - An integral index which must be greater than 0 and less than the cert count as retrieved using GetCertCount.
         * @returns A promise that resolves to a vector of bytes containing the certificate at the index. Returns empty vector if Cert is missing.
         */
        getCert(in_index: number): Promise<Uint8Array>;
        /**
         * Tentatively sets which fields are to be locked by this digital signature upon signing. It is not necessary to call HasCryptographicSignature before using this function. Throws if non-empty array of field names is passed along with FieldPermissions Action == e_lock_all.
         * @param in_action - <pre>
         * PDFNet.DigitalSignatureField.FieldPermissions = {
         * 	e_lock_all : 0
         * 	e_include : 1
         * 	e_exclude : 2
         * }
         * </pre>
         * -- An enumerated value representing which sort of field locking should be done. Options are All (lock all fields), Include (lock listed fields), and Exclude (lock all fields except listed fields).
         * @param [in_field_names_list] - - A list of field names; can be empty (and must be empty, if Action is set to All). Empty by default.
         */
        setFieldPermissions(in_action: number, in_field_names_list?: string[]): Promise<void>;
        /**
         * Must be called to prepare a signature for signing, which is done afterwards by calling Save. Cannot sign two signatures during one save (throws). Default document permission level is e_annotating_formfilling_signing_allowed. Throws if signature field already has a digital signature dictionary.
         * @param in_pkcs12_buffer - - A buffer of bytes containing the PKCS #12 private key certificate store to use to sign this digital signature.
         * @param in_password - - The password to use to parse the PKCS #12 buffer.
         */
        signOnNextSaveFromBuffer(in_pkcs12_buffer: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray, in_password: string): Promise<void>;
        /**
         * Must be called to prepare a signature for signing, which is done afterwards by calling Save. Cannot sign two signatures during one save (throws). Default document permission level is e_annotating_formfilling_signing_allowed. Throws if signature field already has a digital signature dictionary.
         * @param in_signature_handler_id - - The unique id of the signature handler to use to sign this digital signature.
         */
        signOnNextSaveWithCustomHandler(in_signature_handler_id: number): Promise<void>;
        /**
         * Must be called to prepare a signature for certification, which is done afterwards by calling Save. Throws if document already certified. Default document permission level is e_annotating_formfilling_signing_allowed. Throws if signature field already has a digital signature dictionary.
         * @param in_pkcs12_buffer - - A buffer of bytes containing the PKCS #12 private key certificate store to use to certify this digital signature.
         * @param in_password - - The password to use to parse the PKCS #12 buffer.
         */
        certifyOnNextSaveFromBuffer(in_pkcs12_buffer: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray, in_password: string): Promise<void>;
        /**
         * Must be called to prepare a signature for certification, which is done afterwards by calling Save. Throws if document already certified. Default document permission level is e_annotating_formfilling_signing_allowed. Throws if signature field already has a digital signature dictionary.
         * @param in_signature_handler_id - - The unique id of the signature handler to use to certify this digital signature.
         */
        certifyOnNextSaveWithCustomHandler(in_signature_handler_id: number): Promise<void>;
        /**
         * Retrieves the SDF Obj of the digital signature field.
         * @returns A promise that resolves to the underlying SDF/Cos object.
         */
        getSDFObj(): Promise<PDFNet.Obj>;
        /**
         * Returns the fully-qualified names of all fields locked by this signature using the field permissions feature. Retrieves from the digital signature dictionary if the form field HasCryptographicSignature. Otherwise, retrieves from the Lock entry of the digital signature form field. Result is invalidated by any field additions or removals. Does not take document permissions restrictions into account.
         * @returns A promise that resolves to a vector of UStrings representing the fully-qualified names of all fields locked by this signature.
         */
        getLockedFields(): Promise<string[]>;
        /**
         * Verifies this cryptographic digital signature in the manner specified by the VerificationOptions. EXPERIMENTAL. Digital signature verification is undergoing active development, but currently does not support a number of features. If we are missing a feature that is important to you, or if you have files that do not act as expected, please contact us using one of the following forms: https://www.pdftron.com/form/trial-support/ or https://www.pdftron.com/form/request/
         * @param in_opts - - The options specifying how to do the verification.
         * @returns A promise that resolves to a VerificationResult object containing various information about the verifiability of the cryptographic digital signature.
         */
        verify(in_opts: PDFNet.VerificationOptions): Promise<PDFNet.VerificationResult>;
        /**
         * Returns whether or not this signature is a certification.
         * @returns A promise that resolves to a boolean value representing whether or not this signature is a certification.
         */
        isCertification(): Promise<boolean>;
        /**
         * Returns the signing certificate. Must only be called on signed adbe.pkcs7.detached signatures.
         * @returns A promise that resolves to an X509Certificate object.
         *
         * Note: This function does not verify the signature. It merely extracts the claimed signing certificate.
         * This function only works when the build has support for verification-related APIs.
         */
        getSignerCertFromCMS(): Promise<PDFNet.X509Certificate>;
        /**
         * Retrieves the ranges of byte indices within the document over which this signature is intended to apply/be verifiable.
         * @returns A promise that resolves to a container of byte range objects
         *
         * Note: This function does not verify that the signature is valid over its byte
         * ranges. It merely returns them. This can be useful when a document consists of
         * multiple incremental revisions, the latter of which may or may not have been
         * signed, for telling which revisions were actually signed by which signature.
         * The outputs of this function can also be used to truncate the document at the
         * end of a signed byte range, in order that the signed document revision may
         * be retrieved from a document with later incremental revisions. Of course, to
         * be certain that the signature is valid, it must also then be verified using the
         * verification API. Also, the caller is responsible for making sure that the
         * byte ranges returned from this function actually make sense (i.e. fit inside
         * the document).
         */
        getByteRanges(): Promise<PDFNet.ByteRange[]>;
        /**
         * Given a successful verification result that required online information to verify trust
         * (trust verification must have been enabled and successful during the verification),
         * embeds data into the PDF document that allows the signature to be verified offline.
         * (This is accomplished using DSS and VRI dictionaries.) When this operation is
         * successfully completed, one of the two components of secure long term validation (LTV)
         * will be in place. The other necessary component of secure long term validation is
         * to make sure to timestamp the document appropriately while the signature
         * is still verifiable to maintain a chain of unexpired secure timestamps
         * attesting to the integrity of the document. The verifiability of the signature
         * should thereafter be maintainable in such a fashion despite any possible
         * certificate expiry, algorithm compromise, or key compromise that would
         * have otherwise rendered it invalid if it were to be verified using a time in
         * the future rather than a securely-signed timestamp-derived time nearer the time
         * of signing (at which which the signature was verifiable without extra data).
         * This function, if given a good verification result, is also capable of making timestamp
         * (DocTimeStamp ETSI.RFC3161) signatures LTV-enabled, which is necessary to do first when
         * you intend to add another timestamp around an already-timestamped document to extend
         * or enhance its verifiability (as described above), as per the PDF 2.0 and
         * ETSI TS 102 778-4 (PAdES Level 4) specifications.
         * @param in_verification_result - - a successful verification result containing a successful
         * TrustVerificationResult
         * @returns A promise that resolves to a boolean status that reflects whether offline verification information was added successfully
         *
         * Note: It is necessary to save the document incrementally after this function completes successfully
         * in order to actually write the LTV data into the document.
         */
        enableLTVOfflineVerification(in_verification_result: PDFNet.VerificationResult): Promise<boolean>;
        /**
         * Must be called to prepare a secure PDF-embedded timestamp signature (RFC 3161
         * DocTimeStamp) for signing, which is done afterwards by calling Save on the
         * document with an e_incremental flag. Throws if document is locked by other
         * signatures,  if signature is already signed, or if another signature has already
         * been prepared for signing on the next save (because only one signing operation
         * can be done per incremental save). Default document permission level is
         * e_annotating_formfilling_signing_allowed.
         * @param in_timestamping_config - - Configuration options to store for timestamping.
         * These will include various items related to contacting a timestamping authority.
         * Incorrect configuration will result in document Save throwing an exception.
         * The usability of a combination of a TimestampingConfiguration and VerificationOptions
         * can be checked ahead of time to prevent exceptions by calling TestConfiguration on
         * TimestampingConfiguration and passing VerificationOptions.
         * @param in_timestamp_response_verification_options - - Options for the timestamp
         * response verification step (which is required by RFC 3161 to be done as part of
         * timestamping). These response verification options should include the root certificate
         * of the timestamp authority, so that the trust status of the timestamp signature
         * can be verified. The options that should be passed are the same ones that one expects
         * the timestamp to be verifiable with in the future (once it is embedded in the document),
         * except the response verification requires online revocation information whereas
         * the later verification may not (depending on whether LTV offline verification
         * information for the timestamp signature gets embedded into the document by that
         * time). The timestamp response verification step makes sure that (a) the
         * timestamp response has a success status, which is the only time that this is
         * verified in the entire workflow, which prevents embedding an unsuccessful
         * response; (b) that it digests the document correctly and is otherwise generally
         * verifiable; and (c) that the nonce is correct (which is the only time that this
         * is verifiable in the entire workflow) to prevent replay attacks (if it was not
         * requested in the TimestampingConfiguration that the nonce mechanism should be
         * disabled).
         *
         * Note: A failure in timestamp response verification will result in document Save
         * throwing an exception. It is recommended to use TimestampingConfiguration.TestConfiguration
         * with the VerificationOptions ahead of time to avoid this.
         */
        timestampOnNextSave(in_timestamping_config: PDFNet.TimestampingConfiguration, in_timestamp_response_verification_options: PDFNet.VerificationOptions): Promise<void>;
        /**
         * Contacts a remote timestamp authority over network, sends CMS digest, receives and verifies
         * timestamp token, combines the timestamp token and the data of an existing CMS-type (adbe.pkcs7.detached or
         * ETSI.CAdES.detached subfilter) main document signature, and then returns that data to the user.
         *
         * Note: This function does not insert the final CMS-type document signature into the document.
         * You must retrieve it from the result using GetData and then pass that to PDFDoc SaveCustomSignature.
         * @param in_timestamping_config - - Configuration options to store for timestamping.
         * These will include various items related to contacting a timestamping authority.
         * Incorrect configuration will result in an exception being thrown.
         * The usability of a combination of a TimestampingConfiguration and VerificationOptions
         * can be checked ahead of time to prevent exceptions by calling TestConfiguration on
         * TimestampingConfiguration and passing VerificationOptions.
         * @param in_timestamp_response_verification_options - - Options for the timestamp
         * response verification step (which is required by RFC 3161 to be done as part of
         * timestamping). These response verification options should include the root certificate
         * of the timestamp authority, so that the trust status of the timestamp signature
         * can be verified. The options that should be passed are the same ones that one expects
         * the timestamp to be verifiable with in the future (once it is embedded in the document),
         * except the response verification requires online revocation information whereas
         * the later verification may not (depending on whether LTV offline verification
         * information for the embedded timestamp gets embedded into the document by that
         * time). The timestamp response verification step makes sure that (a) the
         * timestamp response has a success status, which is the only time that this is
         * verified in the entire workflow, which prevents embedding an unsuccessful
         * response; (b) that it digests the main signature digest correctly and is otherwise generally
         * verifiable; and (c) that the nonce is correct (which is the only time that this
         * is verifiable in the entire workflow) to prevent replay attacks (if it was not
         * requested in the TimestampingConfiguration that the nonce mechanism should be
         * disabled).
         * @returns A promise that resolves to the result of the timestamp request, including the final document signature as DER-encoded CMS with a timestamp embedded
         */
        generateContentsWithEmbeddedTimestamp(in_timestamping_config: PDFNet.TimestampingConfiguration, in_timestamp_response_verification_options: PDFNet.VerificationOptions): Promise<PDFNet.TimestampingResult>;
        /**
         * Sets the requested SubFilter value (which identifies a signature type) as the only one to use during future signing, overwriting all such previous settings. It is not necessary to call HasCryptographicSignature before calling this function. For example, this function can be used to switch to PAdES signing mode.
         * @param in_subfilter_type - <pre>
         * PDFNet.DigitalSignatureField.SubFilterType = {
         * 	e_adbe_x509_rsa_sha1 : 0
         * 	e_adbe_pkcs7_detached : 1
         * 	e_adbe_pkcs7_sha1 : 2
         * 	e_ETSI_CAdES_detached : 3
         * 	e_ETSI_RFC3161 : 4
         * 	e_unknown : 5
         * 	e_absent : 6
         * }
         * </pre>
         * -- The SubFilter type to set.
         * @param [in_make_mandatory] - - Whether to make usage of this SubFilter mandatory for future signing applications. Default value for this parameter is true.
         */
        useSubFilter(in_subfilter_type: number, in_make_mandatory?: boolean): Promise<void>;
        /**
         * Calculates the digest of the relevant bytes of the document for this signature field, in order to allow
         * the caller to perform custom signing/processing. Signature field must first be prepared using one of the
         * non-sign overloads (CreateSigDictForCustomSigning/Certification), and then the document must be saved; after that, this function can be called.
         * The ByteRanges that the most recent save has entered into the signature dictionary within this signature field
         * will be used to calculate the digest.
         * @param [in_digest_algorithm_type] - <pre>
         * PDFNet.DigestAlgorithm.Type = {
         * 	e_SHA1 : 0
         * 	e_SHA256 : 1
         * 	e_SHA384 : 2
         * 	e_SHA512 : 3
         * 	e_RIPEMD160 : 4
         * 	e_unknown_digest_algorithm : 5
         * }
         * </pre>
         * -- the enumerated type of digest algorithm to use for the calculation. The default is SHA-256.
         * @returns A promise that resolves to an array of bytes containing the digest value
         */
        calculateDigest(in_digest_algorithm_type?: number): Promise<Uint8Array>;
        /**
         * Sets the preferred digest algorithm to use when signing this field. This is done by setting DigestMethod
         * in the Seed Value dictionary. This function can be called before a signature field is even prepared for signing.
         * @param in_digest_algorithm_type - <pre>
         * PDFNet.DigestAlgorithm.Type = {
         * 	e_SHA1 : 0
         * 	e_SHA256 : 1
         * 	e_SHA384 : 2
         * 	e_SHA512 : 3
         * 	e_RIPEMD160 : 4
         * 	e_unknown_digest_algorithm : 5
         * }
         * </pre>
         * -- the digest algorithm to use
         * @param [in_make_mandatory] - - whether to tell signing software to give up if the preferred algorithm is unsupported. Default value for this parameter is true.
         */
        setPreferredDigestAlgorithm(in_digest_algorithm_type: number, in_make_mandatory?: boolean): Promise<void>;
        /**
         * Prepares the field for certification without actually performing certification.
         * Useful for custom signing workflows. It is not necessary to call HasCryptographicSignature
         * before calling this function.
         * @param in_filter_name - the Filter name to use, representing the name of the signature handler that will be used to sign and verify the signature (e.g. Adobe.PPKLite)
         * @param in_subfilter_type - <pre>
         * PDFNet.DigitalSignatureField.SubFilterType = {
         * 	e_adbe_x509_rsa_sha1 : 0
         * 	e_adbe_pkcs7_detached : 1
         * 	e_adbe_pkcs7_sha1 : 2
         * 	e_ETSI_CAdES_detached : 3
         * 	e_ETSI_RFC3161 : 4
         * 	e_unknown : 5
         * 	e_absent : 6
         * }
         * </pre>
         * the SubFilter name to use, representing an interoperable signature type identifier for third-party verification (e.g. adbe.pkcs7.detached, ETSI.CAdES.detached, etc.)
         * @param in_contents_size_to_reserve - The size of the empty Contents entry to create. For security reasons, set the contents size to a value greater than but as close as possible to the size you expect your final signature to be.
         */
        createSigDictForCustomCertification(in_filter_name: string, in_subfilter_type: number, in_contents_size_to_reserve: number): Promise<void>;
        /**
         * Prepares the field for approval signing without actually performing signing.
         * Useful for custom signing workflows. It is not necessary to call HasCryptographicSignature
         * before calling this function.
         * @param in_filter_name - the Filter name to use, representing the name of the signature handler that will be used to sign and verify the signature (e.g. Adobe.PPKLite)
         * @param in_subfilter_type - <pre>
         * PDFNet.DigitalSignatureField.SubFilterType = {
         * 	e_adbe_x509_rsa_sha1 : 0
         * 	e_adbe_pkcs7_detached : 1
         * 	e_adbe_pkcs7_sha1 : 2
         * 	e_ETSI_CAdES_detached : 3
         * 	e_ETSI_RFC3161 : 4
         * 	e_unknown : 5
         * 	e_absent : 6
         * }
         * </pre>
         * the SubFilter name to use, representing an interoperable signature type identifier for third-party verification (e.g. adbe.pkcs7.detached, ETSI.CAdES.detached, etc.)
         * @param in_contents_size_to_reserve - The size of the empty Contents entry to create. For security reasons, set the contents size to a value greater than but as close as possible to the size you expect your final signature to be.
         */
        createSigDictForCustomSigning(in_filter_name: string, in_subfilter_type: number, in_contents_size_to_reserve: number): Promise<void>;
        /**
         * Adds the "M" key and value, representing the PDF-time-of-signing (not to be confused with
         * embedded timestamps, DocTimeStamps, or CMS signing time), to the digital signature dictionary.
         * The digital signature field must have been prepared for signing first. This function should
         * only be used if no secure embedded timestamping support is available from your signing provider.
         * Useful for custom signing workflows, where signing time is not set automatically by the PDFTron SDK,
         * unlike in the usual standard handler signing workflow.
         * @param in_date - the PDF Date datetime value to set
         */
        setSigDictTimeOfSigning(in_date: PDFNet.Date): Promise<void>;
        /**
         * Returns a CMS detached signature incorporating a digest that is provided using the provided PKCS #12 key buffer (.pfx).
         * Note: This function does not change the DigitalSignatureField. Call SaveCustomSignature to write a signature to its PDFDoc.
         * @param in_digest - - the digest value to use
         * @param in_pkcs12_buffer - - a buffer containing the PKCS #12 key (as usually stored in .pfx files) to use for signing
         * @param in_keyfile_password - - the password to use to decrypt the PKCS #12 key file data in the buffer
         * @param in_pades_mode - - whether to create a PAdES-type signature (PDF Advanced Electronic Signatures standards)
         * @param in_digest_algorithm_type - <pre>
         * PDFNet.DigestAlgorithm.Type = {
         * 	e_SHA1 : 0
         * 	e_SHA256 : 1
         * 	e_SHA384 : 2
         * 	e_SHA512 : 3
         * 	e_RIPEMD160 : 4
         * 	e_unknown_digest_algorithm : 5
         * }
         * </pre>
         * -- the identifier to use to write the digest algorithm
         * @returns A promise that resolves to the DER-serialized bytes of a CMS detached signature (CMS ContentInfo)
         */
        static signDigestBuffer(in_digest: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray, in_pkcs12_buffer: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray, in_keyfile_password: string, in_pades_mode: boolean, in_digest_algorithm_type: number): Promise<Uint8Array>;
        /**
         * Low-level optional function belonging to custom-signing APIs allowing creation of PAdES signatures
         * with key elsewhere, allowing CMS to be generated automatically later.
         * Represents one the components of the functionality of SignDigest which are not key-related.
         * Creates the necessary attribute for a PAdES signature (ETSI.CAdES.detached subfilter type).
         * The result of this function can be passed as a contiguous part of the
         * custom attributes buffer parameter of GenerateCMSSignedAttributes.
         *
         * The result will be either the BER-serialized bytes of an ESS_signing_cert or ESS_signing_cert_V2 CMS Attribute
         * (an ASN.1 SEQUENCE containing the correct OID and ESSCertID or ESSCertIDv2), as is appropriate,
         * depending on what digest algorithm type is provided (see RFC 5035).
         * @param in_signer_cert - - the X509 public-key certificate of the signature's signer (mathematically associated with private key to be used)
         * @param in_digest_algorithm_type - <pre>
         * PDFNet.DigestAlgorithm.Type = {
         * 	e_SHA1 : 0
         * 	e_SHA256 : 1
         * 	e_SHA384 : 2
         * 	e_SHA512 : 3
         * 	e_RIPEMD160 : 4
         * 	e_unknown_digest_algorithm : 5
         * }
         * </pre>
         * -- the digest algorithm to be used
         * @returns A promise that resolves to the BER-serialized bytes of an ESS_signing_cert or ESS_signing_cert_V2 CMS attribute
         */
        static generateESSSigningCertPAdESAttribute(in_signer_cert: PDFNet.X509Certificate, in_digest_algorithm_type: number): Promise<Uint8Array>;
        /**
         * Low-level function belonging to custom-signing APIs. Creates the signedAttributes component of
         * Cryptographic Message Syntax (CMS). The result of this function can then be encrypted by a remote
         * private key (cloud service, Hardware Security Module (HSM) device, etc.), using some external API that returns
         * the bytes of a not-already-CMS-embedded signature value (e.g. RSA PKCS #1 v1.5 format). Following that,
         * CMS generation can be performed using GenerateCMSSignature, after which the resulting signature can be
         * inserted into a resulting signed version of the PDF document using the PDFDoc function SaveCustomSignature.
         * @param in_digest_buf - - a buffer containing the digest of the document within ByteRanges of this DigitalSignatureField (see CalculateDigest)
         * @param [in_custom_signedattributes_buf] - - a buffer containing any optional custom BER-encoded signedAttributes to add,
         * including potentially the PAdES one (see GenerateESSSigningCertPAdESAttribute). (Do not place an ASN.1 constructed type around all of the attributes.)
         * Do not pass any of the normal attributes (content type or message digest) as custom attributes because otherwise they will be duplicated.
         * @returns A promise that resolves to the BER-encoded bytes of the future signedAttrs component of a CMS signature, with no surrounding constructed type
         */
        static generateCMSSignedAttributes(in_digest_buf: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray, in_custom_signedattributes_buf?: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray): Promise<Uint8Array>;
        /**
         * Low-level function belonging to custom-signing APIs. Using low-level inputs that permit incorporation of
         * remote key usage (cloud keystore, Hardware Security Module (HSM) device, etc.), generates bytes representing
         * a Cryptographic Message Syntax (CMS)-format signature encoded in DER. The resulting data can be passed to
         * SaveCustomSignature.
         * @param in_signer_cert - - the X509 public-key certificate of the signature's signer (mathematically associated with private key used)
         * @param in_chain_certs_list - - the intermediate and root certificates to include in the CMS to allow verifiers to establish the chain/path of trust
         * @param in_digest_algorithm_oid - - the OID of the digest algorithm used, for embedding in the CMS
         * @param in_signature_algorithm_oid - - the OID of the signature algorithm used, for embedding in the CMS
         * @param in_signature_value_buf - - a buffer containing the signature value to embed in the CMS
         * @param in_signedattributes_buf - - a buffer containing signedAttributes for embedding into the CMS (must exactly match those used when creating signature value)
         * @returns A promise that resolves to finished CMS data for embedding into the document using SaveCustomSignature
         */
        static generateCMSSignature(in_signer_cert: PDFNet.X509Certificate, in_chain_certs_list: PDFNet.X509Certificate[], in_digest_algorithm_oid: PDFNet.ObjectIdentifier, in_signature_algorithm_oid: PDFNet.ObjectIdentifier, in_signature_value_buf: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray, in_signedattributes_buf: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray): Promise<Uint8Array>;
        /**
         * Must be called to prepare a signature for certification, which is done afterwards by calling Save. Throws if document already certified.
        Default document permission level is e_annotating_formfilling_signing_allowed. Throws if signature field already has a digital signature dictionary.
         * @param url - The url to the PKCS #12 private keyfile to use to certify this digital signature.
         * @param in_password - - The password to use to parse the PKCS #12 keyfile.
         * @param [options] - Additional options
         * @param options.withCredentials - Whether to set the withCredentials property on the XMLHttpRequest
         * @param options.customHeaders - An object containing custom HTTP headers to be used when downloading the document
         */
        static certifyOnNextSaveFromURL(url: string, in_password: string, options?: {
            withCredentials: boolean;
            customHeaders: any;
        }): Promise<void>;
        /**
         * Must be called to prepare a signature for signing, which is done afterwards by calling Save. Cannot sign two signatures during one save (throws).
        Default document permission level is e_annotating_formfilling_signing_allowed. Throws if signature field already has a digital signature dictionary.
         * @param url - The url to the PKCS #12 private keyfile to use to sign this digital signature.
         * @param in_password - - The password to use to parse the PKCS #12 keyfile.
         * @param [options] - Additional options
         * @param options.withCredentials - Whether to set the withCredentials property on the XMLHttpRequest
         * @param options.customHeaders - An object containing custom HTTP headers to be used when downloading the document
         */
        static signOnNextSaveFromURL(url: string, in_password: string, options?: {
            withCredentials: boolean;
            customHeaders: any;
        }): Promise<void>;
        /**
         * Retrieves all constructible certificate paths from an adbe.pkcs7.detached digital signature. The signer
        will always be returned if the signature is CMS-based and not corrupt. Must only be called on
        signed adbe.pkcs7.detached signatures. The order of the certificates in each of the paths returned is as follows:
        the signer will be first, and issuers come after it in order of the issuer of the previous certificate.
        The default behaviour is to return a sub-path for each marginal issuer in a max-length path.
         * @returns A promise that resolves to a container of X509Certificate objects
        
        Note: This function does not verify the paths. It merely extracts certificates and constructs paths.
        This function only works when the build has support for verification-related APIs.
         */
        getCertPathsFromCMS(): Promise<PDFNet.X509Certificate[][]>;
        mp_field_dict_obj: PDFNet.Obj;
    }
    /**
     * The class DisallowedChange.
     * Data pertaining to a change detected in a document during a digital
     * signature modification permissions verification step, the change bein
     * g both made after the signature was signed, and disallowed by t
     * he signature's permissions settings.
     */
    class DisallowedChange extends PDFNet.Destroyable {
        /**
         * Returns the SDF object number of the indirect object associated with this DisallowedChange.
         * @returns A promise that resolves to an unsigned 32-bit integer value.
         */
        getObjNum(): Promise<number>;
        /**
         * Returns an enumeration value representing the semantic type of this disallowed change.
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.DisallowedChange.Type = {
         * 	e_form_filled : 0
         * 	e_digital_signature_signed : 1
         * 	e_page_template_instantiated : 2
         * 	e_annotation_created_or_updated_or_deleted : 3
         * 	e_other : 4
         * 	e_unknown : 5
         * }
         * </pre>
         * @returns A promise that resolves to an enumeration value of type: Type of DisallowedChange.
         */
        getType(): Promise<number>;
        /**
         * Returns a string value representing the semantic type of this disallowed change.
         * @returns A promise that resolves to a string.
         */
        getTypeAsString(): Promise<string>;
    }
    /**
     * The class DocSnapshot.
     * Represents a state of the document.
     */
    class DocSnapshot extends PDFNet.Destroyable {
        /**
         * Returns a hash that is unique to particular document states.
         * @returns A promise that resolves to a hash that is unique to particular document states.
         */
        getHash(): Promise<number>;
        /**
         * Returns whether this snapshot is valid.
         * @returns A promise that resolves to whether this snapshot is valid.
         */
        isValid(): Promise<boolean>;
        /**
         * Returns whether this snapshot's document state is equivalent to another.
         * @param snapshot - - the other snapshot with which to compare.
         * @returns A promise that resolves to whether this snapshot's document state is equivalent to another.
         */
        equals(snapshot: PDFNet.DocSnapshot): Promise<boolean>;
    }
    /**
     * Element is the abstract interface used to access graphical elements used to build the
     * display list.
     *
     * Just like many other classes in PDFNet (e.g. ColorSpace, Font, Annot, etc), Element
     * class follows the composite design pattern. This means that all Elements are
     * accessed through the same interface, but depending on the Element type (that can be
     * obtained using GetType()), only methods related to that type can be called.
     * For example, if GetType() returns e_image, it is illegal to call a method specific to
     * another Element type (i.e. a call to a text specific GetTextData() will throw an
     * Exception).
     */
    class Element {
        /**
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.Element.Type = {
         * 	e_null : 0
         * 	e_path : 1
         * 	e_text_begin : 2
         * 	e_text : 3
         * 	e_text_new_line : 4
         * 	e_text_end : 5
         * 	e_image : 6
         * 	e_inline_image : 7
         * 	e_shading : 8
         * 	e_form : 9
         * 	e_group_begin : 10
         * 	e_group_end : 11
         * 	e_marked_content_begin : 12
         * 	e_marked_content_end : 13
         * 	e_marked_content_point : 14
         * }
         * </pre>
         * @returns A promise that resolves to the current element type.
         */
        getType(): Promise<number>;
        /**
         * @returns A promise that resolves to gState of this Element
         */
        getGState(): Promise<PDFNet.GState>;
        /**
         * @returns A promise that resolves to current Transformation Matrix (CTM) that maps coordinates to the
         * initial user space.
         */
        getCTM(): Promise<PDFNet.Matrix2D>;
        /**
         * @returns A promise that resolves to parent logical structure element (such as 'span' or 'paragraph').
         * If the Element is not associated with any structure element, the returned
         * SElement will not be valid (i.e. selem.IsValid() -> false).
         */
        getParentStructElement(): Promise<PDFNet.SElement>;
        /**
         * @returns A promise that resolves to marked Content Identifier (MCID) for this Element or
         * a negative number if the element is not assigned an identifier/MCID.
         *
         * Marked content identifier can be used to associate an Element with
         * logical structure element that refers to the Element.
         */
        getStructMCID(): Promise<number>;
        /**
         * @returns A promise that resolves to true if this element is visible in the optional-content
         * context (OCG::Context). The method considers the context's current OCMD stack,
         * the group ON-OFF states, the non-OC drawing status, the drawing and enumeration mode,
         * and the intent.
         *
         * When enumerating page content, OCG::Context can be passed as a parameter in
         * ElementReader.Begin() method. When using PDFDraw, PDFRasterizer, or PDFView class to
         * render PDF pages use PDFDraw::SetOCGContext() method to select an OC context.
         */
        isOCVisible(): Promise<boolean>;
        /**
         * @returns A promise that resolves to true if the current path element is a clipping path and should be added
         * to clipping path stack.
         */
        isClippingPath(): Promise<boolean>;
        /**
         * @returns A promise that resolves to true if the current path element should be stroked
         */
        isStroked(): Promise<boolean>;
        /**
         * @returns A promise that resolves to true if the current path element should be filled
         */
        isFilled(): Promise<boolean>;
        /**
         * @returns A promise that resolves to true if the current path should be filled using non-zero winding rule,
         * or false if the path should be filled using even-odd rule.
         *
         * According non-zero winding rule, you can determine whether a test point is inside or
         * outside a closed curve as follows: Draw a line from a test point to a point that
         * is distant from the curve. Count the number of times the curve crosses the test
         * line from left to right, and count the number of times the curve crosses the test
         * line from right to left. If those two numbers are the same, the test point is
         * outside the curve; otherwise, the test point is inside the curve.
         *
         * According to even-odd rule, you can determine whether a test point is inside
         * or outside a closed curve as follows: Draw a line from the test point to a point
         * that is distant from the curve. If that line crosses the curve an odd number of
         * times, the test point is inside the curve; otherwise, the test point is outside
         * the curve.
         */
        isWindingFill(): Promise<boolean>;
        /**
         * @returns A promise that resolves to true if the current clip path is using non-zero winding rule, or false
         * for even-odd rule.
         */
        isClipWindingFill(): Promise<boolean>;
        /**
         * indicate whether the path is a clipping path or non-clipping path
         * @param clip - true to set path to clipping path. False for non-clipping path.
         */
        setPathClip(clip: boolean): Promise<void>;
        /**
         * indicate whether the path should be stroked
         * @param stroke - true to set path to be stroked. False for no stroke path.
         */
        setPathStroke(stroke: boolean): Promise<void>;
        /**
         * indicate whether the path should be filled
         * @param fill - true to set path to be filled. False for no fill path.
         */
        setPathFill(fill: boolean): Promise<void>;
        /**
         * sets path's fill rule.
         * @param winding_rule - if winding_rule is true path will be filled using non-zero
         * winding fill rule, otherwise even-odd fill will be used.
         */
        setWindingFill(winding_rule: boolean): Promise<void>;
        /**
         * sets clipping path's fill rule.
         * @param winding_rule - if winding_rule is true clipping should use non-zero
         * winding rule, or false for even-odd rule.
         */
        setClipWindingFill(winding_rule: boolean): Promise<void>;
        setPathTypes(in_seg_types: string, count: number): Promise<void>;
        /**
         * @returns A promise that resolves to the SDF object of the Image/Form object.
         */
        getXObject(): Promise<PDFNet.Obj>;
        /**
         * @returns A promise that resolves to a stream (filter) containing decoded image data
         */
        getImageData(): Promise<PDFNet.Filter>;
        /**
         * @returns A promise that resolves to the size of image data in bytes
         */
        getImageDataSize(): Promise<number>;
        /**
         * @returns A promise that resolves to the SDF object representing the color space in which image
         * are specified or NULL if the image is an image mask
         *
         * The returned color space may be any type of color space except Pattern.
         */
        getImageColorSpace(): Promise<PDFNet.ColorSpace>;
        /**
         * @returns A promise that resolves to the width of the image, in samples.
         */
        getImageWidth(): Promise<number>;
        /**
         * @returns A promise that resolves to the height of the image, in samples.
         */
        getImageHeight(): Promise<number>;
        /**
         * @returns A promise that resolves to decode array or NULL if the parameter is not specified. A decode object is an
         * array of numbers describing how to map image samples into the range of values
         * appropriate for the color space of the image. If ImageMask is true, the array must be
         * either [0 1] or [1 0]; otherwise, its length must be twice the number of color
         * components required by ColorSpace. Default value depends on the color space,
         * See Table 4.36 in PDF Ref. Manual.
         */
        getDecodeArray(): Promise<PDFNet.Obj>;
        /**
         * @returns A promise that resolves to the number of bits used to represent each color component. Only a
         * single value may be specified; the number of bits is the same for all color
         * components. Valid values are 1, 2, 4, and 8.
         */
        getBitsPerComponent(): Promise<number>;
        /**
         * @returns A promise that resolves to the number of color components per sample.
         */
        getComponentNum(): Promise<number>;
        /**
         * @returns A promise that resolves to a boolean indicating whether the inline image is to be treated as an image mask.
         */
        isImageMask(): Promise<boolean>;
        /**
         * @returns A promise that resolves to a boolean indicating whether image interpolation is to be performed.
         */
        isImageInterpolate(): Promise<boolean>;
        /**
         * @returns A promise that resolves to an image XObject defining an image mask to be applied to this image (See
         * 'Explicit Masking', 4.8.5), or an array specifying a range of colors
         * to be applied to it as a color key mask (See 'Color Key Masking').
         *
         * If IsImageMask() return true, this method will return NULL.
         */
        getMask(): Promise<PDFNet.Obj>;
        /**
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.GState.RenderingIntent = {
         * 	e_absolute_colorimetric : 0
         * 	e_relative_colorimetric : 1
         * 	e_saturation : 2
         * 	e_perceptual : 3
         * }
         * </pre>
         * @returns A promise that resolves to the color rendering intent to be used in rendering the image.
         */
        getImageRenderingIntent(): Promise<number>;
        /**
         * @returns A promise that resolves to a pointer to Unicode string for this text Element. The
         * function maps character codes to Unicode array defined by Adobe
         * Glyph List (http://partners.adobe.com/asn/developer/type/glyphlist.txt).
         *
         * Note: In PDF text can be encoded using various encoding schemes
         * and in some cases it is not possible to extract Unicode encoding.
         * If it is not possible to map charcode to Unicode the function will
         * map a character to undefined code, 0xFFFD. This code is defined in
         * private Unicode range.
         *
         * Note: If you would like to map raw text to Unicode (or some other encoding)
         * yourself use CharIterators returned by CharBegin()/CharEnd() and
         * PDF::Font code mapping methods.
         *
         * Note: The string owner is the current element (i.e. ElementReader or ElementBuilder).
         */
        getTextString(): Promise<string>;
        /**
         * @returns A promise that resolves to a reference to the current text matrix (Tm).
         */
        getTextMatrix(): Promise<PDFNet.Matrix2D>;
        /**
         * @returns A promise that resolves to a CharIterator addressing the first CharData element in the text run.
         *
         * CharIterator points to CharData. CharData is a data structure that contains
         * the char_code number (used to retrieve glyph outlines, to map to Unicode, etc.),
         * character positioning information (x, y), and the number of bytes taken by the
         * character within the text buffer.
         *
         * Note: CharIterator follows the standard STL forward-iterator interface.
         *
         * An example of how to use CharIterator.
         * <pre>
         *     for (CharIterator itr = element.GetCharIterator(); itr.HasNext(); itr.Next()) {
         * 			unsigned int char_code = itr.Current().char_code;
         * 			double char_pos_x = itr.Current().x;
         * 			double char_pos_y = itr.Current().y;
         *     }
         * </pre>
         *
         * Note: Character positioning information (x, y) is represented in text space.
         * In order to get the positioning in the user space, the returned value should
         * be scaled using the text matrix (GetTextMatrix()) and the current transformation
         * matrix (GetCTM()). See section 4.2 'Other Coordinate Spaces' in PDF Reference
         * Manual for details and PDFNet FAQ "How do I get absolute/relative text and
         * character positioning?".
         *
         * Note: within a text run a character may occupy more than a single byte (e.g.
         * in case of composite/Type0 fonts). The role of CharIterator/CharData is to
         * provide a uniform and easy to use interface to access character information.
         */
        getCharIterator(): Promise<PDFNet.Iterator<PDFNet.CharData>>;
        /**
         * @returns A promise that resolves to the text advance distance in text space.
         *
         * The total sum of all of the advance values from rendering all of the characters
         * within this element, including the advance value on the glyphs, the effect of
         * properties such as 'char-spacing', 'word-spacing' and positioning adjustments
         * on 'TJ' elements.
         *
         * Note: Computed text length is represented in text space. In order to get the
         * length of the text run in the user space, the returned value should be scaled
         * using the text matrix (GetTextMatrix()) and the current transformation
         * matrix (GetCTM()). See section 4.2 'Other Coordinate Spaces' in PDF Reference
         * Manual for details.
         */
        getTextLength(): Promise<number>;
        /**
         * @returns A promise that resolves to the number used to adjust text matrix in horizontal direction when drawing
         * text. The number is expressed in thousandths of a unit of text space. The returned
         * number corresponds to a number value within TJ array. For 'Tj' text strings the
         * returned value is always 0.
         *
         * Note: because CharIterator positioning information already accounts for TJ
         * adjustments this method is rarely used.
         */
        getPosAdjustment(): Promise<number>;
        /**
         * returns the offset (out_x, out_y) to the start of the current line relative to
         * the beginning of the previous line.
         *
         * out_x and out_y are numbers expressed in unscaled text space units.
         * The returned numbers correspond to the arguments of 'Td' operator.
         * @returns A promise that resolves to an object of type: "Object"
         */
        getNewTextLineOffset(): Promise<object>;
        /**
         * @returns A promise that resolves to true if this element is directly associated with a text matrix
         * (that is Tm operator is just before this text element) or false if the text
         * matrix is default or is inherited from previous text elements.
         */
        hasTextMatrix(): Promise<boolean>;
        /**
         * set the text data for the current e_text Element.
         * @param buf_text_data - a pointer to a buffer containing text.
         */
        setTextData(buf_text_data: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray): Promise<void>;
        /**
         * Sets the text matrix for a text element.
         * @param mtx - The new text matrix for this text element
         */
        setTextMatrix(mtx: PDFNet.Matrix2D): Promise<void>;
        /**
         * Sets the text matrix for a text element. This method accepts text
         * transformation matrix components directly.
         *
         * A transformation matrix in PDF is specified by six numbers, usually
         * in the form of an array containing six elements. In its most general
         * form, this array is denoted [a b c d h v]; it can represent any linear
         * transformation from one coordinate system to another. For more
         * information about PDF matrices please refer to section 4.2.2 'Common
         * Transformations' in PDF Reference Manual, and to documentation for
         * Matrix2D class.
         * @param a - horizontal 'scaling' component of the new text matrix.
         * @param b - 'rotation' component of the new text matrix.
         * @param c - 'rotation' component of the new text matrix.
         * @param d - vertical 'scaling' component of the new text matrix.
         * @param h - horizontal translation component of the new text matrix.
         * @param v - vertical translation component of the new text matrix.
         */
        setTextMatrixEntries(a: number, b: number, c: number, d: number, h: number, v: number): Promise<void>;
        /**
         * @param adjust - number to set the horizontal adjustment to
         *
         * Note: Positive values move the current text element backwards (along text direction).
         *       Negative values move the current text element forward (along text direction).
         */
        setPosAdjustment(adjust: number): Promise<void>;
        /**
         * Recompute the character positioning information (i.e. CharIterator-s) and
         * text length.
         *
         * Element objects caches text length and character positioning information.
         * If the user modifies the text data or graphics state the cached information
         * is not correct. UpdateTextMetrics() can be used to recalculate the correct
         * positioning and length information.
         */
        updateTextMetrics(): Promise<void>;
        /**
         * sets the offset (dx, dy) to the start of the current line relative to the beginning
         * of the previous line.
         * @param dx - horizontal offset to the start of the curret line
         * @param dy - vertical offset to the start of the current line
         */
        setNewTextLineOffset(dx: number, dy: number): Promise<void>;
        /**
         * @returns A promise that resolves to the SDF object of the Shading object.
         */
        getShading(): Promise<PDFNet.Shading>;
        /**
         * @returns A promise that resolves to a dictionary containing the property list or NULL if property
         * dictionary is not present.
         *
         * Note: the function automatically looks under Properties sub-dictionary of the
         * current resource dictionary if the dictionary is not in-line. Therefore you
         * can assume that returned Obj is dictionary if it is not NULL.
         */
        getMCPropertyDict(): Promise<PDFNet.Obj>;
        /**
         * @returns A promise that resolves to a tag is a name object indicating the role or significance of
         * the marked content point/sequence.
         */
        getMCTag(): Promise<PDFNet.Obj>;
        /**
         * @returns A promise that resolves to a pointer to the internal text buffer for this text element.
        Note: GetTextData() returns the raw text data and not a Unicode string.
        In PDF text can be encoded using various encoding schemes so it is necessary
        to consider Font encoding while processing the content of this buffer.
        
        Note: Most of the time GetTextString() is what you are looking for instead.
        GetTextString() maps the raw text directly into Unicode (as specified by Adobe
        Glyph List (AGL) ). Even if you would prefer to decode text yourself it is more
        convenient to use CharIterators returned by CharBegin()/CharEnd() and
        PDF::Font code mapping methods.
        
        Note: the buffer owner is the current element (i.e. ElementReader or ElementBuilder).
         */
        getTextData(): Promise<number>;
        /**
         * Obtains the bounding box for a graphical element.
        
        Calculates the bounding box for a graphical element (i.e. an Element that belongs
        to one of following types: e_path, e_text, e_image, e_inline_image, e_shading e_form).
        The returned bounding box is guaranteed to encompass the Element, but is not guaranteed
        to be the smallest box that could contain the element. For example, for Bezier curves
        the bounding box will enclose all control points, not just the curve itself.
         * @returns A promise that resolves to a rectangle specifying the bounding box of Element (a rectangle that surrounds the
        entire element). The coordinates are represented in the default PDF page coordinate system
        and are using units called points ( 1 point = 1/72 inch =  2.54 /72 centimeter). The
        bounding box already accounts for the effects of current transformation matrix (CTM),
        text matrix, font size, and other properties in the graphics state. If this is a non-graphical
        element, the bounding box is undefined.
         */
        getBBox(): Promise<Rect>;
    }
    /**
     * ElementBuilder is used to build new PDF::Elements (e.g. image, text, path, etc)
     * from scratch. In conjunction with ElementWriter, ElementBuilder can be used to create
     * new page content.
     *
     * Note: Analogous to ElementReader, every call to ElementBuilder.Create? method destroys
     * the Element currently associated with the builder and all previous Element pointers are
     * invalidated.
     *
     * Note: For C++ developers. Analogous to ElementReader, ElementBuilder is the owner of
     * all Element objects it creates.
     */
    class ElementBuilder extends PDFNet.Destroyable {
        /**
         * Constructor for an ElementBuilder object that can be used to build new PDF::Elements
         * (eg. image, text, path, etc.) from scratch. In conjunction with ElementWriter,
         * ElementBuilder can be used to create new page content.
         * @returns A promise that resolves to Returns an ElementBuilder object
         */
        static create(): Promise<PDFNet.ElementBuilder>;
        /**
         * The function sets the graphics state of this Element to the given value.
         * If 'gs' parameter is not specified or is NULL the function resets the
         * graphics state of this Element to the default graphics state (i.e. the
         * graphics state at the beginning of the display list).
         *
         * The function can be used in situations where the same ElementBuilder is used
         * to create content on several pages, XObjects, etc. If the graphics state is not
         * Reset() when moving to a new display list, the new Element will have the same
         * graphics state as the last Element in the previous display list (and this may
         * or may not be your intent).
         *
         * Another use of Reset(gs) is to make sure that two Elements have the graphics
         * state.
         * @param [gs] - GState (graphics state) object. If NULL or unspecified, resets graphics state to default.
         */
        reset(gs?: PDFNet.GState): Promise<void>;
        /**
         * Create a content image Element out of a given document Image.
         * @param img - the given image.
         * @returns A promise that resolves to an object of type: "PDFNet.Element"
         */
        createImage(img: PDFNet.Image): Promise<PDFNet.Element>;
        /**
         * Create a content image Element out of a given document Image.
         * @param img - the given image.
         * @param mtx - the image transformation matrix.
         * @returns A promise that resolves to an object of type: "PDFNet.Element"
         */
        createImageFromMatrix(img: PDFNet.Image, mtx: PDFNet.Matrix2D): Promise<PDFNet.Element>;
        /**
         * Create a content image Element out of a given document Image with
         * the lower left corner at (x, y), and scale factors (hscale, vscale).
         * @param img - the given image.
         * @param x - The horizontal x position to place the lower left corner of the image
         * @param y - The vertical x position to place the lower left corner of the image
         * @param hscale - The horizontal scale of the image
         * @param vscale - The vertical scale of the image
         * @returns A promise that resolves to an object of type: "PDFNet.Element"
         */
        createImageScaled(img: PDFNet.Image, x: number, y: number, hscale: number, vscale: number): Promise<PDFNet.Element>;
        /**
         * Create e_group_begin Element (i.e. 'q' operator in PDF content stream).
         * The function saves the current graphics state.
         * @returns A promise that resolves to an object of type: "PDFNet.Element"
         */
        createGroupBegin(): Promise<PDFNet.Element>;
        /**
         * Create e_group_end Element (i.e. 'Q' operator in PDF content stream).
         * The function restores the previous graphics state.
         * @returns A promise that resolves to an object of type: "PDFNet.Element"
         */
        createGroupEnd(): Promise<PDFNet.Element>;
        /**
         * @param sh - A Shading object. Shading objects represent a flat interface around
         * all PDF shading types (e_function_shading, e_axial_shading, etc.)
         * Create a shading Element.
         * @returns A promise that resolves to an object of type: "PDFNet.Element"
         */
        createShading(sh: PDFNet.Shading): Promise<PDFNet.Element>;
        /**
         * Create a Form XObject Element.
         * @param form - a Form XObject content stream
         * @returns A promise that resolves to an object of type: "PDFNet.Element"
         */
        createFormFromStream(form: PDFNet.Obj): Promise<PDFNet.Element>;
        /**
         * Create a Form XObject Element using the content of the existing page.
         * This method assumes that the XObject will be used in the same
         * document as the given page. If you need to create the Form XObject
         * in a different document use CreateForm(Page, Doc) method.
         * @param page - A page used to create the Form XObject.
         * @returns A promise that resolves to an object of type: "PDFNet.Element"
         */
        createFormFromPage(page: PDFNet.Page): Promise<PDFNet.Element>;
        /**
         * Create a Form XObject Element using the content of the existing page.
         * Unlike CreateForm(Page) method, you can use this method to create form
         * in another document.
         * @param page - A page used to create the Form XObject.
         * @param doc - Destination document for the Form XObject.
         * @returns A promise that resolves to an object of type: "PDFNet.Element"
         */
        createFormFromDoc(page: PDFNet.Page, doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc): Promise<PDFNet.Element>;
        /**
         * Start a text block ('BT' operator in PDF content stream).
         * The function installs the given font in the current graphics state.
         * @param font - font to set the text in the text block to
         * @param font_sz - size to set the text in the text block to
         * @returns A promise that resolves to an object of type: "PDFNet.Element"
         */
        createTextBeginWithFont(font: PDFNet.Font, font_sz: number): Promise<PDFNet.Element>;
        /**
         * Start a text block ('BT' operator in PDF content stream).
         * @returns A promise that resolves to an object of type: "PDFNet.Element"
         */
        createTextBegin(): Promise<PDFNet.Element>;
        /**
         * Ends a text block.
         * @returns A promise that resolves to an object of type: "PDFNet.Element"
         */
        createTextEnd(): Promise<PDFNet.Element>;
        /**
         * Create a text run using the given font.
         * @param text_data - text to initialize the text run with
         * @param font - font of the text in the text run
         * @param font_sz - size of the text in the text run
         * Note: a text run can be created only within a text block
         * @returns A promise that resolves to an object of type: "PDFNet.Element"
         */
        createTextRun(text_data: string, font: PDFNet.Font, font_sz: number): Promise<PDFNet.Element>;
        /**
         * Create a text run using the given font.
         * @param text_data - text to initialize the text run with. Uses unsigned characters.
         * @param font - font of the text in the text run
         * @param font_sz - size of the text in the text run
         * Note: a text run can be created only within a text block
         * @returns A promise that resolves to an object of type: "PDFNet.Element"
         */
        createTextRunUnsigned(text_data: string, font: PDFNet.Font, font_sz: number): Promise<PDFNet.Element>;
        /**
         * Create a new text run.
         * @param text_data - text to initialize the text run with.
         * Note: a text run can be created only within a text block
         * Note: you must set the current Font and font size before calling this function.
         * @returns A promise that resolves to an object of type: "PDFNet.Element"
         */
        createNewTextRun(text_data: string): Promise<PDFNet.Element>;
        /**
         * Create a new text run.
         * @param text_data - text to initialize the text run with. Uses unsigned characters.
         * Note: a text run can be created only within a text block
         * Note: you must set the current Font and font size before calling this function.
         * @returns A promise that resolves to an object of type: "PDFNet.Element"
         */
        createNewTextRunUnsigned(text_data: string): Promise<PDFNet.Element>;
        /**
         * Create a new text run from shaped text.
         * Shaped Text can be created with an approriate Font, using the Font::GetShapedText() method.
         * @param text_data - the shaped text data
         *
         * Note: you must set the current Font and font size before calling this function
         * and the font must be created using Font::CreateCIDTrueTypeFont() method, and should
         * be the same font used to generate the shaped text content.
         *
         * Note: For best results, the font should be encoded using the e_Indices encoding scheme.
         *
         * Note: a text run can be created only within a text block
         * @returns A promise that resolves to an object of type: "PDFNet.Element"
         */
        createShapedTextRun(text_data: PDFNet.ShapedText): Promise<PDFNet.Element>;
        /**
         * Create e_text_new_line Element (i.e. a Td operator in PDF content stream).
         * Move to the start of the next line, offset from the start of the current
         * line by (dx , dy). dx and dy are numbers expressed in unscaled text space
         * units.
         * @param dx - The horizontal x offset from the start of the current line
         * @param dy - The vertical y offset from the start of the current line
         * @returns A promise that resolves to the path Element
         */
        createTextNewLineWithOffset(dx: number, dy: number): Promise<PDFNet.Element>;
        /**
         * Create e_text_new_line Element (i.e. a T* operator in PDF content stream).
         * @returns A promise that resolves to the path Element
         */
        createTextNewLine(): Promise<PDFNet.Element>;
        /**
         * Create a path Element using the given path segment data
         * @param points - An array containing data on the points in the path.
         * What each point represents is determined by the corresponding segment type.
         * @param buf_seg_types - A buffer/array containing data on the segment types.
         * Possible segment types are as follows:
         * <pre>
         * PDFNet.Element.PathSegmentType = {
         * 	e_moveto : 1,
         * 	e_lineto : 2,
         * 	e_cubicto : 3,
         * 	e_conicto : 4,
         * 	e_rect : 5,
         * 	e_closepath : 6
         * }
         * </pre>
         * @returns A promise that resolves to the path Element
         */
        createPath(points: number[], buf_seg_types: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray): Promise<PDFNet.Element>;
        /**
         * Create a rectangle path Element.
         * @param x - The horizontal coordinate of the lower left corner of the rectangle.
         * @param y - The vertical coordinate of the lower left corner of the rectangle.
         * @param width - The width of the rectangle.
         * @param height - The height of the rectangle.
         * @returns A promise that resolves to the path Element
         */
        createRect(x: number, y: number, width: number, height: number): Promise<PDFNet.Element>;
        /**
         * Create an ellipse (or circle, if width == height) path Element.
         * @param x - The horizontal x coordinate of the ellipse center.
         * @param y - The vertical y coordinate of the ellipse center.
         * @param width - The width of the ellipse rectangle.
         * @param height - The height of the ellipse rectangle.
         * @returns A promise that resolves to the path Element
         */
        createEllipse(x: number, y: number, width: number, height: number): Promise<PDFNet.Element>;
        /**
         * Starts building a new path Element that can contain an arbitrary sequence
         * of lines, curves, and rectangles.
         */
        pathBegin(): Promise<void>;
        /**
         * Finishes building of the path Element.
         * @returns A promise that resolves to the path Element
         */
        pathEnd(): Promise<PDFNet.Element>;
        /**
         * Add a rectangle to the current path as a complete subpath.
         * Setting the current point is not required before using this function.
         * @param x - The x coordinate of the lower left corner of the rectangle.
         * @param y - The y coordinate of the lower left corner of the rectangle.
         * @param width - The width of the rectangle.
         * @param height - The height of the rectangle.
         */
        rect(x: number, y: number, width: number, height: number): Promise<void>;
        /**
         * Add an ellipse (or circle, if rx == ry) to the current path as a complete subpath.
         * Setting the current point is not required before using this function.
         * @param x - The x coordinate of the ellipse center.
         * @param y - The y coordinate of the ellipse center.
         * @param width - The x radii of the ellipse.
         * @param height - The y radii of the ellipse.
         */
        ellipse(x: number, y: number, width: number, height: number): Promise<void>;
        /**
         * Set the current point.
         * @param x - The horizontal x component of the point
         * @param y - The vertical y component of the point
         */
        moveTo(x: number, y: number): Promise<void>;
        /**
         * Draw a line from the current point to the given point.
         * @param x - The horizontal x component of the goal point
         * @param y - The vertical y component of the goal point
         */
        lineTo(x: number, y: number): Promise<void>;
        /**
         * Draw a Bezier curve from the current point to the given point (x2, y2) using
         * (cx1, cy1) and (cx2, cy2) as control points.
         * @param cx1 - The x component of the first control point
         * @param cy1 - The y component of the first control point
         * @param cx2 - The x component of the second control point
         * @param cy2 - The y component of the second control point
         * @param x2 - The horizontal x component of the goal point
         * @param y2 - The vertical y component of the goal point
         */
        curveTo(cx1: number, cy1: number, cx2: number, cy2: number, x2: number, y2: number): Promise<void>;
        /**
         * Draw an arc with the specified parameters (lower left corner, width, height and angles).
         * @param x - The horizontal x coordinate of the lower left corner of the ellipse encompassing rectangle
         * @param y - The horizontal y coordinate of the lower left corner of the ellipse encompassing rectangle
         * @param width - overall width of the full ellipse (not considering the angular extents).
         * @param height - overall height of the full ellipse (not considering the angular extents).
         * @param start - starting angle of the arc in degrees
         * @param extent - angular extent of the arc in degrees
         */
        arcTo(x: number, y: number, width: number, height: number, start: number, extent: number): Promise<void>;
        /**
         * Draw an arc from the current point to the end point.
         * @param xr - x radius for the arc
         * @param yr - y radius for the arc
         * @param rx - x-axis rotation in radians
         * @param isLargeArc - indicates if smaller or larger arc is chosen
         * 		1 one of the two larger arc sweeps is chosen
         * 		0 one of the two smaller arc sweeps is chosen
         * @param sweep - direction in which arc is drawn (1 clockwise, 0 counterclockwise)
         * @param endX - x coordinate of end point
         * @param endY - y coordinate of end point
         *
         * Note: The Arc is defined the same way as it is specified by SVG or XPS standards. For
         * 		further questions please refer to the XPS or SVG standards.
         */
        arcTo2(xr: number, yr: number, rx: number, isLargeArc: boolean, sweep: boolean, endX: number, endY: number): Promise<void>;
        /**
         * Closes the current subpath.
         */
        closePath(): Promise<void>;
        /**
         * Create e_marked_content_begin element with an inline property dictionary (i.e. BDC operator in PDF content stream).
         * @param tag - the tag entry for this element.
         * @returns A promise that resolves to the marked content begin element.
         * Note: The inline property dictionary can be accessed and edited using element.GetMCPropertyDict()
         */
        createMarkedContentBeginInlineProperties(tag: string): Promise<PDFNet.Element>;
        /**
         * Create e_marked_content_begin element with an associated property dictionary (i.e. BMC or BDC operator in PDF content stream).
         * @param tag - the tag entry for this element.
         * @param property_dict - the property dictionary.
         * @returns A promise that resolves to the marked content begin element.
         */
        createMarkedContentBegin(tag: string, property_dict: PDFNet.Obj): Promise<PDFNet.Element>;
        /**
         * Create e_marked_content_end element (i.e. EMC operator in PDF content stream).
         * @returns A promise that resolves to the marked content end element.
         */
        createMarkedContentEnd(): Promise<PDFNet.Element>;
        /**
         * Create e_marked_content_point element with an inline property dictionary (i.e. DP operator in PDF content stream).
         * @param tag - the tag entry for this element.
         * @returns A promise that resolves to the marked content point element.
         * Note: The inline property dictionary can be accessed and edited using element.GetMCPropertyDict()
         */
        createMarkedContentPointInlineProperties(tag: string): Promise<PDFNet.Element>;
        /**
         * Create e_marked_content_point element with an associated property dictionary (i.e. MP or DP operator in PDF content stream).
         * @param tag - the tag entry for this element.
         * @param property_dict - the property dictionary.
         * @returns A promise that resolves to the marked content point element.
         */
        createMarkedContentPoint(tag: string, property_dict: PDFNet.Obj): Promise<PDFNet.Element>;
        /**
         * Create a new Unicode text run.
         * @param text_data - the Unicode text
        
        Note: you must set the current Font and font size before calling this function
        and the font must be a CID/Unicode font.
        
        Note: a text run can be created only within a text block
         * @returns A promise that resolves to an object of type: "PDFNet.Element"
         */
        createUnicodeTextRun(text_data: string): Promise<PDFNet.Element>;
    }
    /**
     * ElementReader can be used to parse and process content streams. ElementReader provides a
     * convenient interface used to traverse the Element display list of a page. The display list
     * representing graphical elements (such as text-runs, paths, images, shadings, forms, etc) is
     * accessed using the intrinsic iterator. ElementReader automatically concatenates page contents
     * spanning multiple streams and provides a mechanism to parse contents of sub-display lists
     * (e.g. forms XObjects and Type3 fonts).
     *
     * For a full sample, please refer to ElementReader and ElementReaderAdvTest sample projects.
     */
    class ElementReader extends PDFNet.Destroyable {
        /**
         * Constructor for an ElementReader object that can be used to parse and process
         * content streams.
         * @returns A promise that resolves to Returns an ElementReader object
         */
        static create(): Promise<PDFNet.ElementReader>;
        /**
         * begin processing a page.
         * @param page - A page to start processing.
         * @param [ctx] - An optional parameter used to specify the Optional Content (OC)
         * Context that should be used when processing the page. When the OCG::Context is specified,
         * Element::IsOCVisible() will return 'true' or 'false' depending on the visibility of the
         * current Optional Content Group (OCG) and the states of flags in the given context.
         *
         * Note: When page processing is completed, make sure to call ElementReader.End().
         */
        beginOnPage(page: PDFNet.Page, ctx?: PDFNet.OCGContext): Promise<void>;
        /**
         * begin processing given content stream. The content stream may be
         * a Form XObject, Type3 glyph stream, pattern stream or any other content stream.
         * @param content_stream - A stream object representing the content stream (usually
         * a Form XObject).
         * @param [resource_dict] - An optional '/Resource' dictionary parameter.
         * If content stream refers to named resources that are not present in
         * the local Resource dictionary, the names are looked up in the supplied
         * resource dictionary.
         * @param [ctx] - An optional parameter used to specify the Optional Content (OC)
         * Context that should be used when processing the page. When the OCG::Context is specified,
         * Element::IsOCVisible() will return 'true' or 'false' depending on the visibility of the
         * current Optional Content Group (OCG) and the states of flags in the given context.
         *
         * Note: When page processing is completed, make sure to call ElementReader.End().
         */
        begin(content_stream: PDFNet.Obj, resource_dict?: PDFNet.Obj, ctx?: PDFNet.OCGContext): Promise<void>;
        /**
         * @param res - resource dictionary for finding images, fonts, etc.
         */
        appendResource(res: PDFNet.Obj): Promise<void>;
        /**
         * @returns A promise that resolves to a page Element or a 'NULL' element if the end of current-display list was
         * reached. You may use GetType() to determine the type of the returned Element.
         *
         * Note: Every call to ElementReader::Next() destroys the current Element.
         * Therefore, an Element becomes invalid after subsequent
         * ElementReader::Next() operation.
         */
        next(): Promise<PDFNet.Element>;
        /**
         * @returns A promise that resolves to the current Element or a 'NULL' Element. The current element is the one
         * returned in the last call to Next().
         *
         * Note: Every call to ElementReader::Next() destroys the current Element. Therefore, an
         * Element becomes invalid after subsequent ElementReader::Next() operation.
         */
        current(): Promise<PDFNet.Element>;
        /**
         * when the current element is a form XObject you have the option to skip form
         * processing (by not calling FormBegin()) or to open the form stream and
         * continue Element traversal into the form.
         *
         * To open a form XObject display list use FormBegin() method. The Next() returned
         * Element will be the first Element in the form XObject display list. Subsequent calls to Next()
         * will traverse form's display list until NULL is returned. At any point you can
         * close the form sub-list using ElementReader::End() method. After the form display
         * list is closed (using End()) the processing will return to the parent display list
         * at the point where it left off before entering the form XObject.
         */
        formBegin(): Promise<void>;
        /**
         * a method used to spawn the sub-display list representing the tiling pattern
         * of the current element in the ElementReader. You can call this method at any
         * point as long as the current element is valid.
         * @param fill_pattern - If true, the filling pattern of the current element will
         * be spawned; otherwise, the stroking pattern of the current element will be
         * spawned. Note that the graphics state will be inherited from the parent content
         * stream (the content stream in which the pattern is defined as a resource) automatically.
         * @param [reset_ctm_tfm] - An optional parameter used to indicate whether the pattern's
         * display list should set its initial CTM and transformation matrices to identity matrix.
         * In general, we should leave it to be false.
         *
         * To open a tiling pattern sub-display list use PatternBegin(pattern) method.
         * The Next() returned Element will be the first Element in the pattern display list.
         * Subsequent calls to Next() will traverse pattern's display list until NULL is
         * encountered. At any point you can close the pattern sub-list using
         * ElementReader::End() method. After the pattern display list is closed,
         * the processing will return to the parent display list at the point where
         * pattern display list was spawned.
         */
        patternBegin(fill_pattern: boolean, reset_ctm_tfm?: boolean): Promise<void>;
        /**
         * A method used to spawn a sub-display list representing a Type3 Font glyph. You can
         * call this method at any point as long as the current element in the ElementReader
         * is a text element whose font type is type 3.
         * @param char_data - The information about the glyph to process. You can get this information
         * by dereferencing a CharIterator.
         * @param [resource_dict] - An optional '/Resource' dictionary parameter.
         * If any glyph descriptions refer to named resources but Font Resource dictionary
         * is absent, the names are looked up in the supplied resource dictionary.
         *
         * To open a Type3 font sub-display list use Type3FontBegin() method. The Next()
         * returned Element will be the first Element in the glyph's display list.
         * Subsequent calls to Next() will traverse glyph's display list until NULL is
         * returned. At any point you can close the glyph sub-list using ElementReader::End()
         * method. After the glyph display list is closed, the processing will return to the
         * parent display list at the point where glyph display list was spawned.
         */
        type3FontBegin(char_data: PDFNet.CharData, resource_dict?: PDFNet.Obj): Promise<void>;
        /**
         * Close the current display list.
         *
         * If the current display list is a sub-list created using FormBegin(), PatternBegin(),
         * or Type3FontBegin() methods, the function will end the sub-list and will return
         * processing to the parent display list at the point where it left off before
         * entering the sub-list.
         * @returns A promise that resolves to true if the closed display list is a sub-list or false if it is a root
         * display list.
         */
        end(): Promise<boolean>;
        /**
         * @returns A promise that resolves to an iterator to the beginning of the list containing identifiers of modified
         * graphics state attributes since the last call to ClearChangeList(). The list can
         * be consulted to determine which graphics states were modified between two
         * Elements. Attributes are ordered in the same way as they are set in the content
         * stream. Duplicate attributes are eliminated.
         */
        getChangesIterator(): Promise<PDFNet.Iterator<number>>;
        /**
         * @param attrib - <pre>
         * PDFNet.GState.Attribute = {
         * 	e_transform : 0
         * 	e_rendering_intent : 1
         * 	e_stroke_cs : 2
         * 	e_stroke_color : 3
         * 	e_fill_cs : 4
         * 	e_fill_color : 5
         * 	e_line_width : 6
         * 	e_line_cap : 7
         * 	e_line_join : 8
         * 	e_flatness : 9
         * 	e_miter_limit : 10
         * 	e_dash_pattern : 11
         * 	e_char_spacing : 12
         * 	e_word_spacing : 13
         * 	e_horizontal_scale : 14
         * 	e_leading : 15
         * 	e_font : 16
         * 	e_font_size : 17
         * 	e_text_render_mode : 18
         * 	e_text_rise : 19
         * 	e_text_knockout : 20
         * 	e_text_pos_offset : 21
         * 	e_blend_mode : 22
         * 	e_opacity_fill : 23
         * 	e_opacity_stroke : 24
         * 	e_alpha_is_shape : 25
         * 	e_soft_mask : 26
         * 	e_smoothnes : 27
         * 	e_auto_stoke_adjust : 28
         * 	e_stroke_overprint : 29
         * 	e_fill_overprint : 30
         * 	e_overprint_mode : 31
         * 	e_transfer_funct : 32
         * 	e_BG_funct : 33
         * 	e_UCR_funct : 34
         * 	e_halftone : 35
         * 	e_null : 36
         * }
         * </pre>
         * the GState attribute to test if it has been changed
         * ClearChangeList().
         * @returns A promise that resolves to true if given GState attribute was changed since the last call to
         */
        isChanged(attrib: number): Promise<boolean>;
        /**
         * Clear the list containing identifiers of modified graphics state attributes.
         * The list of modified attributes is then accumulated during a subsequent call(s)
         * to ElementReader.Next().
         */
        clearChangeList(): Promise<void>;
        /**
         * @param name - string of the name of the SDF/Cos object to get
         * @returns A promise that resolves to sDF/Cos object matching the specified name in the current resource
         * dictionary. For 'Page' the name is looked up in the page's /Resources/<Class>
         * dictionary. For Form XObjects, Patterns, and Type3 fonts that have a content
         * stream within page content stream the specified resource is first looked-up in the
         * resource dictionary of the inner stream. If the resource is not found, the name is
         * looked up in the outer content stream's resource dictionary. The function returns
         * NULL if the resource was not found.
         */
        getFont(name: string): Promise<PDFNet.Obj>;
        /**
         * @param name - string of the name of the SDF/Cos object to get
         * Note: see ElementReader::GetFont
         * @returns A promise that resolves to an object of type: "PDFNet.Obj"
         */
        getXObject(name: string): Promise<PDFNet.Obj>;
        /**
         * @param name - string of the name of the SDF/Cos object to get
         * Note: see ElementReader::GetFont
         * @returns A promise that resolves to an object of type: "PDFNet.Obj"
         */
        getShading(name: string): Promise<PDFNet.Obj>;
        /**
         * @param name - string of the name of the SDF/Cos object to get
         * Note: see ElementReader::GetFont
         * @returns A promise that resolves to an object of type: "PDFNet.Obj"
         */
        getColorSpace(name: string): Promise<PDFNet.Obj>;
        /**
         * @param name - string of the name of the SDF/Cos object to get
         * Note: see ElementReader::GetFont
         * @returns A promise that resolves to an object of type: "PDFNet.Obj"
         */
        getPattern(name: string): Promise<PDFNet.Obj>;
        /**
         * @param name - string of the name of the SDF/Cos object to get
         * Note: see ElementReader::GetFont
         * @returns A promise that resolves to an object of type: "PDFNet.Obj"
         */
        getExtGState(name: string): Promise<PDFNet.Obj>;
    }
    /**
     * ElementWriter can be used to assemble and write new content to a page, Form XObject,
     * Type3 Glyph stream, pattern stream, or any other content stream.
     */
    class ElementWriter extends PDFNet.Destroyable {
        /**
         * Constructor for an ElementWriter object that can be used to assemble and write
         * new content to a page, Form XObject, pattern stream or any other content stream.
         * @returns A promise that resolves to Returns an ElementWriter object
         */
        static create(): Promise<PDFNet.ElementWriter>;
        /**
         * begin writing to the given page.
         *
         * By default, new content will be appended to the page, as foreground graphics.
         * It is possible to add new page content as background graphics by setting the
         * second parameter in begin method to 'true' (e.g. writer.Begin(page, true)).
         * @param page - The page to write content.
         * @param [placement] - <pre>
         * PDFNet.ElementWriter.WriteMode = {
         * 	e_underlay : 0
         * 	e_overlay : 1
         * 	e_replacement : 2
         * }
         * </pre>
         * An optional flag indicating whether the new content should
         * be added as a foreground or background layer to the existing page. By default, the new
         * content will appear on top of the existing graphics.
         * @param [page_coord_sys] - An optional flag used to select the target coordinate system
         * if true (default), the coordinates are relative to the lower-left corner of the page,
         * otherwise the coordinates are defined in PDF user coordinate system (which may,
         * or may not coincide with the page coordinates).
         * @param [compress] - An optional flag indicating whether the page content stream
         * should be compressed. This may be useful for debugging content streams. Also
         * some applications need to do a clear text search on strings in the PDF files.
         * By default, all content streams are compressed.
         * @param [resources] - the resource dictionary in which to store resources for the final page.
         * By default, a new resource dictionary will be created.
         */
        beginOnPage(page: PDFNet.Page, placement?: number, page_coord_sys?: boolean, compress?: boolean, resources?: PDFNet.Obj): Promise<void>;
        /**
         * begin writing an Element sequence to a new stream. Use this function to write
         * Elements to a content stream other than the page. For example, you can create
         * Form XObjects (See Section '4.9 Form XObjects' in PDF Reference for more details)
         * pattern streams, Type3 font glyph streams, etc.
         * @param doc - A low-level SDF/Cos document that will contain the new stream. You can
         * access low-level document using PDFDoc::GetSDFDoc() or Obj::GetDoc() methods.
         * @param [compress] - An optional flag indicating whether the page content stream
         * should be compressed. This may be useful for debugging content streams. Also
         * some applications need to do a clear text search on strings in the PDF files.
         * By default, all content streams are compressed.
         *
         * Note: the newly created content stream object is returned when writing operations
         * are completed (i.e. after the call to ElementWriter::End()).
         */
        begin(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, compress?: boolean): Promise<void>;
        /**
         * begin writing an Element sequence to a stream. Use this function to write
         * Elements to a content stream which will replace an existing content stream in an
         * object passed as a parameter.
         * @param stream_obj_to_update - A low-level SDF stream object that will contain the new stream.
         * Old stream inside that object will be discarded.
         * @param [compress] - An optional flag indicating whether the content stream
         * should be compressed. This may be useful for debugging content streams. Also
         * some applications need to do a clear text search on strings in the PDF files.
         * By default, all content streams are compressed.
         * @param [resources] - the resource dictionary in which to store resources for the final page.
         * By default, a new resource dictionary will be created.
         *
         * Note: The content stream object is returned when writing operations
         * are completed (i.e. after the call to ElementWriter::End()).
         */
        beginOnObj(stream_obj_to_update: PDFNet.Obj, compress?: boolean, resources?: PDFNet.Obj): Promise<void>;
        /**
         * Finish writing to a page
         * @returns A promise that resolves to a low-level stream object that was used to store Elements.
         */
        end(): Promise<PDFNet.Obj>;
        /**
         * Writes the Element to the content stream.
         * @param element - The element to write to the content stream.
         */
        writeElement(element: PDFNet.Element): Promise<void>;
        /**
         * A utility function that surrounds the given Element with a graphics state
         * Save/Restore Element (i.e. in PDF content stream represented as 'q element Q').
         *
         * The function is equivalent to calling WriteElement three times:
         * 	 WriteElement(eSave);
         * 	 WriteElement(element);
         * 	 WriteElement(eRestore);
         *
         * where eSave is 'e_group_begin' and eRestore is 'e_group_end' Element
         *
         * The function is useful when XObjects such as Images and Forms are drawn on
         * the page.
         * @param element - Element object to enact function on.
         */
        writePlacedElement(element: PDFNet.Element): Promise<void>;
        /**
         * the Flush method flushes all pending Element writing operations.
         * This method is typically only required to be called when intermixing
         * direct content writing (i.e. WriteBuffer/WriteString) with Element writing.
         */
        flush(): Promise<void>;
        /**
         * Writes an arbitrary buffer to the content stream.
         * This function can be used to insert comments, inline-image data, and
         * chunks of arbitrary content to the output stream.
         */
        writeBuffer(data_buf: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray): Promise<void>;
        /**
         * Writes an arbitrary string to the content stream.
         * Serves the same purpose as WriteBuffer().
         * @param str - String to write to the content stream.
         */
        writeString(str: string): Promise<void>;
        /**
         * This method is used to initialize ElementWriter state with the state of a given ElementReader.
         * This can be used to avoid incorrectly writing inherited GState attributes.
         * @param reader - ElementReader.
         */
        setDefaultGState(reader: PDFNet.ElementReader): Promise<void>;
        /**
         * Write only the graphics state changes applied to this element and skip writing the element itself.
         * This is especially useful when rewriting page content, but with the intention to skip certain elements.
         * @param element - The element for which to write graphics state changes.
         */
        writeGStateChanges(element: PDFNet.Element): Promise<void>;
    }
    /**
     * This class represents the result of verifying a secure embedded
     * timestamp digital signature.
     */
    class EmbeddedTimestampVerificationResult extends PDFNet.Destroyable {
        /**
         * Retrieves the main verification status. The main status is determined based on the other statuses.
         * @returns A promise that resolves to a boolean representing whether or not the verification operation was completely successful.
         */
        getVerificationStatus(): Promise<boolean>;
        /**
         * Retrieves the result condition associated with the CMS signed digest verification step.
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.VerificationResult.DigestStatus = {
         * 	e_digest_invalid : 0
         * 	e_digest_verified : 1
         * 	e_digest_verification_disabled : 2
         * 	e_weak_digest_algorithm_but_digest_verifiable : 3
         * 	e_no_digest_status : 4
         * 	e_unsupported_encoding : 5
         * }
         * </pre>
         * @returns A promise that resolves to a DigestStatus-type enumeration value.
         */
        getCMSDigestStatus(): Promise<number>;
        /**
         * Retrieves the result condition associated with the message imprint digest verification step.
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.VerificationResult.DigestStatus = {
         * 	e_digest_invalid : 0
         * 	e_digest_verified : 1
         * 	e_digest_verification_disabled : 2
         * 	e_weak_digest_algorithm_but_digest_verifiable : 3
         * 	e_no_digest_status : 4
         * 	e_unsupported_encoding : 5
         * }
         * </pre>
         * @returns A promise that resolves to a DigestStatus-type enumeration value.
         */
        getMessageImprintDigestStatus(): Promise<number>;
        /**
         * Retrieves the result condition associated with the trust verification step.
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.VerificationResult.TrustStatus = {
         * 	e_trust_verified : 0
         * 	e_untrusted : 1
         * 	e_trust_verification_disabled : 2
         * 	e_no_trust_status : 3
         * }
         * </pre>
         * @returns A promise that resolves to a TrustStatus-type enumeration value.
         */
        getTrustStatus(): Promise<number>;
        /**
         * Retrieves the result condition associated with the CMS signed digest verification step, as a descriptive string.
         * @returns A promise that resolves to a string
         *
         * Note: Output may change in future versions.
         */
        getCMSDigestStatusAsString(): Promise<string>;
        /**
         * Retrieves the result condition associated with the message imprint digest verification step, as a descriptive string.
         * @returns A promise that resolves to a string
         *
         * Note: Output may change in future versions.
         */
        getMessageImprintDigestStatusAsString(): Promise<string>;
        /**
         * Retrieves the result condition associated with the trust verification step, as a descriptive string.
         * @returns A promise that resolves to a string
         *
         * Note: Output may change in future versions.
         */
        getTrustStatusAsString(): Promise<string>;
        /**
         * Returns whether there is a detailed TrustVerificationResult in this EmbeddedTimestampVerificationResult.
         * @returns A promise that resolves to a boolean
         */
        hasTrustVerificationResult(): Promise<boolean>;
        /**
         * Retrieves the detailed result associated with the trust step of the verification operation that returned this EmbeddedTimestampVerificationResult,
         * if such a detailed trust result is available. Must call HasTrustVerificationResult first and check for a true result.
         * Note: This function will throw if there is no trust result available.
         * @returns A promise that resolves to a TrustVerificationResult object.
         */
        getTrustVerificationResult(): Promise<PDFNet.TrustVerificationResult>;
        /**
         * Retrieves an enumeration value representing the digest algorithm used to sign the timestamp token.
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.DigestAlgorithm.Type = {
         * 	e_SHA1 : 0
         * 	e_SHA256 : 1
         * 	e_SHA384 : 2
         * 	e_SHA512 : 3
         * 	e_RIPEMD160 : 4
         * 	e_unknown_digest_algorithm : 5
         * }
         * </pre>
         * @returns A promise that resolves to a DigestAlgorithm enumeration value.
         */
        getCMSSignatureDigestAlgorithm(): Promise<number>;
        /**
         * Retrieves an enumeration value representing the digest algorithm used inside the message imprint field of the timestamp to digest the main signature value.
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.DigestAlgorithm.Type = {
         * 	e_SHA1 : 0
         * 	e_SHA256 : 1
         * 	e_SHA384 : 2
         * 	e_SHA512 : 3
         * 	e_RIPEMD160 : 4
         * 	e_unknown_digest_algorithm : 5
         * }
         * </pre>
         * @returns A promise that resolves to a DigestAlgorithm enumeration value.
         */
        getMessageImprintDigestAlgorithm(): Promise<number>;
        /**
         * Retrieves reports about unsupported features encountered during verification of the timestamp.
         * Current possible values:
         * 	"GeneralizedTime format with length <number greater than 15>",
         * 	"unsupported digest algorithm"
         * @returns A promise that resolves to a container of strings representing unsupported features encountered during verification of the timestamp
         *
         * Note: Output may change in future versions.
         */
        getUnsupportedFeatures(): Promise<string[]>;
    }
    /**
     * FDFDoc is a class representing Forms Data Format (FDF) documents.
     * FDF is typically used when submitting form data to a server, receiving
     * the response, and incorporating it into the interactive form. It can also
     * be used to export form data to stand-alone files that can be stored, transmitted
     * electronically, and imported back into the corresponding PDF interactive form.
     * In addition, beginning in PDF 1.3, FDF can be used to define a container for
     * annotations that are separate from the PDF document to which they apply.
     */
    class FDFDoc extends PDFNet.Destroyable {
        /**
         * Method to create a XFDFExportOptions object
         * @returns A promise that resolves to a PDFNet.FDFDoc.XFDFExportOptions.
         */
        static createXFDFExportOptions(): Promise<PDFNet.FDFDoc.XFDFExportOptions>;
        /**
         * Default constructor that creates an empty new document.
         * @returns A promise that resolves to an object of type: "PDFNet.FDFDoc"
         */
        static create(): Promise<PDFNet.FDFDoc>;
        /**
         * @returns A promise that resolves to an object of type: "PDFNet.FDFDoc"
         */
        static createFromStream(stream: PDFNet.Filter): Promise<PDFNet.FDFDoc>;
        /**
         * Open a SDF/Cos document from a memory buffer.
         * Note: the document should be fully loaded in the memory buffer.
         * Note: the buffer ownership is not transfered to the Document so the user should
         * clean-up if necessary.
         * @param buf - a memory buffer containing the serialized document
         * @returns A promise that resolves to an object of type: "PDFNet.FDFDoc"
         */
        static createFromMemoryBuffer(buf: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray): Promise<PDFNet.FDFDoc>;
        /**
         * @returns A promise that resolves to true if document was modified, false otherwise
         */
        isModified(): Promise<boolean>;
        /**
         * Saves the document to a memory buffer.
         * @returns A promise that resolves to an object of type: "Uint8Array"
         */
        saveMemoryBuffer(): Promise<Uint8Array>;
        /**
         * @returns A promise that resolves to A dictionary representing the Cos root of the document (document's trailer)
         */
        getTrailer(): Promise<PDFNet.Obj>;
        /**
         * @returns A promise that resolves to A dictionary representing the Cos root of the document (/Root entry
         * within the trailer dictionary)
         */
        getRoot(): Promise<PDFNet.Obj>;
        /**
         * @returns A promise that resolves to the FDF dictionary located in "/Root" or NULL if dictionary is not present.
         */
        getFDF(): Promise<PDFNet.Obj>;
        /**
         * Get the PDF document file that this FDF file was exported from or is intended
         * to be imported into.
         * @returns A promise that resolves to a String with the PDF document file name.
         */
        getPDFFileName(): Promise<string>;
        /**
         * Set the PDF document file that this FDF file was exported from or is intended
         * to be imported into.
         * @param filepath - pathname to the file.
         */
        setPDFFileName(filepath: string): Promise<void>;
        /**
         * Get the ID entry from "/Root/FDF" dictionary.
         * @returns A promise that resolves to An object representing the ID entry in "/Root/FDF" dictionary.
         */
        getID(): Promise<PDFNet.Obj>;
        /**
         * Set the ID entry in "/Root/FDF" dictionary.
         * @param id - ID array object.
         */
        setID(id: PDFNet.Obj): Promise<void>;
        /**
         * An interactive form (sometimes referred to as an AcroForm) is a
         * collection of fields for gathering information interactively from
         * the user. A FDF document may contain any number of fields appearing
         * on any combination of pages, all of which make up a single, global
         * interactive form spanning the entire document.
         *
         * The following methods are used to access and manipulate Interactive form
         * fields (sometimes referred to as AcroForms).
         * @returns A promise that resolves to an iterator to the first FDFField in the document.
         * Note: if the document has no AcroForms, HasNext()
         * will return false.
         */
        getFieldIteratorBegin(): Promise<PDFNet.Iterator<PDFNet.FDFField>>;
        /**
         * An interactive form (sometimes referred to as an AcroForm) is a
         * collection of fields for gathering information interactively from
         * the user. A FDF document may contain any number of fields appearing
         * on any combination of pages, all of which make up a single, global
         * interactive form spanning the entire document.
         *
         * The following methods are used to access and manipulate Interactive form
         * fields (sometimes referred to as AcroForms).
         * @param field_name - String representing the name of the FDFField to get.
         * @returns A promise that resolves to an iterator to the FDFField in the document.
         * Note: if the document has no AcroForms, HasNext()
         * will return false.
         */
        getFieldIterator(field_name: string): Promise<PDFNet.Iterator<PDFNet.FDFField>>;
        /**
         * @param field_name - a string representing the fully qualified name of
         * the field (e.g. "employee.name.first").
         * @returns A promise that resolves to a FDFField associated with the given field_name or invalid
         * field (null) if the field is not found.
         */
        getField(field_name: string): Promise<PDFNet.FDFField>;
        /**
         * Create a new interactive form FDFField.
         * @param type - <pre>
         * PDFNet.Field.Type = {
         * 	e_button : 0
         * 	e_check : 1
         * 	e_radio : 2
         * 	e_text : 3
         * 	e_choice : 4
         * 	e_signature : 5
         * 	e_null : 6
         * }
         * </pre>
         * @returns A promise that resolves to
         */
        fieldCreate(field_name: string, type: number, field_value?: PDFNet.Obj): Promise<PDFNet.FDFField>;
        /**
         * @param type - <pre>
         * PDFNet.Field.Type = {
         * 	e_button : 0
         * 	e_check : 1
         * 	e_radio : 2
         * 	e_text : 3
         * 	e_choice : 4
         * 	e_signature : 5
         * 	e_null : 6
         * }
         * </pre>
         * @returns A promise that resolves to an object of type: "PDFNet.FDFField"
         */
        fieldCreateFromString(field_name: string, type: number, field_value: string): Promise<PDFNet.FDFField>;
        /**
         * @returns A promise that resolves to document's SDF/Cos document
         */
        getSDFDoc(): Promise<PDFNet.SDFDoc>;
        /**
         * Create a new FDFDoc from XFDF input. Input can be either a XFDF file path, or the XFDF data itself.
         * @param file_name - string containing either the file path to a XFDF file, or the XML buffer containing the XFDF.
         * @returns A promise that resolves to a new FDFDoc.
         */
        static createFromXFDF(file_name: string): Promise<PDFNet.FDFDoc>;
        /**
         * Export FDF file as an XFDF file
         * @param filepath - the filepath of the exported XFDF file
         * @param [opts] - Options controlling finer parameters of xfdf export
         */
        saveAsXFDFWithOptions(filepath: string, opts?: PDFNet.FDFDoc.XFDFExportOptions): Promise<void>;
        /**
         * @returns A promise that resolves to an object of type: "string"
         */
        saveAsXFDFAsString(): Promise<string>;
        /**
         * Export FDF file as a XFDF string
         * @param [opts] - Options controlling finer parameters of xfdf export
         * @returns A promise that resolves to a UString containing the XFDF representation of the FDF file
         */
        saveAsXFDFAsStringWithOptions(opts?: PDFNet.FDFDoc.XFDFExportOptions): Promise<string>;
        /**
         * Merge the annotations from XFDF file into FDF file
         * @param command_file - string containing the xml command file path or xml string of the command
         * @param [permitted_user] - optional user name of the permitted user
         */
        mergeAnnots(command_file: string, permitted_user?: string): Promise<void>;
    }
    /**
     * FDFField is an interactive form field in an FDF document
     */
    class FDFField {
        constructor(mp_leaf_node?: PDFNet.Obj, mp_root_array?: PDFNet.Obj);
        /**
         * construct a FDF::FDFField from a SDF dictionary representing a terminal field node.
         * @returns A promise that resolves to an object of type: "PDFNet.FDFField"
         */
        static create(field_dict?: PDFNet.Obj, fdf_dict?: PDFNet.Obj): Promise<PDFNet.FDFField>;
        /**
         * @returns A promise that resolves to the value of the Field (the value of its /V key) or NULL if the
         * value is not specified.
         * The format of field's value varies depending on the field type.
         */
        getValue(): Promise<PDFNet.Obj>;
        /**
         * sets the value of the FDFField (the value of the field's /V key).
         * @param value - the value to set the FDFField to
         *
         * Note: in order to remove/erase the existing value use SetValue(SDF::Null)
         */
        setValue(value: PDFNet.Obj): Promise<void>;
        /**
         * @returns A promise that resolves to a string representing the fully qualified name of the field
         * (e.g. "employee.name.first").
         */
        getName(): Promise<string>;
        /**
         * @returns A promise that resolves to a string representing the partial name of the field (e.g.
         * "first" when "employee.name.first" is fully qualified name).
         */
        getPartialName(): Promise<string>;
        /**
         * @returns A promise that resolves to the object to the underlying SDF/Cos object.
         */
        getSDFObj(): Promise<PDFNet.Obj>;
        /**
         * The function returns the specified attribute.
         * @param attrib - name of the attribute to find
         * @returns A promise that resolves to return the attribute value if the given attribute name
         * was found or a NULL object if the given attribute name was not found.
         */
        findAttribute(attrib: string): Promise<PDFNet.Obj>;
        mp_leaf_node: PDFNet.Obj;
        mp_root_array: PDFNet.Obj;
    }
    /**
     * An interactive form (sometimes referred to as an AcroForm) is a
     * collection of fields for gathering information interactively from
     * the user. A PDF document may contain any number of Fields appearing
     * on any combination of pages, all of which make up a single, global
     * interactive form spanning the entire document.
     *
     * PDFNet fully supports reading, writing, and editing PDF forms and
     * provides many utility methods so that work with forms is simple and
     * efficient. Using PDFNet forms API arbitrary subsets of form fields
     * can be imported or exported from the document, new forms can be
     * created from scratch, and the appearance of existing forms can be
     * modified.
     *
     * In PDFNet Fields are accessed through FieldIterator-s. The list of
     * all Fields present in the document can be traversed as follows:
     *
     * <pre>
     * FieldIterator itr = pdfdoc.GetFieldIterator();
     * for(; itr.HasNext(); itr.Next()) {
     *   Field field = itr.Current();
     *   Console.WriteLine("Field name: {0}", field.GetName());
     *  }
     * </pre>
     *
     * For a full sample, please refer to 'InteractiveForms' sample project.
     *
     * To search field by name use FieldFind method. For example:
     * <pre>
     * FieldIterator itr = pdfdoc.FieldFind("name");
     * if (itr.HasNext()) {
     *   Console.WriteLine("Field name: {0}", itr.Current().GetName());
     * }
     * else { ...field was not found... }
     * </pre>
     *
     * If a given field name was not found or if the end of the field list
     * was reached the iterator HasNext() will return false.
     *
     * If you have a valid iterator you can access the Field using Current() method. For example:
     * Field field = itr.Current();
     *
     * Using Flatten(...) method it is possible to merge field
     * appearances with the page content. Form 'flattening' refers to the
     * operation that changes active form fields into a static area that is
     * part of the PDF document, just like the other text and images in
     * the document. A completely flattened PDF form does not have any
     * widget annotations or interactive fields.
     */
    class Field {
        constructor(leaf_node?: PDFNet.Obj, builder?: PDFNet.ElementBuilder);
        /**
         * construct a PDF::Field from a SDF dictionary representing a terminal field node.
         * @param field_dict - the SDF dictionary to construct the field from.
         * @returns A promise that resolves to an object of type: "PDFNet.Field"
         */
        static create(field_dict: PDFNet.Obj): Promise<PDFNet.Field>;
        /**
         * @returns A promise that resolves to whether this is a valid (non-null) Field. If the
         * function returns false the underlying SDF/Cos object is null and
         * the Field object should be treated as null as well.
         */
        isValid(): Promise<boolean>;
        /**
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.Field.Type = {
         * 	e_button : 0
         * 	e_check : 1
         * 	e_radio : 2
         * 	e_text : 3
         * 	e_choice : 4
         * 	e_signature : 5
         * 	e_null : 6
         * }
         * </pre>
         * @returns A promise that resolves to the field's value, whose type/format varies depending on the field type.
         * See the descriptions of individual field types for further information.
         */
        getType(): Promise<number>;
        /**
         * @returns A promise that resolves to the value of the Field (the value of its /V key) or NULL if the
         * value is not specified.
         *
         * The format of field's value varies depending on the field type.
         */
        getValue(): Promise<PDFNet.Obj>;
        /**
         * @returns A promise that resolves to a string of the value of the Field (the value of its /V key) or
         * NULL if the value is not specified.
         *
         * The format of field's value varies depending on the field type.
         */
        getValueAsString(): Promise<string>;
        /**
         * @returns A promise that resolves to a string of the default value to which the field reverts when a reset-form
         * action is executed or NULL if the default value is not specified.
         *
         * The format of field's value varies depending on the field type.
         */
        getDefaultValueAsString(): Promise<string>;
        /**
         * sets the value of the field (i.e. the value of the field's /V key).
         * The format of field's value varies depending on the field type.
         * @param value - the new field value.
         *
         * Note: in order to remove/erase the existing value use pass a SDF::Null
         * object to SetValue().
         *
         * Note: <p>In PDF, Field's value is separate from its annotation (i.e. how the
         * field appears on the page). After you modify Field's value you need to
         * refresh Field's appearance using RefreshAppearance() method.
         * </p><p>
         * Alternatively, you can delete "AP" entry from the Widget annotation and set
         * "NeedAppearances" flag in AcroForm dictionary (i.e.
         * doc.GetAcroForm().Put("NeedAppearances", Obj.CreateBool(true)); )
         * This will force viewer application to auto-generate new field appearances
         * every time the document is opened.
         * </p><p>
         * Yet another option is to generate a custom annotation appearance using
         * ElementBuilder and ElementWriter and then set the "AP" entry in the widget
         * dictionary to the new appearance stream. This functionality is useful in
         * applications that need advanced control over how the form fields are rendered.
         * </p>
         * @returns A promise that resolves to an object of type: "PDFNet.ViewChangeCollection"
         */
        setValueAsString(value: string): Promise<PDFNet.ViewChangeCollection>;
        /**
         * Sets the value of the field (i.e. the value of the field's /V key).
         * The format of field's value varies depending on the field type.
         * @param value - the new field value.
         *
         * Note: in order to remove/erase the existing value use pass a SDF::Null
         * object to SetValue().
         *
         * Note: <p>In PDF, Field's value is separate from its annotation (i.e. how the
         * field appears on the page). After you modify Field's value you need to
         * refresh Field's appearance using RefreshAppearance() method.
         * </p><p>
         * Alternatively, you can delete "AP" entry from the Widget annotation and set
         * "NeedAppearances" flag in AcroForm dictionary (i.e.
         * doc.GetAcroForm().Put("NeedAppearances", Obj.CreateBool(true)); )
         * This will force viewer application to auto-generate new field appearances
         * every time the document is opened.
         * </p><p>
         * Yet another option is to generate a custom annotation appearance using
         * ElementBuilder and ElementWriter and then set the "AP" entry in the widget
         * dictionary to the new appearance stream. This functionality is useful in
         * applications that need advanced control over how the form fields are rendered.
         * </p>
         * @returns A promise that resolves to an object of type: "PDFNet.ViewChangeCollection"
         */
        setValue(value: PDFNet.Obj): Promise<PDFNet.ViewChangeCollection>;
        /**
         * sets the value of a check-box or radio-button field.
         * @param value - If true, the filed will be set to 'True', if false the field will
         * be set to 'False'.
         *
         * Note: This method is usually for check-box and radio button fields.
         * @returns A promise that resolves to an object of type: "PDFNet.ViewChangeCollection"
         */
        setValueAsBool(value: boolean): Promise<PDFNet.ViewChangeCollection>;
        /**
         * Get the Action associated with the selected Field Trigger event.
         * @param trigger - <pre>
         * PDFNet.Field.EventType = {
         * 	e_action_trigger_keystroke : 13
         * 	e_action_trigger_format : 14
         * 	e_action_trigger_validate : 15
         * 	e_action_trigger_calculate : 16
         * }
         * </pre>
         * the type of trigger event to get
         * @returns A promise that resolves to the Action Obj if present, otherwise NULL
         */
        getTriggerAction(trigger: number): Promise<PDFNet.Obj>;
        /**
         * @returns A promise that resolves to field value as a boolean.
         * Note: This method is usually for check-box and radio button fields.
         */
        getValueAsBool(): Promise<boolean>;
        /**
         * regenerates the appearance stream for the Widget Annotation containing
         * variable text. Call this method if you modified field's value and would
         * like to update field's appearance.
         *
         * Note: If this field contains text, and has been added to a rotated page, the text in
         * the field may be rotated. If RefreshAppearance is called *after* the field is added
         * to a rotated page, then any text will be rotated in the opposite direction of the page
         * rotation. If this method is called *before* the field is added to any rotated page, then
         * no counter rotation will be applied. If you wish to call RefreshAppearance on a field
         * already added to a rotated page, but you don't want the text to be rotated, you can do one
         * of the following; temporarily un-rotate the page, or, temporarily remove the "P" object
         * from the field.
         */
        refreshAppearance(): Promise<void>;
        /**
         * removes any appearances associated with the field.
         */
        eraseAppearance(): Promise<void>;
        /**
         * @returns A promise that resolves to the default value to which the field reverts when a reset-form action
         * is executed or NULL if the default value is not specified.
         *
         * The format of field's value varies depending on the field type.
         */
        getDefaultValue(): Promise<PDFNet.Obj>;
        /**
         * @returns A promise that resolves to a string representing the fully qualified name of the field
         * (e.g. "employee.name.first").
         */
        getName(): Promise<string>;
        /**
         * @returns A promise that resolves to a string representing the partial name of the field (e.g.
         * "first" when "employee.name.first" is fully qualified name).
         */
        getPartialName(): Promise<string>;
        /**
         * modifies the field name.
         * @param field_name - a string representing the fully qualified name of
         * the field (e.g. "employee.name.first").
         */
        rename(field_name: string): Promise<void>;
        /**
         * @returns A promise that resolves to true if this Field is a Widget Annotation
         *
         * Determines whether or not this Field is an Annotation.
         */
        isAnnot(): Promise<boolean>;
        /**
         * Sets the signature handler to use for adding a signature to this field. If the signature handler is not found
         * in PDFDoc's signature handlers list, this field will not be signed. To add signature handlers, use PDFDoc.AddSignatureHandler
         * method.
         *
         * If a signature handler is already assigned to this field and this method is called once again, the associate signature
         * handler for this field will be updated with the new handler.
         * @param signature_handler_id - The unique id of the SignatureHandler to use for adding signature in this field.
         * @returns A promise that resolves to the signature dictionary created using the SignatureHandler, or NULL pointer if the signature handler is not found.
         */
        useSignatureHandler(signature_handler_id: number): Promise<PDFNet.Obj>;
        /**
         * @param flag - <pre>
         * PDFNet.Field.Flag = {
         * 	e_read_only : 0
         * 	e_required : 1
         * 	e_no_export : 2
         * 	e_pushbutton_flag : 3
         * 	e_radio_flag : 4
         * 	e_toggle_to_off : 5
         * 	e_radios_in_unison : 6
         * 	e_multiline : 7
         * 	e_password : 8
         * 	e_file_select : 9
         * 	e_no_spellcheck : 10
         * 	e_no_scroll : 11
         * 	e_comb : 12
         * 	e_rich_text : 13
         * 	e_combo : 14
         * 	e_edit : 15
         * 	e_sort : 16
         * 	e_multiselect : 17
         * 	e_commit_on_sel_change : 18
         * }
         * </pre>
         * @returns A promise that resolves to the value of given field flag
         */
        getFlag(flag: number): Promise<boolean>;
        /**
         * Flags specifying various characteristics of the fields.
         *
         * Field flags common to all field types:
         * ----------------------------------------------
         * If e_read_only flag is set the user may not change the value
         * of the field. Any associated widget annotations will not interact with
         * the user; that is, they will not respond to mouse clicks or change their
         * appearance in response to mouse motions. This flag is useful for fields
         *  whose values are computed or imported from a database.
         *
         * If e_required flag is set, the field must have a value at the time
         * it is exported by a submit-form action.
         *
         * If e_no_export flag is set, the field must not be exported by a
         * submit-form action.
         *
         * Field flags specific to radio buttons:
         * ----------------------------------------------
         * If e_toggle_to_off is clear, exactly one radio button must be selected
         * at all times; clicking the currently selected button has no effect.
         * If set, clicking the selected button deselects it, leaving no button selected.
         *
         * If e_radios_in_unison is set, a group of radio buttons within a radio button
         * field that use the same value for the on state will turn on and off in unison;
         * that is if one is checked, they are all checked. If clear, the buttons are
         * mutually exclusive (the same behavior as HTML radio buttons).
         *
         * Field flags specific to text fields:
         * ----------------------------------------------
         * If e_multiline is set, the field can contain multiple lines of text;
         * if clear, the field's text is restricted to a single line.
         *
         * If e_password If set, the field is intended for entering a secure password
         * that should not be echoed visibly to the screen. Characters typed from the
         * keyboard should instead be echoed in some unreadable form, such as asterisks
         * or bullet characters. The value is not stored if this flag is set.
         *
         * If e_file_select is set, the text entered in the field represents the pathname
         * of a file whose contents are to be submitted as the value of the field.
         *
         * If e_no_spellcheck is set, text entered in the field is not spell-checked.
         *
         * If e_no_scroll is set, the field does not scroll (horizontally for single-line
         * fields, vertically for multiple-line fields) to accommodate more text than fits
         * within its annotation rectangle. Once the field is full, no further text is
         * accepted.
         *
         * If e_comb is set, the field is automatically divided into as many equally
         * spaced positions, or combs, as the value of MaxLen, and the text is laid out
         * into those combs. Meaningful only if the MaxLen entry is present in the text
         * field and if the Multiline, Password, and FileSelect flags are clear.
         *
         * If e_rich_text is set, the value of this field should be represented as a rich
         * text string. If the field has a value, the RV entry of the field dictionary
         * specifies the rich text string.
         *
         * Field flags specific to choice fields:
         * ----------------------------------------------
         *
         * If e_combo is set, the field is a combo box;
         * if clear, the field is a list box.
         *
         * If e_edit is set, the combo box includes an editable text box as well as a
         * dropdown list; if clear, it includes only a drop-down list. This flag is
         * meaningful only if the e_combo flag is set.
         *
         * If e_sort is set, the field's option items should be sorted alphabetically.
         * This flag is intended for use by form authoring tools, not by PDF viewer
         * applications. Viewers should simply display the options in the order in
         * which they occur in the Opt array.
         *
         * If e_multiselect is set, more than one of the field's option items may be
         * selected simultaneously; if clear, no more than one item at a time may be
         * selected.
         *
         * If e_commit_on_sel_change is set, the new value is committed as soon as a
         * selection is made with the pointing device. This option enables applications
         * to perform an action once a selection is made, without requiring the user
         * to exit the field. If clear, the new value is not committed until the user
         * exits the field.
         * @param flag - <pre>
         * PDFNet.Field.Flag = {
         * 	e_read_only : 0
         * 	e_required : 1
         * 	e_no_export : 2
         * 	e_pushbutton_flag : 3
         * 	e_radio_flag : 4
         * 	e_toggle_to_off : 5
         * 	e_radios_in_unison : 6
         * 	e_multiline : 7
         * 	e_password : 8
         * 	e_file_select : 9
         * 	e_no_spellcheck : 10
         * 	e_no_scroll : 11
         * 	e_comb : 12
         * 	e_rich_text : 13
         * 	e_combo : 14
         * 	e_edit : 15
         * 	e_sort : 16
         * 	e_multiselect : 17
         * 	e_commit_on_sel_change : 18
         * }
         * </pre>
         */
        setFlag(flag: number, value: boolean): Promise<void>;
        /**
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.Field.TextJustification = {
         * 	e_left_justified : 0
         * 	e_centered : 1
         * 	e_right_justified : 2
         * }
         * </pre>
         * @returns A promise that resolves to the form of quadding (justification) to be used in displaying
         * the text fields.
         */
        getJustification(): Promise<number>;
        /**
         * sets the justification to be used in displaying the text field.
         * @param j - <pre>
         * PDFNet.Field.TextJustification = {
         * 	e_left_justified : 0
         * 	e_centered : 1
         * 	e_right_justified : 2
         * }
         * </pre>
         * enum representing justification to set the text field to, options are e_left_justified, e_centered and e_right_justified
         * Note: This method is specific to a text field.
         */
        setJustification(j: number): Promise<void>;
        /**
         * sets the maximum length of the field's text, in characters.
         * @param max_len - maximum length of a field's text.
         * Note: This method is specific to a text field.
         */
        setMaxLen(max_len: number): Promise<void>;
        /**
         * @returns A promise that resolves to the maximum length of the field's text, in characters, or a
         * negative number if the length is not limited.
         * Note: This method is specific to a text field.
         */
        getMaxLen(): Promise<number>;
        /**
         * @returns A promise that resolves to the default graphics state that should be used in formatting the
         * text. The state corresponds to /DA entry in the field dictionary.
         */
        getDefaultAppearance(): Promise<PDFNet.GState>;
        /**
         * @returns A promise that resolves to the rectangle that should be refreshed after changing a field.
         */
        getUpdateRect(): Promise<PDFNet.Rect>;
        /**
         * Flatten/Merge existing form field appearances with the page content and
         * remove widget annotation.
         *
         * Form 'flattening' refers to the operation that changes active form fields
         * into a static area that is part of the PDF document, just like the other
         * text and images in the document. A completely flattened PDF form does not
         * have any widget annotations or interactive fields.
         * @param page - page object to flatten
         * Note: an alternative approach to set the field as read only is using
         * Field.SetFlag(Field::e_read_only, true) method. Unlike Field.SetFlag(...),
         * the result of Flatten() operation can not be programatically reversed.
         */
        flatten(page: PDFNet.Page): Promise<void>;
        /**
         * Some of the Field attributes are designated as inheritable.
         * If such an attribute is omitted from a Field object, its value is inherited
         * from an ancestor node in the Field tree. If the attribute is a required one,
         * a value must be supplied in an ancestor node; if it is optional and no
         * inherited value is specified, the default value should be used.
         *
         * The function walks up the Field inheritance tree in search for specified
         * attribute.
         * @returns A promise that resolves to the attribute value if the given attribute name was found
         * or a NULL object if the given attribute name was not found.
         *
         *  Resources dictionary (Required; inheritable)
         *  MediaBox rectangle (Required; inheritable)
         *  CropBox rectangle (Optional; inheritable)
         *  Rotate integer (Optional; inheritable)
         */
        findInheritedAttribute(attrib: string): Promise<PDFNet.Obj>;
        /**
         * @returns A promise that resolves to the underlying SDF/Cos object.
         */
        getSDFObj(): Promise<PDFNet.Obj>;
        /**
         * Returns the total number of options in a list or combo box.
         * @returns A promise that resolves to an object of type: "number"
         */
        getOptCount(): Promise<number>;
        /**
         * @param index - index position of the option to retrieve.
         * @returns A promise that resolves to the string of the option at the givent index.
         * Note: The index must be less than the value returned by GetOptCount().
         */
        getOpt(index: number): Promise<string>;
        /**
         * Returns whether modifying this field would invalidate a digital signature in the document.
         * @returns A promise that resolves to whether modifying this field would invalidate a digital signature in the document
         */
        isLockedByDigitalSignature(): Promise<boolean>;
        leaf_node: PDFNet.Obj;
        builder: PDFNet.ElementBuilder;
    }
    /**
     * A file attachment annotation contains a reference to a file, which may be
     * embedded in the PDF document.
     */
    class FileAttachmentAnnot extends PDFNet.MarkupAnnot {
        /**
         * creates an FileAttachment annotation and initializes it using given Cos/SDF object.
         * d Cos/SDF object used to initialize the FileAttachment annotation
         * @param [d] - The Cos/SDF object to initialze the annotation with.
         * Note: The constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @returns A promise that resolves to an object of type: "PDFNet.FileAttachmentAnnot"
         */
        static createFromObj(d?: PDFNet.Obj): Promise<PDFNet.FileAttachmentAnnot>;
        /**
         * The function saves the data referenced by this File Attachment to an
         * external file.
         *
         * If the file is embedded, the function saves the embedded file.
         * If the file is not embedded, the function will copy the external file.
         * If the file is not embedded and the external file can't be found, the function
         * returns false.
         * @param [save_as] - An optional parameter indicating the filepath and filename
         * where the data should be saved. If this parameter is not specified the function
         * will attempt to save the file using FileSpec.GetFilePath().
         * @returns A promise that resolves to true is the file was saved successfully, false otherwise.
         */
        export(save_as?: string): Promise<boolean>;
        /**
         * @returns A promise that resolves to an object of type: "PDFNet.Annot"
         */
        createFromAnnot(): Promise<PDFNet.Annot>;
        /**
         * Creates a file attachment annotation.
         *
         * A file attachment annotation contains a reference to a file, which typically
         * is embedded in the PDF file.
         * @param doc - A document to which the annotation is added.
         * @param pos - A rectangle specifying the annotation's bounds, in user space coordinates.
         * Note that FileAttachment icons can differ in their appearance dimensions, so you may want
         * to match these Rectangle dimensions or the aspect ratio to avoid a squished or stretched appearance:
         * e_Graph: 40 x 40
         * e_PushPin: 28 x 40
         * e_Paperclip: 14 x 34
         * e_Tag: 40 x 32
         * @param fs - a file specification object used to initialize the file attachment annotation.
         * @param [icon_name] - <pre>
         * PDFNet.FileAttachmentAnnot.Icon = {
         * 	e_Graph : 0
         * 	e_PushPin : 1
         * 	e_Paperclip : 2
         * 	e_Tag : 3
         * 	e_Unknown : 4
         * }
         * </pre>
         * The name of an icon to be used in displaying the annotation, default is PushPin.
         * Note: PDF Viewer applications should provide predefined icon appearances for at least
         * the following standard names: Graph, PushPin, Paperclip, Tag. Additional names may
         * be supported as well. Default value: PushPin.
         * @returns A promise that resolves to a new file attachment annotation.
         */
        static createWithFileSpec(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, pos: PDFNet.Rect, fs: PDFNet.FileSpec, icon_name?: number): Promise<PDFNet.FileAttachmentAnnot>;
        /**
         * @returns A promise that resolves to an object of type: "PDFNet.FileAttachmentAnnot"
         */
        static createDefault(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, pos: PDFNet.Rect, path: string): Promise<PDFNet.FileAttachmentAnnot>;
        /**
         * @returns A promise that resolves to the file specification that contains a file reference or the embedded file data stream.
         */
        getFileSpec(): Promise<PDFNet.FileSpec>;
        /**
         * sets the file specification.
         * @param file - The file specification to associate with this annotation..
         * The file specification contains a file reference or the embedded file data stream.
         */
        setFileSpec(file: PDFNet.FileSpec): Promise<void>;
        /**
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.FileAttachmentAnnot.Icon = {
         * 	e_Graph : 0
         * 	e_PushPin : 1
         * 	e_Paperclip : 2
         * 	e_Tag : 3
         * 	e_Unknown : 4
         * }
         * </pre>
         * @returns A promise that resolves to the type the associated icon style.
         */
        getIcon(): Promise<number>;
        /**
         * sets the icon style associated with FileAttachment annotation.
         * (Optional)
         * @param [type] - <pre>
         * PDFNet.FileAttachmentAnnot.Icon = {
         * 	e_Graph : 0
         * 	e_PushPin : 1
         * 	e_Paperclip : 2
         * 	e_Tag : 3
         * 	e_Unknown : 4
         * }
         * </pre>
         * icon style.
         */
        setIcon(type?: number): Promise<void>;
        /**
         * Returns the name of the icon associated with the FileAttachment annotation.
         * @returns A promise that resolves to a string denoting the name of the icon.
         */
        getIconName(): Promise<string>;
        /**
         * sets the name of the icon associated with the FileAttachment annotation.
         * (Optional)
         * @param iname - A string.denoting the name of the icon.
         * Note: this method should be used to assign non-standard icon type to the annotation.
         */
        setIconName(iname: string): Promise<void>;
    }
    /**
     * FileSpec corresponds to the PDF file specification object.
     *
     * A PDF file can refer to the contents of another file by using a file specification,
     * which can take either of the following forms:
     *
     * - A simple file specification gives just the name of the target file in
     *   a standard format, independent of the naming conventions of any particular file system.
     *
     * - A full file specification includes information related to one or more specific file
     *   systems.
     *
     * - A URL reference.
     *
     * Although the file designated by a file specification is normally external to the
     * PDF file referring to it, it is also possible to embed the file allowing its contents
     * to be stored or transmitted along with the PDF file. However, embedding a file does not
     * change the presumption that it is external to (or separate from) the PDF file.
     *
     * For more details on file specifications, please refer to Section 3.10, 'File Specifications'
     * in the PDF Reference Manual.
     */
    class FileSpec {
        /**
         * Creates a file specification for the given file. By default, the specified
         * file is embedded in PDF.
         * @param doc - A document to which the FileSpec should be added. To obtain
         * SDFDoc from PDFDoc use PDFDoc::GetSDFDoc() or Obj::GetDoc().
         * @param path - The path to convert into a file specification.
         * @param [embed] - A flag indicating whether to embed specified in the PDF.
         * By default, all files are embedded.
         * @returns A promise that resolves to newly created FileSpec object.
         */
        static create(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, path: string, embed?: boolean): Promise<PDFNet.FileSpec>;
        /**
         * Creates a URL file specification.
         * @param doc - A document to which the FileSpec should be added. To obtain
         * SDFDoc from PDFDoc use PDFDoc::GetSDFDoc() or Obj::GetDoc().
         * @param url - A uniform resource locator (URL) of the form defined in
         * Internet RFC 1738, Uniform Resource Locators Specification.
         * @returns A promise that resolves to newly created FileSpec object.
         */
        static createURL(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, url: string): Promise<PDFNet.FileSpec>;
        /**
         * Create a FileSpec and initialize it using given Cos/SDF object.
         * Note: The constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @returns A promise that resolves to an object of type: "PDFNet.FileSpec"
         */
        static createFromObj(f: PDFNet.Obj): Promise<PDFNet.FileSpec>;
        /**
         * Copy Constructor
         * @returns A promise that resolves to an object of type: "PDFNet.FileSpec"
         */
        copy(): Promise<PDFNet.FileSpec>;
        /**
         * Compares two FileSpec-s for equality. The comparison will return true
         * only if both annotations share the same underlying SDF/Cos object.
         * @returns A promise that resolves to an object of type: "boolean"
         */
        compare(d: PDFNet.FileSpec): Promise<boolean>;
        /**
         * @returns A promise that resolves to whether this is a valid (non-null) FileSpec. If the
         * function returns false the underlying SDF/Cos object is null or is not valid
         * and the FileSpec object should be treated as null as well.
         */
        isValid(): Promise<boolean>;
        /**
         * The function saves the data referenced by this FileSpec to an external file.
         * @param [save_as] - An optional parameter indicating the filepath and filename
         * where the data should be saved. If this parameter is not specified, the function
         * will attempt to save the file using FileSpec.GetFilePath().
         *
         * If the file is embedded, the function saves the embedded file.
         * If the file is not embedded, the function will copy the external file.
         * If the file is not embedded and the external file can't be found, the function
         * returns false.
         * @returns A promise that resolves to true is the file was saved successfully, false otherwise.
         */
        export(save_as?: string): Promise<boolean>;
        /**
         * The function returns data referenced by this FileSpec.
         * @returns A promise that resolves to a stream (filter) containing file data.
         * If the file is embedded, the function returns a stream to the embedded file.
         * If the file is not embedded, the function will return a stream to the external file.
         * If the file is not embedded and the external file can't be found, the function
         * returns NULL.
         */
        getFileData(): Promise<PDFNet.Filter>;
        /**
         * @returns A promise that resolves to the file path for this file specification.
         *
         * If the FileSpec is a dictionary, a corresponding platform specific path
         * is returned (DOS, Mac, or Unix). Otherwise the function returns the path represented
         * in the form described in Section 3.10.1, 'File Specification Strings,' or , if the
         * file system is URL, as a uniform resource locator (URL). If the FileSpec is not
         * valid, an empty string is returned.
         */
        getFilePath(): Promise<string>;
        /**
         * the functions sets the descriptive text associated with the file specification.
         * This test is typically used in the EmbeddedFiles name tree.
         */
        setDesc(desc: string): Promise<void>;
        /**
         * @returns A promise that resolves to the underlying SDF/Cos object.
         */
        getSDFObj(): Promise<PDFNet.Obj>;
    }
    /**
     * Provides a generic view of a sequence of bytes.
     *
     * A Filter is the abstract base class of all filters. A filter is an abstraction of
     * a sequence of bytes, such as a file, an input/output device, an inter-process communication
     * pipe, or a TCP/IP socket. The Filter class and its derived classes provide a generic view
     * of these different types of input and output, isolating the programmer from the specific
     * details of the operating system and the underlying devices.
     *
     * Besides providing access to input/output sources Filters can be also to transform the data
     * (e.g. to compress the data stream, to normalize the image data, to encrypt data, etc).
     * Filters can also be attached to each other to form pipelines. For example, a filter used to
     * open an image data file can be attached to a filter that decompresses the data, which is
     * attached to another filter that will normalize the image data.
     *
     * Depending on the underlying data source or repository, filters might support only some of
     * these capabilities. An application can query a stream for its capabilities by using the
     * IsInputFilter() and CanSeek() properties.
     *
     * Note: To read or write data to a filter, a user will typically use FilterReader/FilterWriter class.
     * instead of using Filter methods
     *
     * For example:
     * <pre>
     * StdFile file("my_stream.txt", StdFile::e_read_mode);
     * FilterReader reader(file);
     * while (reader.Read(..)) ...
     * </pre>
     */
    class Filter extends PDFNet.Destroyable {
        /**
         * @returns A promise that resolves to an object of type: "PDFNet.Filter"
         */
        createASCII85Encode(line_width: number, buf_sz: number): Promise<PDFNet.Filter>;
        /**
         * @returns A promise that resolves to an object of type: "PDFNet.Filter"
         */
        static createMemoryFilter(buf_sz: number, is_input: boolean): Promise<PDFNet.Filter>;
        /**
         * @returns A promise that resolves to an object of type: "PDFNet.Filter"
         */
        static createImage2RGBFromElement(elem: PDFNet.Element): Promise<PDFNet.Filter>;
        /**
         * @returns A promise that resolves to an object of type: "PDFNet.Filter"
         */
        static createImage2RGBFromObj(obj: PDFNet.Obj): Promise<PDFNet.Filter>;
        /**
         * @returns A promise that resolves to an object of type: "PDFNet.Filter"
         */
        static createImage2RGB(img: PDFNet.Image): Promise<PDFNet.Filter>;
        /**
         * @returns A promise that resolves to an object of type: "PDFNet.Filter"
         */
        static createImage2RGBAFromElement(elem: PDFNet.Element, premultiply: boolean): Promise<PDFNet.Filter>;
        /**
         * @returns A promise that resolves to an object of type: "PDFNet.Filter"
         */
        static createImage2RGBAFromObj(obj: PDFNet.Obj, premultiply: boolean): Promise<PDFNet.Filter>;
        /**
         * @returns A promise that resolves to an object of type: "PDFNet.Filter"
         */
        static createImage2RGBA(img: PDFNet.Image, premultiply: boolean): Promise<PDFNet.Filter>;
        attachFilter(attach_filter: PDFNet.Filter): Promise<void>;
        /**
         * Release the ownership of the attached filter. After the attached filter is
         * released this filter points to NULL filter.
         * @returns A promise that resolves to Previously attached filter.
         */
        releaseAttachedFilter(): Promise<PDFNet.Filter>;
        /**
         * @returns A promise that resolves to returns attached Filter or a NULL filter if no filter is attached.
         */
        getAttachedFilter(): Promise<PDFNet.Filter>;
        /**
         * @returns A promise that resolves to returns the first filter in the chain (usually a file filter)
         */
        getSourceFilter(): Promise<PDFNet.Filter>;
        /**
         * @returns A promise that resolves to descriptive name of the filter.
         */
        getName(): Promise<string>;
        /**
         * @returns A promise that resolves to string representing the name of corresponding decode filter as
         * it should appear in document (e.g. both ASCIIHexDecode and ASCIIHexEncode
         * should return ASCIIHexDecode).
         */
        getDecodeName(): Promise<string>;
        /**
         * @returns A promise that resolves to beginning of the buffer of Size() bytes that can be used to
         * read or write data.
         */
        begin(): Promise<number>;
        /**
         * @returns A promise that resolves to the size of buffer returned by Begin(). If the Size() returns 0
         * end of data has been reached.
         */
        size(): Promise<number>;
        /**
         * Moves the Begin() pointer num_bytes forward.
         * @param num_bytes - number of bytes to consume. num_bytes must be less than or
         * equal to Size().
         */
        consume(num_bytes: number): Promise<void>;
        /**
         * @returns A promise that resolves to the number of bytes consumed since opening the filter or
         *   the last Seek operation
         */
        count(): Promise<number>;
        /**
         * Sets a new counting point for the current filter. All subsequent Consume()
         * operations will increment this counter.
         *
         * Make sure that the output filter is flushed before using SetCount().
         * @param new_count - number to set the counting point of the filter to.
         * @returns A promise that resolves to the value of previous counter
         */
        setCount(new_count: number): Promise<number>;
        /**
         * The functions specifies the length of the data stream. The default
         * implementation doesn't do anything. For some derived filters such
         * as file segment filter it may be useful to override this function
         * in order to limit the stream length.
         * @param bytes - the length of stream in bytes
         */
        setStreamLength(bytes: number): Promise<void>;
        /**
         * Forces any data remaining in the buffer to be written to input or
         * output filter.
         */
        flush(): Promise<void>;
        /**
         * Forces any data remaining in the filter chain to the source or destination.
         */
        flushAll(): Promise<void>;
        /**
         * @returns A promise that resolves to boolean indicating whether this is an input filter.
         */
        isInputFilter(): Promise<boolean>;
        /**
         * @returns A promise that resolves to true if the stream supports seeking; otherwise, false.
         * default is to return false.
         */
        canSeek(): Promise<boolean>;
        /**
         * When overridden in a derived class, sets the position within the current stream.
         * @param offset - A byte offset relative to origin. If offset is negative,
         *  the new position will precede the position specified by origin by the number
         *  of bytes specified by offset. If offset is zero, the new position will be the
         *  position specified by origin. If offset is positive, the new position will follow
         *  the position specified by origin by the number of bytes specified by offset.
         * @param origin - <pre>
         * PDFNet.Filter.ReferencePos = {
         * 	e_begin : 0
         * 	e_end : 2
         * 	e_cur : 1
         * }
         * </pre>
         * A value of type ReferencePos indicating the reference point used
         * to obtain the new position
         *
         * Note: After each Seek() operation the number of consumed bytes (i.e.
         * Count()) is set to 0.
         */
        seek(offset: number, origin: number): Promise<void>;
        /**
         * Reports the current read position in the stream relative to the stream origin.
         * @returns A promise that resolves to The current position in the stream
         */
        tell(): Promise<number>;
        /**
         * Create Filter iterator. Filter iterator similar to a regular filter. However,
         * there can be only one owner of the attached filter.
         *
         * Note: Derived classes should make sure that there is only one owner of the
         *   attached stream. Otherwise the attached stream may be deleted several times.
         * @returns A promise that resolves to an object of type: "PDFNet.Filter"
         */
        createInputIterator(): Promise<PDFNet.Filter>;
        /**
         * @returns A promise that resolves to the file path to the underlying file stream.
         * Default implementation returns empty string.
         */
        getFilePath(): Promise<string>;
        /**
         * Note: MemoryFilter specific function.
         * @returns A promise that resolves to a pointer to the beginning of the buffer. Use method Count() to
         * determine the number of bytes written to or read from MemoryFilter.
         */
        memoryFilterGetBuffer(): Promise<number>;
        /**
         * Note: MemoryFilter specific function used to change filter mode from output to input.
         * The utility function is useful in cases when and output data buffer should be
         * converted to an input stream.
         *
         * Note: The function has no effect on an input MemoryFilter.
         */
        memoryFilterSetAsInputFilter(): Promise<void>;
        memoryFilterReset(): Promise<void>;
        /**
         * @param buf - A memory buffer containing the underlying data.
         * @returns A promise that resolves to a "Filter" created from the buffer
         */
        static createFromMemory(buf: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray): Promise<PDFNet.Filter>;
        /**
         * @param url - A url from which the data can be downloaded.
         * @param [options] - Additional options
         * @param options.withCredentials - Whether to set the withCredentials property on the XMLHttpRequest
         * @param options.customHeaders - An object containing custom HTTP headers to be used when downloading the document
         * @returns A promise that resolves to a "Filter" created from the url
         */
        static createURLFilter(url: string, options?: {
            withCredentials: boolean;
            customHeaders: any;
        }): Promise<PDFNet.Filter>;
        /**
         * Constructor for Flate encoder.
        FlateEncode filter can be used to compress any data stream
        using Flate (i.e. ZIP) compression method.
         * @param [input_filter = PDFNet.Filter("0")] - the input data stream
         * @param [compression_level = -1] - compression_level must be a number between 0 and 9: 1 gives best speed,
        9 gives best compression, 0 gives no compression at all (the input data is simply
        copied a block at a time), -1 requests a default compromise between speed
        and compression (currently equivalent to level 6).
         * @param [buf_sz = 256] - filter buffer size (in bytes).
         * @returns A promise that resolves to an object of type: "Filter" (generated documentation)
         */
        static createFlateEncode(input_filter?: PDFNet.Filter, compression_level?: number, buf_sz?: number): Promise<PDFNet.Filter>;
    }
    /**
     * FilterReader is a utility class providing a convenient way to read data
     * from an input filter (using Filter directly is not very intuitive).
     *
     * For example:
     * <pre>
     * StdFile file("my_stream.txt", StdFile::e_read_mode);
     * FilterReader reader(file);
     * while (reader.Read(...)) ...
     * </pre>
     */
    class FilterReader extends PDFNet.Destroyable {
        /**
         * Creates a new filter reader object
         * @returns A promise that resolves to an object of type: "PDFNet.FilterReader"
         */
        static create(filter: PDFNet.Filter): Promise<PDFNet.FilterReader>;
        /**
         * Attaches a filter to the this FilterReader.
         * @param filter - filter object to attach
         */
        attachFilter(filter: PDFNet.Filter): Promise<void>;
        /**
         * @returns A promise that resolves to The attached Filter or a NULL filter if no filter is attached.
         */
        getAttachedFilter(): Promise<PDFNet.Filter>;
        /**
         * Sets the position within the current stream.
         * @param offset - A byte offset relative to origin. If offset is negative,
         *  the new position will precede the position specified by origin by the number
         *  of bytes specified by offset. If offset is zero, the new position will be the
         *  position specified by origin. If offset is positive, the new position will follow
         *  the position specified by origin by the number of bytes specified by offset.
         * @param origin - <pre>
         * PDFNet.Filter.ReferencePos = {
         * 	e_begin : 0
         * 	e_end : 2
         * 	e_cur : 1
         * }
         * </pre>
         * A value of type ReferencePos indicating the reference point used
         * to obtain the new position
         *
         * Note: After each Seek() operation the number of consumed bytes (i.e. Count()) is set to 0.
         */
        seek(offset: number, origin: number): Promise<void>;
        /**
         * Reports the current read position in the stream relative to the stream origin.
         * @returns A promise that resolves to The current position in the stream
         */
        tell(): Promise<number>;
        /**
         * @returns A promise that resolves to the number of bytes consumed since opening the filter or
         * since the last Seek operation.
         */
        count(): Promise<number>;
        /**
         * Forces any data remaining in the buffer to be written to input or output filter.
         */
        flush(): Promise<void>;
        /**
         * Forces any data remaining in the filter chain to the source or destination.
         */
        flushAll(): Promise<void>;
        /**
         * @returns A promise that resolves to the next character from the stream or EOF (-1) if the end of file is reached.
         */
        get(): Promise<number>;
        /**
         * @returns A promise that resolves to the next character without extracting it from the stream or
         * 			 or EOF (-1) if the end of file is reached.
         */
        peek(): Promise<number>;
        /**
         * Read data from the attached filter
         * @param buf_size - The maximum amount to read
         * @returns A promise that resolves to a Uint8Array containing the data that was read.
                    the promise will resolve to null if no data was remaining.
         */
        read(buf_size: number): Promise<Uint8Array>;
        /**
         * Read all the remaining data to a buffer from the attached filter
         * @returns A promise that resolves to a Uint8Array containing the data that was read.
                    the promise will resolve to null if no data was remaining.
         */
        readAllIntoBuffer(): Promise<Uint8Array>;
    }
    /**
     * FilterWriter is a utility class providing a convenient way to write data
     * to an output filter (using Filter directly is not very intuitive).
     *
     * For example:
     * <pre>
     * StdFile outfile("file.dat", StdFile::e_write_mode);
     * FilterWriter fwriter(outfile);
     * fwriter.WriteBuffer(buf, buf_sz);
     * fwriter.Flush();
     * </pre>
     */
    class FilterWriter extends PDFNet.Destroyable {
        /**
         * Constructor
         * @returns A promise that resolves to an object of type: "PDFNet.FilterWriter"
         */
        static create(filter: PDFNet.Filter): Promise<PDFNet.FilterWriter>;
        /**
         * Attaches a filter to the this FilterWriter.
         * @param filter - filter object to attach
         */
        attachFilter(filter: PDFNet.Filter): Promise<void>;
        /**
         * @returns A promise that resolves to The attached Filter or a NULL filter if no filter is attached.
         */
        getAttachedFilter(): Promise<PDFNet.Filter>;
        /**
         * Sets the position within the current stream.
         * @param offset - A byte offset relative to origin. If offset is negative,
         *  the new position will precede the position specified by origin by the number
         *  of bytes specified by offset. If offset is zero, the new position will be the
         *  position specified by origin. If offset is positive, the new position will follow
         *  the position specified by origin by the number of bytes specified by offset.
         * @param origin - <pre>
         * PDFNet.Filter.ReferencePos = {
         * 	e_begin : 0
         * 	e_end : 2
         * 	e_cur : 1
         * }
         * </pre>
         * A value of type ReferencePos indicating the reference point used
         * to obtain the new position
         *
         * Note: After each Seek() operation the number of consumed bytes (i.e. Count()) is set to 0.
         */
        seek(offset: number, origin: number): Promise<void>;
        /**
         * Reports the current read position in the stream relative to the stream origin.
         * @returns A promise that resolves to The current position in the stream
         */
        tell(): Promise<number>;
        /**
         * @returns A promise that resolves to the number of bytes consumed since opening the filter or
         * since the last Seek operation.
         */
        count(): Promise<number>;
        /**
         * Forces any data remaining in the buffer to be written to input or output filter.
         */
        flush(): Promise<void>;
        /**
         * Forces any data remaining in the filter chain to the source or destination.
         */
        flushAll(): Promise<void>;
        /**
         * Write a single character to the output stream.
         * @param ch - An unsigned character to write to the output stream.
         */
        writeUChar(ch: number): Promise<void>;
        /**
         * Write an integer to the output stream.
         * @param num - An integer to write to the output stream.
         */
        writeInt16(num: number): Promise<void>;
        /**
         * Write an integer to the output stream.
         * @param num - An integer to write to the output stream.
         */
        writeUInt16(num: number): Promise<void>;
        /**
         * Write an integer to the output stream.
         * @param num - An integer to write to the output stream.
         */
        writeInt32(num: number): Promise<void>;
        /**
         * Write an integer to the output stream.
         * @param num - An integer to write to the output stream.
         */
        writeUInt32(num: number): Promise<void>;
        /**
         * Write an integer to the output stream.
         * @param num - An integer to write to the output stream.
         */
        writeInt64(num: number): Promise<void>;
        /**
         * Write an integer to the output stream.
         * @param num - An integer to write to the output stream.
         */
        writeUInt64(num: number): Promise<void>;
        /**
         * Write a string to the output stream.
         * @param str - A string to write to the output stream.
         */
        writeString(str: string): Promise<void>;
        /**
         * Write the entire input stream to the output stream (i.e. to this FilterWriter).
         * @param reader - A FilterReader attached to an input stream.
         */
        writeFilter(reader: PDFNet.FilterReader): Promise<void>;
        /**
         * Write out a null terminated 'line' followed by a end of line character
         * default end of line character is carriage return.
         * @param line - string to write out.
         * @param [eol] - end of line character. Defaults to carriage return (0x0D).
         */
        writeLine(line: string, eol?: number): Promise<void>;
        /**
         * @param buf - buffer object to write out.
         * @returns A promise that resolves to returns the number of bytes actually written to a stream. This number may
         *   less than buf_size if the stream is corrupted.
         */
        writeBuffer(buf: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray): Promise<number>;
    }
    /**
     * Flattener is a optional PDFNet add-on that can be used to simplify and optimize
     * existing PDF's to render faster on devices with lower memory and speeds.
     *
     * PDF documents can frequently contain very complex page description (e.g.
     * thousands of paths, different shadings, color spaces, blend modes, large images
     * etc.) that may not be suitable for interactive viewing on mobile devices.
     * Flattener can be used to speed-up PDF rendering on mobile devices and on the Web
     * by simplifying page content (e.g. flattening complex graphics into images) while
     * maintaining vector text whenever possible.
     *
     * By using the FlattenMode::e_simple option each page in the PDF will be
     * reduced to a single background image, with the remaining text over top in vector
     * format. Some text may still get flattened, in particular any text that is clipped,
     * or underneath, other content that will be flattened.
     *
     * On the other hand the FlattenMode::e_fast will not flatten simple content, such
     * as simple straight lines, nor will it flatten Type3 fonts.
     *
     * Note: 'Flattener' is available as a separately licensable add-on to PDFNet
     * core license.
     *
     * Note: See 'pdftron.PDF.Optimizer' for alternate approach to optimize PDFs with
     * focus on file size reduction.
     */
    class Flattener extends PDFNet.Destroyable {
        /**
         * Flattener constructor
         * @returns A promise that resolves to an object of type: "PDFNet.Flattener"
         */
        static create(): Promise<PDFNet.Flattener>;
        /**
         * The output resolution, from 1 to 1000, in Dots Per Inch (DPI) at which to
         * render elements which cannot be directly converted.
         * the default value is 150 Dots Per Inch
         * @param dpi - the resolution in Dots Per Inch
         */
        setDPI(dpi: number): Promise<void>;
        /**
         * Used to control how precise or relaxed text flattening is. When some text is
         * preserved (not flattened to image) the visual appearance of the document may be altered.
         * @param threshold - <pre>
         * PDFNet.Flattener.Threshold = {
         * 	e_very_strict : 0
         * 	e_strict : 1
         * 	e_default : 2
         * 	e_keep_most : 3
         * 	e_keep_all : 4
         * }
         * </pre>
         * the threshold setting to use.
         */
        setThreshold(threshold: number): Promise<void>;
        /**
         * Specifies the maximum image size in pixels.
         * @param max_pixels - the maximum number of pixels an image can have.
         */
        setMaximumImagePixels(max_pixels: number): Promise<void>;
        /**
         * Specifies whether to leave images in existing compression, or as JPEG.
         * @param jpg - if true PDF will contain all JPEG images.
         */
        setPreferJPG(jpg: boolean): Promise<void>;
        /**
         * Specifies the compression quality to use when generating JPEG images.
         * @param quality - the JPEG compression quality, from 0(highest compression) to 100(best quality).
         */
        setJPGQuality(quality: number): Promise<void>;
        /**
         * Enable or disable path hinting.
         * @param hinting - if true path hinting is enabled. Path hinting is used to slightly
         * adjust paths in order to avoid or alleviate artifacts of hair line cracks between
         * certain graphical elements. This option is turned on by default.
         */
        setPathHinting(hinting: boolean): Promise<void>;
        /**
         * Process each page in the PDF, flattening content that matches the mode criteria.
         * @param doc - the document to flatten.
         * @param mode - <pre>
         * PDFNet.Flattener.Mode = {
         * 	e_simple : 0
         * 	e_fast : 1
         * }
         * </pre>
         * indicates the criteria for which elements are flattened.
         */
        process(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, mode: number): Promise<void>;
        /**
         * Process the given page, flattening content that matches the mode criteria.
         * @param page - the page to flatten.
         * @param mode - <pre>
         * PDFNet.Flattener.Mode = {
         * 	e_simple : 0
         * 	e_fast : 1
         * }
         * </pre>
         * indicates the criteria for which elements are flattened.
         */
        processPage(page: PDFNet.Page, mode: number): Promise<void>;
    }
    /**
     * A font that is used to draw text on a page. It corresponds to a Font Resource
     * in a PDF file. More than one page may reference the same Font object.
     * A Font has a number of attributes, including an array of widths, the character
     * encoding, and the font's resource name.
     *
     * PDF document can contain several different types of fonts and Font class
     * represents a single, flat interface around all PDF font types.
     *
     * There are two main classes of fonts in PDF: simple and composite fonts.
     *
     * Simple fonts are Type1, TrueType, and Type3 fonts. All simple fonts have the
     * following properties:<BR><BR>
     *  - Glyphs in the font are selected by single-byte character codes
     *    obtained from a string that is shown by the text-showing operators.
     *    Logically, these codes index into a table of 256 glyphs; the mapping
     *    from codes to glyphs is called the font's encoding. Each font program
     *    has a built-in encoding. Under some circumstances, the encoding can
     *    be altered by means described in Section 5.5.5 "Character Encoding" in
     *    PDF Reference Manual.<BR><BR>
     *
     *  - Each glyph has a single set of metrics. Therefore simple fonts support
     *    only horizontal writing mode.<BR><BR>
     *
     * A composite font is one whose glyphs are obtained from a font like object
     * called a CIDFont (e.g. CIDType0Font and CIDType0Font). A composite font is
     * represented by a font dictionary whose Subtype value is Type0. The Type 0 font
     * is known as the root font, while its associated CIDFont is called its descendant.
     * CID-keyed fonts provide a convenient and efficient method for defining
     * multiple-byte character encodings and fonts with a large number of glyphs.
     * These capabilities provide great flexibility for representing text in writing
     * systems for languages with large character sets, such as Chinese, Japanese,
     * and Korean (CJK).
     */
    class Font extends PDFNet.Destroyable {
        /**
         * create a PDF::Font object from an existing SDF font object that is embedded
         * in the document. If font_dict is null, a non valid font is created.
         * @param [font_dict] - The Cos/SDF object to create the Font object with.
         * @returns A promise that resolves to an object of type: "PDFNet.Font"
         */
        static createFromObj(font_dict?: PDFNet.Obj): Promise<PDFNet.Font>;
        /**
         * Constructor
         * @param doc - Document on which to create the font on.
         * @param type - <pre>
         * PDFNet.Font.StandardType1Font = {
         * 	e_times_roman : 0
         * 	e_times_bold : 1
         * 	e_times_italic : 2
         * 	e_times_bold_italic : 3
         * 	e_helvetica : 4
         * 	e_helvetica_bold : 5
         * 	e_helvetica_oblique : 6
         * 	e_helvetica_bold_oblique : 7
         * 	e_courier : 8
         * 	e_courier_bold : 9
         * 	e_courier_oblique : 10
         * 	e_courier_bold_oblique : 11
         * 	e_symbol : 12
         * 	e_zapf_dingbats : 13
         * 	e_null : 14
         * }
         * </pre>
         * The type of font to create.
         * <pre>
         * PDFNet.Font.StandardType1Font = {
         * 	e_times_roman : 0
         * 	e_times_bold : 1
         * 	e_times_italic : 2
         * 	e_times_bold_italic : 3
         * 	e_helvetica : 4
         * 	e_helvetica_bold : 5
         * 	e_helvetica_oblique : 6
         * 	e_helvetica_bold_oblique : 7
         * 	e_courier : 8
         * 	e_courier_bold : 9
         * 	e_courier_oblique : 10
         * 	e_courier_bold_oblique : 11
         * 	e_symbol : 12
         * 	e_zapf_dingbats : 13
         * 	e_null : 14
         * }
         * </pre>
         * @returns A promise that resolves to an object of type: "Font" (generated documentation)
         */
        static create(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, type: number): Promise<PDFNet.Font>;
        /**
         * Create a new Unicode font based on the description of an existing PDF font.
         * @param doc - document in which the external font should be embedded.
         * @param from - A Font object that provides the name for choosing a font. If the
         * font with that name can be located and it covers a sufficient character set
         * characters from that font will be used. Otherwise the font object created will
         * be from a another font that covers the character set.
         * @param char_set - An initial character set. This provides an approach to specify
         * any characters that are required to be included in the final font as part of a
         * string. Note that additional characters will be added to the character set as
         * needed, so it is not required to specify them here. (empty string is a perfectly
         * valid and common value for this argument)
         * @returns A promise that resolves to an object of type: "PDFNet.Font"
         */
        static createFromFontDescriptor(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, from: PDFNet.Font, char_set: string): Promise<PDFNet.Font>;
        /**
         * Create a new Unicode font based on the description of an existing PDF font.
         * @param doc - document in which the external font should be embedded.
         * @param name - A font name that provides a hint when choosing a font. If the font
         * with that name can be located and it covers a sufficient character set characters
         * from that font will be used. Otherwise the font object created will be from a
         * another font that covers the character set.
         * @param char_set - An initial character set. This provides an approach to specify
         * any characters that are required to be included in the final font as part of a
         * string. Note that additional characters will be added to the character set as
         * needed, so it is not required to specify them here. (empty string is a perfectly
         * valid and common value for this argument)
         * @returns A promise that resolves to an object of type: "PDFNet.Font"
         */
        static createFromName(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, name: string, char_set: string): Promise<PDFNet.Font>;
        /**
         * @param type - <pre>
         * PDFNet.Font.StandardType1Font = {
         * 	e_times_roman : 0
         * 	e_times_bold : 1
         * 	e_times_italic : 2
         * 	e_times_bold_italic : 3
         * 	e_helvetica : 4
         * 	e_helvetica_bold : 5
         * 	e_helvetica_oblique : 6
         * 	e_helvetica_bold_oblique : 7
         * 	e_courier : 8
         * 	e_courier_bold : 9
         * 	e_courier_oblique : 10
         * 	e_courier_bold_oblique : 11
         * 	e_symbol : 12
         * 	e_zapf_dingbats : 13
         * 	e_null : 14
         * }
         * </pre>
         * @returns A promise that resolves to an object of type: "PDFNet.Font"
         */
        static createAndEmbed(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, type: number): Promise<PDFNet.Font>;
        /**
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.Font.Type = {
         * 	e_Type1 : 0
         * 	e_TrueType : 1
         * 	e_MMType1 : 2
         * 	e_Type3 : 3
         * 	e_Type0 : 4
         * 	e_CIDType0 : 5
         * 	e_CIDType2 : 6
         * }
         * </pre>
         * @returns A promise that resolves to font Type
         */
        getType(): Promise<number>;
        /**
         * @returns A promise that resolves to true for non-CID based fonts such as Type1, TrueType, and Type3
         *
         * All simple fonts have the following properties:<BR><BR>
         *
         * Glyphs in the font are selected by single-byte character codes
         *   obtained from a string that is shown by the text-showing operators.
         *   Logically, these codes index into a table of 256 glyphs; the mapping
         *   from codes to glyphs is called the font's encoding. Each font program
         *   has a built-in encoding. Under some circumstances, the encoding can
         *   be altered by means described in Section 5.5.5 "Character Encoding" in
         *   PDF Reference Manual.<BR><BR>
         *
         * Each glyph has a single set of metrics. Therefore simple fonts support
         *   only horizontal writing mode.<BR><BR>
         */
        isSimple(): Promise<boolean>;
        /**
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.Font.Type = {
         * 	e_Type1 : 0
         * 	e_TrueType : 1
         * 	e_MMType1 : 2
         * 	e_Type3 : 3
         * 	e_Type0 : 4
         * 	e_CIDType0 : 5
         * 	e_CIDType2 : 6
         * }
         * </pre>
         * @returns A promise that resolves to the type of a given SDF/Cos font dictionary
         */
        static getTypeFromObj(font_dict: PDFNet.Obj): Promise<number>;
        /**
         * @returns A promise that resolves to a SDF/Cos object of this Font.
         */
        getSDFObj(): Promise<PDFNet.Obj>;
        /**
         * @returns A promise that resolves to a SDF/Cos object representing FontDescriptor or NULL is FontDescriptor
         * is not present.
         */
        getDescriptor(): Promise<PDFNet.Obj>;
        /**
         * @returns A promise that resolves to the name of a font. The behavior depends on the font type;
         * for a Type 3 font it gets the value of the Name key in a PDF Font resource.
         * For other types it gets the value of the BaseFont key in a PDF font resource.
         */
        getName(): Promise<string>;
        /**
         * @returns A promise that resolves to the face's family name. This is an ASCII string, usually in English,
         * which describes the typeface's family (like 'Times New Roman', 'Bodoni', 'Garamond',
         * etc). This is a least common denominator used to list fonts.
         */
        getFamilyName(): Promise<string>;
        /**
         * @returns A promise that resolves to true if all glyphs have the same width
         */
        isFixedWidth(): Promise<boolean>;
        /**
         * @returns A promise that resolves to true if glyphs have serifs
         */
        isSerif(): Promise<boolean>;
        /**
         * @returns A promise that resolves to true if font contains characters outside the Adobe standard Latin character set.
         */
        isSymbolic(): Promise<boolean>;
        /**
         * @returns A promise that resolves to true if glyphs have dominant vertical strokes that are slanted.
         */
        isItalic(): Promise<boolean>;
        /**
         * @returns A promise that resolves to true if font contains no lowercase letters
         */
        isAllCap(): Promise<boolean>;
        /**
         * @returns A promise that resolves to true if bold glyphs should be painted with extra pixels at very small text sizes.
         */
        isForceBold(): Promise<boolean>;
        /**
         * @returns A promise that resolves to true if the font uses horizontal writing mode, false for vertical writing mode.
         */
        isHorizontalMode(): Promise<boolean>;
        /**
         * @returns A promise that resolves to advance width, measured in glyph space units for the glyph
         * matching given character code.
         *
         * Note: 1000 glyph units = 1 text space unit
         * Note: The width returned has NOT been scaled by the font size, text matrix,
         * 		 nor the CTM.
         *
         * The function gets the advance width of the font glyph. The advance width
         * is the amount by which the current point advances when the glyph is drawn.
         * The advance width may not correspond to the visible width of the glyph
         * and for this reason, the advance width cannot be used to determine the glyphs'
         * bounding boxes.
         */
        getWidth(char_code: number): Promise<number>;
        /**
         * @returns A promise that resolves to the maximal advance width, in font units, for all glyphs in this face.
         */
        getMaxWidth(): Promise<number>;
        /**
         * @returns A promise that resolves to the default width to use for character codes whose widths are
         * not specified in a font dictionary's Widths array.
         */
        getMissingWidth(): Promise<number>;
        /**
         * GetCharCodeIterator represents an iterator interface used to traverse
         * a list of char codes for which there is a glyph outline in the embedded font.
         * @returns A promise that resolves to an object of type: "PDFNet.Iterator<number>"
         */
        getCharCodeIterator(): Promise<PDFNet.Iterator<number>>;
        /**
         * Creates a set of positioned glyphs corresponding to the visual representation
         * of the provided text string.
         *
         * The shaped text will take into  account any advanced positioning and
         * substitution features provided by an underylying embedded font file.
         * For example, these features could include kerning, ligatures, and diacritic
         * positioning. Typically the resulting shaped text would be fed into
         * ElementBuilder.CreateShapedTextRun()
         * @param text_to_shape - the string to be shaped.
         * @returns A promise that resolves to a ShapedText object representing the result of the shaping operation.
         *
         * Note: Shaping requires a Type0 font with an embedded font file which
         * covers all the unicode codepoints in the source text. For best results,
         * this font should use the e_Indices encoding scheme, as shaping features
         * that combine multiple codepoints into one glyph (ligatures, for example)
         * will not work well in non-index encoded fonts.
         */
        getShapedText(text_to_shape: string): Promise<PDFNet.ShapedText>;
        /**
         * @returns A promise that resolves to the font's encoding array (the mapping of character codes to glyphs).
         * The array contains 256 pointers. If a pointer is not NULL, it points to a
         * C string containing the name of the glyph for the code point corresponding
         * to the index. If it is NULL, then the name of the glyph is unchanged from
         * that specified by the font's built-in encoding.
         *
         * For a Type 3 font, all glyph names will be present in the encoding array,
         * and NULL entries correspond to un-encoded code points.
         *
         * Note: The Font object is the owner of the array.
         * Note: This function is not applicable to composite fonts (e_type0, e_CIDType0,
         * and e_CIDType2) and will throw an exception.
         */
        getEncoding(): Promise<string>;
        /**
         * Tests whether or not the specified font is stored as a font file in a stream
         * embedded in the PDF file.
         * @returns A promise that resolves to true if the font is embedded in the file, false otherwise.
         */
        isEmbedded(): Promise<boolean>;
        /**
         * @returns A promise that resolves to the PostScript font name for the embedded font. If the embedded font
         * name is not available the function returns the empty string .
         */
        getEmbeddedFontName(): Promise<string>;
        /**
         * @returns A promise that resolves to the stream object of the embedded font or NULL if there if the
         * font is not embedded.
         * Note: This function is not applicable to Type3 font and will throw exception.
         */
        getEmbeddedFont(): Promise<PDFNet.Obj>;
        /**
         * @returns A promise that resolves to the size of decoded buffer containing embedded font data or 0
         * if this information is not known in advance.
         *
         * Note: The size of decoded buffer may not be known in advance for all
         * fonts and may not be correct.
         * Note: This function is not applicable to Type3 font and will throw exception.
         */
        getEmbeddedFontBufSize(): Promise<number>;
        /**
         * @returns A promise that resolves to the number of font units per EM square for this face. This is
         * typically 2048 for TrueType fonts, 1000 for Type1 fonts
         *
         * Note: Only relevant for scalable formats (such as TrueType and Type1).
         *
         * Note: This function is not applicable to Type3 font and will throw an exception.
         * Use GetType3FontMatrix instead.
         */
        getUnitsPerEm(): Promise<number>;
        /**
         * @returns A promise that resolves to a rectangle expressed in the glyph coordinate system, specifying the
         * font bounding box. This is the smallest rectangle enclosing the shape that would
         * result if all of the glyphs of the font were placed with their origins coincident
         * and then filled.
         */
        getBBox(): Promise<PDFNet.Rect>;
        /**
         * The face's ascender is the vertical distance from the baseline to the topmost
         * point of any glyph in the face. This field's value is a positive number, expressed
         * in the glyph coordinate system. For all font types except Type 3, the units of
         * glyph space are one-thousandth of a unit of text space. Some font designs use
         * a value different from 'bbox.yMax'.
         *
         * Note: Only relevant for scalable formats.
         * @returns A promise that resolves to an object of type: "number"
         */
        getAscent(): Promise<number>;
        /**
         * The face's descender is the vertical distance from the baseline to the bottommost
         * point of any glyph in the face. This field's value is a negative number expressed
         * in the glyph coordinate system. For all font types except Type 3, the units of
         * glyph space are one-thousandth of a unit of text space. Some font designs use
         * a value different from 'bbox.yMin'.
         *
         * Note: Only relevant for scalable formats.
         * @returns A promise that resolves to an object of type: "number"
         */
        getDescent(): Promise<number>;
        /**
         * @returns A promise that resolves to font::e_null if the font is not a standard Type1 font or some
         * other StandardType1Font value for a standard Type1 font.
         */
        getStandardType1FontType(): Promise<number>;
        /**
         * @returns A promise that resolves to true if the embedded font is represented as CFF (Compact Font Format).
         * Note: Only Type1 and Type1C fonts can be represented in CFF format
         */
        isCFF(): Promise<boolean>;
        /**
         * @returns A promise that resolves to type3 font matrix, mapping glyph space to text space
         * A common practice is to define glyphs in terms of a 1000-unit
         * glyph coordinate system, in which case the font matrix is [0.001 0 0 0.001 0 0].
         *
         * Note: Relevant only for a Type3 font.
         */
        getType3FontMatrix(): Promise<PDFNet.Matrix2D>;
        /**
         * @returns A promise that resolves to a SDF/Cos glyph stream for the given char_code.
         * If specified char_code is not found in the CharProcs dictionary the
         * function returns NULL.
         *
         * Note: Relevant only for a Type3 font.
         */
        getType3GlyphStream(char_code: number): Promise<PDFNet.Obj>;
        /**
         * @param char_code - character to query for vertical advance
         * Note: Use this method only for composite fonts with vertical writing mode
         * (i.e. if Font.IsHorizontalMode() returns false). The method will return 0 as vertical
         * advance for simple fonts or for composite fonts with only horizontal writing mode.
         * Note: Relevant only for a Type0 font.
         * @returns A promise that resolves to vertical advance. vertical advance is a displacement vector for vertical
         * writing mode (i.e. writing mode 1); its horizontal component is always 0.
         */
        getVerticalAdvance(char_code: number): Promise<object>;
        /**
         * @returns A promise that resolves to descendant CIDFont.
         *
         * Note: Relevant only for a Type0 font.
         */
        getDescendant(): Promise<PDFNet.Font>;
        /**
         * @returns A promise that resolves to a CID matching specified charcode.
         *
         * Note: Relevant only for a Type0 font.
         */
        mapToCID(char_code: number): Promise<number>;
    }
    /**
     * A FreeText annotation (PDF 1.3) displays text directly on the page.
     * Unlike an ordinary Text annotation, a FreeText annotation has no
     * open or closed state; The content of the FreeText annotation is always
     * visible instead of being displayed in a popup window.
     */
    class FreeTextAnnot extends PDFNet.MarkupAnnot {
        /**
         * creates a FreeText annotation and initializes it using given Cos/SDF object.
         * @param [d] - The Cos/SDF object to initialze the annotation with.
         * Note: The constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @returns A promise that resolves to an object of type: "PDFNet.FreeTextAnnot"
         */
        static createFromObj(d?: PDFNet.Obj): Promise<PDFNet.FreeTextAnnot>;
        /**
         * creates a FreeText annotation and initializes it using given annotation object.
         * @param ann - Annot object used to initialize the FreeText annotation.
         * Note: The constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @returns A promise that resolves to an object of type: "PDFNet.FreeTextAnnot"
         */
        static createFromAnnot(ann: PDFNet.Annot): Promise<PDFNet.FreeTextAnnot>;
        /**
         * Creates a new FreeText annotation in the specified document.
         * @param doc - A document to which the FreeText annotation is added.
         * @param pos - A rectangle specifying the FreeText annotation's bounds in default user space units.
         * @returns A promise that resolves to a newly created blank FreeText annotation.
         */
        static create(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, pos: PDFNet.Rect): Promise<PDFNet.FreeTextAnnot>;
        static create(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, type: number, pos: PDFNet.Rect): Promise<PDFNet.Annot>;
        /**
         * Returns the default appearance of the FreeText annotation.
         * @returns A promise that resolves to a string representing the default appearance of the annotation.
         * Note: The default appearance string is used to format the text.
         * The annotation dictionary's Appearance entry, if present,
         * will take precedence over this entry.
         * Note: this method corresponds to the 'DA' entry in the annotation dictionary.
         */
        getDefaultAppearance(): Promise<string>;
        /**
         * sets the default appearance of the FreeText annotation.
         * @param app_str - A string representing the default appearance of the annotation.
         * Note: The default appearance string is used to format the text.
         * The annotation dictionary's Appearance entry, if present,
         * will take precedence over this entry.
         * Note: this method corresponds to the 'DA' entry in the annotation dictionary.
         */
        setDefaultAppearance(app_str: string): Promise<void>;
        /**
         * Returns the quading format of the FreeText annotation.
         * (PDF 1.4)
         * @returns A promise that resolves to a int (code) indicating the quading format of the FreeText annotation.
         * Note: The following are the quading formats corresponding to each int code.
         * 0 Left-justified
         * 1 Centered
         * 2 Right-justified
         */
        getQuaddingFormat(): Promise<number>;
        /**
         * Sets the quading format of the FreeText annotation.
         * (Optional; PDF 1.4)
         * @param format - A int code indicating the quading format of the FreeText annotation.
         * Default value: 0 (left-justified).
         * Note: The int code specifies the form of quadding (justification)
         * that shall be used in displaying the annotation's text:
         * 0 Left-justified
         * 1 Centered
         * 2 Right-justified
         */
        setQuaddingFormat(format: number): Promise<void>;
        /**
         * @returns A promise that resolves to an object of type: "Object"
         */
        getCalloutLinePoints(): Promise<object>;
        /**
         * sets the callout line points of the FreeText annotation.
         * (Optional; meaningful only if IT is FreeTextCallout; PDF 1.6)
         * @param p1 - The target point. (where the ending style is used)
         * @param p2 - The knee point.
         * @param p3 - The ending point.
         * Note: The coordinates are defined in default user space.
         */
        setCalloutLinePoints(p1: PDFNet.Point, p2: PDFNet.Point, p3: PDFNet.Point): Promise<void>;
        /**
         * sets the callout line points of the FreeText annotation.
         * (Optional; meaningful only if IT is FreeTextCallout; PDF 1.6)
         * @param p1 - The target point. (where the ending style is used)
         * @param p2 - The ending point.
         * Note: The coordinates are defined in default user space.
         */
        setCalloutLinePointsTwo(p1: PDFNet.Point, p2: PDFNet.Point): Promise<void>;
        /**
         * Returns Intent name of the FreeText annotation.
         * (PDF 1.4)
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.FreeTextAnnot.IntentName = {
         * 	e_FreeText : 0
         * 	e_FreeTextCallout : 1
         * 	e_FreeTextTypeWriter : 2
         * 	e_Unknown : 3
         * }
         * </pre>
         * @returns A promise that resolves to the intent name of the annotation as
         * an entry from the enum "IntentName".
         */
        getIntentName(): Promise<number>;
        /**
         * Sets the Intent name of the FreeText annotation.
         * (Optional; PDF 1.4)
         * @param [mode] - <pre>
         * PDFNet.FreeTextAnnot.IntentName = {
         * 	e_FreeText : 0
         * 	e_FreeTextCallout : 1
         * 	e_FreeTextTypeWriter : 2
         * 	e_Unknown : 3
         * }
         * </pre>
         * The intent name of the annotation as
         * an entry from the enum "IntentName".
         */
        setIntentName(mode?: number): Promise<void>;
        setIntentNameDefault(): Promise<void>;
        /**
         * Returns the ending style of the callout line of the FreeText Annotation.
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.LineAnnot.EndingStyle = {
         * 	e_Square : 0
         * 	e_Circle : 1
         * 	e_Diamond : 2
         * 	e_OpenArrow : 3
         * 	e_ClosedArrow : 4
         * 	e_Butt : 5
         * 	e_ROpenArrow : 6
         * 	e_RClosedArrow : 7
         * 	e_Slash : 8
         * 	e_None : 9
         * 	e_Unknown : 10
         * }
         * </pre>
         * @returns A promise that resolves to the ending style represented as one of the entries of the enum "EndingStyle"
         * Note: The ending style specifies the line ending style that
         * shall be used in drawing the callout line specified in CallOut Line Points
         * (CL). The enum entry shall specify the line ending style for the endpoint
         * defined by the target point(p1) of the CallOut Line Points.
         * Default value: e_None.
         */
        getEndingStyle(): Promise<number>;
        /**
         * Sets the ending style of the callout line of the FreeText Annotation.
         * (Optional; meaningful only if CL is present; PDF 1.6)
         * @param style - <pre>
         * PDFNet.LineAnnot.EndingStyle = {
         * 	e_Square : 0
         * 	e_Circle : 1
         * 	e_Diamond : 2
         * 	e_OpenArrow : 3
         * 	e_ClosedArrow : 4
         * 	e_Butt : 5
         * 	e_ROpenArrow : 6
         * 	e_RClosedArrow : 7
         * 	e_Slash : 8
         * 	e_None : 9
         * 	e_Unknown : 10
         * }
         * </pre>
         * The ending style represented using one of the
         * entries of the enum "EndingStyle"
         * Note: The ending style specifies the line ending style that
         * shall be used in drawing the callout line specified in CallOut Line Points
         * (CL). The enum entry shall specify the line ending style for the endpoint
         * defined by the target point(p1) of the CallOut Line Points.
         * Default value: e_None.
         */
        setEndingStyle(style: number): Promise<void>;
        /**
         * sets the ending style of the callout line of the FreeText Annotation.
         * (Optional; meaningful only if CL is present; PDF 1.6)
         * @param est - The ending style represented using a string.
         * Note: The ending style specifies the line ending style that
         * shall be used in drawing the callout line specified in CallOut Line Points
         * (CL). The enum entry shall specify the line ending style for the endpoint
         * defined by the target point(p1) of the CallOut Line Points.
         * Default value: "None".
         */
        setEndingStyleName(est: string): Promise<void>;
        /**
         * sets the text color of the FreeText Annotation.
         * @param color - ColorPt object representing the color.
         * @param col_comp - number of colorant components in ColorPt object.
         *
         * Note: Current implementation of this method creates a non-standard
         * entry in the annotation dictionary and uses it to generate the appearance
         * stream. Make sure you call RefreshAppearance() after changing text or
         * line color, and remember that editing the annotation in other PDF
         * applications will produce different appearance.
         */
        setTextColor(color: PDFNet.ColorPt, col_comp: number): Promise<void>;
        /**
         * returns the text color of the FreeText Annotation.
         *
         * Note: Current implementation of this method uses a non-standard
         * entry in the annotation dictionary and will not return meaningful
         * results when called on annotations not created with PDFTron software.
         * @returns A promise that resolves to an object of type: "Object"
         */
        getTextColor(): Promise<object>;
        /**
         * sets the line and border color of the FreeText Annotation.
         * @param color - ColorPt object representing the color.
         * @param col_comp - number of colorant components in ColorPt object.
         *
         * Note: Current implementation of this method creates a non-standard
         * entry in the annotation dictionary and uses it to generate the appearance
         * stream. Make sure you call RefreshAppearance() after changing text or
         * line color, and remember that editing the annotation in other PDF
         * applications will produce different appearance.
         */
        setLineColor(color: PDFNet.ColorPt, col_comp: number): Promise<void>;
        /**
         * @returns A promise that resolves to an object of type: "Object"
         */
        getLineColor(): Promise<object>;
        /**
         * Sets the default appearance font size. A value of zero specifies
         * that the font size should should adjust so that the text uses
         * as much of the FreeText bounding box as possible.
         * @param font_size - Set the default font size. A value of zero means
         * auto resize font.
         */
        setFontSize(font_size: number): Promise<void>;
        /**
         * Get the default appearance font size. To get the actual font
         * size used, call RefreshAppearance and then use ElementReader
         * on the content stream of this annotation.
         * @returns A promise that resolves to the default font size, where a value of zero indicates
         * auto sizing.
         */
        getFontSize(): Promise<number>;
    }
    /**
     * Although PDF is not a programming language it provides several types of function
     * object that represent parameterized classes of functions, including mathematical
     * formulas and sampled representations with arbitrary resolution. Functions are used
     * in various ways in PDF, including device-dependent rasterization information for
     * high-quality printing (halftone spot functions and transfer functions), color
     * transform functions for certain color spaces, and specification of colors as a
     * function of position for smooth shadings. Functions in PDF represent static,
     * self-contained numerical transformations.<br><br>
     *
     * PDF::Function represents a single, flat interface around all PDF function types.
     */
    class Function extends PDFNet.Destroyable {
        /**
         * create a PDF::Function object from an existing SDF function dictionary. If funct_dict
         * is null, a non valid Function object is created.
         * @returns A promise that resolves to an object of type: "PDFNet.Function"
         */
        static create(funct_dict?: PDFNet.Obj): Promise<PDFNet.Function>;
        /**
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.Function.Type = {
         * 	e_sampled : 0
         * 	e_exponential : 2
         * 	e_stitching : 3
         * 	e_postscript : 4
         * }
         * </pre>
         * @returns A promise that resolves to the function type
         */
        getType(): Promise<number>;
        /**
         * @returns A promise that resolves to the number of input components required by the function
         */
        getInputCardinality(): Promise<number>;
        /**
         * @returns A promise that resolves to the number of output components returned by the function
         */
        getOutputCardinality(): Promise<number>;
        eval(inval: number, outval: number): Promise<void>;
        /**
         * @returns A promise that resolves to the underlying SDF/Cos object
         */
        getSDFObj(): Promise<PDFNet.Obj>;
    }
    /**
     * GState is a class that keeps track of a number of style attributes used to visually
     * define graphical Elements. Each PDF::Element has an associated GState that can be used to
     * query or set various graphics properties.
     *
     * Note: current clipping path is not tracked in the graphics state for efficiency
     * reasons. In most cases tracking of the current clipping path is best left to the
     * client.
     */
    class GState {
        /**
         * @returns A promise that resolves to the transformation matrix for this element.
         * Note: If you are looking for a matrix that maps coordinates to the initial
         * user space see Element::GetCTM().
         */
        getTransform(): Promise<PDFNet.Matrix2D>;
        /**
         * @returns A promise that resolves to color space used for stroking
         */
        getStrokeColorSpace(): Promise<PDFNet.ColorSpace>;
        /**
         * @returns A promise that resolves to color space used for filling
         */
        getFillColorSpace(): Promise<PDFNet.ColorSpace>;
        /**
         * @returns A promise that resolves to a color value/point represented in the current stroke color space
         */
        getStrokeColor(): Promise<PDFNet.ColorPt>;
        /**
         * @returns A promise that resolves to the SDF pattern object of currently selected PatternColorSpace used for stroking.
         */
        getStrokePattern(): Promise<PDFNet.PatternColor>;
        /**
         * @returns A promise that resolves to a color value/point represented in the current fill color space
         */
        getFillColor(): Promise<PDFNet.ColorPt>;
        /**
         * @returns A promise that resolves to the pattern color of currently selected pattern color space used for filling.
         */
        getFillPattern(): Promise<PDFNet.PatternColor>;
        /**
         * @returns A promise that resolves to current value of flatness tolerance
         *
         * Flatness is a number in the range 0 to 100; a value of 0 specifies the output
         * device's default flatness tolerance.
         *
         * The flatness tolerance controls the maximum permitted distance in device pixels
         * between the mathematically correct path and an approximation constructed from
         * straight line segments.
         */
        getFlatness(): Promise<number>;
        /**
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.GState.LineCap = {
         * 	e_butt_cap : 0
         * 	e_round_cap : 1
         * 	e_square_cap : 2
         * }
         * </pre>
         * @returns A promise that resolves to currently selected LineCap style
         *
         * The line cap style specifies the shape to be used at the ends of open sub-paths
         * (and dashes, if any) when they are stroked.
         */
        getLineCap(): Promise<number>;
        /**
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.GState.LineJoin = {
         * 	e_miter_join : 0
         * 	e_round_join : 1
         * 	e_bevel_join : 2
         * }
         * </pre>
         * @returns A promise that resolves to currently selected LineJoin style
         *
         * The line join style specifies the shape to be used at the corners of paths that
         * are stroked.
         */
        getLineJoin(): Promise<number>;
        /**
         * @returns A promise that resolves to the thickness of the line used to stroke a path.
         * Note: A line width of 0 denotes the thinnest line that can be rendered at device
         * resolution: 1 device pixel wide.
         */
        getLineWidth(): Promise<number>;
        /**
         * @returns A promise that resolves to current value of miter limit.
         *
         * The miter limit imposes a maximum on the ratio of the miter length to the
         * line width. When the limit is exceeded, the join is converted from a miter
         * to a bevel.
         */
        getMiterLimit(): Promise<number>;
        /**
         * @returns A promise that resolves to the phase of the currently selected dash pattern. dash phase is expressed in
         * user space units.
         */
        getPhase(): Promise<number>;
        /**
         * @returns A promise that resolves to currently selected character spacing.
         *
         * The character spacing parameter is a number specified in unscaled text space
         * units. When the glyph for each character in the string is rendered, the character
         * spacing is added to the horizontal or vertical component of the glyph's displacement,
         * depending on the writing mode. See Section 5.2.1 in PDF Reference Manual for details.
         */
        getCharSpacing(): Promise<number>;
        /**
         * @returns A promise that resolves to currently selected word spacing
         *
         * Word spacing works the same way as character spacing, but applies only to the
         * space character (char code 32). See Section 5.2.2 in PDF Reference Manual for details.
         */
        getWordSpacing(): Promise<number>;
        /**
         * @returns A promise that resolves to currently selected horizontal scale
         *
         * The horizontal scaling parameter adjusts the width of glyphs by stretching
         * or compressing them in the horizontal direction. Its value is specified as
         * a percentage of the normal width of the glyphs, with 100 being the normal width.
         * The scaling always applies to the horizontal coordinate in text space, independently
         * of the writing mode. See Section 5.2.3 in PDF Reference Manual for details.
         */
        getHorizontalScale(): Promise<number>;
        /**
         * @returns A promise that resolves to currently selected leading parameter
         *
         * The leading parameter is measured in unscaled text space units. It specifies
         * the vertical distance between the baselines of adjacent lines of text.
         * See Section 5.2.4 in PDF Reference Manual for details.
         */
        getLeading(): Promise<number>;
        /**
         * @returns A promise that resolves to currently selected font
         */
        getFont(): Promise<PDFNet.Font>;
        /**
         * @returns A promise that resolves to the font size
         */
        getFontSize(): Promise<number>;
        /**
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.GState.TextRenderingMode = {
         * 	e_fill_text : 0
         * 	e_stroke_text : 1
         * 	e_fill_stroke_text : 2
         * 	e_invisible_text : 3
         * 	e_fill_clip_text : 4
         * 	e_stroke_clip_text : 5
         * 	e_fill_stroke_clip_text : 6
         * 	e_clip_text : 7
         * }
         * </pre>
         * @returns A promise that resolves to current text rendering mode.
         *
         * The text rendering mode determines whether showing text causes glyph outlines to
         * be stroked, filled, used as a clipping boundary, or some combination of the three.
         * See Section 5.2.5 in PDF Reference Manual for details..
         */
        getTextRenderMode(): Promise<number>;
        /**
         * @returns A promise that resolves to current value of text rise
         *
         * Text rise specifies the distance, in unscaled text space units, to move the
         * baseline up or down from its default location. Positive values of text rise
         * move the baseline up
         */
        getTextRise(): Promise<number>;
        /**
         * @returns A promise that resolves to a boolean flag that determines the text element is considered
         * elementary objects for purposes of color compositing in the transparent imaging
         * model.
         */
        isTextKnockout(): Promise<boolean>;
        /**
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.GState.RenderingIntent = {
         * 	e_absolute_colorimetric : 0
         * 	e_relative_colorimetric : 1
         * 	e_saturation : 2
         * 	e_perceptual : 3
         * }
         * </pre>
         * @returns A promise that resolves to the color intent to be used for rendering the Element
         */
        getRenderingIntent(): Promise<number>;
        /**
         * A utility function that maps a string representing a rendering intent to
         * RenderingIntent type.
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.GState.RenderingIntent = {
         * 	e_absolute_colorimetric : 0
         * 	e_relative_colorimetric : 1
         * 	e_saturation : 2
         * 	e_perceptual : 3
         * }
         * </pre>
         * @param name - string that represents the rendering intent to get.
         * @returns A promise that resolves to the color rendering intent type matching the specified string
         */
        static getRenderingIntentType(name: string): Promise<number>;
        /**
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.GState.BlendMode = {
         * 	e_bl_compatible : 0
         * 	e_bl_normal : 1
         * 	e_bl_multiply : 2
         * 	e_bl_screen : 3
         * 	e_bl_difference : 4
         * 	e_bl_darken : 5
         * 	e_bl_lighten : 6
         * 	e_bl_color_dodge : 7
         * 	e_bl_color_burn : 8
         * 	e_bl_exclusion : 9
         * 	e_bl_hard_light : 10
         * 	e_bl_overlay : 11
         * 	e_bl_soft_light : 12
         * 	e_bl_luminosity : 13
         * 	e_bl_hue : 14
         * 	e_bl_saturation : 15
         * 	e_bl_color : 16
         * }
         * </pre>
         * @returns A promise that resolves to the current blend mode to be used in the transparent imaging model.
         * Corresponds to the /BM key within the ExtGState's dictionary.
         */
        getBlendMode(): Promise<number>;
        /**
         * @returns A promise that resolves to the opacity value for painting operations other than stroking.
         * Returns the value of the /ca key in the ExtGState dictionary. If the value is not
         * found, the default value of 1 is returned.
         */
        getFillOpacity(): Promise<number>;
        /**
         * @returns A promise that resolves to opacity value for stroke painting operations for paths and glyph outlines.
         * Returns the value of the /CA key in the ExtGState dictionary. If the value is not
         * found, the default value of 1 is returned.
         */
        getStrokeOpacity(): Promise<number>;
        /**
         * @returns A promise that resolves to the alpha source flag ('alpha is shape'), specifying whether the
         * current soft mask and alpha constant are to be interpreted as shape values
         * (true) or opacity values (false).
         */
        getAISFlag(): Promise<boolean>;
        /**
         * @returns A promise that resolves to associated soft mask. NULL if the soft mask is not selected or
         * SDF dictionary representing the soft mask otherwise.
         */
        getSoftMask(): Promise<PDFNet.Obj>;
        /**
         * @returns A promise that resolves to the soft mask transform. This is the transformation matrix at the moment the soft
         * mask is established in the graphics state with the gs operator. This information is only
         * relevant when applying the soft mask that may be specified in the graphics state to the
         * current element.
         */
        getSoftMaskTransform(): Promise<PDFNet.Matrix2D>;
        /**
         * @returns A promise that resolves to whether overprint is enabled for stroke painting operations.
         * Corresponds to the /OP key within the ExtGState's dictionary.
         */
        getStrokeOverprint(): Promise<boolean>;
        /**
         * @returns A promise that resolves to whether overprint is enabled for fill painting operations.
         * Corresponds to the /op key within the ExtGState's dictionary.
         */
        getFillOverprint(): Promise<boolean>;
        /**
         * @returns A promise that resolves to the overprint mode used by this graphics state.
         * Corresponds to the /OPM key within the ExtGState's dictionary.
         */
        getOverprintMode(): Promise<number>;
        /**
         * @returns A promise that resolves to a flag specifying whether stroke adjustment is enabled in the graphics
         * state. Corresponds to the /SA key within the ExtGState's dictionary.
         */
        getAutoStrokeAdjust(): Promise<boolean>;
        /**
         * @returns A promise that resolves to the smoothness tolerance used to control the quality of smooth
         * shading. Corresponds to the /SM key within the ExtGState's dictionary.
         * The allowable error (or tolerance) is expressed as a fraction of the range
         * of the color component, from 0.0 to 1.0.
         */
        getSmoothnessTolerance(): Promise<number>;
        /**
         * @returns A promise that resolves to currently selected transfer function (NULL by default) used during
         * color conversion process. A transfer function adjusts the values of color
         * components to compensate for nonlinear response in an output device and in
         * the human eye. Corresponds to the /TR key within the ExtGState's dictionary.
         */
        getTransferFunct(): Promise<PDFNet.Obj>;
        /**
         * @returns A promise that resolves to currently selected black-generation function (NULL by default) used
         * during conversion between DeviceRGB and DeviceCMYK. Corresponds to the /BG key
         * within the ExtGState's dictionary.
         */
        getBlackGenFunct(): Promise<PDFNet.Obj>;
        /**
         * @returns A promise that resolves to currently selected undercolor-removal function (NULL by default) used
         * during conversion between DeviceRGB and DeviceCMYK. Corresponds to the /UCR key
         * within the ExtGState's dictionary.
         */
        getUCRFunct(): Promise<PDFNet.Obj>;
        /**
         * @returns A promise that resolves to currently selected halftone dictionary or stream (NULL by default).
         * Corresponds to the /HT key within the ExtGState's dictionary.
         * Halftoning is a process by which continuous-tone colors are approximated on an
         * output device that can achieve only a limited number of discrete colors.
         */
        getHalftone(): Promise<PDFNet.Obj>;
        /**
         * Set the transformation matrix associated with this element.
         * @param mtx - The new transformation for this text element.
         *
         * Note: in PDF associating a transformation matrix with an element
         * ('cm' operator) will also affect all subsequent elements.
         */
        setTransformMatrix(mtx: PDFNet.Matrix2D): Promise<void>;
        /**
         * Set the transformation matrix associated with this element.
         *
         * A transformation matrix in PDF is specified by six numbers, usually
         * in the form of an array containing six elements. In its most general
         * form, this array is denoted [a b c d h v]; it can represent any linear
         * transformation from one coordinate system to another. For more
         * information about PDF matrices please refer to section 4.2.2 'Common
         * Transformations' in PDF Reference Manual, and to documentation for
         * pdftron::Common::Matrix2D class.
         * @param a - horizontal 'scaling' component of the new text matrix.
         * @param b - 'rotation' component of the new text matrix.
         * @param c - 'rotation' component of the new text matrix.
         * @param d - vertical 'scaling' component of the new text matrix.
         * @param h - horizontal translation component of the new text matrix.
         * @param v - vertical translation component of the new text matrix.
         */
        setTransform(a: number, b: number, c: number, d: number, h: number, v: number): Promise<void>;
        /**
         * Concatenate the given matrix to the transformation matrix of this element.
         * @param mtx - Matrix2D object to concatenate the current matrix with.
         */
        concatMatrix(mtx: PDFNet.Matrix2D): Promise<void>;
        /**
         * Concatenate the given matrix expressed in its values to the transformation
         * matrix of this element.
         * @param a - horizontal 'scaling' component of the new text matrix.
         * @param b - 'rotation' component of the new text matrix.
         * @param c - 'rotation' component of the new text matrix.
         * @param d - vertical 'scaling' component of the new text matrix.
         * @param h - horizontal translation component of the new text matrix.
         * @param v - vertical translation component of the new text matrix.
         */
        concat(a: number, b: number, c: number, d: number, h: number, v: number): Promise<void>;
        /**
         * Sets the color space used for stroking operations
         * @param cs - ColorSpace object to use for stroking operations
         */
        setStrokeColorSpace(cs: PDFNet.ColorSpace): Promise<void>;
        /**
         * Sets the color space used for filling operations
         * @param cs - ColorSpace object to use for filling operations
         */
        setFillColorSpace(cs: PDFNet.ColorSpace): Promise<void>;
        /**
         * Sets the color value/point used for stroking operations.
         * @param c - is the color used for stroking operations
         * Note: The color value must be represented in the currently selected color space used
         * for stroking.
         */
        setStrokeColorWithColorPt(c: PDFNet.ColorPt): Promise<void>;
        /**
         * Set the stroke color to the given tiling pattern.
         * @param pattern - SDF pattern object.
         * Note: The currently selected stroke color space must be Pattern color space.
         */
        setStrokeColorWithPattern(pattern: PDFNet.PatternColor): Promise<void>;
        /**
         * Set the stroke color to the given uncolored tiling pattern.
         * @param pattern - pattern (PatternType = 1 and PaintType = 2) object.
         * @param c - is a color in the pattern's underlying color space.
         * Note: The currently selected stroke color space must be Pattern color space.
         */
        setStrokeColor(pattern: PDFNet.PatternColor, c: PDFNet.ColorPt): Promise<void>;
        /**
         * Sets the color value/point used for filling operations.
         * @param c - the color used for filling operations
         * The color value must be represented in the currently selected color space used
         * for filling.
         */
        setFillColorWithColorPt(c: PDFNet.ColorPt): Promise<void>;
        /**
         * Set the fill color to the given tiling pattern.
         * @param pattern - New pattern color.
         * Note: The currently selected fill color space must be Pattern color space.
         */
        setFillColorWithPattern(pattern: PDFNet.PatternColor): Promise<void>;
        /**
         * Set the fill color to the given uncolored tiling pattern.
         * @param pattern - PatternColor (PatternType = 1 and PaintType = 2) object.
         * @param c - is a color in the pattern's underlying color space.
         * Note: The currently selected fill color space must be Pattern color space.
         */
        setFillColor(pattern: PDFNet.PatternColor, c: PDFNet.ColorPt): Promise<void>;
        /**
         * Sets the value of flatness tolerance.
         * @param flatness - is a number in the range 0 to 100; a value of 0 specifies the output
         * device's default flatness tolerance.
         *
         * The flatness tolerance controls the maximum permitted distance in device pixels
         * between the mathematically correct path and an approximation constructed from
         * straight line segments.
         */
        setFlatness(flatness: number): Promise<void>;
        /**
         * Sets LineCap style property.
         *
         * The line cap style specifies the shape to be used at the ends of open subpaths
         * (and dashes, if any) when they are stroked.
         * @param cap - <pre>
         * PDFNet.GState.LineCap = {
         * 	e_butt_cap : 0
         * 	e_round_cap : 1
         * 	e_square_cap : 2
         * }
         * </pre>
         */
        setLineCap(cap: number): Promise<void>;
        /**
         * Sets LineJoin style property.
         *
         * The line join style specifies the shape to be used at the corners of paths that
         * are stroked.
         * @param join - <pre>
         * PDFNet.GState.LineJoin = {
         * 	e_miter_join : 0
         * 	e_round_join : 1
         * 	e_bevel_join : 2
         * }
         * </pre>
         */
        setLineJoin(join: number): Promise<void>;
        /**
         * Sets the thickness of the line used to stroke a path.
         * @param width - a non-negative number expressed in user space units.
         * A line width of 0 denotes the thinnest line that can be rendered at device
         * resolution: 1 device pixel wide.
         */
        setLineWidth(width: number): Promise<void>;
        /**
         * Sets miter limit.
         * @param miter_limit - A number that imposes a maximum on the ratio of the miter
         * length to the line width. When the limit is exceeded, the join is converted
         * from a miter to a bevel.
         */
        setMiterLimit(miter_limit: number): Promise<void>;
        /**
         * Sets the dash pattern used to stroke paths. The line dash pattern controls
         * the pattern of dashes and gaps used to stroke paths. It is specified by a dash
         * array and a dash phase. The elements of both the dash array and the dash phase
         * are expressed in user space units.
         * @param dash_array - the numbers that specify the lengths of alternating dashes and gaps.
         * @param phase - specifies the distance into the dash pattern at which to start the dash.
         */
        setDashPattern(dash_array: number[], phase: number): Promise<void>;
        /**
         * Sets character spacing.
         * @param char_spacing - a number specified in unscaled text space units. When the
         * glyph for each character in the string is rendered, the character spacing is
         * added to the horizontal or vertical component of the glyph's displacement,
         * depending on the writing mode. See Section 5.2.1 in PDF Reference Manual for details.
         */
        setCharSpacing(char_spacing: number): Promise<void>;
        /**
         * Sets word spacing.
         * @param word_spacing - a number specified in unscaled text space units.
         * Word spacing works the same way as character spacing, but applies only to the
         * space character (char code 32). See Section 5.2.2 in PDF Reference Manual for details.
         */
        setWordSpacing(word_spacing: number): Promise<void>;
        /**
         * Sets horizontal scale.
         * The horizontal scaling parameter adjusts the width of glyphs by stretching
         * or compressing them in the horizontal direction. Its value is specified as
         * a percentage of the normal width of the glyphs, with 100 being the normal width.
         * The scaling always applies to the horizontal coordinate in text space, independently
         * of the writing mode. See Section 5.2.3 in PDF Reference Manual for details.
         * @param hscale - value to set horizontal scale to.
         */
        setHorizontalScale(hscale: number): Promise<void>;
        /**
         * Sets the leading parameter.
         *
         * The leading parameter is measured in unscaled text space units. It specifies
         * the vertical distance between the baselines of adjacent lines of text.
         * See Section 5.2.4 in PDF Reference Manual for details.
         * @param leading - number representing vertical distance between lines of text
         */
        setLeading(leading: number): Promise<void>;
        /**
         * Sets the font and font size used to draw text.
         * @param font - Font to draw the text with
         * @param font_sz - size of the font to draw the text with
         */
        setFont(font: PDFNet.Font, font_sz: number): Promise<void>;
        /**
         * Sets text rendering mode.
         * The text rendering mode determines whether showing text causes glyph outlines to
         * be stroked, filled, used as a clipping boundary, or some combination of the three.
         * See Section 5.2.5 in PDF Reference Manual for details..
         * @param rmode - <pre>
         * PDFNet.GState.TextRenderingMode = {
         * 	e_fill_text : 0
         * 	e_stroke_text : 1
         * 	e_fill_stroke_text : 2
         * 	e_invisible_text : 3
         * 	e_fill_clip_text : 4
         * 	e_stroke_clip_text : 5
         * 	e_fill_stroke_clip_text : 6
         * 	e_clip_text : 7
         * }
         * </pre>
         * the mode that text will rendered with.
         * rmode can take the following values:
         * PDFNet.GState.TextRenderingMode = {
         * 	e_fill_text : 0,
         * 	e_stroke_text : 1,
         * 	e_fill_stroke_text : 2,
         * 	e_invisible_text : 3,
         * 	e_fill_clip_text : 4,
         * 	e_stroke_clip_text : 5,
         * 	e_fill_stroke_clip_text : 6,
         * 	e_clip_text : 7
         * }
         */
        setTextRenderMode(rmode: number): Promise<void>;
        /**
         * Sets text rise.
         * Text rise specifies the distance, in unscaled text space units, to move the
         * baseline up or down from its default location. Positive values of text rise
         * move the baseline up
         * @param rise - distance to move baseline up. Negative values move baseline down.
         */
        setTextRise(rise: number): Promise<void>;
        /**
         * Mark the object as elementary for purposes of color compositing in the
         * transparent imaging model.
         * @param knockout - Whether an object is elementary or not.
         */
        setTextKnockout(knockout: boolean): Promise<void>;
        /**
         * Sets the color intent to be used for rendering the Element.
         * @param intent - <pre>
         * PDFNet.GState.RenderingIntent = {
         * 	e_absolute_colorimetric : 0
         * 	e_relative_colorimetric : 1
         * 	e_saturation : 2
         * 	e_perceptual : 3
         * }
         * </pre>
         */
        setRenderingIntent(intent: number): Promise<void>;
        /**
         * Sets the current blend mode to be used in the transparent imaging model.
         * Corresponds to the /BM key within the ExtGState's dictionary.
         * @param BM - <pre>
         * PDFNet.GState.BlendMode = {
         * 	e_bl_compatible : 0
         * 	e_bl_normal : 1
         * 	e_bl_multiply : 2
         * 	e_bl_screen : 3
         * 	e_bl_difference : 4
         * 	e_bl_darken : 5
         * 	e_bl_lighten : 6
         * 	e_bl_color_dodge : 7
         * 	e_bl_color_burn : 8
         * 	e_bl_exclusion : 9
         * 	e_bl_hard_light : 10
         * 	e_bl_overlay : 11
         * 	e_bl_soft_light : 12
         * 	e_bl_luminosity : 13
         * 	e_bl_hue : 14
         * 	e_bl_saturation : 15
         * 	e_bl_color : 16
         * }
         * </pre>
         * New blending mode type.
         *
         * <pre>
         * // C#
         * gs.SetBlendMode(GState.BlendMode.e_lighten);
         *
         * // C++
         * gs->SetBlendMode(GState::e_lighten);
         * </pre>
         */
        setBlendMode(BM: number): Promise<void>;
        /**
         * Sets the opacity value for painting operations other than stroking.
         * Corresponds to the value of the /ca key in the ExtGState dictionary.
         * @param ca - value to set fill opacity to
         */
        setFillOpacity(ca: number): Promise<void>;
        /**
         * Sets opacity value for stroke painting operations for paths and glyph outlines.
         * Corresponds to the value of the /CA key in the ExtGState dictionary.
         * @param ca - value to set stroke opacity to
         */
        setStrokeOpacity(ca: number): Promise<void>;
        /**
         * specifies if the alpha is to be interpreted as a shape or opacity mask.
         * The alpha source flag ('alpha is shape'), specifies whether the
         * current soft mask and alpha constant are to be interpreted as shape values
         * (true) or opacity values (false).
         * @param AIS - true for interpretation as shape values or false for opacity values
         */
        setAISFlag(AIS: boolean): Promise<void>;
        /**
         * Sets the soft mask of the extended graphics state.
         * Corresponds to the /SMask key within the ExtGState's dictionary.
         * @param SM - SDF/Cos black-generation function or name
         */
        setSoftMask(SM: PDFNet.Obj): Promise<void>;
        /**
         * specifies if overprint is enabled for stroke operations. Corresponds to the /OP
         * key within the ExtGState's dictionary.
         * @param OP - true to enable overprint for stroke, false to disable.
         */
        setStrokeOverprint(OP: boolean): Promise<void>;
        /**
         * specifies if overprint is enabled for fill operations. Corresponds to the /op
         * key within the ExtGState's dictionary.
         * @param op - true to enable overprint for fill, false to disable.
         */
        setFillOverprint(op: boolean): Promise<void>;
        /**
         * Sets the overprint mode. Corresponds to the /OPM key within the ExtGState's
         * dictionary.
         * @param OPM - overprint mode.
         */
        setOverprintMode(OPM: number): Promise<void>;
        /**
         * Specify whether to apply automatic stroke adjustment.
         * Corresponds to the /SA key within the ExtGState's dictionary.
         * @param SA - if true automatic stroke adjustment will be applied.
         */
        setAutoStrokeAdjust(SA: boolean): Promise<void>;
        /**
         * Sets the smoothness tolerance used to control the quality of smooth
         * shading. Corresponds to the /SM key within the ExtGState's dictionary.
         */
        setSmoothnessTolerance(SM: number): Promise<void>;
        /**
         * Sets black-generation function used during conversion between DeviceRGB
         * and DeviceCMYK. Corresponds to the /BG key within the ExtGState's
         * dictionary.
         * @param BG - SDF/Cos black-generation function or name
         */
        setBlackGenFunct(BG: PDFNet.Obj): Promise<void>;
        /**
         * Sets undercolor-removal function used during conversion between DeviceRGB
         * and DeviceCMYK. Corresponds to the /UCR key within the ExtGState's
         * dictionary.
         * @param UCR - SDF/Cos undercolor-removal function or name
         */
        setUCRFunct(UCR: PDFNet.Obj): Promise<void>;
        /**
         * Sets transfer function used during color conversion process. A transfer
         * function adjusts the values of color components to compensate for nonlinear
         * response in an output device and in the human eye. Corresponds to the /TR key
         * within the ExtGState's dictionary.
         * @param TR - SDF/Cos transfer function, array, or name
         */
        setTransferFunct(TR: PDFNet.Obj): Promise<void>;
        /**
         * @param HT - SDF/Cos halftone dictionary, stream, or name
         * @returns A promise that resolves to currently selected halftone dictionary or stream (NULL by default).
         * Corresponds to the /HT key within the ExtGState's dictionary.
         * Halftoning is a process by which continuous-tone colors are approximated on an
         * output device that can achieve only a limited number of discrete colors.
         */
        setHalftone(HT: PDFNet.Obj): Promise<void>;
    }
    /**
     * The class GeometryCollection.
     * A Preprocessed PDF geometry collection
     */
    class GeometryCollection extends PDFNet.Destroyable {
        /**
         * return the point within the collection which is closest to the queried point. All values are in the page coordinate space.
         * @param x - - the x coordinate to snap, in page coordinates.
         * @param y - - the y coordinate to snap, in page coordinates.
         * @param mode - - a combination of flags from the SnappingMode enumeration.
         * @returns A promise that resolves to a point within the collection, closest to the queried point. If the collection is empty, the queried point will be returned unchanged.
         */
        snapToNearest(x: number, y: number, mode: number): Promise<PDFNet.Point>;
        /**
         * return the point within the collection which is closest to the queried point. All values are in the page coordinate space.
         * @param x - - the x coordinate to snap.
         * @param y - - the y coordinate to snap.
         * @param dpi - - the resolution of the rendered page, in pixels per inch.
         * @param mode - - a combination of flags from the SnappingMode enumeration.
         * @returns A promise that resolves to a point within the collection, closest to the queried point. If the collection is empty, the queried point will be returned unchanged.
         */
        snapToNearestPixel(x: number, y: number, dpi: number, mode: number): Promise<PDFNet.Point>;
    }
    /**
     * A Highlight annotation covers a word or a group of contiguous words with partially transparent
     * color.
     */
    class HighlightAnnot extends PDFNet.TextMarkupAnnot {
        /**
         * creates a Highlight annotation and initializes it using given Cos/SDF object.
         * @param d - The Cos/SDF object to initialze the annotation with.
         * Note: The constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @returns A promise that resolves to an object of type: "PDFNet.HighlightAnnot"
         */
        static createFromObj(d: PDFNet.Obj): Promise<PDFNet.HighlightAnnot>;
        /**
         * creates a Highlight annotation and initializes it using given annotation object.
         * @param ann - Annot object used to initialize the Highlight annotation.
         * Note: The constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @returns A promise that resolves to an object of type: "PDFNet.HighlightAnnot"
         */
        static createFromAnnot(ann: PDFNet.Annot): Promise<PDFNet.HighlightAnnot>;
        /**
         * Creates a new Highlight annotation in the specified document.
         * @param doc - A document to which the Highlight annotation is added.
         * @param pos - A rectangle specifying the Highlight annotation's bounds in default user space units.
         * @returns A promise that resolves to a newly created blank Highlight annotation.
         */
        static create(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, pos: PDFNet.Rect): Promise<PDFNet.HighlightAnnot>;
        static create(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, type: number, pos: PDFNet.Rect): Promise<PDFNet.Annot>;
    }
    /**
     * Highlights is used to store the necessary information and perform certain
     * tasks in accordance with Adobe's Highlight standard, whose details can be
     * found at:
     *
     * http://partners.adobe.com/public/developer/en/pdf/HighlightFileFormat.pdf
     *
     * In a nutshell, the Highlights class maintains a set of highlights.
     * Each highlight contains three pieces of information:
     *
     * page: the number of the page this Highlight is on;
     * position: the start position (text offset) of this Highlight;
     * length: the length of this Highlight.
     *
     * Possible use case scenarios for Highlights include:
     *  - Load a Highlight file (in XML format) and highlight the corresponding
     *    texts in the viewer (e.g., if the viewer is implemented using PDFViewCtrl,
     *    it can be achieved simply by calling PDFViewCtrl::SelectByHighlights()
     *    method);
     *  - Save the Highlight information (e.g., constructed by the TextSearch
     *    class) to an XML file for external uses.
     *
     * Note:
     *  - The Highlights class does not maintain the corresponding PDF document for
     *    its highlights. It is the user's responsibility to match them up.
     *  - The Highlights class ensures that each highlight it maintains is
     *    unique (no two highlights have the same page, position and length values).
     *  - The current implementation of Highlights only supports the 'characters'
     *    encoding for 'units' as described in the format; the 'words' encoding is
     *    not supported at this point.
     *
     *
     * For a sample code, please take a look at the TextSearchTest sample project.
     */
    class Highlights extends PDFNet.Destroyable {
        /**
         * Constructor and destructor.
         * @returns A promise that resolves to an object of type: "PDFNet.Highlights"
         */
        static create(): Promise<PDFNet.Highlights>;
        /**
         * @returns A promise that resolves to an object of type: "PDFNet.Highlights"
         */
        copyCtor(): Promise<PDFNet.Highlights>;
        /**
         * Add highlights.
         * @param hlts - the Highlights instance containing the highlights to be added.
         */
        add(hlts: PDFNet.Highlights): Promise<void>;
        /**
         * Save the current Highlight information in the class to an XML string.
         * @returns A promise that resolves to the highlight XML file contents as a string
         */
        saveToString(): Promise<string>;
        /**
         * Clear the current Highlight information in the class.
         */
        clear(): Promise<void>;
        /**
         * Rewind the internal pointer to the first highlight.
         * @param doc - the PDF document to which the highlights correspond.
         *
         * Note: the PDF document can be a dummy document unless GetCurrentQuads()
         * is to be called.
         */
        begin(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc): Promise<void>;
        /**
         * Query if there is any subsequent highlight after the current highlight.
         * @returns A promise that resolves to an object of type: "boolean"
         */
        hasNext(): Promise<boolean>;
        /**
         * Move the current highlight to the next highlight.
         */
        next(): Promise<void>;
        /**
         * Get the page number of the current highlight.
         * @returns A promise that resolves to an object of type: "number"
         */
        getCurrentPageNumber(): Promise<number>;
        /**
         * Get a TextRange object that represents the current highlight.
         * @returns A promise that resolves to an object of type: "PDFNet.TextRange"
         */
        getCurrentTextRange(): Promise<PDFNet.TextRange>;
        /**
         * Retrieves an array of Quads (each quad contains 4 points) representing the regions that were
        highlighted.
         * @returns A promise that resolves to an object of type: "number" (generated documentation)
         */
        getCurrentQuads(): Promise<PDFNet.QuadPoint[]>;
    }
    /**
     * Image class provides common methods for working with PDF images.
     *
     * Note: PDF::Element contains a similar interface used to access image data.
     * To create the Image object from image PDF::Element, pass the Element's SDF/Cos
     * dictionary to Image constructor (i.e. Image image(element->GetXObject()) )
     */
    class Image {
        /**
         * Create and embed an Image. Embed the raw image data taking into account
         * specified compression hints.
         *
         * By default the function will compress all images using Flate compression.
         * It is possible to fine tune compression or to select a different compression
         * algorithm using 'encoder_hints' object.
         * @param doc - A document to which the image should be added. The 'Doc' object
         * can be obtained using Obj::GetDoc() or PDFDoc::GetSDFDoc().
         * @param buf - The stream or buffer containing image data. The image data must
         * not be compressed and must follow PDF format for sample representation (please refer
         * to section 4.8.2 'Sample Representation' in PDF Reference Manual for details).
         * @param width - The width of the image, in samples.
         * @param height - The height of the image, in samples.
         * @param bpc - The number of bits used to represent each color component.
         * @param color_space - The color space in which image samples are represented.
         * @param [encoder_hints] - An optional parameter that can be used to fine tune
         * compression or to select a different compression algorithm. See Image::Create()
         * for details.
         * @returns A promise that resolves to pDF::Image object representing the embedded image.
         */
        static createFromMemory(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, buf: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray, width: number, height: number, bpc: number, color_space: PDFNet.ColorSpace, encoder_hints?: PDFNet.Obj): Promise<PDFNet.Image>;
        /**
         * Create and embed an Image. Embed the raw image data taking into account
         * specified compression hints.
         * Note: see Image::Create for details.
         * @returns A promise that resolves to an object of type: "PDFNet.Image"
         */
        static createFromMemory2(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, buf: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray, encoder_hints?: PDFNet.Obj): Promise<PDFNet.Image>;
        /**
         * Create and embed an Image. Embed the raw image data taking into account
         * specified compression hints.
         * Note: see Image::Create for details.
         * @returns A promise that resolves to an object of type: "PDFNet.Image"
         */
        static createFromStream(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, image_data: PDFNet.FilterReader, width: number, height: number, bpc: number, color_space: PDFNet.ColorSpace, encoder_hints?: PDFNet.Obj): Promise<PDFNet.Image>;
        /**
         * Create and embed an Image. Embed the raw image data taking into account
         * specified compression hints.
         *
         * Note: see Image::Create for details.
         * Note: PDFNet takes ownership of the filter
         * @returns A promise that resolves to an object of type: "PDFNet.Image"
         */
        static createFromStream2(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, image_data: PDFNet.Filter, encoder_hints?: PDFNet.Obj): Promise<PDFNet.Image>;
        /**
         * Create and embed an ImageMask. Embed the raw image data taking into account
         * specified compression hints. The ImageMask can be used as a stencil mask for
         * painting in the current color or as an explicit mask specifying which areas of
         * the image to paint and which to mask out. One of the most important uses of
         * stencil masking is for painting character glyphs represented as bitmaps.
         * @param doc - A document to which the image should be added. The 'Doc' object
         * can be obtained using Obj::GetDoc() or PDFDoc::GetSDFDoc().
         * @param buf - The stream or buffer containing image data stored in 1 bit per
         * sample format. The image data must not be compressed and must follow PDF format for
         * sample representation (please refer to section 4.8.2 'Sample Representation' in PDF
         * Reference Manual for details).
         * @param width - The width of the image, in samples.
         * @param height - The height of the image, in samples.
         * @param [encoder_hints] - An optional parameter that can be used to fine tune
         * compression or to select a different compression algorithm. See Image::Create()
         * for details.
         * @returns A promise that resolves to pDF::Image object representing the embedded ImageMask.
         */
        static createImageMask(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, buf: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray, width: number, height: number, encoder_hints?: PDFNet.Obj): Promise<PDFNet.Image>;
        /**
         * Create and embed an ImageMask.
         * Note: see Image::CreateImageMask for details.
         * @returns A promise that resolves to an object of type: "PDFNet.Image"
         */
        static createImageMaskFromStream(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, image_data: PDFNet.FilterReader, width: number, height: number, encoder_hints?: PDFNet.Obj): Promise<PDFNet.Image>;
        /**
         * create and embed a Soft Mask. Embed the raw image data taking into account
         * specified compression hints.
         * A soft-mask image (see "Soft-Mask Images" in PDF Reference Manual) is
         * used as a source of mask shape or mask opacity values in the transparent
         * imaging model.
         * @param doc - A document to which the image should be added. The 'Doc' object
         * can be obtained using Obj::GetDoc() or PDFDoc::GetSDFDoc().
         * @param buf - The stream or buffer containing image data represented in
         * DeviceGray color space (i.e. one component per sample). The image data must not
         * be compressed and must follow PDF format for sample representation (please refer
         * to section 4.8.2 'Sample Representation' in PDF Reference Manual for details).
         * @param width - The width of the image, in samples.
         * @param height - The height of the image, in samples.
         * @param bpc - The number of bits used to represent each color component.
         * @param [encoder_hints] - An optional parameter that can be used to fine tune
         * compression or to select a different compression algorithm. See Image::Create()
         * for details.
         * Note: this feature is available only in PDF 1.4 and higher.
         * @returns A promise that resolves to an object of type: "PDFNet.Image"
         */
        static createSoftMask(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, buf: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray, width: number, height: number, bpc: number, encoder_hints?: PDFNet.Obj): Promise<PDFNet.Image>;
        /**
         * Create and embed a Soft Mask. Embed the raw image data taking into account
         * specified compression hints.
         * Note: see Image::CreateSoftMask for details.
         * @returns A promise that resolves to an object of type: "PDFNet.Image"
         */
        static createSoftMaskFromStream(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, image_data: PDFNet.FilterReader, width: number, height: number, bpc: number, encoder_hints?: PDFNet.Obj): Promise<PDFNet.Image>;
        /**
         * @param input_format - <pre>
         * PDFNet.Image.InputFilter = {
         * 	e_none : 0
         * 	e_jpeg : 1
         * 	e_jp2 : 2
         * 	e_flate : 3
         * 	e_g3 : 4
         * 	e_g4 : 5
         * 	e_ascii_hex : 6
         * }
         * </pre>
         * @returns A promise that resolves to an object of type: "PDFNet.Image"
         */
        static createDirectFromMemory(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, buf: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray, width: number, height: number, bpc: number, color_space: PDFNet.ColorSpace, input_format: number): Promise<PDFNet.Image>;
        /**
         * Embed the raw image data taking into account specified compression hints.
         * Note: see the above method for details.
         * @param input_format - <pre>
         * PDFNet.Image.InputFilter = {
         * 	e_none : 0
         * 	e_jpeg : 1
         * 	e_jp2 : 2
         * 	e_flate : 3
         * 	e_g3 : 4
         * 	e_g4 : 5
         * 	e_ascii_hex : 6
         * }
         * </pre>
         * @returns A promise that resolves to an object of type: "PDFNet.Image"
         */
        static createDirectFromStream(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, image_data: PDFNet.FilterReader, width: number, height: number, bpc: number, color_space: PDFNet.ColorSpace, input_format: number): Promise<PDFNet.Image>;
        /**
         * Create an image from an existing image represented as a SDF/Cos object.
         *
         * Note: To create the Image object from image PDF::Element, pass the Element's
         * SDF/Cos dictionary to Image constructor (i.e. Image image(element->GetXObject()))
         * @returns A promise that resolves to an object of type: "PDFNet.Image"
         */
        static createFromObj(image_xobject?: PDFNet.Obj): Promise<PDFNet.Image>;
        /**
         * Copy Constructor
         * @returns A promise that resolves to an object of type: "PDFNet.Image"
         */
        copy(): Promise<PDFNet.Image>;
        /**
         * @returns A promise that resolves to the underlying SDF/Cos object
         */
        getSDFObj(): Promise<PDFNet.Obj>;
        /**
         * @returns A promise that resolves to whether this is a valid raster image. If the function returns false the
         * underlying SDF/Cos object is not a valid raster image and this Image object should
         * be treated as null.
         */
        isValid(): Promise<boolean>;
        /**
         * @returns A promise that resolves to a stream (filter) containing decoded image data
         */
        getImageData(): Promise<PDFNet.Filter>;
        /**
         * @returns A promise that resolves to the size of image data in bytes
         */
        getImageDataSize(): Promise<number>;
        /**
         * @returns A promise that resolves to the SDF object representing the color space in which image
         * samples are specified or NULL if:
         *  the image is an image mask
         *  or is compressed using JPXDecode with missing ColorSpace entry in image dictionary.
         *
         * The returned color space may be any type of color space except Pattern.
         */
        getImageColorSpace(): Promise<PDFNet.ColorSpace>;
        /**
         * @returns A promise that resolves to the width of the image, in samples.
         */
        getImageWidth(): Promise<number>;
        /**
         * @returns A promise that resolves to the height of the image, in samples.
         */
        getImageHeight(): Promise<number>;
        /**
         * @returns A promise that resolves to decode array or NULL if the parameter is not specified. A decode object is an
         * array of numbers describing how to map image samples into the range of values
         * appropriate for the images color space . If ImageMask is true, the array must be
         * either [0 1] or [1 0]; otherwise, its length must be twice the number of color
         * components required by ColorSpace. Default value depends on the color space,
         * See Table 4.36 in PDF Ref. Manual.
         */
        getDecodeArray(): Promise<PDFNet.Obj>;
        /**
         * @returns A promise that resolves to the number of bits used to represent each color component. Only a
         * single value may be specified; the number of bits is the same for all color
         * components. Valid values are 1, 2, 4, 8, and 16.
         */
        getBitsPerComponent(): Promise<number>;
        /**
         * @returns A promise that resolves to the number of color components per sample.
         */
        getComponentNum(): Promise<number>;
        /**
         * @returns A promise that resolves to a boolean indicating whether the inline image is to be treated as an image mask.
         */
        isImageMask(): Promise<boolean>;
        /**
         * @returns A promise that resolves to a boolean indicating whether image interpolation is to be performed.
         */
        isImageInterpolate(): Promise<boolean>;
        /**
         * @returns A promise that resolves to an image XObject defining an image mask to be applied to this image (See
         * 'Explicit Masking', 4.8.5), or an array specifying a range of colors
         * to be applied to it as a color key mask (See 'Color Key Masking').
         *
         * If IsImageMask() return true, this method will return NULL.
         */
        getMask(): Promise<PDFNet.Obj>;
        /**
         * set an Explicit Image Mask.
         * @param image_mask - An Image object which serves as an explicit mask for the
         * base (this) image. The base image and the image mask need not have the
         * same resolution (Width and Height values), but since all images are defined on
         * the unit square in user space, their boundaries on the page will coincide; that is,
         * they will overlay each other. The image mask indicates which places on the page
         * are to be painted and which are to be masked out (left unchanged). Unmasked areas
         * are painted with the corresponding portions of the base image; masked areas
         * are not.
         *
         * Note: image_mask must be a valid image mask (i.e. image_mask.IsImageMask() must
         * return true.
         */
        setMask(image_mask: PDFNet.Image): Promise<void>;
        /**
         * set a Color Key Mask.
         * @param mask - is an Cos/SDF array specifying a range of colors to be masked
         * out. Samples in the image that fall within this range are not painted, allowing
         * the existing background to show through. The effect is similar to that of the
         * video technique known as chroma-key. For details of the array format please
         * refer to section 4.8.5 'Color Key Masking' in PDF Reference Manual.
         *
         * Note: the current document takes the ownership of the given SDF object.
         */
        setMaskWithObj(mask: PDFNet.Obj): Promise<void>;
        /**
         * @returns A promise that resolves to an image XObject defining a Soft Mask to be applied to this image
         * (See section 7.5.4 'Soft-Mask Images' in PDF Reference Manual), or NULL
         * if the image does not have the soft mask.
         */
        getSoftMask(): Promise<PDFNet.Obj>;
        /**
         * set a Soft Mask.
         * @param soft_mask - is a subsidiary Image object defining a soft-mask image
         * (See section 7.5.4 'Soft-Mask Images' in PDF Reference Manual) to be used
         * as a source of mask shape or mask opacity values in the transparent imaging
         * model. The alpha source parameter in the graphics state determines whether
         * the mask values are interpreted as shape or opacity.
         */
        setSoftMask(soft_mask: PDFNet.Image): Promise<void>;
        /**
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.GState.RenderingIntent = {
         * 	e_absolute_colorimetric : 0
         * 	e_relative_colorimetric : 1
         * 	e_saturation : 2
         * 	e_perceptual : 3
         * }
         * </pre>
         * @returns A promise that resolves to the color rendering intent to be used in rendering the image.
         */
        getImageRenderingIntent(): Promise<number>;
        /**
         * Saves this image to the output stream.
         * (0 PNG, 1 TIF, 2 JPEG).
         * @param writer - A pointer to FilterWriter used to write to the
         * output stream. If the parameter is null, nothing will be written
         * to the output stream, but the function returns the format identifier.
         * @returns A promise that resolves to the number indicating the selected image format:
         * Note: see the overloaded Image::Export method for more information.
         */
        exportFromStream(writer: PDFNet.FilterWriter): Promise<number>;
        /**
         * Saves this image to a TIFF output stream.
         * @param writer - FilterWriter used to write to the output stream.
         */
        exportAsTiffFromStream(writer: PDFNet.FilterWriter): Promise<void>;
        /**
         * Saves this image to a PNG output stream.
         * @param writer - FilterWriter used to write to the output stream.
         */
        exportAsPngFromStream(writer: PDFNet.FilterWriter): Promise<void>;
        /**
         * This function will fully download the image url as a memory buffer and embed it in the supplied PDFDoc.
         * @param doc - the PDF document in which to embed the image
         * @param url - The image url to download and embed.
         * @param [options] - Additional options
         * @param options.withCredentials - Whether to set the withCredentials property on the XMLHttpRequest
         * @param options.customHeaders - An object containing custom HTTP headers to be used when downloading the document
         * @returns A promise that resolves to an object of type: "Image"
         */
        static createFromURL(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, url: string, encoder_hints?: number, options?: {
            withCredentials: boolean;
            customHeaders: any;
        }): Promise<PDFNet.Image>;
    }
    /**
     * An ink annotation (PDF 1.3) represents a freehand "scribble" composed
     * of one or more disjoint paths. When opened, it shall display a pop-up
     * window containing the text of the associated note.
     */
    class InkAnnot extends PDFNet.MarkupAnnot {
        /**
         * creates an Ink annotation and initializes it using given Cos/SDF object.
         * @param [d] - The Cos/SDF object to initialze the annotation with.
         * Note: The constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @returns A promise that resolves to an object of type: "PDFNet.InkAnnot"
         */
        static createFromObj(d?: PDFNet.Obj): Promise<PDFNet.InkAnnot>;
        /**
         * creates an Ink annotation and initializes it using given annotation object.
         * @param ann - Annot object used to initialize the Ink annotation.
         * Note: The constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @returns A promise that resolves to an object of type: "PDFNet.InkAnnot"
         */
        static createFromAnnot(ann: PDFNet.Annot): Promise<PDFNet.InkAnnot>;
        /**
         * Creates a new Ink annotation in the specified document.
         * @param doc - A document to which the Ink annotation is added.
         * @param pos - A rectangle specifying the Ink annotation's bounds in default user space units.
         * @returns A promise that resolves to a newly created blank Ink annotation.
         */
        static create(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, pos: PDFNet.Rect): Promise<PDFNet.InkAnnot>;
        static create(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, type: number, pos: PDFNet.Rect): Promise<PDFNet.Annot>;
        /**
         * Returns number of paths in the annotation.
         * @returns A promise that resolves to an integer representing the number of paths in the 'InkList'
         * entry of the annotation dictionary.
         * Note: Each path is an array of Point objects specifying points along the path.
         * When drawn, the points shall be connected by straight lines or curves
         * in an implementation-dependent way.
         */
        getPathCount(): Promise<number>;
        /**
         * Returns number of points in a certain stroked path in the InkList.
         * @param pathindex - path index for each the point count is returned. Index starts at 0.
         * @returns A promise that resolves to an integer representing the number of points in the stroked path of the Ink list.
         */
        getPointCount(pathindex: number): Promise<number>;
        /**
         * Returns the specific point in a given path.
         * @param pathindex - path index for each the point is returned. Index starts at 0.
         * @param pointindex - index of point in the path. Index starts at 0.
         * @returns A promise that resolves to a Point object for specified path and point index.
         * Note: Each path is an array of Point objects specifying points along the path.
         * When drawn, the points shall be connected by straight lines or curves
         * in an implementation-dependent way.
         */
        getPoint(pathindex: number, pointindex: number): Promise<PDFNet.Point>;
        /**
         * sets the specific point in the Ink List, adding it if needed.
         * @param pathindex - An unsigned integer indicating the index of the path.
         * @param pointindex - An unsigned integer indicating the index of the point
         * within the stroked path indicated by the parameter "pathindex".
         * @param pt - A Point object that is to be assigned.
         * Note: Ink annotation contains an array of paths.
         * Each path is an array of Point objects specifying points along the path.
         * When drawn, the points shall be connected by straight lines or curves
         * in an implementation-dependent way.
         */
        setPoint(pathindex: number, pointindex: number, pt: PDFNet.Point): Promise<void>;
        /**
         * Erase a rectangle area formed by pt1pt2 with width
         * @param pt1 - A point object that is one end of the eraser segment
         * @param pt2 - A point object that is the other end of the eraser segment
         * @param width - The half width of the eraser
         * @returns A promise that resolves to whether an ink stroke was erased
         */
        erase(pt1: PDFNet.Point, pt2: PDFNet.Point, width: number): Promise<boolean>;
        /**
         * Retrieves whether the Ink will draw like a highlighter.
         * @returns A promise that resolves to true if the Ink will draw like a highlighter. (multiply blend mode)
         * If false it will draw in normal mode. (normal blend mode)
         */
        getHighlightIntent(): Promise<boolean>;
        /**
         * Enables or disables the Ink drawing like a highlighter.
         * @param highlight - true if the Ink will draw like a highlighter. (multiply blend mode)
         * If false it will draw in normal mode. (normal blend mode)
         */
        setHighlightIntent(highlight: boolean): Promise<void>;
    }
    /**
     * Supports a simple iteration over a generic collection.
     */
    class Iterator<T> extends PDFNet.Destroyable {
        /**
         * @returns A promise that resolves to true if the iterator can be successfully advanced to the
         * next element; false if the iterator is no longer valid.
         */
        hasNext(): Promise<boolean>;
        /**
         * Advances the iterator to the next element of the collection.
         */
        next(): Promise<void>;
        /**
         * @returns A promise that resolves to an object which this iterator points to.
         */
        current(): Promise<T>;
    }
    /**
     * [Missing documentation]
     */
    class KeyStrokeActionResult extends PDFNet.Destroyable {
        /**
         * @returns A promise that resolves to an object of type: "boolean"
         */
        isValid(): Promise<boolean>;
        /**
         * @returns A promise that resolves to an object of type: "string"
         */
        getText(): Promise<string>;
        /**
         * Copy Constructor
         * @returns A promise that resolves to an object of type: "PDFNet.KeyStrokeActionResult"
         */
        copy(): Promise<PDFNet.KeyStrokeActionResult>;
    }
    /**
     * [Missing documentation]
     */
    class KeyStrokeEventData extends PDFNet.Destroyable {
        /**
         * Constructor
         * @returns A promise that resolves to an object of type: "PDFNet.KeyStrokeEventData"
         */
        static create(field_name: string, current: string, change: string, selection_start: number, selection_end: number): Promise<PDFNet.KeyStrokeEventData>;
        /**
         * Copy Constructor
         * @returns A promise that resolves to an object of type: "PDFNet.KeyStrokeEventData"
         */
        copy(): Promise<PDFNet.KeyStrokeEventData>;
    }
    /**
     * A line annotation (PDF 1.3) is used to display a single straight
     * line on the page. When opened, it should display a pop-up window containing
     * the text of the associated note.
     */
    class LineAnnot extends PDFNet.MarkupAnnot {
        /**
         * creates a Line annotation and initializes it using given Cos/SDF object.
         * Note: The constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @returns A promise that resolves to an object of type: "PDFNet.LineAnnot"
         */
        static createFromObj(d?: PDFNet.Obj): Promise<PDFNet.LineAnnot>;
        /**
         * creates a Line annotation and initializes it using given annotation object.
         * @param ann - Annot object used to initialize the Line annotation.
         * Note: The constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @returns A promise that resolves to an object of type: "PDFNet.LineAnnot"
         */
        static createFromAnnot(ann: PDFNet.Annot): Promise<PDFNet.LineAnnot>;
        /**
         * Creates a new Line annotation in the specified document.
         * @param doc - A document to which the annotation is added.
         * @param pos - A rectangle specifying the annotation's bounds in default user space units.
         * @returns A promise that resolves to a newly created blank Line annotation.
         */
        static create(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, pos: PDFNet.Rect): Promise<PDFNet.LineAnnot>;
        static create(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, type: number, pos: PDFNet.Rect): Promise<PDFNet.Annot>;
        /**
         * Returns the coordinates of the start of a line.
         * @returns A promise that resolves to a point specifying the coordinates of the start of the line.
         */
        getStartPoint(): Promise<PDFNet.Point>;
        /**
         * sets the coordinates of the start of a line.
         * @param sp - A point specifying the coordinates of the end of the line.
         */
        setStartPoint(sp: PDFNet.Point): Promise<void>;
        /**
         * Returns the coordinates of the end of a line.
         * @returns A promise that resolves to a point specifying the coordinates of the end of the line.
         */
        getEndPoint(): Promise<PDFNet.Point>;
        /**
         * sets the coordinates of the end of a line.
         * @param ep - A point specifying the coordinates of the end of the line.
         */
        setEndPoint(ep: PDFNet.Point): Promise<void>;
        /**
         * Returns the ending style that applies to the first point of the line.
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.LineAnnot.EndingStyle = {
         * 	e_Square : 0
         * 	e_Circle : 1
         * 	e_Diamond : 2
         * 	e_OpenArrow : 3
         * 	e_ClosedArrow : 4
         * 	e_Butt : 5
         * 	e_ROpenArrow : 6
         * 	e_RClosedArrow : 7
         * 	e_Slash : 8
         * 	e_None : 9
         * 	e_Unknown : 10
         * }
         * </pre>
         * @returns A promise that resolves to a enum value from the "EndingStyle".
         * Note: Default value: e_None.
         */
        getStartStyle(): Promise<number>;
        /**
         * sets the ending style that applies to the first point of the line.
         * (Optional; PDF 1.4.)
         * @param ss - <pre>
         * PDFNet.LineAnnot.EndingStyle = {
         * 	e_Square : 0
         * 	e_Circle : 1
         * 	e_Diamond : 2
         * 	e_OpenArrow : 3
         * 	e_ClosedArrow : 4
         * 	e_Butt : 5
         * 	e_ROpenArrow : 6
         * 	e_RClosedArrow : 7
         * 	e_Slash : 8
         * 	e_None : 9
         * 	e_Unknown : 10
         * }
         * </pre>
         * A enum value from the "EndingStyle".
         * Note: Default value: e_None.
         */
        setStartStyle(ss: number): Promise<void>;
        /**
         * Returns the ending style  that applies to the second point of the line.
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.LineAnnot.EndingStyle = {
         * 	e_Square : 0
         * 	e_Circle : 1
         * 	e_Diamond : 2
         * 	e_OpenArrow : 3
         * 	e_ClosedArrow : 4
         * 	e_Butt : 5
         * 	e_ROpenArrow : 6
         * 	e_RClosedArrow : 7
         * 	e_Slash : 8
         * 	e_None : 9
         * 	e_Unknown : 10
         * }
         * </pre>
         * @returns A promise that resolves to a enum value from the "EndingStyle".
         * Note: Default value: e_None.
         */
        getEndStyle(): Promise<number>;
        /**
         * sets the ending style  that applies to the second point of the line.
         * (Optional; PDF 1.4)
         * @param es - <pre>
         * PDFNet.LineAnnot.EndingStyle = {
         * 	e_Square : 0
         * 	e_Circle : 1
         * 	e_Diamond : 2
         * 	e_OpenArrow : 3
         * 	e_ClosedArrow : 4
         * 	e_Butt : 5
         * 	e_ROpenArrow : 6
         * 	e_RClosedArrow : 7
         * 	e_Slash : 8
         * 	e_None : 9
         * 	e_Unknown : 10
         * }
         * </pre>
         * A enum value from the "EndingStyle".
         * Note: Default value: e_None.
         */
        setEndStyle(es: number): Promise<void>;
        /**
         * Returns the leader line length of a line.
         * @returns A promise that resolves to a number denoting the length of the leader line in default user space units.
         * Note: Usually if this entry is specified, the line is intended to be a dimension line (see
         * "IT" entry of the annotation dictionary).
         * Note: Leader length is length of leader lines in default user space that extend from each endpoint
         * of the line perpendicular to the line itself. A positive value shall mean that the leader lines
         * appear in the direction that is clockwise when traversing the line from its starting point to
         * its ending point (as specified by L); a negative value shall indicate the opposite direction.
         * Default value: 0 (no leader lines)
         */
        getLeaderLineLength(): Promise<number>;
        /**
         * Sets the leader line length of a line.
         * (PDF 1.6)
         * @param length - A number denoting the length of the leader line in default user space units.
         * Note: Usually if this entry is specified, the line is intended to be a dimension line (see
         * "IT" entry of the annotation dictionary).
         * Note: Leader length is length of leader lines in default user space that extend from each endpoint
         * of the line perpendicular to the line itself. A positive value shall mean that the leader lines
         * appear in the direction that is clockwise when traversing the line from its starting point to
         * its ending point (as specified by L); a negative value shall indicate the opposite direction.
         * Default value: 0 (no leader lines)
         */
        setLeaderLineLength(length: number): Promise<void>;
        /**
         * Returns the leader line extension length of a line.
         * @returns A promise that resolves to a number denoting the length of the leader line extension in default user space units.
         * Note: The leader line extension length is a non-negative number that shall represents
         * the length of leader line extensions that extend from the line proper 180 degrees from
         * the leader lines.
         * Default value: 0 (no leader line extensions)
         */
        getLeaderLineExtensionLength(): Promise<number>;
        /**
         * Sets the leader line extension length of a line.
         * (PDF 1.6)
         * @param length - A number denoting the length of the leader line extension in default user space units.
         * Note: The leader line extension length is a non-negative number that shall represents
         * the length of leader line extensions that extend from the line proper 180 degrees from
         * the leader lines.
         * Default value: 0 (no leader line extensions)
         */
        setLeaderLineExtensionLength(length: number): Promise<void>;
        /**
         * Returns true if caption is to be shown, otherwise false.
         * @returns A promise that resolves to a boolean value indicating whether the caption will be shown.
         * Note: If true, the text specified by the Contents or RCentries shall be replicated as a
         * caption in the appearance of the line. The text shall be rendered in a manner
         * appropriate to the content, taking into account factors such as writing direction.
         * Default value: false.
         */
        getShowCaption(): Promise<boolean>;
        /**
         * Sets the option of whether to show caption.
         * @param showCaption - A boolean value indicating whether the caption will be shown.
         * Note: If true, the text specified by the Contents or RC entries shall be replicated as a
         * caption in the appearance of the line. The text shall be rendered in a manner
         * appropriate to the content, taking into account factors such as writing direction.
         * Default value: false.
         */
        setShowCaption(showCaption: boolean): Promise<void>;
        /**
         * Returns the intent type of the line.
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.LineAnnot.IntentType = {
         * 	e_LineArrow : 0
         * 	e_LineDimension : 1
         * 	e_null : 2
         * }
         * </pre>
         * @returns A promise that resolves to an intent type value from the "IntentType" enum.
         * Note: Intent type describes the intent of the line annotation. Valid values shall be "e_LineArrow", which means
         * that the annotation is intended to function as an arrow, and "e_LineDimension", which means that the annotation
         * is intended to function as a dimension line.
         */
        getIntentType(): Promise<number>;
        /**
         * sets the intent type of the line.
         * (For PDF 1.6)
         * @param it - <pre>
         * PDFNet.LineAnnot.IntentType = {
         * 	e_LineArrow : 0
         * 	e_LineDimension : 1
         * 	e_null : 2
         * }
         * </pre>
         * An intent type value from the "IntentType" enum.
         * Note: Intent type describes the intent of the line annotation. Valid values shall be "e_LineArrow", which means
         * that the annotation is intended to function as an arrow, and "e_LineDimension", which means that the annotation
         * is intended to function as a dimension line.
         */
        setIntentType(it: number): Promise<void>;
        /**
         * @returns A promise that resolves to an object of type: "number"
         * <pre>
         * PDFNet.LineAnnot.CapPos = {
         * 	e_Inline : 0
         * 	e_Top : 1
         * }
         * </pre>
         */
        getCapPos(): Promise<number>;
        /**
         * @param it - <pre>
         * PDFNet.LineAnnot.CapPos = {
         * 	e_Inline : 0
         * 	e_Top : 1
         * }
         * </pre>
         */
        setCapPos(it: number): Promise<void>;
        /**
         * Returns the leader line offset length of a line.
         * @returns A promise that resolves to a number denoting the length of the leader line offset in default user space units.
         * Note: Leader line offset number is a non-negative number that shall represent the length of the leader
         * line offset, which is the amount of empty space between the endpoints of the
         * annotation and the beginning of the leader lines.
         */
        getLeaderLineOffset(): Promise<number>;
        /**
         * sets the leader line offset length of a line.
         * (PDF 1.7)
         * @param length - A number denoting the length of the leader line offset in default user space units.
         * Note: Leader line offset number is a non-negative number that shall represent the length of the leader
         * line offset, which is the amount of empty space between the endpoints of the
         * annotation and the beginning of the leader lines.
         */
        setLeaderLineOffset(length: number): Promise<void>;
        /**
         * Returns the horizontal offset of the caption.
         * @returns A promise that resolves to a number denoting the horizontal offset of the caption in default user space units.
         * Note: The horizontal offset specifies the offset of the caption text from the line's midpoint,
         * with a positive value indicating offset to the right and a negative value indicating offset to the left.
         * Default value: 0 (no offset from normal horizontal positioning).
         */
        getTextHOffset(): Promise<number>;
        /**
         * sets the horizontal offset of the caption.
         * (For PDF 1.7 )
         * @param offset - A number denoting the horizontal offset of the caption in default user space units.
         * Note: The horizontal offset specifies the offset of the caption text from the line's midpoint,
         * with a positive value indicating offset to the right and a negative value indicating offset to the left.
         * Default value: 0 (no offset from normal horizontal positioning).
         */
        setTextHOffset(offset: number): Promise<void>;
        /**
         * Returns the vertical offset of the caption.
         * @returns A promise that resolves to a number denoting the vertical offset of the caption in default user space units.
         * Note: The vertical offset specifies the offset of the caption text perpendicular to the annotation line,
         * with a positive value indicating a shift up and a negative value indicating a shift down.
         * Default value: 0 (no offset from normal vertical positioning).
         */
        getTextVOffset(): Promise<number>;
        /**
         * sets the vertical offset of the caption.
         * (For PDF 1.7 )
         * @param offset - A number denoting the vertical offset of the caption in default user space units.
         * Note: The vertical offset specifies the offset of the caption text perpendicular to the annotation line,
         * with a positive value indicating a shift up and a negative value indicating a shift down.
         * Default value: 0 (no offset from normal vertical positioning).
         */
        setTextVOffset(offset: number): Promise<void>;
    }
    /**
     * A link annotation represents either a hypertext link to a destination elsewhere in the document
     * or an action to be performed.
     */
    class LinkAnnot extends PDFNet.Annot {
        /**
         * creates a Link annotation and initializes it using given Cos/SDF object.
         * @param [d] - The Cos/SDF object to initialze the annotation with.
         * Note: The constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @returns A promise that resolves to an object of type: "PDFNet.LinkAnnot"
         */
        static createFromObj(d?: PDFNet.Obj): Promise<PDFNet.LinkAnnot>;
        /**
         * creates a Link annotation and initializes it using given annotation object.
         * @param ann - Annot object used to initialize the Link annotation.
         * Note: The constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @returns A promise that resolves to an object of type: "PDFNet.LinkAnnot"
         */
        static createFromAnnot(ann: PDFNet.Annot): Promise<PDFNet.LinkAnnot>;
        /**
         * Creates a new Link annotation in the specified document.
         * @param doc - A document to which the Link annotation is added.
         * @param pos - A rectangle specifying the Link annotation's bounds in default user space units.
         * @returns A promise that resolves to a newly created blank Link annotation.
         */
        static create(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, pos: PDFNet.Rect): Promise<PDFNet.LinkAnnot>;
        static create(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, type: number, pos: PDFNet.Rect): Promise<PDFNet.Annot>;
        /**
         * removes this annotation's action.
         */
        removeAction(): Promise<void>;
        /**
         * Returns the Action of the Link Annotation.
         * @returns A promise that resolves to an Action object of the Link annotation.
         * Note: The return value is an action that shall be performed when the
         * link annotation is activated
         */
        getAction(): Promise<PDFNet.Action>;
        /**
         * sets the Action of the Link Annotation.
         * (Optional; PDF 1.1 )
         * @param action - An Action object that shall be associated with this Link annotation.
         * Note: The parameter is an action that shall be performed when the
         * link annotation is activated.
         */
        setAction(action: PDFNet.Action): Promise<void>;
        /**
         * Returns the highlighting mode of this Link annotation.
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.LinkAnnot.HighlightingMode = {
         * 	e_none : 0
         * 	e_invert : 1
         * 	e_outline : 2
         * 	e_push : 3
         * }
         * </pre>
         * @returns A promise that resolves to the highLighting mode as a value of the enum "HighlightingMode".
         * Note: The annotation's highlighting mode is the visual effect that shall be used when
         * the mouse button is pressed or held down inside its active area.
         */
        getHighlightingMode(): Promise<number>;
        /**
         * Sets the highlighting mode for this Link annotation.
         * (Optional; PDF 1.2 )
         * @param value - <pre>
         * PDFNet.LinkAnnot.HighlightingMode = {
         * 	e_none : 0
         * 	e_invert : 1
         * 	e_outline : 2
         * 	e_push : 3
         * }
         * </pre>
         * the mode as a value of the enum "HighlightingMode".
         * Note: The annotation's highlighting mode is the visual effect that shall be used when
         * the mouse button is pressed or held down inside its active area.
         */
        setHighlightingMode(value: number): Promise<void>;
        /**
         * Returns the number of QuadPoints in the 'QuadPoints' array of the Link annotation.
         * @returns A promise that resolves to the number of QuadPoints.
         * Note: An array of n QuadPoints specifying the coordinates of n quadrilaterals
         * in default user space that comprise the region in which the link should be active.
         * The coordinates specifying the four vertices of the quadrilateral are in counterclockwise order.
         * For orientation purposes, the bottom of a quadrilateral is the line formed by p1 and p2 of the QuadPoint.
         * QuadPoints shall be ignored if any coordinate in the array lies outside the region specified by Rect.
         */
        getQuadPointCount(): Promise<number>;
        /**
         * Returns the QuadPoint located at a certain index of the QuadPoint array of the Link
         * annotation.
         * @param idx - The index of the QuadPoint, starts at zero and should be less than the return value of GetQuadPointCount().
         * @returns A promise that resolves to the QuadPoint located at a certain index of the QuadPoint array of the Link annotation.
         * Note: An array of n QuadPoints specifying the coordinates of n quadrilaterals
         * in default user space that comprise the region in which the link should be active.
         * The coordinates specifying the four vertices of the quadrilateral are in counterclockwise order.
         * For orientation purposes, the bottom of a quadrilateral is the line formed by p1 and p2 of the QuadPoint.
         * QuadPoints shall be ignored if any coordinate in the array lies outside the region specified by Rect.
         */
        getQuadPoint(idx: number): Promise<PDFNet.QuadPoint>;
        /**
         * set the QuadPoint to be located at a certain index of the QuadPoint array of the Link annotation.
         * (Optional; PDF 1.6 )
         * @param idx - The index of the QuadPoint, starts at zero and should be less than the return value of GetQuadPointCount().
         * @param qp - The QuadPoint to be stored in the annotation.
         * Note: An array of n QuadPoints specifying the coordinates of n quadrilaterals
         * in default user space that comprise the region in which the link should be active.
         * The coordinates specifying the four vertices of the quadrilateral are in counterclockwise order.
         * For orientation purposes, the bottom of a quadrilateral is the line formed by p1 and p2 of the QuadPoint.
         * QuadPoints shall be ignored if any coordinate in the array lies outside the region specified by Rect.
         */
        setQuadPoint(idx: number, qp: PDFNet.QuadPoint): Promise<void>;
    }
    /**
     * An object representing a List Box used in a PDF Form.
     */
    class ListBoxWidget extends PDFNet.WidgetAnnot {
        /**
         * Creates a new List Box Widget annotation, in the specified document.
         * @param doc - The document to which the annotation is added.
         * @param pos - A rectangle specifying the annotation's bounds, specified in
         * user space coordinates.
         * @param [field_name] - The name of the field for which to create a List Box Widget
         * @returns A promise that resolves to a newly created blank List Box Widget annotation.
         */
        static create(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, pos: PDFNet.Rect, field_name?: string): Promise<PDFNet.ListBoxWidget>;
        static create(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, pos: PDFNet.Rect, field: PDFNet.Field): Promise<PDFNet.WidgetAnnot>;
        static create(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, type: number, pos: PDFNet.Rect): Promise<PDFNet.Annot>;
        /**
         * Creates a new List Box Widget annotation, in the specified document.
         * @param doc - The document to which the annotation is added.
         * @param pos - A rectangle specifying the annotation's bounds, specified in
         * user space coordinates.
         * @param field - the field for which to create a List Box Widget
         * @returns A promise that resolves to a newly created blank List Box Widget annotation.
         */
        static createWithField(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, pos: PDFNet.Rect, field: PDFNet.Field): Promise<PDFNet.ListBoxWidget>;
        /**
         * Creates a List Box Widget annotation and initialize it using given Cos/SDF object.
         *
         * <p>
         * <b> Note: </b> The constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @param [d] - the object to use to initialize the List Box Widget
         * @returns A promise that resolves to an object of type: "PDFNet.ListBoxWidget"
         */
        static createFromObj(d?: PDFNet.Obj): Promise<PDFNet.ListBoxWidget>;
        /**
         * Creates a List Box Widget annotation and initialize it using given annotation object.
         *
         * <p>
         * <b> Note: </b>  The constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @param annot - The annotation to use.
         * @returns A promise that resolves to an object of type: "PDFNet.ListBoxWidget"
         */
        static createFromAnnot(annot: PDFNet.Annot): Promise<PDFNet.ListBoxWidget>;
        /**
         * Adds option to List Box Widget.
         * @param value - The option to add
         */
        addOption(value: string): Promise<void>;
        /**
         * Adds multiple options to List Box Widget.
         * @param opts - The options to add.
         */
        addOptions(opts: string[]): Promise<void>;
        /**
         * Sets the options for the ListBox widget.
         * @param selected_opts - The options to select.
         */
        setSelectedOptions(selected_opts: string[]): Promise<void>;
        /**
         * Replaces the current List Box widget options with a new set.
         * @param new_opts - The new set of options to use.
         */
        replaceOptions(new_opts: string[]): Promise<void>;
        /**
         * Removes the option from List Box widget.
         * @param value - The option to remove.
         */
        removeOption(value: string): Promise<void>;
    }
    /**
     * Markup is a base class for a number of annotations types that
     * are used to mark up PDF documents. These annotations have text that
     * appears as part of the annotation and may be displayed in other ways by a
     * conforming reader, such as in a Comments pane.
     * Markup annotations may be divided into the following groups:
     * - Free text annotations display text directly on the page.
     *   The annotation's Contents entry specifies the displayed text.
     * - Most other markup annotations have an associated pop-up window
     *   that may contain text. The annotation's Contents entry specifies
     *   the text that shall be displayed when the pop-up window is opened.
     *   These include text, line, square, circle, polygon, polyline,
     *   highlight,underline, squiggly-underline, strikeout, rubber stamp,
     *   caret, ink, and file attachment annotations.
     * - Sound annotations do not have a pop-up window but may also have
     *   associated text specified by the Contents entry.
     * - A subset of markup annotations are intended to markup text of a
     *   document (e.g. highlight, strikeout, jagged, underline) and they
     *   are derived from TextMarkup base class.
     *
     * Note: The pop-up annotation type must not appear by itself; it must be
     * associated with a markup annotation that uses it to display text.
     *
     * The meaning of an annotation's Contents entry varies by annotation type.
     * Typically, it is the text that shall be displayed for the annotation or,
     * if the annotation does not display text, an alternate description of the
     * annotation's contents in human-readable form. When separating text into
     * paragraphs, a CARRIAGE RETURN (0Dh) must be used.
     */
    class MarkupAnnot extends PDFNet.Annot {
        /**
         * creates a markup annotation and initializes it using given Cos/SDF object.
         * @param [d] - The Cos/SDF object to initialze the annotation with.
         * Note: The constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @returns A promise that resolves to an object of type: "PDFNet.MarkupAnnot"
         */
        static createFromObj(d?: PDFNet.Obj): Promise<PDFNet.MarkupAnnot>;
        /**
         * creates a markup annotation and initializes it using given annotation object.
         * @param ann - Annot object used to initialize the Markup annotation.
         * Note: The constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @returns A promise that resolves to an object of type: "PDFNet.MarkupAnnot"
         */
        static createFromAnnot(ann: PDFNet.Annot): Promise<PDFNet.MarkupAnnot>;
        /**
         * Returns the title of the markup annotation.
         * @returns A promise that resolves to a string representing the title of the markup annotation,
         * or null is the title is not specified.
         *
         * Note: The title is The text label that is displayed in the
         * title bar of the annotation's pop-up window when open and active
         * Markup annotation.
         * This entry is also used to identify the user who added the annotation.
         * It corresponds to the 'T' field of the annotation's dictionary.
         */
        getTitle(): Promise<string>;
        /**
         * sets the title of the markup annotation.
         * (Optional; PDF 1.1)
         * @param title - A string.
         * Note: The title is The text label that is displayed in the
         * title bar of the annotation's pop-up window when open and active
         * Markup annotation.
         * This entry is also used to identify the user who added the annotation.
         * It corresponds to the 'T' field of the annotation's dictionary.
         */
        setTitle(title: string): Promise<void>;
        /**
         * sets the title of the markup annotation.
         * (Optional; PDF 1.1)
         * @param title - A string.
         * Note: The title is The text label that is displayed in the
         * title bar of the annotation's pop-up window when open and active
         * Markup annotation.
         * This entry is also used to identify the user who added the annotation.
         * It corresponds to the 'T' field of the annotation's dictionary.
         */
        setTitleUString(title: string): Promise<void>;
        /**
         * Returns the Popup object associated with this markup annotation.
         * @returns A promise that resolves to a Popup object that is associated with this markup annotation.
         * Note: The Popup is An indirect reference to a pop-up annotation for
         * entering or editing the text associated with this annotation.
         */
        getPopup(): Promise<PDFNet.Annot>;
        /**
         * Sets the Popup object associated with this markup annotation.
         * (Optional; PDF 1.3 )
         * @param ppup - A Popup object that is associated with this markup annotation.
         * Note: the Popup is An indirect reference to a pop-up annotation for
         * entering or editing the text associated with this annotation.
         */
        setPopup(ppup: PDFNet.Annot): Promise<void>;
        /**
         * @returns A promise that resolves to the opacity value.
         * Default value: 1.0.
         * Note: This value is applied to all visible elements of the annotation in its closed state
         * (including its background and border) but not to the pop-up window that appears when
         * the annotation is opened. When an appearance stream is presented with the annotation,
         * this entry is ignored.(However, if the compliant viewer regenerates
         * the annotation's appearance stream, it may incorporate this Opacity entry
         * into the stream's content.)
         * Note: This corresponds to the 'CA' field of the annotation's dictionary.
         */
        getOpacity(): Promise<number>;
        /**
         * Sets the opacity value for the annotation.
         * (Optional; PDF 1.4 )
         * @param op - A number indicating the Markup annotation's opacity value.
         * Default value: 1.0.
         * Note: This value is applied to all visible elements of the annotation in its closed state
         * (including its background and border) but not to the pop-up window that appears when
         * the annotation is opened. When an appearance stream is presented with the annotation,
         * this entry is ignored.(However, if the compliant viewer regenerates
         * the annotation's appearance stream, it may incorporate this Opacity entry
         * into the stream's content.)
         * Note: This corresponds to the 'CA' field of the annotation's dictionary.
         */
        setOpacity(op: number): Promise<void>;
        /**
         * Returns the subject of the Markup annotation.
         * (PDF 1.5)
         * @returns A promise that resolves to a string representing the subject of the Markup annotation.
         * Note: The subject is a short piece of text description about the annotation.
         * Note: This corresponds to the 'Subj' field of the annotation's dictionary.
         */
        getSubject(): Promise<string>;
        /**
         * Sets subject of the Markup annotation.
         * (Optional; PDF 1.5 )
         * @param contents - A string representing the subject of the Markup annotation.
         * Note: The subject is a short piece of text description about the annotation.
         * Note: This corresponds to the 'Subj' field of the annotation's dictionary.
         */
        setSubject(contents: string): Promise<void>;
        /**
         * @returns A promise that resolves to the creation date for the markup annotation.
         *
         * Note: This corresponds to the 'CreationDate' field of the markup annotation's dictionary.
         */
        getCreationDates(): Promise<PDFNet.Date>;
        /**
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.MarkupAnnot.BorderEffect = {
         * 	e_None : 0
         * 	e_Cloudy : 1
         * }
         * </pre>
         * @returns A promise that resolves to the border effect of the markup annotation.
         * Default value: e_None.
         *
         * Beginning with PDF 1.5, some annotations (square, circle, and polygon) may have a 'BE' entry,
         * which is a border effect dictionary that specifies an effect that shall be applied to the border
         * of the annotations. Beginning with PDF 1.6, the free text annotation may also have a BE entry.
         * Note: When "e_Cloudy" is chosen,the width and
         * dash array specified by the annotation's BorderStyle entry
         * needs to be taken into consideration.
         */
        getBorderEffect(): Promise<number>;
        /**
         * Sets the border effect of the markup annotation. (Optional; PDF 1.5 )
         *
         * Beginning with PDF 1.5, some annotations (square, circle, and polygon) may have a 'BE' entry,
         * which is a border effect dictionary that specifies an effect that shall be applied to the border
         * of the annotations. Beginning with PDF 1.6, the free text annotation may also have a BE entry.
         * @param [effect] - <pre>
         * PDFNet.MarkupAnnot.BorderEffect = {
         * 	e_None : 0
         * 	e_Cloudy : 1
         * }
         * </pre>
         * An entry from the enum "BorderEffect" that
         * represents the border effect of the Markup annotation.
         * Default value: e_None.
         * Note: When "e_Cloudy" is chosen,the width and
         * dash array specified by the annotation's BorderStyle entry
         * needs to be taken into consideration.
         */
        setBorderEffect(effect?: number): Promise<void>;
        /**
         * @returns A promise that resolves to a number describing the intensity of the border effect, in the range 0 to 2.
         *
         * Beginning with PDF 1.5, some annotations (square, circle, and polygon) may have a 'BE' entry,
         * which is a border effect dictionary that specifies an effect that shall be applied to the border
         * of the annotations. Beginning with PDF 1.6, the free text annotation may also have a BE entry.
         */
        getBorderEffectIntensity(): Promise<number>;
        /**
         * sets the border effect intensity of the markup annotation.
         * (Optional; valid only if Border effect is Cloudy)
         *
         * Beginning with PDF 1.5, some annotations (square, circle, and polygon) may have a 'BE' entry,
         * which is a border effect dictionary that specifies an effect that shall be applied to the border
         * of the annotations. Beginning with PDF 1.6, the free text annotation may also have a BE entry.
         * @param [intensity] - A number describing the intensity of the border effect, in the
         * range 0 (which is default) to 2.
         * Note: this parameter applies only if Border effect is e_Cloudy.
         */
        setBorderEffectIntensity(intensity?: number): Promise<void>;
        /**
         * Sets the creation date for the markup annotation.
         * (Optional; PDF 1.5 )
         * @param dt - A Date object indicating the date the markup annotation is created.
         * Note: This corresponds to the 'CreationDate' field of the markup annotation's dictionary.
         */
        setCreationDates(dt: PDFNet.Date): Promise<void>;
        /**
         * Returns the interior color of the annotation.
         * @returns A promise that resolves to a ColorPt object that denotes the color of the annotation.
         * Note: The color can be in different color spaces: Gray, RGB, or CMYK.
         * Call "GetInteriorColorCompNum" to access the color space information.
         * Note: According to PDF Reference Manual interior color is not the property
         * that is expected for Markup annotations in general, but it applies
         * to many derived annotations (Line,Square,Circle,Polygon,PolyLine,Redaction) and therefore get()/set() methods are
         * provided in the base class Markup. Annotations that do not use interior color
         * will ignore the interior color ('IC' entry), if present in their annotation dictionary.
         * In case no color is specified, CMYK white is returned.
         */
        getInteriorColor(): Promise<PDFNet.ColorPt>;
        /**
         * Returns the number indicating the interior color space of the annotation.
         * @returns A promise that resolves to an integer indicating the number of channels forming the color space.
         * 3 corresponds to RGB, 4 corresponds to CMYK, and 1 corresponds to Gray.
         * If the interior is transparent, the return value is 0.
         */
        getInteriorColorCompNum(): Promise<number>;
        setInteriorColorRGB(col: PDFNet.ColorPt): Promise<void>;
        /**
         * Sets the interior color of the Markup annotation.
         * @param c - A ColorPt object that denotes the color of the Markup annotation.
         * @param CompNum - An integer indicating the number of channels forming the
         * color space used. It also defines the length of the array to be allocated
         * for storing the entries of c.
         * Note: It is necessary to make sure the consistency between the type of
         * parameter c and the value of parameter CompNum. RGB ColorPt corresponds to 3,
         * CMYK ColorPt corresponds to 4, Gray ColorPt corresponds to 1, and transparent
         * corresponds to 0.
         * Note: According to PDF Reference Manual interior color is not the property
         * that is expected for Markup annotations in general, but it applies
         * to many derived annotation classes and therefore get()/set() methods are
         * provided in the base class Markup. Annotations that do not use interior color
         * will ignore the interior color ('IC' entry), if present in their annotation dictionary.
         *
         * Entries out of the specified color space array length will be discarded.
         * Missing entries for a specified color space will lead to potential
         * exceptions.
         */
        setInteriorColor(c: PDFNet.ColorPt, CompNum: number): Promise<void>;
        /**
         * Returns the inner bounding rectangle of the Markup annotation.
         * @returns A promise that resolves to a rectangle specifying the region where content should be displayed.
         *
         * Note: This rectangle can be same as or inside of  the annotation's rectangle.
         * If it is smaller, such a difference may occur in
         * situations where a border effect causes the size of the annotation Rect
         * entry to increase beyond that of the rectangle. For FreeText annotation with
         * a callout, content rectangle specifies an inner region for the text to be displayed.
         * Note: According to PDF Reference Manual content rectangle is not the property
         * that is expected for Markup annotations in general, but it applies
         * to many derived annotation classes (FreeText,Square,Circle,Caret) and therefore get()/set() methods are
         * provided in the base class Markup. Annotations that do not use this property
         * will ignore the content rectangle ('RD' entry), if present in their annotation dictionary.
         */
        getContentRect(): Promise<PDFNet.Rect>;
        /**
         * sets the inner bounding rectangle of the Markup annotation. (Optional)
         * @param cr - A Rect struct to be assign to the 'RD' entry of the annotation dictionary.
         * Note: This rectangle can be same as or inside of  the annotation's rectangle.
         * If it is smaller, such a difference may occur in
         * situations where a border effect causes the size of the annotation Rect
         * entry to increase beyond that of the rectangle. For FreeText annotation with
         * a callout, content rectangle specifies an inner region for the text to be displayed.
         * Note: According to PDF Reference Manual content rectangle is not the property
         * that is expected for Markup annotations in general, but it applies
         * to many derived annotation classes (FreeText,Square,Circle,Caret) and therefore get()/set() methods are
         * provided in the base class Markup. Annotations that do not use this property
         * will ignore the content rectangle ('RD' entry), if present in their annotation dictionary.
         */
        setContentRect(cr: PDFNet.Rect): Promise<void>;
        /**
         * Returns the rectangle difference between overall annotation rectangle and content rectangle.
         * @returns A promise that resolves to a set of four numbers represented as a Rect struct.
         * Note: The four numbers of the returning struct specify the difference
         * between two rectangles: the Rect entry of the annotation and the actual
         * bounding box of the underlying rectangle. Such a difference may occur in
         * situations where a border effect causes the size of the annotation Rect
         * entry to increase beyond that of the rectangle.
         * The four numbers of the returning struct correspond to the differences
         * in default user space, between the left, top, right, and bottom of the
         * two above mentioned rectangles.
         * Note: GetPadding() and GetContentRectangle() both use 'RD' entry of the
         * annotation dictionary, but represent it to user in different ways.
         */
        getPadding(): Promise<PDFNet.Rect>;
        /**
         * sets the rectangle difference between overall annotation rectangle and content rectangle. (Optional)
         * @param rd - A set of four numbers represented as a Rect struct
         * Note: The four numbers of rd specify the difference
         * between two rectangles: the Rect entry of the annotation and the actual
         * bounding box of the underlying rectangle. Such a difference may occur in
         * situations where a border effect causes the size of the annotation Rect
         * entry to increase beyond that of the rectangle.
         * The four numbers of the rd correspond to the differences
         * in default user space, between the left, top, right, and bottom of the
         * two above mentioned rectangles.
         * Note: SetPadding() and SetContentRectangle() both use 'RD' entry of the
         * annotation dictionary. Two methods are provided to give users additional
         * flexibility and ease of use in setting the values of the 'RD' field.
         */
        setPadding(rd: PDFNet.Rect): Promise<void>;
        /**
         * Rotates the appearance of the Markup annotation.
         * @param angle - The new rotation
         * Note: Apply a rotation to an existing appearance.
         * This rotation will be reflected in the bounding rect of the annot (which
         * will be updated), but not in any other part of the annotation dictionary.
         * This will effectively create a custom appearance for the annotation,
         * and any subsequent calls to `RefreshAppearance` will clear this transformation.
         */
        rotateAppearance(angle: number): Promise<void>;
    }
    /**
     * 2D Matrix
     *
     * A Matrix2D object represents a 3x3 matrix that, in turn, represents an affine transformation.
     * A Matrix2D object stores only six of the nine numbers in a 3x3 matrix because all 3x3
     * matrices that represent affine transformations have the same third column (0, 0, 1).
     *
     * Affine transformations include rotating, scaling, reflecting, shearing, and translating.
     * In PDFNet, the Matrix2D class provides the foundation for performing affine transformations
     * on vector drawings, images, and text.
     *
     * A transformation matrix specifies the relationship between two coordinate spaces.
     * By modifying a transformation matrix, objects can be scaled, rotated, translated,
     * or transformed in other ways.
     *
     * A transformation matrix in PDF is specified by six numbers, usually in the form
     * of an array containing six elements. In its most general form, this array is denoted
     * [a b c d h v]; The following table lists the arrays that specify the most common
     * transformations:
     *
     *   - Translations are specified as [1 0 0 1 tx ty], where tx and ty are the distances
     *     to translate the origin of the coordinate system in the horizontal and vertical
     *     dimensions, respectively.
     *
     *   - Scaling is obtained by [sx 0 0 sy 0 0]. This scales the coordinates so that 1
     *     unit in the horizontal and vertical dimensions of the new coordinate system is
     *     the same size as sx and sy units, respectively, in the previous coordinate system.
     *
     *   - Rotations are produced by [cos(A) sin(A) -sin(A) cos(A) 0 0], which has the effect
     *     of rotating the coordinate system axes by an angle 'A' counterclockwise.
     *
     *   - Skew is specified by [1 tan(A) tan(B) 1 0 0], which skews the x axis by an angle
     *     A and the y axis by an angle B.
     *
     *  Matrix2D elements are positioned as follows :
     * 			| m_a m_b 0 |
     * 			| m_c m_d 0 |
     * 			| m_h m_v 1 |
     *
     * A single Matrix2D object can store a single transformation or a sequence of transformations.
     * The latter is called a composite transformation. The matrix of a composite transformation is
     * obtained by multiplying (concatenating) the matrices of the individual transformations.
     * Because matrix multiplication is not commutative-the order in which matrices are multiplied
     * is significant. For example, if you first rotate, then scale, then translate, you get a
     * different result than if you first translate, then rotate, then scale.
     *
     * --------------------
     * Since Matrix2D is a struct, it can be created manually by calling "new PDFNet.Matrix2D(m_a, m_b, m_c, m_d, m_h, m_v)"
     * eg. var myfoo = new PDFNet.Matrix2D(1,0,0,1,0,0);
     *
     * Default values for a Matrix2D struct are:
     * m_a = 0
     * m_b = 0
     * m_c = 0
     * m_d = 0
     * m_h = 0
     * m_v = 0
     */
    class Matrix2D {
        constructor(m_a?: number, m_b?: number, m_c?: number, m_d?: number, m_h?: number, m_v?: number);
        /**
         * Copy Constructor
         * @returns A promise that resolves to an object of type: "PDFNet.Matrix2D"
         */
        copy(): Promise<PDFNet.Matrix2D>;
        /**
         * The Set method sets the elements of this matrix.
         * @param a - the matrix element in the first row, first column.
         * @param b - the matrix element in the first row, second column.
         * @param c - the matrix element in the second row, first column.
         * @param d - the matrix element in the second row, second column.
         * @param h - the matrix element in the third row, first column.
         * @param v - the matrix element in the third row, second column.
         */
        set(a: number, b: number, c: number, d: number, h: number, v: number): Promise<void>;
        /**
         * the Concat method updates this matrix with the product of itself and another matrix
         * specified through an argument list.
         * @param a - the matrix element in the first row, first column.
         * @param b - the matrix element in the first row, second column.
         * @param c - the matrix element in the second row, first column.
         * @param d - the matrix element in the second row, second column.
         * @param h - the matrix element in the third row, first column.
         * @param v - the matrix element in the third row, second column.
         */
        concat(a: number, b: number, c: number, d: number, h: number, v: number): Promise<void>;
        /**
         * The equality operator determines whether the elements of this matrix are equal to
         * the elements of another matrix.
         * @param m2 - A Matrix object that is compared with this Matrix object.
         * @returns A promise that resolves to a boolean regarding whether two matrices are the same.
         */
        equals(m2: PDFNet.Matrix2D): Promise<boolean>;
        /**
         * @returns A promise that resolves to if this matrix is invertible, the Inverse method returns its inverse matrix.
         */
        inverse(): Promise<PDFNet.Matrix2D>;
        /**
         * Updates this matrix with the product of itself and a
         * translation matrix (i.e. it is equivalent to this.m_h += h; this.m_v += v).
         * @param h - the horizontal component of the translation.
         * @param v - the vertical component of the translation.
         * Note: This method is deprecated. Please use PreTranslate or PostTranslate instead. The behavior of this method is identical to PreTranslate, but
         * PostTranslate will be more suitable for some use cases.
         */
        translate(h: number, v: number): Promise<void>;
        /**
         * Updates this matrix to the concatenation of a translation matrix and the original matrix.
         * M' = T(h, v) * M. It is equivalent to this.m_h += h; this.m_v += v.
         * @param h - the horizontal component of the translation.
         * @param v - the vertical component of the translation.
         */
        preTranslate(h: number, v: number): Promise<void>;
        /**
         * Updates this matrix by concatenating a translation matrix.
         * M' = M * T(h, v). It is equivalent to this.Concat(1,0,0,1,h,v).
         * @param h - the horizontal component of the translation.
         * @param v - the vertical component of the translation.
         */
        postTranslate(h: number, v: number): Promise<void>;
        /**
         * The Scale method updates this matrix with the product of itself and a scaling matrix.
         * @param h - the horizontal scale factor.
         * @param v - the vertical scale factor
         */
        scale(h: number, v: number): Promise<void>;
        /**
         * Create zero matrix (0 0 0 0 0 0)
         * @returns A promise that resolves to an object of type: "PDFNet.Matrix2D"
         */
        static createZeroMatrix(): Promise<PDFNet.Matrix2D>;
        /**
         * Create identity matrix (1 0 0 1 0 0)
         * @returns A promise that resolves to an object of type: "PDFNet.Matrix2D"
         */
        static createIdentityMatrix(): Promise<PDFNet.Matrix2D>;
        /**
         * @param angle - the angle of rotation in radians.
         * Positive values specify clockwise rotation.
         * @returns A promise that resolves to a rotation matrix for a given angle.
         */
        static createRotationMatrix(angle: number): Promise<PDFNet.Matrix2D>;
        multiply(m: PDFNet.Matrix2D): Promise<void>;
        /**
         * Creates and initializes a Matrix object based on six numbers that define an
        affine transformation.
         * @param [a = 0] - the matrix element in the first row, first column.
         * @param [b = 0] - the matrix element in the first row, second column.
         * @param [c = 0] - the matrix element in the second row, first column.
         * @param [d = 0] - the matrix element in the second row, second column.
         * @param [h = 0] - the matrix element in the third row, first column.
         * @param [v = 0] - the matrix element in the third row, second column.
         * @returns A promise that resolves to an object of type: "Matrix2D".
         */
        static create(a?: number, b?: number, c?: number, d?: number, h?: number, v?: number): Promise<PDFNet.Matrix2D>;
        /**
         * Transform/multiply the point (x, y) using this matrix
         * @param x - x-coordinate of point to transform
         * @param y - y-coordinate of point to transform
         * @returns A promise that resolves to a javascript object that contains an x value and y value
         */
        mult(x: number, y: number): Promise<PDFNet.Obj>;
        m_a: number;
        m_b: number;
        m_c: number;
        m_d: number;
        m_h: number;
        m_v: number;
    }
    /**
     * A movie annotation contains animated graphics and sound to be
     * presented on the computer screen and through the speakers. When the
     * annotation is activated, the movie is played.
     */
    class MovieAnnot extends PDFNet.Annot {
        /**
         * creates a Movie annotation and initializes it using given Cos/SDF object.
         * @param [d] - The Cos/SDF object to initialze the annotation with.
         * Note: The constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @returns A promise that resolves to an object of type: "PDFNet.MovieAnnot"
         */
        static createFromObj(d?: PDFNet.Obj): Promise<PDFNet.MovieAnnot>;
        /**
         * creates a Movie annotation and initializes it using given annotation object.
         * @param ann - Annot object used to initialize the Movie annotation.
         * Note: The constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @returns A promise that resolves to an object of type: "PDFNet.MovieAnnot"
         */
        static createFromAnnot(ann: PDFNet.Annot): Promise<PDFNet.MovieAnnot>;
        /**
         * Creates a new Movie annotation in the specified document.
         * @param doc - A document to which the Movie annotation is added.
         * @param pos - A rectangle specifying the Movie annotation's bounds in default user space units.
         * @returns A promise that resolves to a newly created blank Movie annotation.
         */
        static create(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, pos: PDFNet.Rect): Promise<PDFNet.MovieAnnot>;
        static create(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, type: number, pos: PDFNet.Rect): Promise<PDFNet.Annot>;
        /**
         * Returns the title of the Movie Annotation.
         * @returns A promise that resolves to a string representing the title of the Movie Annotation.
         * Note: Movie actions may use this title to reference the movie annotation.
         */
        getTitle(): Promise<string>;
        /**
         * sets the title of the Movie Annotation.
         * (Optional)
         * @param title - A string representing the title of the Movie Annotation.
         * Note: Movie actions may use this title to reference the movie annotation.
         */
        setTitle(title: string): Promise<void>;
        /**
         * Returns the option of whether the Movie is to be played.
         * @returns A promise that resolves to a boolean value indicating if the movie is to be played.
         * Note: IsToBePlayed is a flag specifying whether to play the movie when the annotation is activated.
         * The movie shall be played using default activation parameters. If the value is false,
         * the movie shall not be played.
         * Default value: true.
         */
        isToBePlayed(): Promise<boolean>;
        /**
         * sets the option of whether the Movie is to be played.
         * (Optional)
         * @param [isplay] - A boolean value telling if the movie is to be played.
         * Default value: true.
         * Note: IsToBePlayed is a flag specifying whether to play the movie when the annotation is activated.
         * The movie shall be played using default activation parameters. If the value is false,
         * the movie shall not be played.
         * Default value: true.
         */
        setToBePlayed(isplay?: boolean): Promise<void>;
    }
    /**
     * A NameTree is a common data structure in PDF. See section 3.8.5 'Name Trees'
     * in PDF Reference Manual for more details.
     *
     * A name tree serves a similar purpose to a dictionary - associating keys and
     * values - but by different means. NameTrees allow efficient storage of very
     * large association collections (string/Obj* maps). A NameTree can have many
     * more entries than a SDF/Cos dictionary can.
     *
     * NameTree-s use SDF/Cos-style strings (not null-terminated C strings), which
     * may use Unicode encoding etc.
     *
     * <pre>
     *   PDFDoc doc("../Data/PDFReference.pdf");
     *   NameTree dests = NameTree::Find(*doc.GetSDFDoc(), "Dests");
     *   if (dests.IsValid()) {
     *     // Traversing the NameTree
     *     UString key;
     *     for (DictIterator i = dests.GetIterator(); i.HasNext(); i.Next())
     *        i.Key().GetAsPDFText(key); // ...
     *   }
     * </pre>
     */
    class NameTree {
        /**
         * Retrieves the NameTree inside the '/Root/Names' dictionary with the
         * specified key name, or creates it if it does not exist.
         * @param doc - The document in which the name tree is created.
         * @param name - The name of the NameTree to create.
         * @returns A promise that resolves to the newly created NameTree for the doc or an existing tree with
         * the same key name.
         *
         * Note: although it is possible to create a name tree anywhere in the document
         * the convention is that all trees are located under '/Root/Names' dictionary.
         */
        static create(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, name: string): Promise<PDFNet.NameTree>;
        /**
         * Retrieves a name tree, with the given key name, from the '/Root/Names'
         * dictionary of the doc.
         * @param doc - The document in which to search for the name.
         * @param name - The name of the name tree to find.
         * @returns A promise that resolves to the requested NameTree. If the requested NameTree exists
         * NameTree.IsValid() will return true, and false otherwise.
         */
        static find(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, name: string): Promise<PDFNet.NameTree>;
        /**
         * Create a high level NameTree wrapper around an existing SDF/Cos NameTree.
         * This does not copy the object.
         * @param name_tree - SDF/Cos root of the NameTree object.
         * @returns A promise that resolves to an object of type: "PDFNet.NameTree"
         */
        static createFromObj(name_tree: PDFNet.Obj): Promise<PDFNet.NameTree>;
        /**
         * Copy Constructor
         * @returns A promise that resolves to an object of type: "PDFNet.NameTree"
         */
        copy(): Promise<PDFNet.NameTree>;
        /**
         * @returns A promise that resolves to whether this is a valid (non-null) NameTree. If the
         * function returns false the underlying SDF/Cos object is null and
         * the NameTree object should be treated as null as well.
         */
        isValid(): Promise<boolean>;
        /**
         * @returns A promise that resolves to an object of type: "PDFNet.DictIterator"
         */
        getIterator(key: string): Promise<PDFNet.DictIterator>;
        /**
         * @returns A promise that resolves to an object of type: "PDFNet.Obj"
         */
        getValue(key: string): Promise<PDFNet.Obj>;
        /**
         * @returns A promise that resolves to an iterator that addresses the first element in the NameTree.
         * The iterator can be used to traverse all entries stored in the NameTree.
         *
         * <pre>
         *  UString key;
         *  for (NameTreeIterator i = dests.GetIterator(); i.HasNext(); i.Next()) {
         *    i.GetKey().GetAsPDFText(key); // ...
         *  }
         * </pre>
         */
        getIteratorBegin(): Promise<PDFNet.DictIterator>;
        put(key: string, value: PDFNet.Obj): Promise<void>;
        eraseKey(key: string): Promise<void>;
        /**
         * Removes the NameTree entry pointed by the iterator.
         * @param pos - ditionary iterator object that points to the NameTree entry to be removed.
         */
        erase(pos: PDFNet.DictIterator): Promise<void>;
        /**
         * @returns A promise that resolves to the object to the underlying SDF/Cos object. If the NameTree.IsValid()
         * returns false the SDF/Cos object is NULL.
         */
        getSDFObj(): Promise<PDFNet.Obj>;
    }
    /**
     * A NumberTree is a common data structure in PDF. See section 3.8.6 'Number Trees'
     * in PDF Reference Manual for more details.
     *
     * A number tree serves a similar purpose to a dictionary - associating keys and
     * values - but by different means. NumberTrees allow efficient storage of very
     * large association collections (number/Obj* maps). A NumberTree can have many
     * more entries than a SDF/Cos dictionary can.
     *
     * Sample code:
     * <pre>
     *   PDFDoc doc("../Data/test.pdf");
     *   NumberTree labels(doc.GetRoot().Get("PageLabels").Value());
     *   if (labels.IsValid()) {
     *     // Traversing the NumberTree
     *     for (NumberTreeIterator i = labels.GetIterator(); i.HasNext(); i.Next())
     *         cout << "Key: " << i.Key().GetNumber() << endl;
     *   }
     * </pre>
     */
    class NumberTree {
        /**
         * Create a high level NumberTree wrapper around an existing SDF/Cos NumberTree.
         * This does not copy the object.
         * @param number_tree - SDF/Cos root of the NumberTree object.
         * @returns A promise that resolves to an object of type: "PDFNet.NumberTree"
         */
        static create(number_tree: PDFNet.Obj): Promise<PDFNet.NumberTree>;
        /**
         * Copy Constructor
         * @returns A promise that resolves to an object of type: "PDFNet.NumberTree"
         */
        copy(): Promise<PDFNet.NumberTree>;
        /**
         * @returns A promise that resolves to whether this is a valid (non-null) NumberTree. If the
         * function returns false the underlying SDF/Cos object is null and
         * the NumberTree object should be treated as null as well.
         */
        isValid(): Promise<boolean>;
        /**
         * Search for the specified key in the NumberTree.
         * @param key - the number representing the key to be found.
         *
         * Sample code:
         *   NumberTreeIterator i = dests.Find(5);
         *   if (i.HasNext()) {
         *     cout << "Key: " << i.GetKey()->GetNumber() << endl;
         *     cout << "Value: " << i.GetValue()->GetType() << endl;
         *   }
         * @returns A promise that resolves to if the key is present the function returns a NumberTreeIterator the points
         * to the given Key/Value pair. If the key is not found the function returns End()
         * (a non-valid) iterator.
         */
        getIterator(key: number): Promise<PDFNet.DictIterator>;
        /**
         * @returns A promise that resolves to an object of type: "PDFNet.Obj"
         */
        getValue(key: number): Promise<PDFNet.Obj>;
        /**
         * @returns A promise that resolves to an iterator to the first key/value pair (i.e. NNTreeData) in
         * the document. You can use the Next method on the returned iterator to
         * traverse all entries stored under the NumberTree.
         *
         * Sample code:
         * 	 for (NumberTreeIterator i = dests.GetIterator(); i.HasNext(); i.Next())
         * 	   cout << "Key: " << i.GetKey().GetNumber() << endl;
         */
        getIteratorBegin(): Promise<PDFNet.DictIterator>;
        /**
         * Puts a new entry in the name tree. If an entry with this number
         * is already in the tree, it is replaced.
         * @param key - A number representing the key of the new entry.
         * @param value - the value associated with the key. It can be any SDF::Obj.
         */
        put(key: number, value: PDFNet.Obj): Promise<void>;
        /**
         * Removes the specified object from the tree. Does nothing if no object
         * with that number exists.
         * @param key - A number representing the key of the entry to be removed.
         */
        eraseKey(key: number): Promise<void>;
        /**
         * Removes the NumberTree entry pointed by the iterator.
         * @param pos - dictionary iterator object that points to the NumberTree entry to be removed
         */
        erase(pos: PDFNet.DictIterator): Promise<void>;
        /**
         * @returns A promise that resolves to the object to the underlying SDF/Cos object. If the NumberTree.IsValid()
         * returns false the SDF/Cos object is NULL.
         */
        getSDFObj(): Promise<PDFNet.Obj>;
    }
    /**
     * optional-content group
     */
    class OCG {
        /**
         * Constructor
         * @returns A promise that resolves to an object of type: "PDFNet.OCG"
         */
        static create(pdfdoc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, name: string): Promise<PDFNet.OCG>;
        /**
         * @returns A promise that resolves to an object of type: "PDFNet.OCG"
         */
        static createFromObj(ocg_dict: PDFNet.Obj): Promise<PDFNet.OCG>;
        /**
         * Copy Constructor
         * @returns A promise that resolves to an object of type: "PDFNet.OCG"
         */
        copy(): Promise<PDFNet.OCG>;
        /**
         * @returns A promise that resolves to pointer to the underlying SDF/Cos object.
         */
        getSDFObj(): Promise<PDFNet.Obj>;
        /**
         * @returns A promise that resolves to true if this is a valid (non-null) OCG, false otherwise.
         */
        isValid(): Promise<boolean>;
        /**
         * @returns A promise that resolves to the name of this optional-content group (OCG).
         */
        getName(): Promise<string>;
        /**
         * sets the name of this optional-content group (OCG).
         * @param value - The new name.
         */
        setName(value: string): Promise<void>;
        /**
         * @returns A promise that resolves to oCG intent.
         * An intent is a name object (or an array of name objects) broadly describing the
         * intended use, which can be either "View" or "Design". A group's content is
         * considered to be optional (that is, the group's state is considered in its
         * visibility) if any intent in its list matches an intent of the context. The
         * intent list of the context is usually set from the intent list of the document
         * configuration.
         */
        getIntent(): Promise<PDFNet.Obj>;
        /**
         * Sets the Intent entry in an optional-content group's SDF/Cos dictionary.
         * For more information, see GetIntent().
         * @param value - The new Intent entry value (a name object or an array of name objects).
         */
        setIntent(value: PDFNet.Obj): Promise<void>;
        /**
         * @returns A promise that resolves to true if this group is associated with a Usage dictionary, false otherwise.
         */
        hasUsage(): Promise<boolean>;
        /**
         * @param key - The usage key in the usage dictionary entry. The possible key values are:
         * CreatorInfo, Language, Export, Zoom, Print, View, User, PageElement.
         * @returns A promise that resolves to the usage information associated with the given key in the Usage dictionary
         * for the group, or a NULL if the entry is not present. A Usage dictionary entry
         * provides more specific intended usage information than an intent entry.
         */
        getUsage(key: string): Promise<PDFNet.Obj>;
        /**
         * @param ctx - The context for which to get the group's state.
         * @returns A promise that resolves to true if this OCG object is in the ON state in a given context,
         * false otherwise.
         */
        getCurrentState(ctx: PDFNet.OCGContext): Promise<boolean>;
        /**
         * sets the current ON-OFF state of the optional-content group (OCG) object in a given context.
         * @param ctx - The context for which to set the group's state.
         * @param state - The new state.
         */
        setCurrentState(ctx: PDFNet.OCGContext, state: boolean): Promise<void>;
        /**
         * @param cfg - The configuration for which to get the group's initial state.
         * Note: If the configuration has a BaseState of Unchanged, and the OCG is
         * not listed explicitly in its ON list or OFF list, then the initial state
         * is taken from the OCG's current state in the document's default context.
         * @returns A promise that resolves to the initial state (ON or OFF) of the optional-content group
         * (OCG) object in a given configuration.
         */
        getInitialState(cfg: PDFNet.OCGConfig): Promise<boolean>;
        /**
         * sets the initial state (ON or OFF) of the optional-content group (OCG)
         * object in a given configuration.
         * @param cfg - The configuration for which to set the group's initial state.
         * @param state - The new initial state, true if the state is ON, false if it is OFF.
         */
        setInitialState(cfg: PDFNet.OCGConfig, state: boolean): Promise<void>;
        /**
         * @param cfg - The OC configuration.
         * @returns A promise that resolves to true if this OCG is locked in a given configuration, false otherwise.
         * The on/off state of a locked OCG cannot be toggled by the user through the user interface.
         */
        isLocked(cfg: PDFNet.OCGConfig): Promise<boolean>;
        /**
         * Sets the locked state of an OCG in a given configuration. The on/off state of a
         * locked OCG cannot be toggled by the user through the user interface.
         * @param cfg - IN/OUT The optional-content configuration.
         * @param state - true if the OCG should be locked, false otherwise.
         */
        setLocked(cfg: PDFNet.OCGConfig, state: boolean): Promise<void>;
    }
    /**
     * The OCGConfig object represents an optional-content (OC) configuration
     * structure (see section 4.10.3 in PDF Reference), used to persist a set
     * of visibility states and other optional-content information in a PDF file
     * A document has a default configuration, saved in the D entry in the
     * 'OCProperties' dictionary (that can be obtained using [PDFDoc].getOCConfig()),
     * and can have a list of other configurations, saved as an array in the
     * 'Configs' entry in the OCProperties dictionary.
     * <p>
     * Configurations are typically used to initialize the OCG ON-OFF states for
     * an optional-content context (OCGContext). The OCG order in the configuration
     * is the order in which the groups appear in the Layers panel of a PDF viewer.
     * The configuration can also define a set of mutually exclusive OCGs, called a
     * radio button group.
     * </p>
     */
    class OCGConfig {
        /**
         * Creates a new optional-content configuration from an existing SDF/Cos object.
         * @param dict - SDF object to create optional-content configuration from.
         * @returns A promise that resolves to an object of type: "PDFNet.OCGConfig"
         */
        static createFromObj(dict: PDFNet.Obj): Promise<PDFNet.OCGConfig>;
        /**
         * Creates a new optional-content configuration object in the document.
         * @param pdfdoc - The document in which the new OCG::Config will be created.
         * @param default_config - If true, the configuration will be set as the
         * default OCG configuration (i.e. listed as a D entry under 'OCProperties'
         * dictionary).
         * @returns A promise that resolves to the newly created configuration object.
         */
        static create(pdfdoc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, default_config: boolean): Promise<PDFNet.OCGConfig>;
        /**
         * Copy Constructor
         * @returns A promise that resolves to an object of type: "PDFNet.OCGConfig"
         */
        copy(): Promise<PDFNet.OCGConfig>;
        /**
         * @returns A promise that resolves to pointer to the underlying SDF/Cos object.
         */
        getSDFObj(): Promise<PDFNet.Obj>;
        /**
         * @returns A promise that resolves to the Obj array that specifies the order of optional content (OC) groups
         * in this configuration or NULL if the configuration does not contain any OCGs.
         * The order of OCGs in the array is used to represent the order in which the
         * group names are displayed in the Layers panel of a PDF viewer application.
         * For more information, please refer to Section 4.10.3 in the PDF Reference.
         */
        getOrder(): Promise<PDFNet.Obj>;
        /**
         * Sets the user interface display order of optional-content groups (OCGs) in
         * this configuration. This is the order in which the group names are displayed
         * in the Layers panel of a PDF viewer.
         * @param value - The SDF/Cos object containing the OCG order array.
         * For more information, please refer to section 4.10.3 in the PDF Reference.
         */
        setOrder(value: PDFNet.Obj): Promise<void>;
        /**
         * @returns A promise that resolves to the name of an optional-content configuration (suitable for
         * presentation in a user interface).
         */
        getName(): Promise<string>;
        /**
         * sets the name of an optional-content configuration (suitable for presentation
         * in a user interface). The method stores the specified string as the Name entry
         * in the configuration's SDF/Cos dictionary.
         * @param value - The new name string.
         */
        setName(value: string): Promise<void>;
        /**
         * @returns A promise that resolves to the creator property of an optional-content configuration. The string
         * is used to represent the name of the application or feature that created this
         * configuration.
         */
        getCreator(): Promise<string>;
        /**
         * sets the creator property of an optional-content configuration. Stores the
         * specified string as the Creator entry in the configuration's SDF/Cos dictionary.
         * @param value - The new creator string.
         */
        setCreator(value: string): Promise<void>;
        /**
         * @returns A promise that resolves to the base initialization state. This state is used to initialize the states
         * of all the OCGs in a document when this configuration is applied. The value of this entry
         * must be one of the following names:
         *  <li>ON: The states of all groups are turned ON. </li>
         *  <li>OFF: The states of all groups are turned OFF.</li>
         *  <li>Unchanged: The states of all groups are left unchanged.</li>
         *
         * <p> After base initialization, the contents of the ON and OFF arrays are processed, overriding
         * the state of the groups included in the arrays.</p>
         * Note: If BaseState is present in the document's default configuration dictionary, its value must
         * be "ON".
         */
        getInitBaseState(): Promise<string>;
        /**
         * sets the base initialization state. For more info, please see GetInitBaseState().
         * @param [value] - new base state ("ON", "OFF", or "Unchanged").
         */
        setInitBaseState(value?: string): Promise<void>;
        /**
         * @returns A promise that resolves to the "ON" initialization array from the configuration dictionary or
         * NULL if the array is not present. The returned object is an array of optional
         * content groups whose state should be set to ON when this configuration is applied.
         * Note: If the BaseState entry is ON, this entry is redundant.
         */
        getInitOnStates(): Promise<PDFNet.Obj>;
        /**
         * sets the 'ON' initialization array in the configuration dictionary.
         * @param value - the initialization array to be used
         * Note: For more info, please see SetInitOnStates() and section 4.10.3 in PDF Reference.
         */
        setInitOnStates(value: PDFNet.Obj): Promise<void>;
        /**
         * @returns A promise that resolves to the "OFF" initialization array from the configuration dictionary or
         * NULL if the array is not present. The returned object is an array of optional
         * content groups whose state should be set to OFF when this configuration is applied.
         * Note: If the BaseState entry is OFF, this entry is redundant.
         */
        getInitOffStates(): Promise<PDFNet.Obj>;
        /**
         * sets the 'OFF' initialization array in the configuration dictionary.
         * @param value - the initialization array to be used.
         * Note: For more info, please see SetInitOffStates() and section 4.10.3 in PDF Reference.
         */
        setInitOffStates(value: PDFNet.Obj): Promise<void>;
        /**
         * @returns A promise that resolves to oCG configuration intent. An intent is a name object (or an array of name
         * objects) broadly describing the intended use, which can be either "View" or "Design".
         * A group's content is considered to be optional (that is, the group's state is considered
         * in its visibility) if any intent in its list matches an intent of the context. The
         * intent list of the context is usually set from the intent list of the document
         * configuration. If the configuration has no Intent entry, the default value of
         * "View" is used.
         */
        getIntent(): Promise<PDFNet.Obj>;
        /**
         * Sets the Intent entry in an optional-content configuration's SDF/Cos dictionary.
         * For more information, see GetIntent().
         * @param value - The new Intent entry value (a name object or an array of name objects).
         */
        setIntent(value: PDFNet.Obj): Promise<void>;
        /**
         * @returns A promise that resolves to the list of locked OCGs or NULL if there are no locked OCGs.
         * The on/off state of a locked OCG cannot be toggled by the user through the
         * user interface.
         */
        getLockedOCGs(): Promise<PDFNet.Obj>;
        /**
         * sets the array of locked OCGs. The on/off state of a locked OCG cannot be
         * toggled by the user through the user interface.
         * @param value - An SDF/Cos array of OCG objects to be locked in this
         * configuration, or an empty array if the configuration should not contain
         * locked OCGs. The default is the empty array.
         */
        setLockedOCGs(value: PDFNet.Obj): Promise<void>;
    }
    /**
     * <p>
     * The OCGContext object represents an optional-content context in a document, within which
     * document objects such as words or annotations are visible or hidden. The context keeps track
     * of the ON-OFF states of all of the optional-content groups (OCGs) in a document. Content is
     * or is not visible with respect to the OCG states stored in a specific context. Unlike other
     * objects in OCG namespace, the OCGContext does not correspond to any explicit PDF structure.
     * </p><p>
     * Each PDFView has a default context (PDF::GetOCGContext()) that it uses for on-screen drawing
     * and that determines the default state for any drawing. The context has flags that control
     * whether to draw content that is marked as optional, and whether to draw content that is not
     * marked as optional.
     * </p><p>
     * When enumerating page content, OCGContext can be passed as a parameter in ElementReader.Begin()
     * method. When using PDFDraw, PDFRasterizer, or PDFView class to render PDF pages use
     *  ( PDFDraw::SetOCGContext() method to select an OC context.
     * </p><p>
     * There can be more than one Context object, representing different combinations of OCG states.
     * You can change the states of OCGs within any context. You can build contexts with your own
     * combination of OCG states, and issue drawing or enumeration commands using that context.
     * For example, you can pass an optional-content context to ElementReader.Begin(). You can save
     * the resulting state information as part of the configuration (e.g. using Config::SetInit methods),
     * but the context itself has no corresponding PDF representation, and is not saved.
     * </p>
     */
    class OCGContext extends PDFNet.Destroyable {
        /**
         * create a context object that represents an optional-content state of the
         * document from a given configuration.
         * @param cfg - A configuration from which to take initial OCG states.
         * @returns A promise that resolves to an object of type: "PDFNet.OCGContext"
         */
        static createFromConfig(cfg: PDFNet.OCGConfig): Promise<PDFNet.OCGContext>;
        /**
         * Copy Constructor
         * @returns A promise that resolves to an object of type: "PDFNet.OCGContext"
         */
        copy(): Promise<PDFNet.OCGContext>;
        /**
         * @param grp - The optional-content group (OCG) that is queried.
         * @returns A promise that resolves to the ON-OFF states (true or false) for the given optional-content
         * group (OCG) in this OC context.
         */
        getState(grp: PDFNet.OCG): Promise<boolean>;
        /**
         * sets the ON-OFF states for the given optional-content group (OCG) in this
         * context.
         * @param grp - The optional-content group (OCG) that is queried.
         * @param state - true for 'ON' and false for 'OFF'.
         */
        setState(grp: PDFNet.OCG, state: boolean): Promise<void>;
        /**
         * sets the sates of all OCGs in the context to ON or OFF.
         * @param all_on - A flag used to specify whether the OCG states should be set
         * to ON (if true), or OFF (if false).
         */
        resetStates(all_on: boolean): Promise<void>;
        /**
         * Sets the non-OC status for this context. Content that is not marked
         * as optional content is drawn (or element.IsOCVisible()) when 'draw_non_OC'
         * is true, and not drawn/visible otherwise.
         * @param draw_non_OC - A flag specifying whether the content that is not
         * marked as optional should be treated as visible.
         */
        setNonOCDrawing(draw_non_OC: boolean): Promise<void>;
        /**
         * @returns A promise that resolves to the non-OC status for this context. The flag indicates whether the
         * content that is not marked as optional should be treated as visible.
         * For more information, please see SetNonOCDrawing().
         */
        getNonOCDrawing(): Promise<boolean>;
        /**
         * sets the drawing and enumeration type for this context. This type, together
         * with the visibility determined by the OCG and OCMD states, controls whether
         * content that is marked as optional content is drawn or enumerated.
         * @param oc_draw_mode - <pre>
         * PDFNet.OCGContext.OCDrawMode = {
         * 	e_VisibleOC : 0
         * 	e_AllOC : 1
         * 	e_NoOC : 2
         * }
         * </pre>
         * A flag specifying the visibility of optional content.
         */
        setOCDrawMode(oc_draw_mode: number): Promise<void>;
        /**
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.OCGContext.OCDrawMode = {
         * 	e_VisibleOC : 0
         * 	e_AllOC : 1
         * 	e_NoOC : 2
         * }
         * </pre>
         * @returns A promise that resolves to the drawing and enumeration type for this context.
         * For more information, please see SetOCMode() and OCG::Context::OCDrawMode.
         */
        getOCMode(): Promise<number>;
    }
    /**
     * The OCMD object represents an Optional Content Membership Dictionary (OCMD)
     * that allows the visibility of optional content to depend on the states in a
     * set of optional-content groups (OCG::Group). The object directly corresponds
     * to the OCMD dictionary (Section 4.10.1 'Optional Content Groups' in PDF
     * Reference).
     * <p>
     * An OCMD collects a set of OCGs. It sets a visibility policy, so that
     * content in the member groups is visible only when all groups are ON
     * or OFF, or when any of the groups is ON or OFF. This makes it possible
     * to set up complex dependencies among groups. For example, an object can be
     * visible only if some other conditions are met (such as if another layer is
     * visible).
     * </p>
     */
    class OCMD {
        /**
         * Creates a new optional-content group membership dictionary (OCMD) object from
         * an existing SDF/Cos object.
         * @returns A promise that resolves to an object of type: "PDFNet.OCMD"
         */
        static createFromObj(ocmd_dict: PDFNet.Obj): Promise<PDFNet.OCMD>;
        /**
         * Creates a new optional-content membership dictionary (OCMD) object in the
         * given document for the given groups and visibility policy.
         * @param pdfdoc - The document in which the new OCMD will be created.
         * @param ocgs - An array of optional-content groups (OCGs) to be members of the dictionary.
         * @param vis_policy - <pre>
         * PDFNet.OCMD.VisibilityPolicyType = {
         * 	e_AllOn : 0
         * 	e_AnyOn : 1
         * 	e_AnyOff : 2
         * 	e_AllOff : 3
         * }
         * </pre>
         * The visibility policy that determines the visibility of content with respect
         * to the ON-OFF state of OCGs listed in the dictionary.
         * @returns A promise that resolves to the newly created OCG::OCMD object.
         */
        static create(pdfdoc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, ocgs: PDFNet.Obj, vis_policy: number): Promise<PDFNet.OCMD>;
        /**
         * Copy Constructor
         * @returns A promise that resolves to an object of type: "PDFNet.OCMD"
         */
        copy(): Promise<PDFNet.OCMD>;
        /**
         * @returns A promise that resolves to pointer to the underlying SDF/Cos object.
         */
        getSDFObj(): Promise<PDFNet.Obj>;
        /**
         * Returns the optional-content groups listed under 'OCGs' entry in the object
         * dictionary.
         * @returns A promise that resolves to a dictionary (for a single OCG::Group object), an SDF::Obj array
         * (for multiple OCG::Group objects) or NULL (for an empty OCMD).
         */
        getOCGs(): Promise<PDFNet.Obj>;
        /**
         * @returns A promise that resolves to if the PDOCMD has a visibility expression entry, return the
         * SDF::Obj array object representing the expression, otherwise returns NULL.
         */
        getVisibilityExpression(): Promise<PDFNet.Obj>;
        /**
         * @returns A promise that resolves to true if this is a valid (non-null) OCMD, false otherwise.
         */
        isValid(): Promise<boolean>;
        /**
         * @param ctx - The context in which the visibility of content is tested.
         * @returns A promise that resolves to true if content tagged with this OCMD is visible in the given
         * context, false if it is hidden.
         * <p>
         * Based on the optional-content groups listed in the dictionary, the current
         * ON-OFF state of those groups within the specified context, and the
         * dictionary's visibility policy, test whether the content tagged with
         * this dictionary would be visible.
         */
        isCurrentlyVisible(ctx: PDFNet.OCGContext): Promise<boolean>;
        /**
         * Returns the optional-content membership dictionary's visibility policy, which
         * determines the visibility of content with respect to the ON-OFF state of
         * OCGs listed in the dictionary.
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.OCMD.VisibilityPolicyType = {
         * 	e_AllOn : 0
         * 	e_AnyOn : 1
         * 	e_AnyOff : 2
         * 	e_AllOff : 3
         * }
         * </pre>
         * @returns A promise that resolves to the visibility policy.
         */
        getVisibilityPolicy(): Promise<number>;
        /**
         * Sets the optional-content membership dictionary's visibility policy, which
         * determines the visibility of content with respect to the ON-OFF state of
         * OCGs listed in the dictionary.
         * @param vis_policy - <pre>
         * PDFNet.OCMD.VisibilityPolicyType = {
         * 	e_AllOn : 0
         * 	e_AnyOn : 1
         * 	e_AnyOff : 2
         * 	e_AllOff : 3
         * }
         * </pre>
         * New visibility policy.
         */
        setVisibilityPolicy(vis_policy: number): Promise<void>;
    }
    /**
     * The class OCRModule.
     * static interface to PDFTron SDKs OCR functionality
     */
    class OCRModule {
        /**
         * Add hidden text layer to a PDF consisting of raster image(s).
         * @param dst - - The source and destination document.
         * @param json - - JSON representing OCR results.
         */
        static applyOCRJsonToPDF(dst: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, json: string): Promise<void>;
        /**
         * Add hidden text layer to a PDF consisting of raster image(s).
         * @param dst - - The source and destination document.
         * @param xml - - XML representing OCR results.
         */
        static applyOCRXmlToPDF(dst: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, xml: string): Promise<void>;
    }
    /**
     * Obj is a concrete class for all SDF/Cos objects. Obj hierarchy implements the
     * composite design pattern. As a result, you can invoke a member function of any
     * 'derived' object through Obj interface. If the member function is not supported
     * (e.g. if you invoke Obj::GetNumber() on a boolean object) an Exception will be
     * thrown.
     *
     * You can use GetType() or obl.Is???() member functions to find out type-information at
     * run time, however most of the time the type can be inferred from the PDF specification.
     * Therefore when you call Doc::GetTrailer() you can assume that returned object is
     * a dictionary. If there is any ambiguity use Is???() methods.
     *
     * Objects can't be shared across documents, however you can use Doc::ImportObj()
     * to copy objects from one document to another.
     *
     * Objects can be shared within a document provided that they are created as indirect.
     * Indirect objects are the ones that are referenced in cross-reference table.
     * To create an object as indirect use doc.CreateIndirect???() (where ? is the
     * Object type).
     */
    class Obj {
        /**
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.Obj.Type = {
         * 	e_null : 0
         * 	e_bool : 1
         * 	e_number : 2
         * 	e_name : 3
         * 	e_string : 4
         * 	e_dict : 5
         * 	e_array : 6
         * 	e_stream : 7
         * }
         * </pre>
         * @returns A promise that resolves to the object type.
         * Note: this method can be invoked on any Obj.
         */
        getType(): Promise<number>;
        /**
         * @returns A promise that resolves to the document to which this object belongs.
         * Note: this method can be invoked on any Obj.
         */
        getDoc(): Promise<PDFNet.SDFDoc>;
        /**
         * The function writes the Obj to the output stream
         * @param stream - the input stream where the Obj will be written
         * Note: this method can be invoked on any Obj.
         */
        write(stream: PDFNet.FilterWriter): Promise<void>;
        /**
         * @param to - Obj to compare to
         * @returns A promise that resolves to true if two Obj's point to the same object.
         * This method does not compare object content. For this operation use
         * IsEqualValue() instead.
         */
        isEqual(to: PDFNet.Obj): Promise<boolean>;
        /**
         * @returns A promise that resolves to true if this is a Bool object, false otherwise.
         * Note: this method can be invoked on any Obj.
         */
        isBool(): Promise<boolean>;
        /**
         * @returns A promise that resolves to bool value if this is Bool.
         */
        getBool(): Promise<boolean>;
        /**
         * @param b - bool value used to set Bool object.
         */
        setBool(b: boolean): Promise<void>;
        /**
         * @returns A promise that resolves to true if this is a Number object, false otherwise.
         * Note: this method can be invoked on any Obj.
         */
        isNumber(): Promise<boolean>;
        /**
         * @returns A promise that resolves to value, if this is Number.
         */
        getNumber(): Promise<number>;
        /**
         * @param n - value used to set Number object.
         */
        setNumber(n: number): Promise<void>;
        /**
         * @returns A promise that resolves to true if this is a Null object, false otherwise.
         * Note: this method can be invoked on any Obj.
         */
        isNull(): Promise<boolean>;
        /**
         * @returns A promise that resolves to true if this is a Str (String) object, false otherwise.
         * Note: this method can be invoked on any Obj.
         */
        isString(): Promise<boolean>;
        /**
         * @returns A promise that resolves to a pointer to the string buffer. Please note that the string may not
         * be NULL terminated and that it may not be represented in ASCII or Unicode
         * encoding. For more information on SDF/Cos String objects, please refer to
         * section 3.2.3 'String Objects' in PDF Reference Manual.
         *
         * Note: if SDF/Cos String object is represented as 'PDF Text' (Section 3.8.1
         * 'Text Strings' in PDF Reference) you can use GetAsPDFText method to obtain
         * Unicode representation of the string.
         *
         * Note: use Size() member function in order to obtain the number of bytes in string buffer.
         */
        getBuffer(): Promise<number>;
        setString(value: string): Promise<void>;
        /**
         * Sets the string object value.
         * @param value - A Unicode string value.
         */
        setUString(value: string): Promise<void>;
        /**
         * @returns A promise that resolves to true if this is Name, false otherwise.
         * Note: this method can be invoked on any Obj.
         */
        isName(): Promise<boolean>;
        /**
         * @returns A promise that resolves to string representing the Name object.
         */
        getName(): Promise<string>;
        /**
         * @param name - value used to set Name object.
         */
        setName(name: string): Promise<void>;
        /**
         * @returns A promise that resolves to true if this is Indirect object (i.e. object referenced in the
         * cross-reference table), false otherwise.
         * Note: this method can be invoked on any Obj.
         */
        isIndirect(): Promise<boolean>;
        /**
         * @returns A promise that resolves to object number. If this is not an Indirect object, object number of
         * a containing indirect object is returned.
         * Note: this method can be invoked on any Obj.
         */
        getObjNum(): Promise<number>;
        /**
         * @returns A promise that resolves to generation number. If this is not an Indirect object, generation number of
         * a containing indirect object is returned.
         * Note: this method can be invoked on any Obj.
         */
        getGenNum(): Promise<number>;
        /**
         * @returns A promise that resolves to object offset from the beginning of the file. If this is not an Indirect object,
         * offset of a containing indirect object is returned.
         * Note: this method can be invoked on any Obj.
         */
        getOffset(): Promise<number>;
        /**
         * @returns A promise that resolves to true if the object is in use or is marked as free.
         * Note: this method can be invoked on any Obj.
         */
        isFree(): Promise<boolean>;
        /**
         * Set the object mark. Mark is a boolean value that can be associated with every
         * indirect object. This is especially useful when an object graph should be
         * traversed and an operation should be performed on each node only once.
         * @param mark - boolean value that the object's mark should be set to.
         * Note: this method can be invoked on any Obj.
         */
        setMark(mark: boolean): Promise<void>;
        /**
         * @returns A promise that resolves to true if the object is marked.
         * Note: this method can be invoked on any Obj.
         */
        isMarked(): Promise<boolean>;
        /**
         * @returns A promise that resolves to true if the object is loaded in memory.
         * Note: this method can be invoked on any Obj.
         */
        isLoaded(): Promise<boolean>;
        /**
         * @returns A promise that resolves to true if this is a Container (a dictionary, array, or a stream),
         * false otherwise.
         * Note: this method can be invoked on any Obj.
         */
        isContainer(): Promise<boolean>;
        /**
         * @returns A promise that resolves to the 'size' of the object. The definition of 'size' depends on
         * the object type. In particular:
         *  For a dictionary or a stream object, the method will return the
         *    number of key/value pairs in the dictionary.
         *  For an array object the method will return the number of Obj
         *    entries in the array.
         *  For a string object the method will return the number of bytes
         *    in the string buffer.
         *  For any other object the method will always return 1.
         *
         * Note: this method can be invoked on any Obj.
         */
        size(): Promise<number>;
        /**
         * @returns A promise that resolves to an iterator that addresses the first element in the dictionary.
         * <pre>
         *  DictIterator itr = dict.GetDictIterator();
         *  while (itr.HasNext()) {
         *      Obj key = itr.Key();
         *      Obj value = itr.Value();
         *      // ...
         *      itr.Next()
         *   }
         * </pre>
         */
        getDictIterator(): Promise<PDFNet.DictIterator>;
        /**
         * @returns A promise that resolves to true if this is a dictionary (i.e. Dict), false otherwise.
         * Note: this method can be invoked on any Obj.
         */
        isDict(): Promise<boolean>;
        /**
         * Search the dictionary for a given key.
         * @param key - a key to search for in the dictionary
         * @returns A promise that resolves to the iterator to the matching key/value pair or invalid iterator
         * (i.e. itr.HasNext()==fase) if the if the dictionary does not contain the given key.
         *
         * Note: A dictionary entry whose value is Obj::Null is equivalent to an absent entry.
         * <pre>
         *  DictIterator itr = info_dict.Find("Info");
         *  if (itr.HasNext()) {
         *    Obj info = itr.Value();
         *    if (info.IsDict())
         *      info.PutString("Producer", "PDFTron PDFNet SDK");
         * }
         * </pre>
         */
        find(key: string): Promise<PDFNet.DictIterator>;
        /**
         * Search the dictionary for a given key.
         * @param key - a key to search for in the dictionary
         * @returns A promise that resolves to nULL if the dictionary does not contain the specified key.
         * Otherwise return the corresponding value.
         * Note: A dictionary entry whose value is Obj::Null is equivalent to an absent entry.
         */
        findObj(key: string): Promise<PDFNet.Obj>;
        /**
         * Search the dictionary for a given key and throw an exception if the key is not found.
         * @param key - a key to search for in the dictionary
         * @returns A promise that resolves to obj::Null object if the value matching specified key is a Obj::Null object.
         * otherwise return the iterator to the matching key/value pair.
         */
        get(key: string): Promise<PDFNet.DictIterator>;
        /**
         * Inserts a <key, Obj::Type::e_name> pair in the dictionary.
         * @param key - The key of the value to set.
         * @param name - The value of the Obj::Type::e_name object to be inserted into
         * the dictionary.
         * @returns A promise that resolves to a newly created name object.
         * Note: If a dictionary already contains an entry with the same key, the old entry
         * will be deleted and all DictIterators to this entry will be invalidated.
         */
        putName(key: string, name: string): Promise<PDFNet.Obj>;
        /**
         * Inserts a <key, Obj::Type::e_array> pair in the dictionary.
         * @param key - The key of the value to set.
         * @returns A promise that resolves to a newly created array object.
         *
         * Note: If a dictionary already contains an entry with the same key, the old entry
         * will be deleted and all DictIterators to this entry will be invalidated.
         */
        putArray(key: string): Promise<PDFNet.Obj>;
        /**
         * Inserts a <key, Obj::Type::e_bool> pair in the dictionary.
         * @param key - The key of the value to set.
         * @param value - The value of the Obj::Type::e_bool object to be inserted into
         * the dictionary.
         * @returns A promise that resolves to a newly created boolean object.
         * Note: If a dictionary already contains an entry with the same key, the old entry
         * will be deleted and all DictIterators to this entry will be invalidated.
         */
        putBool(key: string, value: boolean): Promise<PDFNet.Obj>;
        /**
         * Inserts a <key, Obj::Type::e_dict> pair in the dictionary.
         * @param key - The key of the value to set.
         * @returns A promise that resolves to a newly created dictionary.
         * Note: If a dictionary already contains an entry with the same key, the old entry
         * will be deleted and all DictIterators to this entry will be invalidated.
         */
        putDict(key: string): Promise<PDFNet.Obj>;
        /**
         * Inserts a <key, Obj::Type::e_number> pair in the dictionary.
         * @param key - The key of the value to set.
         * @param value - The value of the Obj::Type::e_number object to be inserted into
         * the dictionary.
         * @returns A promise that resolves to a newly created number object.
         * Note: If a dictionary already contains an entry with the same key, the old entry
         * will be deleted and all DictIterators to this entry will be invalidated.
         */
        putNumber(key: string, value: number): Promise<PDFNet.Obj>;
        /**
         * Inserts a <key, Obj::Type::e_string> pair in the dictionary.
         * @param key - The key of the value to set.
         * @param value - The value of the Obj::Type::e_string object to be inserted into
         * the dictionary.
         * @returns A promise that resolves to a newly created string object.
         * Note: If a dictionary already contains an entry with the same key, the old entry
         * will be deleted and all DictIterators to this entry will be invalidated.
         */
        putString(key: string, value: string): Promise<PDFNet.Obj>;
        /**
         * Inserts a <key, Obj::Type::e_string> pair in the dictionary.
         * @param key - The key of the value to set.
         * @param t - The value of the Obj::Type::e_string object to be inserted into
         * the dictionary.
         * Note: PutText will create the string object as a 'PDF Text' object.
         * @returns A promise that resolves to a newly created string object.
         * Note: If a dictionary already contains an entry with the same key, the old entry
         * will be deleted and all DictIterators to this entry will be invalidated.
         */
        putText(key: string, t: string): Promise<PDFNet.Obj>;
        /**
         * Inserts a <key, Obj::Type::e_null> pair in the dictionary.
         * @param key - The key of the value to set.
         * Note: The effect of calling this method is essentially the same as dict.Erase(key) .
         */
        putNull(key: string): Promise<void>;
        /**
         * Inserts a <key, Obj> pair in the dictionary.
         * @param key - The key of the value to set.
         * @param input_obj - The value to be inserted into the dictionary. If 'obj' is
         * indirect (i.e. is a shared) object it will be inserted by reference,
         * otherwise the object will be cloned and then inserted into the dictionary.
         * @returns A promise that resolves to a newly inserted object.
         */
        put(key: string, input_obj: PDFNet.Obj): Promise<PDFNet.Obj>;
        /**
         * Inserts a <key, [x1,y1,x2,y2]> pair in the dictionary.
         * @param key - The key of the value to set.
         * @param x1 - The bottom left x value of the rect to be inserted
         * @param y1 - The bottom left y value of the rect to be inserted
         * @param x2 - The top right x value of the rect to be inserted
         * @param y2 - The top right y value of the rect to be inserted
         * @returns A promise that resolves to a newly created array object.
         *
         * Note: If a dictionary already contains an entry with the same key, the old entry
         * will be deleted and all DictIterators to this entry will be invalidated.
         */
        putRect(key: string, x1: number, y1: number, x2: number, y2: number): Promise<PDFNet.Obj>;
        /**
         * Inserts a <key, [a,b,c,d,h,v]> pair in the dictionary.
         * @param key - The key of the value to set.
         * @param mtx - A matrix used to set the values in an array of six numbers.
         * The resulting array will be inserted into the dictionary.
         * @returns A promise that resolves to a newly created array object.
         *
         * Note: If a dictionary already contains an entry with the same key, the old entry
         * will be deleted and all DictIterators to this entry will be invalidated.
         */
        putMatrix(key: string, mtx: PDFNet.Matrix2D): Promise<PDFNet.Obj>;
        /**
         * Removes an element in the dictionary that matches the given key.
         * @param key - A string representing the key value of the element to remove.
         */
        eraseFromKey(key: string): Promise<void>;
        /**
         * Removes an element in the dictionary from specified position.
         * @param pos - A dictionary iterator indicating the position of the element to remove.
         */
        erase(pos: PDFNet.DictIterator): Promise<void>;
        /**
         * Change the key value of a dictionary entry.
         * The key can't be renamed if another key with the same name already exists
         * in the dictionary. In this case Rename returns false.
         * @param old_key - A string representing the key value to be changed.
         * @param new_key - A string representing the key value that the old key is changed into.
         * @returns A promise that resolves to an object of type: "boolean"
         */
        rename(old_key: string, new_key: string): Promise<boolean>;
        /**
         * @returns A promise that resolves to true if this is an Array, false otherwise.
         * Note: this method can be invoked on any Obj.
         */
        isArray(): Promise<boolean>;
        /**
         * @param index - The array element to obtain. The first element in an array has an index of zero.
         * @returns A promise that resolves to an object of type: "PDFNet.Obj"
         */
        getAt(index: number): Promise<PDFNet.Obj>;
        /**
         * Inserts an Obj::Type::e_name object in the array.
         * @param pos - The location in the array to insert the object . The object is inserted
         *          before the specified location. The first element in an array has a pos of
         * 	        zero. If pos >= Array->Length(), appends obj to array.
         * @param name - The value of the Obj::Type::e_name object to be inserted.
         * @returns A promise that resolves to a newly created name object.
         */
        insertName(pos: number, name: string): Promise<PDFNet.Obj>;
        /**
         * Inserts an Obj::Type::e_array object in the array.
         * @param pos - The location in the array to insert the object . The object is inserted
         *          before the specified location. The first element in an array has a pos of
         * 	        zero. If pos >= Array->Length(), appends obj to array.
         * @returns A promise that resolves to a newly created array object.
         */
        insertArray(pos: number): Promise<PDFNet.Obj>;
        /**
         * Inserts an Obj::Type::e_bool object in the array.
         * @param pos - The location in the array to insert the object . The object is inserted
         *          before the specified location. The first element in an array has a pos of
         * 	        zero. If pos >= Array->Length(), appends obj to array.
         * @param value - The value of the Obj::Type::e_bool object to be inserted.
         * @returns A promise that resolves to a newly created boolean object.
         */
        insertBool(pos: number, value: boolean): Promise<PDFNet.Obj>;
        /**
         * Inserts an Obj::Type::e_dict object in the array.
         * @param pos - The location in the array to insert the object . The object is inserted
         *          before the specified location. The first element in an array has a pos of
         * 	        zero. If pos >= Array->Length(), appends obj to array.
         * @returns A promise that resolves to a newly created dictionary object.
         */
        insertDict(pos: number): Promise<PDFNet.Obj>;
        /**
         * Inserts an Obj::Type::e_number object in the array.
         * @param pos - The location in the array to insert the object . The object is inserted
         *          before the specified location. The first element in an array has a pos of
         * 	        zero. If pos >= Array->Length(), appends obj to array.
         * @param value - The value of the Obj::Type::e_number object to be inserted.
         * @returns A promise that resolves to a newly created number object.
         */
        insertNumber(pos: number, value: number): Promise<PDFNet.Obj>;
        /**
         * Inserts an Obj::Type::e_string object in the array.
         * @param pos - The location in the array to insert the object . The object is inserted
         *          before the specified location. The first element in an array has a pos of
         * 	        zero. If pos >= Array->Length(), appends obj to array.
         * @param value - The value of the Obj::Type::e_string object to be inserted.
         * @returns A promise that resolves to a newly created string object.
         */
        insertString(pos: number, value: string): Promise<PDFNet.Obj>;
        /**
         * Inserts an Obj::Type::e_string object in the array.
         * @param pos - The location in the array to insert the object . The object is inserted
         *          before the specified location. The first element in an array has a pos of
         * 	        zero. If pos >= Array->Length(), appends obj to array.
         * @param t - The value of the Obj::Type::e_string object to be inserted.
         *
         * Note: InsertText will create the string object as a 'PDF Text' object.
         * @returns A promise that resolves to a newly created string object.
         */
        insertText(pos: number, t: string): Promise<PDFNet.Obj>;
        /**
         * Inserts an Obj::Type::e_null object in the array.
         * @param pos - The location in the array to insert the object . The object is inserted
         *          before the specified location. The first element in an array has a pos of
         * 	        zero. If pos >= Array->Length(), appends obj to array.
         * @returns A promise that resolves to a newly created null object.
         */
        insertNull(pos: number): Promise<PDFNet.Obj>;
        /**
         * Inserts an existing Obj in this array.
         * @param pos - The location in the array to insert the object . The object is inserted
         *          before the specified location. The first element in an array has a pos of
         * 	        zero. If pos >= Array->Length(), appends obj to array.
         * @param input_obj - The value to be inserted into the dictionary. If 'obj' is
         * indirect (i.e. is a shared) object it will be inserted by reference,
         * otherwise the object will be cloned and then inserted.
         * @returns A promise that resolves to a newly inserted object.
         */
        insert(pos: number, input_obj: PDFNet.Obj): Promise<PDFNet.Obj>;
        /**
         * Inserts an array of 4 numbers in this array.
         * @param pos - The location in the array to insert the object . The object is inserted
         *          before the specified location. The first element in an array has a pos of
         * 	        zero. If pos >= Array->Length(), appends obj to array.
         * @param x1 - The bottom left x value of the rect to be inserted
         * @param y1 - The bottom left y value of the rect to be inserted
         * @param x2 - The top right x value of the rect to be inserted
         * @param y2 - The top right y value of the rect to be inserted
         * @returns A promise that resolves to a newly created array object.
         */
        insertRect(pos: number, x1: number, y1: number, x2: number, y2: number): Promise<PDFNet.Obj>;
        /**
         * Inserts an array of 6 numbers in this array.
         * @param pos - The location in the array to insert the object . The object is inserted
         *          before the specified location. The first element in an array has a pos of
         * 	        zero. If pos >= Array->Length(), appends obj to array.
         * @param mtx - A matrix used to set the values in an array of six numbers.
         * The resulting array will be then inserted in this array.
         * @returns A promise that resolves to a newly created array object.
         */
        insertMatrix(pos: number, mtx: PDFNet.Matrix2D): Promise<PDFNet.Obj>;
        /**
         * Appends a new Obj::Type::e_name object at the end of the array.
         * @param name - The value of the Obj::Type::e_name object.
         * @returns A promise that resolves to the new array object.
         */
        pushBackName(name: string): Promise<PDFNet.Obj>;
        /**
         * Appends a new Obj::Type::e_array object at the end of the array.
         * @returns A promise that resolves to the new array object.
         */
        pushBackArray(): Promise<PDFNet.Obj>;
        /**
         * Appends a new Obj::Type::e_bool object at the end of the array.
         * @param value - The value of the Obj::Type::e_bool object.
         * @returns A promise that resolves to the new boolean object.
         */
        pushBackBool(value: boolean): Promise<PDFNet.Obj>;
        /**
         * Appends a new Obj::Type::e_dict object at the end of the array.
         * @returns A promise that resolves to the new dictionary object.
         */
        pushBackDict(): Promise<PDFNet.Obj>;
        /**
         * Appends a new Obj::Type::e_number object at the end of the array.
         * @param value - The value of the Obj::Type::e_number object.
         * @returns A promise that resolves to the new number object.
         */
        pushBackNumber(value: number): Promise<PDFNet.Obj>;
        /**
         * Appends a new Obj::Type::e_string object at the end of the array.
         * @param value - The value of the Obj::Type::e_string object.
         * @returns A promise that resolves to the new string object.
         */
        pushBackString(value: string): Promise<PDFNet.Obj>;
        /**
         * Appends a new Obj::Type::e_string object at the end of the array.
         * @param t - The value of the Obj::Type::e_string object to be inserted.
         * Note: InsertText will create the string object as a 'PDF Text' object.
         * @returns A promise that resolves to the new string object.
         */
        pushBackText(t: string): Promise<PDFNet.Obj>;
        /**
         * Appends a new Obj::Type::e_null object at the end of the array.
         * @returns A promise that resolves to the new null object.
         */
        pushBackNull(): Promise<PDFNet.Obj>;
        /**
         * Appends an existing Obj at the end of the array.
         * @param input_obj - The value to be inserted into the dictionary. If 'obj' is
         * indirect (i.e. is a shared) object it will be inserted by reference,
         * otherwise the object will be cloned and then appended.
         * @returns A promise that resolves to a newly appended object.
         */
        pushBack(input_obj: PDFNet.Obj): Promise<PDFNet.Obj>;
        /**
         * Appends an array of 4 numbers at the end of the array.
         * @param x1 - The bottom left x value of the rect to be inserted
         * @param y1 - The bottom left y value of the rect to be inserted
         * @param x2 - The top right x value of the rect to be inserted
         * @param y2 - The top right y value of the rect to be inserted
         * @returns A promise that resolves to a newly appended array object.
         */
        pushBackRect(x1: number, y1: number, x2: number, y2: number): Promise<PDFNet.Obj>;
        /**
         * Appends an array of 6 numbers at the end of the array.
         * @param mtx - A matrix used to set the values in an array of six numbers.
         * The resulting array will be then inserted in this array.
         * @returns A promise that resolves to a newly appended array object.
         */
        pushBackMatrix(mtx: PDFNet.Matrix2D): Promise<PDFNet.Obj>;
        /**
         * Checks whether the position is within the array bounds and then removes it from the
         * array and moves each subsequent element to the slot with the next smaller index and
         * decrements the arrays length by 1.
         * @param pos - The index for the array member to remove. Array indexes start at 0.
         */
        eraseAt(pos: number): Promise<void>;
        /**
         * @returns A promise that resolves to true if this is a Stream, false otherwise.
         * Note: this method can be invoked on any Obj.
         */
        isStream(): Promise<boolean>;
        /**
         * @returns A promise that resolves to the length of the raw/encoded stream equal to the Length parameter
         */
        getRawStreamLength(): Promise<number>;
        setStreamData(data_buf: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray): Promise<void>;
        /**
         * allows to replace the content stream with a new one
         * without creating a new object
         */
        setStreamDataWithFilter(data_buf: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray, filter_chain: PDFNet.Filter): Promise<void>;
        /**
         * @param decrypt - If true decrypt the stream if the stream is encrypted.
         * @returns A promise that resolves to A filter to the encoded stream
         */
        getRawStream(decrypt: boolean): Promise<PDFNet.Filter>;
        /**
         * @returns A promise that resolves to A filter to the decoded stream
         */
        getDecodedStream(): Promise<PDFNet.Filter>;
        /**
         * Convert the SDF/Cos String object to 'PDF Text String' (a Unicode string).
        
        PDF Text Strings are not used to represent page content, however they
        are used in text annotations, bookmark names, article names, document
        information etc. These strings are encoded in either PDFDocEncoding or
        Unicode character encoding. For more information on PDF Text Strings,
        please refer to section 3.8.1 'Text Strings' in PDF Reference.
        Note: Not all SDF/Cos String objects are used to represent 'PDF Text'.
        PDF Reference indicates (on a case by case basis ) where an SDF/Cos String
        object can be used as 'PDF Text'.
         * @returns A promise that resolves to the Unicode string of the SDF/Cos String object
         */
        getAsPDFText(): Promise<string>;
    }
    /**
     * ObjSet is a lightweight container that can hold a collection of SDF objects.
     */
    class ObjSet extends PDFNet.Destroyable {
        /**
         * Constructor
         * @returns A promise that resolves to an object of type: "PDFNet.ObjSet"
         */
        static create(): Promise<PDFNet.ObjSet>;
        /**
         * Create a new name object in this object set.
         * @param name - The name of the object to create
         * @returns A promise that resolves to an object of type: "PDFNet.Obj"
         */
        createName(name: string): Promise<PDFNet.Obj>;
        /**
         * Create a new array object in this object set.
         * @returns A promise that resolves to an object of type: "PDFNet.Obj"
         */
        createArray(): Promise<PDFNet.Obj>;
        /**
         * Create a new boolean object in this object set.
         * @param value - The boolean value of the object to create
         * @returns A promise that resolves to an object of type: "PDFNet.Obj"
         */
        createBool(value: boolean): Promise<PDFNet.Obj>;
        /**
         * Create a new dictionary object in this object set.
         * @returns A promise that resolves to an object of type: "PDFNet.Obj"
         */
        createDict(): Promise<PDFNet.Obj>;
        /**
         * Create a new null object in this object set.
         * @returns A promise that resolves to an object of type: "PDFNet.Obj"
         */
        createNull(): Promise<PDFNet.Obj>;
        /**
         * Create a new number object in this object set.
         * @param value - numeric value of the number object to create.
         * @returns A promise that resolves to an object of type: "PDFNet.Obj"
         */
        createNumber(value: number): Promise<PDFNet.Obj>;
        /**
         * Create a new string object in this object set.
         * The unsigned string value of the string object to create.
         * @returns A promise that resolves to an object of type: "PDFNet.Obj"
         */
        createString(value: string): Promise<PDFNet.Obj>;
        /**
         * parses a json string to create either a Dictionary or an Array in ObjSet.
         *
         * return the created object as Obj
         * @returns A promise that resolves to an object of type: "PDFNet.Obj"
         */
        createFromJson(json: string): Promise<PDFNet.Obj>;
    }
    /**
     * This class represents an object identifier (OID), as defined by ITU and used in X.509.
     */
    class ObjectIdentifier extends PDFNet.Destroyable {
        /**
         * Constructs an ObjectIdentifier from an enum.
         * @param in_oid_enum - the enumerated value to use
         *
         * Note: Not all possible OID values are available as enum values.
         * @returns A promise that resolves to an object of type: "PDFNet.ObjectIdentifier"
         */
        static createFromPredefined(in_oid_enum: number): Promise<PDFNet.ObjectIdentifier>;
        /**
         * @returns A promise that resolves to an object of type: "PDFNet.ObjectIdentifier"
         */
        static createFromIntArray(in_list: number[]): Promise<PDFNet.ObjectIdentifier>;
        /**
         * @param in_algorithm - <pre>
         * PDFNet.DigestAlgorithm.Type = {
         * 	e_SHA1 : 0
         * 	e_SHA256 : 1
         * 	e_SHA384 : 2
         * 	e_SHA512 : 3
         * 	e_RIPEMD160 : 4
         * 	e_unknown_digest_algorithm : 5
         * }
         * </pre>
         * @returns A promise that resolves to an object of type: "PDFNet.ObjectIdentifier"
         */
        static createFromDigestAlgorithm(in_algorithm: number): Promise<PDFNet.ObjectIdentifier>;
        /**
         * Retrieves the value of the object identifier.
         * @returns A promise that resolves to the value of the object identifier, as a container of integer components.
         */
        getRawValue(): Promise<number[]>;
    }
    /**
     * [Missing documentation]
     */
    class OwnedBitmap {
    }
    /**
     * PDFACompliance class is used to validate PDF documents for PDF/A (ISO 19005:1/2/3)
     * compliance or to convert existing PDF files to PDF/A compliant documents.
     *
     * The conversion option analyzes the content of existing PDF files and performs
     * a sequence of modifications in order to produce a PDF/A compliant document.
     * Features that are not suitable for long-term archiving (such as encryption,
     * obsolete compression schemes, missing fonts, or device-dependent color) are
     * replaced with their PDF/A compliant equivalents. Because the conversion process
     * applies only necessary changes to the source file, the information loss is
     * minimal. Also, because the converter provides a detailed report for each change,
     * it is simple to inspect changes and to determine whether the conversion loss
     * is acceptable.
     *
     * The validation option in PDF/A Manager can be used to quickly determine whether
     * a PDF file fully complies with the PDF/A specification according to the
     * international standard ISO 19005:1/2/3. For files that are not compliant, the
     * validation option can be used to produce a detailed report of compliance
     * violations as well as a list of relevant error objects.
     *
     * Key Functions:
     * - Checks if a PDF file is compliant with PDF/A (ISO 19005:1/2/3) specification.
     * - Converts any PDF to a PDF/A compliant document.
     * - Supports PDF/A-1a, PDF/A-1b, PDF/A-2b
     * - Produces a detailed report of compliance violations and associated PDF objects.
     * - Keeps the required changes a minimum, preserving the consistency of the original.
     * - Tracks all changes to allow for automatic assessment of data loss.
     * - Allows user to customize compliance checks or omit specific changes.
     * - Preserves tags, logical structure, and color information in existing PDF documents.
     * - Offers automatic font substitution, embedding, and subsetting options.
     * - Supports automation and batch operation. PDF/A Converter is designed to be used
     *   in unattended mode in high throughput server or batch environments
     */
    class PDFACompliance extends PDFNet.Destroyable {
        /**
         * @returns A promise that resolves to the number of compliance violations.
         */
        getErrorCount(): Promise<number>;
        /**
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.PDFACompliance.ErrorCode = {
         * 	e_PDFA0_1_0 : 10
         * 	e_PDFA0_1_1 : 11
         * 	e_PDFA0_1_2 : 12
         * 	e_PDFA0_1_3 : 13
         * 	e_PDFA0_1_4 : 14
         * 	e_PDFA0_1_5 : 15
         * 	e_PDFA1_2_1 : 121
         * 	e_PDFA1_2_2 : 122
         * 	e_PDFA1_3_1 : 131
         * 	e_PDFA1_3_2 : 132
         * 	e_PDFA1_3_3 : 133
         * 	e_PDFA1_3_4 : 134
         * 	e_PDFA1_4_1 : 141
         * 	e_PDFA1_4_2 : 142
         * 	e_PDFA1_6_1 : 161
         * 	e_PDFA1_7_1 : 171
         * 	e_PDFA1_7_2 : 172
         * 	e_PDFA1_7_3 : 173
         * 	e_PDFA1_7_4 : 174
         * 	e_PDFA1_8_1 : 181
         * 	e_PDFA1_8_2 : 182
         * 	e_PDFA1_8_3 : 183
         * 	e_PDFA1_8_4 : 184
         * 	e_PDFA1_8_5 : 185
         * 	e_PDFA1_8_6 : 186
         * 	e_PDFA1_10_1 : 1101
         * 	e_PDFA1_11_1 : 1111
         * 	e_PDFA1_11_2 : 1112
         * 	e_PDFA1_12_1 : 1121
         * 	e_PDFA1_12_2 : 1122
         * 	e_PDFA1_12_3 : 1123
         * 	e_PDFA1_12_4 : 1124
         * 	e_PDFA1_12_5 : 1125
         * 	e_PDFA1_12_6 : 1126
         * 	e_PDFA1_13_1 : 1131
         * 	e_PDFA2_2_1 : 221
         * 	e_PDFA2_3_2 : 232
         * 	e_PDFA2_3_3 : 233
         * 	e_PDFA2_3_3_1 : 2331
         * 	e_PDFA2_3_3_2 : 2332
         * 	e_PDFA2_3_4_1 : 2341
         * 	e_PDFA2_4_1 : 241
         * 	e_PDFA2_4_2 : 242
         * 	e_PDFA2_4_3 : 243
         * 	e_PDFA2_4_4 : 244
         * 	e_PDFA2_5_1 : 251
         * 	e_PDFA2_5_2 : 252
         * 	e_PDFA2_6_1 : 261
         * 	e_PDFA2_7_1 : 271
         * 	e_PDFA2_8_1 : 281
         * 	e_PDFA2_9_1 : 291
         * 	e_PDFA2_10_1 : 2101
         * 	e_PDFA3_2_1 : 321
         * 	e_PDFA3_3_1 : 331
         * 	e_PDFA3_3_2 : 332
         * 	e_PDFA3_3_3_1 : 3331
         * 	e_PDFA3_3_3_2 : 3332
         * 	e_PDFA3_4_1 : 341
         * 	e_PDFA3_5_1 : 351
         * 	e_PDFA3_5_2 : 352
         * 	e_PDFA3_5_3 : 353
         * 	e_PDFA3_5_4 : 354
         * 	e_PDFA3_5_5 : 355
         * 	e_PDFA3_5_6 : 356
         * 	e_PDFA3_6_1 : 361
         * 	e_PDFA3_7_1 : 371
         * 	e_PDFA3_7_2 : 372
         * 	e_PDFA3_7_3 : 373
         * 	e_PDFA4_1 : 41
         * 	e_PDFA4_2 : 42
         * 	e_PDFA4_3 : 43
         * 	e_PDFA4_4 : 44
         * 	e_PDFA4_5 : 45
         * 	e_PDFA4_6 : 46
         * 	e_PDFA5_2_1 : 521
         * 	e_PDFA5_2_2 : 522
         * 	e_PDFA5_2_3 : 523
         * 	e_PDFA5_2_4 : 524
         * 	e_PDFA5_2_5 : 525
         * 	e_PDFA5_2_6 : 526
         * 	e_PDFA5_2_7 : 527
         * 	e_PDFA5_2_8 : 528
         * 	e_PDFA5_2_9 : 529
         * 	e_PDFA5_2_10 : 5210
         * 	e_PDFA5_2_11 : 5211
         * 	e_PDFA5_3_1 : 531
         * 	e_PDFA5_3_2_1 : 5321
         * 	e_PDFA5_3_2_2 : 5322
         * 	e_PDFA5_3_2_3 : 5323
         * 	e_PDFA5_3_2_4 : 5324
         * 	e_PDFA5_3_2_5 : 5325
         * 	e_PDFA5_3_3_1 : 5331
         * 	e_PDFA5_3_3_2 : 5332
         * 	e_PDFA5_3_3_3 : 5333
         * 	e_PDFA5_3_3_4 : 5334
         * 	e_PDFA5_3_4_0 : 5340
         * 	e_PDFA5_3_4_1 : 5341
         * 	e_PDFA5_3_4_2 : 5342
         * 	e_PDFA5_3_4_3 : 5343
         * 	e_PDFA6_1_1 : 611
         * 	e_PDFA6_1_2 : 612
         * 	e_PDFA6_2_1 : 621
         * 	e_PDFA6_2_2 : 622
         * 	e_PDFA6_2_3 : 623
         * 	e_PDFA7_2_1 : 721
         * 	e_PDFA7_2_2 : 722
         * 	e_PDFA7_2_3 : 723
         * 	e_PDFA7_2_4 : 724
         * 	e_PDFA7_2_5 : 725
         * 	e_PDFA7_3_1 : 731
         * 	e_PDFA7_3_2 : 732
         * 	e_PDFA7_3_3 : 733
         * 	e_PDFA7_3_4 : 734
         * 	e_PDFA7_3_5 : 735
         * 	e_PDFA7_3_6 : 736
         * 	e_PDFA7_3_7 : 737
         * 	e_PDFA7_3_8 : 738
         * 	e_PDFA7_3_9 : 739
         * 	e_PDFA7_5_1 : 751
         * 	e_PDFA7_8_1 : 781
         * 	e_PDFA7_8_2 : 782
         * 	e_PDFA7_8_3 : 783
         * 	e_PDFA7_8_4 : 784
         * 	e_PDFA7_8_5 : 785
         * 	e_PDFA7_8_6 : 786
         * 	e_PDFA7_8_7 : 787
         * 	e_PDFA7_8_8 : 788
         * 	e_PDFA7_8_9 : 789
         * 	e_PDFA7_8_10 : 7810
         * 	e_PDFA7_8_11 : 7811
         * 	e_PDFA7_8_12 : 7812
         * 	e_PDFA7_8_13 : 7813
         * 	e_PDFA7_8_14 : 7814
         * 	e_PDFA7_8_15 : 7815
         * 	e_PDFA7_8_16 : 7816
         * 	e_PDFA7_8_17 : 7817
         * 	e_PDFA7_8_18 : 7818
         * 	e_PDFA7_8_19 : 7819
         * 	e_PDFA7_8_20 : 7820
         * 	e_PDFA7_8_21 : 7821
         * 	e_PDFA7_8_22 : 7822
         * 	e_PDFA7_8_23 : 7823
         * 	e_PDFA7_8_24 : 7824
         * 	e_PDFA7_8_25 : 7825
         * 	e_PDFA7_8_26 : 7826
         * 	e_PDFA7_8_27 : 7827
         * 	e_PDFA7_8_28 : 7828
         * 	e_PDFA7_8_29 : 7829
         * 	e_PDFA7_8_30 : 7830
         * 	e_PDFA7_8_31 : 7831
         * 	e_PDFA7_11_1 : 7111
         * 	e_PDFA7_11_2 : 7112
         * 	e_PDFA7_11_3 : 7113
         * 	e_PDFA7_11_4 : 7114
         * 	e_PDFA7_11_5 : 7115
         * 	e_PDFA9_1 : 91
         * 	e_PDFA9_2 : 92
         * 	e_PDFA9_3 : 93
         * 	e_PDFA9_4 : 94
         * 	e_PDFA3_8_1 : 381
         * 	e_PDFA8_2_2 : 822
         * 	e_PDFA8_3_3_1 : 8331
         * 	e_PDFA8_3_3_2 : 8332
         * 	e_PDFA8_3_4_1 : 8341
         * 	e_PDFA1_2_3 : 123
         * 	e_PDFA1_10_2 : 1102
         * 	e_PDFA1_10_3 : 1103
         * 	e_PDFA1_12_10 : 11210
         * 	e_PDFA1_13_5 : 1135
         * 	e_PDFA2_3_10 : 2310
         * 	e_PDFA2_4_2_10 : 24220
         * 	e_PDFA2_4_2_11 : 24221
         * 	e_PDFA2_4_2_12 : 24222
         * 	e_PDFA2_4_2_13 : 24223
         * 	e_PDFA2_5_10 : 2510
         * 	e_PDFA2_5_11 : 2511
         * 	e_PDFA2_5_12 : 2512
         * 	e_PDFA2_8_3_1 : 2831
         * 	e_PDFA2_8_3_2 : 2832
         * 	e_PDFA2_8_3_3 : 2833
         * 	e_PDFA2_8_3_4 : 2834
         * 	e_PDFA2_8_3_5 : 2835
         * 	e_PDFA2_10_20 : 21020
         * 	e_PDFA2_10_21 : 21021
         * 	e_PDFA11_0_0 : 11000
         * 	e_PDFA6_2_11_8 : 62118
         * 	e_PDFA8_1 : 81
         * 	e_PDFA_3E1 : 1
         * 	e_PDFA_3E2 : 2
         * 	e_PDFA_3E3 : 3
         * 	e_PDFA_LAST : 4
         * }
         * </pre>
         * @param idx - The index in the array of error code identifiers.
         * The array is indexed starting from zero.
         * @returns A promise that resolves to the error identifier.
         */
        getError(idx: number): Promise<number>;
        /**
         * @param id - <pre>
         * PDFNet.PDFACompliance.ErrorCode = {
         * 	e_PDFA0_1_0 : 10
         * 	e_PDFA0_1_1 : 11
         * 	e_PDFA0_1_2 : 12
         * 	e_PDFA0_1_3 : 13
         * 	e_PDFA0_1_4 : 14
         * 	e_PDFA0_1_5 : 15
         * 	e_PDFA1_2_1 : 121
         * 	e_PDFA1_2_2 : 122
         * 	e_PDFA1_3_1 : 131
         * 	e_PDFA1_3_2 : 132
         * 	e_PDFA1_3_3 : 133
         * 	e_PDFA1_3_4 : 134
         * 	e_PDFA1_4_1 : 141
         * 	e_PDFA1_4_2 : 142
         * 	e_PDFA1_6_1 : 161
         * 	e_PDFA1_7_1 : 171
         * 	e_PDFA1_7_2 : 172
         * 	e_PDFA1_7_3 : 173
         * 	e_PDFA1_7_4 : 174
         * 	e_PDFA1_8_1 : 181
         * 	e_PDFA1_8_2 : 182
         * 	e_PDFA1_8_3 : 183
         * 	e_PDFA1_8_4 : 184
         * 	e_PDFA1_8_5 : 185
         * 	e_PDFA1_8_6 : 186
         * 	e_PDFA1_10_1 : 1101
         * 	e_PDFA1_11_1 : 1111
         * 	e_PDFA1_11_2 : 1112
         * 	e_PDFA1_12_1 : 1121
         * 	e_PDFA1_12_2 : 1122
         * 	e_PDFA1_12_3 : 1123
         * 	e_PDFA1_12_4 : 1124
         * 	e_PDFA1_12_5 : 1125
         * 	e_PDFA1_12_6 : 1126
         * 	e_PDFA1_13_1 : 1131
         * 	e_PDFA2_2_1 : 221
         * 	e_PDFA2_3_2 : 232
         * 	e_PDFA2_3_3 : 233
         * 	e_PDFA2_3_3_1 : 2331
         * 	e_PDFA2_3_3_2 : 2332
         * 	e_PDFA2_3_4_1 : 2341
         * 	e_PDFA2_4_1 : 241
         * 	e_PDFA2_4_2 : 242
         * 	e_PDFA2_4_3 : 243
         * 	e_PDFA2_4_4 : 244
         * 	e_PDFA2_5_1 : 251
         * 	e_PDFA2_5_2 : 252
         * 	e_PDFA2_6_1 : 261
         * 	e_PDFA2_7_1 : 271
         * 	e_PDFA2_8_1 : 281
         * 	e_PDFA2_9_1 : 291
         * 	e_PDFA2_10_1 : 2101
         * 	e_PDFA3_2_1 : 321
         * 	e_PDFA3_3_1 : 331
         * 	e_PDFA3_3_2 : 332
         * 	e_PDFA3_3_3_1 : 3331
         * 	e_PDFA3_3_3_2 : 3332
         * 	e_PDFA3_4_1 : 341
         * 	e_PDFA3_5_1 : 351
         * 	e_PDFA3_5_2 : 352
         * 	e_PDFA3_5_3 : 353
         * 	e_PDFA3_5_4 : 354
         * 	e_PDFA3_5_5 : 355
         * 	e_PDFA3_5_6 : 356
         * 	e_PDFA3_6_1 : 361
         * 	e_PDFA3_7_1 : 371
         * 	e_PDFA3_7_2 : 372
         * 	e_PDFA3_7_3 : 373
         * 	e_PDFA4_1 : 41
         * 	e_PDFA4_2 : 42
         * 	e_PDFA4_3 : 43
         * 	e_PDFA4_4 : 44
         * 	e_PDFA4_5 : 45
         * 	e_PDFA4_6 : 46
         * 	e_PDFA5_2_1 : 521
         * 	e_PDFA5_2_2 : 522
         * 	e_PDFA5_2_3 : 523
         * 	e_PDFA5_2_4 : 524
         * 	e_PDFA5_2_5 : 525
         * 	e_PDFA5_2_6 : 526
         * 	e_PDFA5_2_7 : 527
         * 	e_PDFA5_2_8 : 528
         * 	e_PDFA5_2_9 : 529
         * 	e_PDFA5_2_10 : 5210
         * 	e_PDFA5_2_11 : 5211
         * 	e_PDFA5_3_1 : 531
         * 	e_PDFA5_3_2_1 : 5321
         * 	e_PDFA5_3_2_2 : 5322
         * 	e_PDFA5_3_2_3 : 5323
         * 	e_PDFA5_3_2_4 : 5324
         * 	e_PDFA5_3_2_5 : 5325
         * 	e_PDFA5_3_3_1 : 5331
         * 	e_PDFA5_3_3_2 : 5332
         * 	e_PDFA5_3_3_3 : 5333
         * 	e_PDFA5_3_3_4 : 5334
         * 	e_PDFA5_3_4_0 : 5340
         * 	e_PDFA5_3_4_1 : 5341
         * 	e_PDFA5_3_4_2 : 5342
         * 	e_PDFA5_3_4_3 : 5343
         * 	e_PDFA6_1_1 : 611
         * 	e_PDFA6_1_2 : 612
         * 	e_PDFA6_2_1 : 621
         * 	e_PDFA6_2_2 : 622
         * 	e_PDFA6_2_3 : 623
         * 	e_PDFA7_2_1 : 721
         * 	e_PDFA7_2_2 : 722
         * 	e_PDFA7_2_3 : 723
         * 	e_PDFA7_2_4 : 724
         * 	e_PDFA7_2_5 : 725
         * 	e_PDFA7_3_1 : 731
         * 	e_PDFA7_3_2 : 732
         * 	e_PDFA7_3_3 : 733
         * 	e_PDFA7_3_4 : 734
         * 	e_PDFA7_3_5 : 735
         * 	e_PDFA7_3_6 : 736
         * 	e_PDFA7_3_7 : 737
         * 	e_PDFA7_3_8 : 738
         * 	e_PDFA7_3_9 : 739
         * 	e_PDFA7_5_1 : 751
         * 	e_PDFA7_8_1 : 781
         * 	e_PDFA7_8_2 : 782
         * 	e_PDFA7_8_3 : 783
         * 	e_PDFA7_8_4 : 784
         * 	e_PDFA7_8_5 : 785
         * 	e_PDFA7_8_6 : 786
         * 	e_PDFA7_8_7 : 787
         * 	e_PDFA7_8_8 : 788
         * 	e_PDFA7_8_9 : 789
         * 	e_PDFA7_8_10 : 7810
         * 	e_PDFA7_8_11 : 7811
         * 	e_PDFA7_8_12 : 7812
         * 	e_PDFA7_8_13 : 7813
         * 	e_PDFA7_8_14 : 7814
         * 	e_PDFA7_8_15 : 7815
         * 	e_PDFA7_8_16 : 7816
         * 	e_PDFA7_8_17 : 7817
         * 	e_PDFA7_8_18 : 7818
         * 	e_PDFA7_8_19 : 7819
         * 	e_PDFA7_8_20 : 7820
         * 	e_PDFA7_8_21 : 7821
         * 	e_PDFA7_8_22 : 7822
         * 	e_PDFA7_8_23 : 7823
         * 	e_PDFA7_8_24 : 7824
         * 	e_PDFA7_8_25 : 7825
         * 	e_PDFA7_8_26 : 7826
         * 	e_PDFA7_8_27 : 7827
         * 	e_PDFA7_8_28 : 7828
         * 	e_PDFA7_8_29 : 7829
         * 	e_PDFA7_8_30 : 7830
         * 	e_PDFA7_8_31 : 7831
         * 	e_PDFA7_11_1 : 7111
         * 	e_PDFA7_11_2 : 7112
         * 	e_PDFA7_11_3 : 7113
         * 	e_PDFA7_11_4 : 7114
         * 	e_PDFA7_11_5 : 7115
         * 	e_PDFA9_1 : 91
         * 	e_PDFA9_2 : 92
         * 	e_PDFA9_3 : 93
         * 	e_PDFA9_4 : 94
         * 	e_PDFA3_8_1 : 381
         * 	e_PDFA8_2_2 : 822
         * 	e_PDFA8_3_3_1 : 8331
         * 	e_PDFA8_3_3_2 : 8332
         * 	e_PDFA8_3_4_1 : 8341
         * 	e_PDFA1_2_3 : 123
         * 	e_PDFA1_10_2 : 1102
         * 	e_PDFA1_10_3 : 1103
         * 	e_PDFA1_12_10 : 11210
         * 	e_PDFA1_13_5 : 1135
         * 	e_PDFA2_3_10 : 2310
         * 	e_PDFA2_4_2_10 : 24220
         * 	e_PDFA2_4_2_11 : 24221
         * 	e_PDFA2_4_2_12 : 24222
         * 	e_PDFA2_4_2_13 : 24223
         * 	e_PDFA2_5_10 : 2510
         * 	e_PDFA2_5_11 : 2511
         * 	e_PDFA2_5_12 : 2512
         * 	e_PDFA2_8_3_1 : 2831
         * 	e_PDFA2_8_3_2 : 2832
         * 	e_PDFA2_8_3_3 : 2833
         * 	e_PDFA2_8_3_4 : 2834
         * 	e_PDFA2_8_3_5 : 2835
         * 	e_PDFA2_10_20 : 21020
         * 	e_PDFA2_10_21 : 21021
         * 	e_PDFA11_0_0 : 11000
         * 	e_PDFA6_2_11_8 : 62118
         * 	e_PDFA8_1 : 81
         * 	e_PDFA_3E1 : 1
         * 	e_PDFA_3E2 : 2
         * 	e_PDFA_3E3 : 3
         * 	e_PDFA_LAST : 4
         * }
         * </pre>
         * error code identifier (obtained using GetError() method).
         * @returns A promise that resolves to the number of object references associated with a given error.
         */
        getRefObjCount(id: number): Promise<number>;
        /**
         * @param id - <pre>
         * PDFNet.PDFACompliance.ErrorCode = {
         * 	e_PDFA0_1_0 : 10
         * 	e_PDFA0_1_1 : 11
         * 	e_PDFA0_1_2 : 12
         * 	e_PDFA0_1_3 : 13
         * 	e_PDFA0_1_4 : 14
         * 	e_PDFA0_1_5 : 15
         * 	e_PDFA1_2_1 : 121
         * 	e_PDFA1_2_2 : 122
         * 	e_PDFA1_3_1 : 131
         * 	e_PDFA1_3_2 : 132
         * 	e_PDFA1_3_3 : 133
         * 	e_PDFA1_3_4 : 134
         * 	e_PDFA1_4_1 : 141
         * 	e_PDFA1_4_2 : 142
         * 	e_PDFA1_6_1 : 161
         * 	e_PDFA1_7_1 : 171
         * 	e_PDFA1_7_2 : 172
         * 	e_PDFA1_7_3 : 173
         * 	e_PDFA1_7_4 : 174
         * 	e_PDFA1_8_1 : 181
         * 	e_PDFA1_8_2 : 182
         * 	e_PDFA1_8_3 : 183
         * 	e_PDFA1_8_4 : 184
         * 	e_PDFA1_8_5 : 185
         * 	e_PDFA1_8_6 : 186
         * 	e_PDFA1_10_1 : 1101
         * 	e_PDFA1_11_1 : 1111
         * 	e_PDFA1_11_2 : 1112
         * 	e_PDFA1_12_1 : 1121
         * 	e_PDFA1_12_2 : 1122
         * 	e_PDFA1_12_3 : 1123
         * 	e_PDFA1_12_4 : 1124
         * 	e_PDFA1_12_5 : 1125
         * 	e_PDFA1_12_6 : 1126
         * 	e_PDFA1_13_1 : 1131
         * 	e_PDFA2_2_1 : 221
         * 	e_PDFA2_3_2 : 232
         * 	e_PDFA2_3_3 : 233
         * 	e_PDFA2_3_3_1 : 2331
         * 	e_PDFA2_3_3_2 : 2332
         * 	e_PDFA2_3_4_1 : 2341
         * 	e_PDFA2_4_1 : 241
         * 	e_PDFA2_4_2 : 242
         * 	e_PDFA2_4_3 : 243
         * 	e_PDFA2_4_4 : 244
         * 	e_PDFA2_5_1 : 251
         * 	e_PDFA2_5_2 : 252
         * 	e_PDFA2_6_1 : 261
         * 	e_PDFA2_7_1 : 271
         * 	e_PDFA2_8_1 : 281
         * 	e_PDFA2_9_1 : 291
         * 	e_PDFA2_10_1 : 2101
         * 	e_PDFA3_2_1 : 321
         * 	e_PDFA3_3_1 : 331
         * 	e_PDFA3_3_2 : 332
         * 	e_PDFA3_3_3_1 : 3331
         * 	e_PDFA3_3_3_2 : 3332
         * 	e_PDFA3_4_1 : 341
         * 	e_PDFA3_5_1 : 351
         * 	e_PDFA3_5_2 : 352
         * 	e_PDFA3_5_3 : 353
         * 	e_PDFA3_5_4 : 354
         * 	e_PDFA3_5_5 : 355
         * 	e_PDFA3_5_6 : 356
         * 	e_PDFA3_6_1 : 361
         * 	e_PDFA3_7_1 : 371
         * 	e_PDFA3_7_2 : 372
         * 	e_PDFA3_7_3 : 373
         * 	e_PDFA4_1 : 41
         * 	e_PDFA4_2 : 42
         * 	e_PDFA4_3 : 43
         * 	e_PDFA4_4 : 44
         * 	e_PDFA4_5 : 45
         * 	e_PDFA4_6 : 46
         * 	e_PDFA5_2_1 : 521
         * 	e_PDFA5_2_2 : 522
         * 	e_PDFA5_2_3 : 523
         * 	e_PDFA5_2_4 : 524
         * 	e_PDFA5_2_5 : 525
         * 	e_PDFA5_2_6 : 526
         * 	e_PDFA5_2_7 : 527
         * 	e_PDFA5_2_8 : 528
         * 	e_PDFA5_2_9 : 529
         * 	e_PDFA5_2_10 : 5210
         * 	e_PDFA5_2_11 : 5211
         * 	e_PDFA5_3_1 : 531
         * 	e_PDFA5_3_2_1 : 5321
         * 	e_PDFA5_3_2_2 : 5322
         * 	e_PDFA5_3_2_3 : 5323
         * 	e_PDFA5_3_2_4 : 5324
         * 	e_PDFA5_3_2_5 : 5325
         * 	e_PDFA5_3_3_1 : 5331
         * 	e_PDFA5_3_3_2 : 5332
         * 	e_PDFA5_3_3_3 : 5333
         * 	e_PDFA5_3_3_4 : 5334
         * 	e_PDFA5_3_4_0 : 5340
         * 	e_PDFA5_3_4_1 : 5341
         * 	e_PDFA5_3_4_2 : 5342
         * 	e_PDFA5_3_4_3 : 5343
         * 	e_PDFA6_1_1 : 611
         * 	e_PDFA6_1_2 : 612
         * 	e_PDFA6_2_1 : 621
         * 	e_PDFA6_2_2 : 622
         * 	e_PDFA6_2_3 : 623
         * 	e_PDFA7_2_1 : 721
         * 	e_PDFA7_2_2 : 722
         * 	e_PDFA7_2_3 : 723
         * 	e_PDFA7_2_4 : 724
         * 	e_PDFA7_2_5 : 725
         * 	e_PDFA7_3_1 : 731
         * 	e_PDFA7_3_2 : 732
         * 	e_PDFA7_3_3 : 733
         * 	e_PDFA7_3_4 : 734
         * 	e_PDFA7_3_5 : 735
         * 	e_PDFA7_3_6 : 736
         * 	e_PDFA7_3_7 : 737
         * 	e_PDFA7_3_8 : 738
         * 	e_PDFA7_3_9 : 739
         * 	e_PDFA7_5_1 : 751
         * 	e_PDFA7_8_1 : 781
         * 	e_PDFA7_8_2 : 782
         * 	e_PDFA7_8_3 : 783
         * 	e_PDFA7_8_4 : 784
         * 	e_PDFA7_8_5 : 785
         * 	e_PDFA7_8_6 : 786
         * 	e_PDFA7_8_7 : 787
         * 	e_PDFA7_8_8 : 788
         * 	e_PDFA7_8_9 : 789
         * 	e_PDFA7_8_10 : 7810
         * 	e_PDFA7_8_11 : 7811
         * 	e_PDFA7_8_12 : 7812
         * 	e_PDFA7_8_13 : 7813
         * 	e_PDFA7_8_14 : 7814
         * 	e_PDFA7_8_15 : 7815
         * 	e_PDFA7_8_16 : 7816
         * 	e_PDFA7_8_17 : 7817
         * 	e_PDFA7_8_18 : 7818
         * 	e_PDFA7_8_19 : 7819
         * 	e_PDFA7_8_20 : 7820
         * 	e_PDFA7_8_21 : 7821
         * 	e_PDFA7_8_22 : 7822
         * 	e_PDFA7_8_23 : 7823
         * 	e_PDFA7_8_24 : 7824
         * 	e_PDFA7_8_25 : 7825
         * 	e_PDFA7_8_26 : 7826
         * 	e_PDFA7_8_27 : 7827
         * 	e_PDFA7_8_28 : 7828
         * 	e_PDFA7_8_29 : 7829
         * 	e_PDFA7_8_30 : 7830
         * 	e_PDFA7_8_31 : 7831
         * 	e_PDFA7_11_1 : 7111
         * 	e_PDFA7_11_2 : 7112
         * 	e_PDFA7_11_3 : 7113
         * 	e_PDFA7_11_4 : 7114
         * 	e_PDFA7_11_5 : 7115
         * 	e_PDFA9_1 : 91
         * 	e_PDFA9_2 : 92
         * 	e_PDFA9_3 : 93
         * 	e_PDFA9_4 : 94
         * 	e_PDFA3_8_1 : 381
         * 	e_PDFA8_2_2 : 822
         * 	e_PDFA8_3_3_1 : 8331
         * 	e_PDFA8_3_3_2 : 8332
         * 	e_PDFA8_3_4_1 : 8341
         * 	e_PDFA1_2_3 : 123
         * 	e_PDFA1_10_2 : 1102
         * 	e_PDFA1_10_3 : 1103
         * 	e_PDFA1_12_10 : 11210
         * 	e_PDFA1_13_5 : 1135
         * 	e_PDFA2_3_10 : 2310
         * 	e_PDFA2_4_2_10 : 24220
         * 	e_PDFA2_4_2_11 : 24221
         * 	e_PDFA2_4_2_12 : 24222
         * 	e_PDFA2_4_2_13 : 24223
         * 	e_PDFA2_5_10 : 2510
         * 	e_PDFA2_5_11 : 2511
         * 	e_PDFA2_5_12 : 2512
         * 	e_PDFA2_8_3_1 : 2831
         * 	e_PDFA2_8_3_2 : 2832
         * 	e_PDFA2_8_3_3 : 2833
         * 	e_PDFA2_8_3_4 : 2834
         * 	e_PDFA2_8_3_5 : 2835
         * 	e_PDFA2_10_20 : 21020
         * 	e_PDFA2_10_21 : 21021
         * 	e_PDFA11_0_0 : 11000
         * 	e_PDFA6_2_11_8 : 62118
         * 	e_PDFA8_1 : 81
         * 	e_PDFA_3E1 : 1
         * 	e_PDFA_3E2 : 2
         * 	e_PDFA_3E3 : 3
         * 	e_PDFA_LAST : 4
         * }
         * </pre>
         * error code identifier (obtained using GetError() method).
         * @param err_idx - The index in the array of object references.
         * The array is indexed starting from zero.
         * @returns A promise that resolves to a specific object reference associated with a given error type.
         * The return value is a PDF object identifier (i.e. object number for
         * 'pdftron.SDF.Obj)) for the that is associated with the error.
         */
        getRefObj(id: number, err_idx: number): Promise<number>;
        /**
         * @param id - <pre>
         * PDFNet.PDFACompliance.ErrorCode = {
         * 	e_PDFA0_1_0 : 10
         * 	e_PDFA0_1_1 : 11
         * 	e_PDFA0_1_2 : 12
         * 	e_PDFA0_1_3 : 13
         * 	e_PDFA0_1_4 : 14
         * 	e_PDFA0_1_5 : 15
         * 	e_PDFA1_2_1 : 121
         * 	e_PDFA1_2_2 : 122
         * 	e_PDFA1_3_1 : 131
         * 	e_PDFA1_3_2 : 132
         * 	e_PDFA1_3_3 : 133
         * 	e_PDFA1_3_4 : 134
         * 	e_PDFA1_4_1 : 141
         * 	e_PDFA1_4_2 : 142
         * 	e_PDFA1_6_1 : 161
         * 	e_PDFA1_7_1 : 171
         * 	e_PDFA1_7_2 : 172
         * 	e_PDFA1_7_3 : 173
         * 	e_PDFA1_7_4 : 174
         * 	e_PDFA1_8_1 : 181
         * 	e_PDFA1_8_2 : 182
         * 	e_PDFA1_8_3 : 183
         * 	e_PDFA1_8_4 : 184
         * 	e_PDFA1_8_5 : 185
         * 	e_PDFA1_8_6 : 186
         * 	e_PDFA1_10_1 : 1101
         * 	e_PDFA1_11_1 : 1111
         * 	e_PDFA1_11_2 : 1112
         * 	e_PDFA1_12_1 : 1121
         * 	e_PDFA1_12_2 : 1122
         * 	e_PDFA1_12_3 : 1123
         * 	e_PDFA1_12_4 : 1124
         * 	e_PDFA1_12_5 : 1125
         * 	e_PDFA1_12_6 : 1126
         * 	e_PDFA1_13_1 : 1131
         * 	e_PDFA2_2_1 : 221
         * 	e_PDFA2_3_2 : 232
         * 	e_PDFA2_3_3 : 233
         * 	e_PDFA2_3_3_1 : 2331
         * 	e_PDFA2_3_3_2 : 2332
         * 	e_PDFA2_3_4_1 : 2341
         * 	e_PDFA2_4_1 : 241
         * 	e_PDFA2_4_2 : 242
         * 	e_PDFA2_4_3 : 243
         * 	e_PDFA2_4_4 : 244
         * 	e_PDFA2_5_1 : 251
         * 	e_PDFA2_5_2 : 252
         * 	e_PDFA2_6_1 : 261
         * 	e_PDFA2_7_1 : 271
         * 	e_PDFA2_8_1 : 281
         * 	e_PDFA2_9_1 : 291
         * 	e_PDFA2_10_1 : 2101
         * 	e_PDFA3_2_1 : 321
         * 	e_PDFA3_3_1 : 331
         * 	e_PDFA3_3_2 : 332
         * 	e_PDFA3_3_3_1 : 3331
         * 	e_PDFA3_3_3_2 : 3332
         * 	e_PDFA3_4_1 : 341
         * 	e_PDFA3_5_1 : 351
         * 	e_PDFA3_5_2 : 352
         * 	e_PDFA3_5_3 : 353
         * 	e_PDFA3_5_4 : 354
         * 	e_PDFA3_5_5 : 355
         * 	e_PDFA3_5_6 : 356
         * 	e_PDFA3_6_1 : 361
         * 	e_PDFA3_7_1 : 371
         * 	e_PDFA3_7_2 : 372
         * 	e_PDFA3_7_3 : 373
         * 	e_PDFA4_1 : 41
         * 	e_PDFA4_2 : 42
         * 	e_PDFA4_3 : 43
         * 	e_PDFA4_4 : 44
         * 	e_PDFA4_5 : 45
         * 	e_PDFA4_6 : 46
         * 	e_PDFA5_2_1 : 521
         * 	e_PDFA5_2_2 : 522
         * 	e_PDFA5_2_3 : 523
         * 	e_PDFA5_2_4 : 524
         * 	e_PDFA5_2_5 : 525
         * 	e_PDFA5_2_6 : 526
         * 	e_PDFA5_2_7 : 527
         * 	e_PDFA5_2_8 : 528
         * 	e_PDFA5_2_9 : 529
         * 	e_PDFA5_2_10 : 5210
         * 	e_PDFA5_2_11 : 5211
         * 	e_PDFA5_3_1 : 531
         * 	e_PDFA5_3_2_1 : 5321
         * 	e_PDFA5_3_2_2 : 5322
         * 	e_PDFA5_3_2_3 : 5323
         * 	e_PDFA5_3_2_4 : 5324
         * 	e_PDFA5_3_2_5 : 5325
         * 	e_PDFA5_3_3_1 : 5331
         * 	e_PDFA5_3_3_2 : 5332
         * 	e_PDFA5_3_3_3 : 5333
         * 	e_PDFA5_3_3_4 : 5334
         * 	e_PDFA5_3_4_0 : 5340
         * 	e_PDFA5_3_4_1 : 5341
         * 	e_PDFA5_3_4_2 : 5342
         * 	e_PDFA5_3_4_3 : 5343
         * 	e_PDFA6_1_1 : 611
         * 	e_PDFA6_1_2 : 612
         * 	e_PDFA6_2_1 : 621
         * 	e_PDFA6_2_2 : 622
         * 	e_PDFA6_2_3 : 623
         * 	e_PDFA7_2_1 : 721
         * 	e_PDFA7_2_2 : 722
         * 	e_PDFA7_2_3 : 723
         * 	e_PDFA7_2_4 : 724
         * 	e_PDFA7_2_5 : 725
         * 	e_PDFA7_3_1 : 731
         * 	e_PDFA7_3_2 : 732
         * 	e_PDFA7_3_3 : 733
         * 	e_PDFA7_3_4 : 734
         * 	e_PDFA7_3_5 : 735
         * 	e_PDFA7_3_6 : 736
         * 	e_PDFA7_3_7 : 737
         * 	e_PDFA7_3_8 : 738
         * 	e_PDFA7_3_9 : 739
         * 	e_PDFA7_5_1 : 751
         * 	e_PDFA7_8_1 : 781
         * 	e_PDFA7_8_2 : 782
         * 	e_PDFA7_8_3 : 783
         * 	e_PDFA7_8_4 : 784
         * 	e_PDFA7_8_5 : 785
         * 	e_PDFA7_8_6 : 786
         * 	e_PDFA7_8_7 : 787
         * 	e_PDFA7_8_8 : 788
         * 	e_PDFA7_8_9 : 789
         * 	e_PDFA7_8_10 : 7810
         * 	e_PDFA7_8_11 : 7811
         * 	e_PDFA7_8_12 : 7812
         * 	e_PDFA7_8_13 : 7813
         * 	e_PDFA7_8_14 : 7814
         * 	e_PDFA7_8_15 : 7815
         * 	e_PDFA7_8_16 : 7816
         * 	e_PDFA7_8_17 : 7817
         * 	e_PDFA7_8_18 : 7818
         * 	e_PDFA7_8_19 : 7819
         * 	e_PDFA7_8_20 : 7820
         * 	e_PDFA7_8_21 : 7821
         * 	e_PDFA7_8_22 : 7822
         * 	e_PDFA7_8_23 : 7823
         * 	e_PDFA7_8_24 : 7824
         * 	e_PDFA7_8_25 : 7825
         * 	e_PDFA7_8_26 : 7826
         * 	e_PDFA7_8_27 : 7827
         * 	e_PDFA7_8_28 : 7828
         * 	e_PDFA7_8_29 : 7829
         * 	e_PDFA7_8_30 : 7830
         * 	e_PDFA7_8_31 : 7831
         * 	e_PDFA7_11_1 : 7111
         * 	e_PDFA7_11_2 : 7112
         * 	e_PDFA7_11_3 : 7113
         * 	e_PDFA7_11_4 : 7114
         * 	e_PDFA7_11_5 : 7115
         * 	e_PDFA9_1 : 91
         * 	e_PDFA9_2 : 92
         * 	e_PDFA9_3 : 93
         * 	e_PDFA9_4 : 94
         * 	e_PDFA3_8_1 : 381
         * 	e_PDFA8_2_2 : 822
         * 	e_PDFA8_3_3_1 : 8331
         * 	e_PDFA8_3_3_2 : 8332
         * 	e_PDFA8_3_4_1 : 8341
         * 	e_PDFA1_2_3 : 123
         * 	e_PDFA1_10_2 : 1102
         * 	e_PDFA1_10_3 : 1103
         * 	e_PDFA1_12_10 : 11210
         * 	e_PDFA1_13_5 : 1135
         * 	e_PDFA2_3_10 : 2310
         * 	e_PDFA2_4_2_10 : 24220
         * 	e_PDFA2_4_2_11 : 24221
         * 	e_PDFA2_4_2_12 : 24222
         * 	e_PDFA2_4_2_13 : 24223
         * 	e_PDFA2_5_10 : 2510
         * 	e_PDFA2_5_11 : 2511
         * 	e_PDFA2_5_12 : 2512
         * 	e_PDFA2_8_3_1 : 2831
         * 	e_PDFA2_8_3_2 : 2832
         * 	e_PDFA2_8_3_3 : 2833
         * 	e_PDFA2_8_3_4 : 2834
         * 	e_PDFA2_8_3_5 : 2835
         * 	e_PDFA2_10_20 : 21020
         * 	e_PDFA2_10_21 : 21021
         * 	e_PDFA11_0_0 : 11000
         * 	e_PDFA6_2_11_8 : 62118
         * 	e_PDFA8_1 : 81
         * 	e_PDFA_3E1 : 1
         * 	e_PDFA_3E2 : 2
         * 	e_PDFA_3E3 : 3
         * 	e_PDFA_LAST : 4
         * }
         * </pre>
         * error code identifier (obtained using GetError() method).
         * @returns A promise that resolves to a descriptive error message for the given error identifier.
         */
        static getPDFAErrorMessage(id: number): Promise<string>;
        /**
         * Retrieves whether document's XMP metadata claims PDF/A conformance and to what part and level.
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.PDFACompliance.Conformance = {
         * 	e_Level1A : 1
         * 	e_Level1B : 2
         * 	e_Level2A : 3
         * 	e_Level2B : 4
         * 	e_Level2U : 5
         * 	e_Level3A : 6
         * 	e_Level3B : 7
         * 	e_Level3U : 8
         * }
         * </pre>
         * @param doc - the document
         * @returns A promise that resolves to presumptive PDFA part number and conformance level, as an enumerated value.
         */
        static getDeclaredConformance(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc): Promise<number>;
        /**
         * Serializes the converted PDF/A document to a memory buffer.
         * Note: This method assumes that the first parameter passed in PDFACompliance
         * constructor (i.e. the convert parameter) is set to 'true'.
         * @param [linearized] - An optional flag used to specify whether the resulting
         * PDF/A document should be web-optimized (linearized).
         * @returns A promise that resolves to the converted document saved as a memory buffer.
         */
        saveAsFromBuffer(linearized?: boolean): Promise<Uint8Array>;
        /**
         * Perform PDF/A validation or PDF/A conversion on the input PDF document
        which is stored in a memory buffer.
         * @param convert - A flag used to instruct PDF/A processor to perform PDF/A
        conversion (if 'true') or PDF/A validation (if 'false'). After PDF/A conversion
        you can save the resulting document using Save() method(s).
         * @param url - A url from which the serialized PDF document can be downloaded.
         * @param [pwd = ""] - A parameter that can be used to specify the password for encrypted PDF documents (typically only useful in the conversion mode).
         * @param [conform = PDFNet.PDFACompliance.Conformance.e_Level1B] - <pre>
        PDFNet.PDFACompliance.Conformance = {
          e_Level1A : 1,
          e_Level1B : 2,
          e_Level2A : 3,
          e_Level2B : 4,
          e_Level2U : 5,
          e_Level3A : 6,
          e_Level3B : 7,
          e_Level3U : 8
        }
        </pre>
        The PDF conformance level defined in PDFNet.PDFACompliance.Conformance.
         * @param [excep = new Int32Array(0)] - Exceptions to ignore.
         * @param [max_ref_objs = 10] - The maximum number of object references per error condition.
         * @returns A promise that resolves to a PDFACompliance object
         */
        static createFromUrl(convert: boolean, url: string, pwd?: string, conform?: number, excep?: Int32Array, max_ref_objs?: number, first_stop?: boolean): Promise<PDFNet.PDFACompliance>;
        /**
         * Perform PDF/A validation or PDF/A conversion on the input PDF document
        which is stored in a memory buffer.
         * @param convert - A flag used to instruct PDF/A processor to perform PDF/A
        conversion (if 'true') or PDF/A validation (if 'false'). After PDF/A conversion
        you can save the resulting document using Save() method(s).
         * @param buf - A memory buffer containing the serialized PDF document.
         * @param [pwd = ""] - A parameter that can be used to specify the password for encrypted PDF documents (typically only useful in the conversion mode).
         * @param [conform = PDFNet.PDFACompliance.Conformance.e_Level1B] - <pre>
        PDFNet.PDFACompliance.Conformance = {
          e_Level1A : 1,
          e_Level1B : 2,
          e_Level2A : 3,
          e_Level2B : 4,
          e_Level2U : 5,
          e_Level3A : 6,
          e_Level3B : 7,
          e_Level3U : 8
        }
        </pre>
        The PDF conformance level defined in PDFNet.PDFACompliance.Conformance.
         * @param [excep = new Int32Array(0)] - Exceptions to ignore.
         * @param [max_ref_objs = 10] - The maximum number of object references per error condition.
         * @returns A promise that resolves to a PDFACompliance object
         */
        static createFromBuffer(convert: boolean, buf: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray, pwd?: string, conform?: number, excep?: Int32Array, max_ref_objs?: number, first_stop?: boolean): Promise<PDFNet.PDFACompliance>;
    }
    /**
     * Note: PDFDC is deprecated. Please use PDFDCEx instead.
     * PDFDC is a utility class used to represent a PDF Device Context (DC).
     *
     * Windows developers can use standard GDI or GDI+ API-s to write on PDFDC
     * and to generate PDF documents based on their existing drawing functions.
     * PDFDC can also be used to implement file conversion from any printable
     * file format to PDF.
     *
     * PDFDC class can be used in many ways to translate from GDI to PDF:
     *  - To translate a single GDI drawing into a single page PDF document.
     *  - To translate a single GDI drawing into an object which can be reused
     *    many times throughout a PDF document (i.e. as a Form XObject).
     *  - To translate many GDI drawings into single page or multipage PDF document.
     *  ...
     *
     * Very few code changes are required to perform the translation from GDI to
     * PDF as PDFDC provides a GDI Device Context handle which can be passed to
     * all GDI function requiring an HDC.  PDFDC does not use a "Virtual Printer"
     * approach so the translation should be of both high quality and speed.
     * Unfortunately this also means that StartDoc, EndDoc, StartPage and EndPage
     * cannot be called with an HDC created with PDFDC::Begin.
     *
     * For more advanced translations or creations of PDF documents, such as security
     * handling, the use of other PDFNet classes will be required.
     *
     * An example use of PDFDC can be found in PDFDCTest.cpp:
     *
     * <pre>
     * // Start with a PDFDoc to put the picture into, and a PDFDC to translate GDI to PDF
     * PDFDoc pdfdoc;
     * PDFDC pdfDc;
     *
     * // Create a page to put the GDI content onto
     * Page page = pdfdoc.PageCreate();
     *
     * // Begin the translation from GDI to PDF.
     * // Provide the page to place the picture onto, and the bounding box for the content.
     * // We're going to scale the GDI content to fill the page while preserving the aspect
     * // ratio.
     * // Get back a GDI Device Context
     * HDC hDC = pdfDc.Begin( page, page.GetCropBox() );
     *
     *
     * ... perform GDI drawing ...
     *
     * // Complete the translation
     * pdfDc.End();
     *
     * // Add the page to the document
     * pdfdoc.PagePushBack(page);
     *
     * // Save the PDF document
     * pdfdoc.Save("PDFDC_is_cool.pdf", SDF::SDFDoc::e_remove_unused, NULL);
     * </pre>
     */
    class PDFDC {
    }
    /**
     * PDFDCEX is a utility class used to represent a PDF Device Context (DC).
     *
     * Windows developers can use standard GDI or GDI+ API-s to write on PDFDCEX
     * and to generate PDF documents based on their existing drawing functions.
     * PDFDCEX can also be used to implement file conversion from any printable
     * file format to PDF.
     *
     * PDFDCEX class can be used in many ways to translate from GDI to PDF:
     *  - To translate a single GDI drawing into a single page PDF document.
     *  - To translate a single GDI drawing into an object which can be reused
     *    many times throughout a PDF document (i.e. as a Form XObject).
     *  - To translate many GDI drawings into single page or multipage PDF document.
     *  ...
     *
     * Very few code changes are required to perform the translation from GDI to
     * PDF as PDFDCEX provides a GDI Device Context handle which can be passed to
     * all GDI function requiring an HDC.  PDFDCEX does use a "Virtual Printer"
     * approach so the translation should be of both high quality and speed.
     *
     * For more advanced translations or creations of PDF documents, such as security
     * handling, the use of other PDFNet classes will be required.
     *
     * An example use of PDFDCEX can be found in PDFDCTest.cpp:
     *
     * <pre>
     * // Start with a PDFDoc to put the picture into, and a PDFDCEX to translate GDI to PDF
     * PDFDoc pdfdoc;
     * PDFDCEX pdfdcex;
     *
     * // Begin the translation from GDI to PDF, provide the PDFDoc to append the translated
     * // GDI drawing to and get back a GDI Device Context
     * HDC hDC = pdfdcex.Begin(pdfdoc);
     * ::StartPage(hDC);
     *
     * ... perform GDI drawing ...
     *
     * ::EndPage(hDC);
     * // Complete the translation
     * pdfdcex.EndDoc();
     *
     * // Save the PDF document
     * pdfdoc.Save("PDFDCEX_is_cool.pdf", SDF::SDFDoc::e_remove_unused, NULL);
     * </pre>
     */
    class PDFDCEX {
    }
    /**
     * PDFDoc is a high-level class describing a single PDF (Portable Document
     * Format) document. Most applications using PDFNet will use this class to
     * open existing PDF documents, or to create new PDF documents from scratch.
     *
     * The class offers a number of entry points into the document. For example,
     *  - To access pages use pdfdoc.getPageIterator() or pdfdoc.getPage(page_num).
     *  - To access form fields use pdfdoc.getFieldIterator(), pdfdoc.getFieldIterator(name) or pdfdoc.getField(name).
     *  - To access document's meta-data use pdfdoc.getDocInfo().
     *  - To access the outline tree use pdfdoc.getFirstBookmark().
     *  - To access low-level Document Catalog use pdfdoc.getRoot().
     *  ...
     *
     * The class also offers utility methods to slit and merge PDF pages,
     * to create new pages, to flatten forms, to change security settings, etc.
     */
    class PDFDoc extends PDFNet.Destroyable {
        /**
         * Method to create a RefreshOptions object
         * @returns A promise that resolves to a PDFNet.PDFDoc.RefreshOptions.
         */
        static createRefreshOptions(): Promise<PDFNet.PDFDoc.RefreshOptions>;
        /**
         * Method to create a DiffOptions object
         * @returns A promise that resolves to a PDFNet.PDFDoc.DiffOptions.
         */
        static createDiffOptions(): Promise<PDFNet.PDFDoc.DiffOptions>;
        /**
         * Method to create a TextDiffOptions object
         * @returns A promise that resolves to a PDFNet.PDFDoc.TextDiffOptions.
         */
        static createTextDiffOptions(): Promise<PDFNet.PDFDoc.TextDiffOptions>;
        /**
         * Method to create a MergeXFDFOptions object
         * @returns A promise that resolves to a PDFNet.PDFDoc.MergeXFDFOptions.
         */
        static createMergeXFDFOptions(): Promise<PDFNet.PDFDoc.MergeXFDFOptions>;
        /**
         * Method to create a ViewerOptimizedOptions object
         * @returns A promise that resolves to a PDFNet.PDFDoc.ViewerOptimizedOptions.
         */
        static createViewerOptimizedOptions(): Promise<PDFNet.PDFDoc.ViewerOptimizedOptions>;
        /**
         * Get the Action associated with the selected Doc Trigger event.
         * @param trigger - <pre>
         * PDFNet.PDFDoc.EventType = {
         * 	e_action_trigger_doc_will_close : 17
         * 	e_action_trigger_doc_will_save : 18
         * 	e_action_trigger_doc_did_save : 19
         * 	e_action_trigger_doc_will_print : 20
         * 	e_action_trigger_doc_did_print : 21
         * }
         * </pre>
         * the type of trigger event to get
         * @returns A promise that resolves to the Action Obj if present, otherwise NULL
         */
        getTriggerAction(trigger: number): Promise<PDFNet.Obj>;
        /**
         * Default constructor. Creates an empty new document.
         * @returns A promise that resolves to an object of type: "PDFNet.PDFDoc"
         */
        static create(): Promise<PDFNet.PDFDoc>;
        /**
         * @returns A promise that resolves to an object of type: "PDFNet.PDFDoc"
         */
        static createFromFilter(stream: PDFNet.Filter): Promise<PDFNet.PDFDoc>;
        /**
         * Open a SDF/Cos document from a memory buffer.
         * Note: the document should be fully loaded in the memory buffer.
         * Note: the buffer ownership is not transfered to the document so the user should
         * clean-up any allocated memory if necessary.
         * @param buf - a memory buffer containing the serialized document
         * @returns A promise that resolves to an object of type: "PDFNet.PDFDoc"
         */
        static createFromBuffer(buf: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray): Promise<PDFNet.PDFDoc>;
        /**
         * @returns A promise that resolves to an object of type: "PDFNet.PDFDoc"
         */
        static createFromLayoutEls(buf: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray): Promise<PDFNet.PDFDoc>;
        /**
         * Copy Constructor
         * @returns A promise that resolves to an object of type: "PDFNet.PDFDoc"
         */
        createShallowCopy(): Promise<PDFNet.PDFDoc>;
        /**
         * @returns A promise that resolves to true if the document is/was originally encrypted false otherwise.
         */
        isEncrypted(): Promise<boolean>;
        /**
         * Initializes document's SecurityHandler using the supplied
         * password. This version of InitSecurityHandler() assumes that
         * document uses Standard security and that a password is specified
         * directly.
         *
         * This function should be called immediately after an encrypted
         * document is opened. The function does not have any side effects on
         * documents that are not encrypted.
         *
         * If the security handler was successfully initialized, it can be later
         * obtained using GetSecurityHandler() method.
         * @param password - Specifies the password used to open the document without
         * any user feedback. If you would like to dynamically obtain the password,
         * you need to derive a custom class from StdSecurityHandler() and use
         * InitSecurityHandler() without any parameters. See EncTest sample
         * for example code.
         * @returns A promise that resolves to true if the given password successfully unlocked the document,
         * false otherwise.
         */
        initStdSecurityHandlerUString(password: string): Promise<boolean>;
        /**
         * Initializes document's SecurityHandler using the supplied
         * password. This version of InitSecurityHandler() assumes that
         * document uses Standard security and that a password is specified
         * directly.
         *
         * This function should be called immediately after an encrypted
         * document is opened. The function does not have any side effects on
         * documents that are not encrypted.
         *
         * If the security handler was successfully initialized, it can be later
         * obtained using GetSecurityHandler() method.
         * @param password_buf - Specifies the password used to open the document without
         * any user feedback. If you would like to dynamically obtain the password,
         * you need to derive a custom class from StdSecurityHandler() and use
         * InitSecurityHandler() without any parameters. See EncTest sample
         * for example code.
         * @returns A promise that resolves to true if the given password successfully unlocked the document,
         * false otherwise.
         */
        initStdSecurityHandlerBuffer(password_buf: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray): Promise<boolean>;
        /**
         * @returns A promise that resolves to currently selected SecurityHandler.
         *
         * Note: InitSecurityHandler() should be called before GetSecurityHandler()
         * in order to initialize the handler.
         *
         * Note: Returned security handler can be modified in order to change the
         * security settings of the existing document. Changes to the current handler
         * will not invalidate the access to the original file and will take effect
         * during document Save().
         *
         * Note: If the security handler is modified, document will perform a full save
         * even if e_incremental was given as a flag in Save() method.
         */
        getSecurityHandler(): Promise<PDFNet.SecurityHandler>;
        setSecurityHandler(handler: PDFNet.SecurityHandler): Promise<void>;
        /**
         * This function removes document security.
         */
        removeSecurity(): Promise<void>;
        /**
         * @returns A promise that resolves to the class representing document information metadata.
         * (i.e. entries in the document information dictionary).
         */
        getDocInfo(): Promise<PDFNet.PDFDocInfo>;
        /**
         * @returns A promise that resolves to viewer preferences for this document.
         *
         * PDFDocViewPrefs is a high-level utility class that can be
         * used to control the way the document is to be presented on
         * the screen or in print.
         */
        getViewPrefs(): Promise<PDFNet.PDFDocViewPrefs>;
        /**
         * Call this function to determine whether the document has been modified since
         * it was last saved.
         * @returns A promise that resolves to true if document was modified, false otherwise
         */
        isModified(): Promise<boolean>;
        /**
         * Checks whether or not the underlying file has an XRef table that had to be repaired
         * when the file was opened. If the document had an invalid XRef table when opened,
         * PDFNet will have repaired the XRef table for its working representation of the document.
         * @returns A promise that resolves to true if document was found to be corrupted, and was repaired, during
         * opening and has not been saved since.
         *
         * Note: If this function returns true, it is not possible to incrementally save the document
         * (see http://www.pdftron.com/kb_corrupt_xref)
         */
        hasRepairedXRef(): Promise<boolean>;
        /**
         * Call this function to determine whether the document is represented in
         * linearized (fast web view) format.
         * @returns A promise that resolves to true if document is stored in fast web view format, false otherwise.
         *
         * Note: any changes to the document can invalidate linearization. The function will
         * return 'true' only if the original document is linearized and if it is not
         * modified.
         *
         * In order to provide good performance over relatively slow communication links,
         * PDFNet can generate PDF documents with linearized objects and hint tables that
         * can allow a PDF viewer application to download and view one page of a PDF file
         * at a time, rather than requiring the entire file (including fonts and images) to
         * be downloaded before any of it can be viewed.
         *
         * To save a document in linearized (fast web view) format you only need to pass
         * 'Doc.SaveOptions.e_linearized' flag in the Save method.
         */
        isLinearized(): Promise<boolean>;
        /**
         * Saves the document to a memory buffer.
         * @param flags - A bit field composed of an OR of SDFDoc::SaveOptions values. Note that
         * this method ignores e_incremental flag.
         * @returns A promise that resolves to a Uint8Array containing file data.
         * Note: Save will modify the PDFDoc object's internal representation.  As such,
         * 			  the user should acquire a write lock before calling save.
         */
        saveMemoryBuffer(flags: number): Promise<Uint8Array>;
        /**
         * Saves the document to a stream.
         * @param stream - The output stream where to write data.
         * @param flags - A bit field composed of an OR of the SDFDoc::SaveOptions values.
         *
         * Note: Save will modify the PDFDoc object's internal representation.  As such,
         * 			  the user should acquire a write lock before calling save.
         *
         * Note: If the original pdf has a corrupt xref table (see HasRepairedXref), then
         * it can not be saved using the e_incremental flag.
         */
        saveStream(stream: PDFNet.Filter, flags: number): Promise<void>;
        /**
         * Saves a custom signature Contents to a document which has been prepared to receive it. No changes should be made to document in meantime.
         * @param in_signature - The signature Contents to write
         * @param in_field - The signature field to which to write
         * @returns A promise that resolves to an object of type: "Uint8Array"
         */
        saveCustomSignatureBuffer(in_signature: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray, in_field: PDFNet.DigitalSignatureField): Promise<Uint8Array>;
        /**
         * Saves a custom signature Contents to a document which has been prepared to receive it. No changes should be made to document in meantime.
         * @param in_signature - The signature Contents to write
         * @param in_field - The signature field to which to write
         * @returns A promise that resolves to an object of type: "PDFNet.Filter"
         */
        saveCustomSignatureStream(in_signature: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray, in_field: PDFNet.DigitalSignatureField): Promise<PDFNet.Filter>;
        /**
         * Use the Next() method on the returned iterator to traverse all pages in the document.
         * For example:
         * <pre>
         *   PageIterator itr = pdfdoc.GetPageIterator();
         *   while (itr.HasNext()) { //  Read every page
         *      Page page = itr.Current();
         *      // ...
         *      itr.Next()
         *   }
         * </pre>
         *
         * For full sample code, please take a look at ElementReader, PDFPageTest and PDFDraw sample projects.
         * @param [page_number] - page to set the iterator on. 1 corresponds to the first page.
         * @returns A promise that resolves to an iterator to the first page in the document.
         */
        getPageIterator(page_number?: number): Promise<PDFNet.Iterator<PDFNet.Page>>;
        /**
         * @param page_number - the page number in document's page sequence. Page numbers
         * in document's page sequence are indexed from 1.
         * @returns A promise that resolves to a Page corresponding to a given page number, or null (invalid page)
         * if the document does not contain the given page number.
         *
         * For example:
         * <pre>
         *   Page page = pdfdoc.GetPage(page_num);
         *   if (page == null) return; //  Page not found
         * </pre>
         */
        getPage(page_number: number): Promise<PDFNet.Page>;
        /**
         * @param page_itr - the PageIterator to the page that should be removed
         * A PageIterator for the given page can be obtained using PDFDoc::GetPageIterator(page_num)
         * or using direct iteration through document's page sequence.
         */
        pageRemove(page_itr: PDFNet.Iterator<PDFNet.Page>): Promise<void>;
        /**
         * Insert/Import a single page at a specific location in the page sequence.
         * @param where - The location in the page sequence indicating where to insert
         * the page. The page is inserted before the specified location.
         * @param page - A page to insert.
         * Note: Invalidates all PageIterators pointing to the document.
         */
        pageInsert(where: PDFNet.Iterator<PDFNet.Page>, page: PDFNet.Page): Promise<void>;
        /**
         * Inserts a range of pages from specified PDFDoc
         * @param insert_before_page_number - the destination of the insertion. If less than or equal to 1,
         * the pages are added to the beginning of the document. If larger than the number of pages
         * in the destination document, the pages are appended to the document.
         * @param src_doc - source PDFDoc to insert from
         * @param start_page - start of the page number to insert
         * @param end_page - end of the page number to insert
         * @param flag - <pre>
         * PDFNet.PDFDoc.InsertFlag = {
         * 	e_none : 0
         * 	e_insert_bookmark : 1
         * }
         * </pre>
         * specifies insert options
         */
        insertPages(insert_before_page_number: number, src_doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, start_page: number, end_page: number, flag: number): Promise<void>;
        /**
         * Inserts a range of pages from specified PDFDoc using PageSet
         * @param insert_before_page_number - the destination of the insertion. If less than or equal to 1,
         * the pages are added to the beginning of the document. If larger than the number of pages
         * in the destination document, the pages are appended to the document.
         * @param src_doc - source PDFDoc to insert from
         * @param source_page_set - a collection of the page number to insert
         * @param flag - <pre>
         * PDFNet.PDFDoc.InsertFlag = {
         * 	e_none : 0
         * 	e_insert_bookmark : 1
         * }
         * </pre>
         * specifies insert options
         */
        insertPageSet(insert_before_page_number: number, src_doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, source_page_set: PDFNet.PageSet, flag: number): Promise<void>;
        /**
         * Moves a range of pages from specified PDFDoc. Pages are deleted from source document after move.
         * @param move_before_page_number - the destination of the move. If less than or equal to 1,
         * the pages are moved to the beginning of the document. If larger than the number of pages
         * in the destination document, the pages are moved to the end of the document.
         * @param src_doc - source PDFDoc to move from
         * @param start_page - start of the page number to move
         * @param end_page - end of the page number to move
         * @param flag - <pre>
         * PDFNet.PDFDoc.InsertFlag = {
         * 	e_none : 0
         * 	e_insert_bookmark : 1
         * }
         * </pre>
         * specifies insert options
         * Note: MovePages function does not save src_doc. It merely delete pages in memeory. For permanent changes,
         * PDFDoc::Save should be used to save src_doc after function exists.
         */
        movePages(move_before_page_number: number, src_doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, start_page: number, end_page: number, flag: number): Promise<void>;
        /**
         * Moves a range of pages from specified PDFDoc. Pages are deleted from source document after move.
         * @param move_before_page_number - the destination of the move. If less than or equal to 1,
         * the pages are moved to the beginning of the document. If larger than the number of pages
         * in the destination document, the pages are moved to the end of the document.
         * @param src_doc - source PDFDoc to move from
         * @param source_page_set - a collection of the page number to move
         * @param flag - <pre>
         * PDFNet.PDFDoc.InsertFlag = {
         * 	e_none : 0
         * 	e_insert_bookmark : 1
         * }
         * </pre>
         * specifies insert options
         * Note: MovePages function does not save src_doc. It merely delete pages in memeory. For permanent changes,
         * PDFDoc::Save should be used to save src_doc after function exists.
         */
        movePageSet(move_before_page_number: number, src_doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, source_page_set: PDFNet.PageSet, flag: number): Promise<void>;
        /**
         * Adds a page to the beginning of a document's page sequence.
         * @param page - a page to prepend to the document
         * Invalidates all PageIterators pointing to the document.
         */
        pagePushFront(page: PDFNet.Page): Promise<void>;
        /**
         * Adds a page to the end of a document's page sequence.
         * @param page - a page to append to the document
         * Note: Invalidates all PageIterators pointing to the document.
         */
        pagePushBack(page: PDFNet.Page): Promise<void>;
        /**
         * Create a new, empty page in the document. You can use PageWriter to fill the
         * page with new content. Finally the page should be inserted at specific
         * place within document page sequence using PageInsert/PagePushFront/PagePushBack
         * methods.
         * @param [media_box] - A rectangle, expressed in default user space units, defining
         * the boundaries of the physical medium on which the page is intended to be
         * displayed or printed. A user space units is 1/72 of an inch. If media_box is
         * not specified the default dimensions of the page are 8.5 x 11 inches (or
         * 8.5*72, 11*72 units).
         *
         * <p>The following is a listing of some standard U.S. page sizes:</p>
         *  <ul>
         *    <li>Letter    = Rect(0, 0, 612, 792)
         *    <li>Legal	    = Rect(0, 0, 612, 1008)
         *    <li>Ledger	= Rect(0, 0, 1224, 792)
         *    <li>Tabloid   = Rect(0, 0, 792, 1224)
         *    <li>Executive	= Rect(0, 0, 522, 756)
         * </ul>
         *
         * <p>The following is a listing of ISO standard page sizes:</p>
         *  <ul>
         *    <li> 4A0 = Rect(0, 0, 4768, 6741)
         *    <li> 2A0 = Rect(0, 0, 3370, 4768)
         *    <li> A0 =  Rect(0, 0, 2384, 3370)
         *    <li> A1 =  Rect(0, 0, 1684, 2384)
         *    <li> A2 =  Rect(0, 0, 1191, 1684)
         *    <li> A3 =  Rect(0, 0, 842,  1191)
         *    <li> A4 =  Rect(0, 0, 595,  842)
         *    <li> A5 =  Rect(0, 0, 420,  595)
         *    <li> A6 =  Rect(0, 0, 298,  420)
         *    <li> A7 =  Rect(0, 0, 210,  298)
         *    <li> A8 =  Rect(0, 0, 147,  210)
         *    <li> A9 =  Rect(0, 0, 105,  147)
         *    <li> A10 = Rect(0, 0, 74,   105)
         *    <li> B0 =  Rect(0, 0, 2835, 4008)
         *    <li> B1 =  Rect(0, 0, 2004, 2835)
         *    <li> B2 =  Rect(0, 0, 1417, 2004)
         *    <li> B3 =  Rect(0, 0, 1001, 1417)
         *    <LI> B4 =  Rect(0, 0, 709,  1001)
         *    <LI> B5 =  Rect(0, 0, 499,  709)
         *    <LI> B6 =  Rect(0, 0, 354,  499)
         *    <LI> B7 =  Rect(0, 0, 249,  354)
         *    <LI> B8 =  Rect(0, 0, 176,  249)
         *    <LI> B9 =  Rect(0, 0, 125,  176)
         *    <li> B10 = Rect(0, 0, 88,   125)
         *    <li> C0 =  Rect(0, 0, 2599, 3677)
         *    <li> C1 =  Rect(0, 0, 1837, 2599)
         *    <li> C2 =  Rect(0, 0, 1298, 1837)
         *    <li> C3 =  Rect(0, 0, 918,  1298)
         *    <li> C4 =  Rect(0, 0, 649,  918)
         *    <li> C5 =  Rect(0, 0, 459,  649)
         *    <li> C6 =  Rect(0, 0, 323,  459)
         *    <li> C7 =  Rect(0, 0, 230,  323)
         *    <li> C8 =  Rect(0, 0, 162,  230)
         *    <li> C9 =  Rect(0, 0, 113,  162)
         *    <li>C10 =  Rect(0, 0, 79,   113)
         * </ul>
         * @returns A promise that resolves to a new, empty page.
         *
         * Note: the new page still does not belong to document page sequence and should be
         * subsequently placed at a specific location within the sequence.
         */
        pageCreate(media_box?: PDFNet.Rect): Promise<PDFNet.Page>;
        /**
         * Imports two external pages and highlights the differences between them.
         * This function adds two new pages to the current document. The two input
         * pages are typically coming from two different PDF files.
         * Note: Each contiguous block of change is considered a single difference.
         * A deletion immediately followed by an insertion is considered a single edit.
         * @param page1 - is the before page, the basis of the comparison (read-only)
         * @param page2 - is the after page, to which the basis is compared (read-only)
         * @returns A promise that resolves to the total number of differences found
         * Note: This function is beta and is subject to change
         */
        appendTextDiffPage(page1: PDFNet.Page, page2: PDFNet.Page): Promise<number>;
        /**
         * Imports two external PDFs and highlights the differences between them.
         * This function appends alternating pages from the two input documents into the current document.
         * Note: Each contiguous block of change is considered a single difference.
         * A deletion immediately followed by an insertion is considered a single edit.
         * @param doc1 - is the before document, the basis of the comparison (read-only)
         * @param doc2 - is the after document, to which the basis is compared (read-only)
         * @param [options] - processing options (optional)
         * @returns A promise that resolves to the total number of differences found
         * Note: This function is beta and is subject to change
         */
        appendTextDiffDoc(doc1: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, doc2: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, options?: PDFNet.PDFDoc.TextDiffOptions): Promise<number>;
        /**
         * Imports two external PDFs and highlights the differences between them.
         * This function directly adds the highlights to the two input documents.
         * Note: Each contiguous block of change is considered a single difference.
         * A deletion immediately followed by an insertion is considered a single edit.
         * @param doc1 - is the before document, the basis of the comparison
         * @param doc2 - is the after document, to which the basis is compared
         * @param [options] - processing options (optional)
         * @returns A promise that resolves to the total number of differences found
         * Note: This function is beta and is subject to change
         */
        static highlightTextDiff(doc1: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, doc2: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, options?: PDFNet.PDFDoc.TextDiffOptions): Promise<number>;
        /**
         * @returns A promise that resolves to the first Bookmark from the document's outline tree. If the
         * Bookmark tree is empty the underlying SDF/Cos Object is null and returned
         * Bookmark is not valid (i.e. Bookmark::IsValid() returns false).
         */
        getFirstBookmark(): Promise<PDFNet.Bookmark>;
        /**
         * Adds/links the specified Bookmark to the root level of document's outline tree.
         * @param root_bookmark - Bookmark to Add/link
         * Note: parameter 'root_bookmark' must not be linked (must not be belong) to
         * a bookmark tree.
         */
        addRootBookmark(root_bookmark: PDFNet.Bookmark): Promise<void>;
        /**
         * @returns A promise that resolves to A dictionary representing the Cos root of the document (document's trailer)
         */
        getTrailer(): Promise<PDFNet.Obj>;
        /**
         * @returns A promise that resolves to A dictionary representing the Cos root of the document (/Root entry
         * within the trailer dictionary)
         */
        getRoot(): Promise<PDFNet.Obj>;
        jsContextInitialize(): Promise<void>;
        /**
         * @returns A promise that resolves to A dictionary representing the root of the low level page-tree
         */
        getPages(): Promise<PDFNet.Obj>;
        /**
         * @returns A promise that resolves to the number of pages in the document.
         */
        getPageCount(): Promise<number>;
        /**
         * Returns the number of bytes that have been downloaded, when `HasDownloader()` is True.
         * @returns A promise that resolves to the number bytes downloaded.
         */
        getDownloadedByteCount(): Promise<number>;
        /**
         * Returns the document's total size in bytes, when `HasDownloader()` is True.
         * @returns A promise that resolves to the total number of bytes in the remote document.
         */
        getTotalRemoteByteCount(): Promise<number>;
        /**
         * An interactive form (sometimes referred to as an AcroForm) is a
         * collection of fields for gathering information interactively from
         * the user. A PDF document may contain any number of fields appearing
         * on any combination of pages, all of which make up a single, global
         * interactive form spanning the entire document.
         *
         * The following methods are used to access and manipulate Interactive form
         * fields (sometimes referred to as AcroForms).
         * @returns A promise that resolves to an iterator to the first Field in the document.
         *
         * The list of all Fields present in the document can be traversed as follows:
         * <pre>
         * FieldIterator itr = pdfdoc.GetFieldIterator();
         * for(; itr.HasNext(); itr.Next()) {
         *   Field field = itr.Current();
         *   Console.WriteLine("Field name: {0}", field.GetName());
         *  }
         * </pre>
         *
         * For a sample, please refer to 'InteractiveForms' sample project.
         */
        getFieldIteratorBegin(): Promise<PDFNet.Iterator<PDFNet.Field>>;
        /**
         * An interactive form (sometimes referred to as an AcroForm) is a
         * collection of fields for gathering information interactively from
         * the user. A PDF document may contain any number of fields appearing
         * on any combination of pages, all of which make up a single, global
         * interactive form spanning the entire document.
         *
         * The following methods are used to access and manipulate Interactive form
         * fields (sometimes referred to as AcroForms).
         * @param field_name - String representing the name of the field to get.
         * @returns A promise that resolves to an iterator to the Field in the document.
         *
         * For a sample, please refer to 'InteractiveForms' sample project.
         */
        getFieldIterator(field_name: string): Promise<PDFNet.Iterator<PDFNet.Field>>;
        /**
         * @param field_name - a string representing the fully qualified name of
         * the field (e.g. "employee.name.first").
         * @returns A promise that resolves to a FieldIterator referring to an interactive Field
         * or to invalid field if the field name was not found. If a given field name was
         * not found itr.HasNext() will return false. For example:
         *
         * <pre>
         * FieldIterator itr = pdfdoc.GetFieldIterator("name");
         * if (itr.HasNext()) {
         *   Console.WriteLine("Field name: {0}", itr.Current().GetName());
         * }
         * else { ...field was not found... }
         * </pre>
         */
        getField(field_name: string): Promise<PDFNet.Field>;
        /**
         * Create a new interactive form Field.
         * @param field_name - a string representing the fully qualified name of the
         * field (e.g. "employee.name.first"). field_name must be either a unique name or
         * equal to an existing terminal field name.
         * @param type - <pre>
         * PDFNet.Field.Type = {
         * 	e_button : 0
         * 	e_check : 1
         * 	e_radio : 2
         * 	e_text : 3
         * 	e_choice : 4
         * 	e_signature : 5
         * 	e_null : 6
         * }
         * </pre>
         * field type (e.g. Field::e_text, Field::e_button, etc.)
         * @returns A promise that resolves to the new form Field.
         */
        fieldCreate(field_name: string, type: number, field_value?: PDFNet.Obj, def_field_value?: PDFNet.Obj): Promise<PDFNet.Field>;
        /**
         * Create a new interactive form Field.
         * @param field_name - a string representing the fully qualified name of the
         * field (e.g. "employee.name.first"). field_name must be either a unique name or
         * equal to an existing terminal field name.
         * @param type - <pre>
         * PDFNet.Field.Type = {
         * 	e_button : 0
         * 	e_check : 1
         * 	e_radio : 2
         * 	e_text : 3
         * 	e_choice : 4
         * 	e_signature : 5
         * 	e_null : 6
         * }
         * </pre>
         * field type (e.g. Field::e_text, Field::e_button, etc.)
         * @returns A promise that resolves to the new form Field.
         */
        fieldCreateFromStrings(field_name: string, type: number, field_value: string, def_field_value?: string): Promise<PDFNet.Field>;
        /**
         * Regenerates the appearance stream for every widget annotation in the document
         * Call this method if you modified field's value and would like to update
         * field's appearances.
         */
        refreshFieldAppearances(): Promise<void>;
        /**
         * Generates the appearance stream for annotations in the document using the specified options. A common use case is to generate appearances
         * only for missing annotations, which can be accomplished using the default options.
         * @param [options] - Options that can be used to adjust this generation process.
         */
        refreshAnnotAppearances(options?: PDFNet.PDFDoc.RefreshOptions): Promise<void>;
        /**
         * Flatten all annotations in the document.
         * @param [forms_only] - if false flatten all annotations, otherwise flatten
         * only form fields.
         */
        flattenAnnotations(forms_only?: boolean): Promise<void>;
        flattenAnnotationsAdvanced(flags: number): Promise<void>;
        /**
         * @returns A promise that resolves to the AcroForm dictionary located in "/Root" or NULL if dictionary is not present.
         */
        getAcroForm(): Promise<PDFNet.Obj>;
        /**
         * Extract form data and/or annotations to FDF
         * @param [flag] - <pre>
         * PDFNet.PDFDoc.ExtractFlag = {
         * 	e_forms_only : 0
         * 	e_annots_only : 1
         * 	e_both : 2
         * }
         * </pre>
         * specifies extract options
         * @returns A promise that resolves to a pointer to the newly created FDF file with an interactive data.
         */
        fdfExtract(flag?: number): Promise<PDFNet.FDFDoc>;
        /**
         * Extract form data and/or annotations to FDF
         * @param pages_to_extract - The set of pages for which to extract interactive data.
         * @param [flag] - <pre>
         * PDFNet.PDFDoc.ExtractFlag = {
         * 	e_forms_only : 0
         * 	e_annots_only : 1
         * 	e_both : 2
         * }
         * </pre>
         * specifies extract options
         * @returns A promise that resolves to a pointer to the newly created FDF file with an interactive data.
         */
        fdfExtractPageSet(pages_to_extract: PDFNet.PageSet, flag?: number): Promise<PDFNet.FDFDoc>;
        /**
         * Import form data from FDF file to PDF interactive form.
         * @param fdf_doc - a reference to the FDF file
         */
        fdfMerge(fdf_doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc): Promise<void>;
        /**
         * Replace existing form and annotation data with those imported from the FDF file. It will
         * make annotations in the FDF match those in the PDF.
         * Since this method avoids updating annotations unnecessarily it works well with incremental save
         * and can sometimes preserve annotation appearances, but it requires that the annotations
         * intended to be in the final document be in the provided FDF file.
         * Note: Some PDF viewers (like Chrome) cannot display annotations that don't already have
         * an appearance, so it is often desirable to call PDFDoc.RefreshAnnotAppearances after
         * this method to ensure these annotations can still be displayed in those applications.
         * Note: This method is not suitable for realtime collaboration.
         * @param fdf_doc - a pointer to the FDF file
         */
        fdfUpdate(fdf_doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc): Promise<void>;
        /**
         * @returns A promise that resolves to action that is triggered when the document is opened.
         * The returned action can be either a destination or some other kind
         * of Action (see Section 8.5, 'Actions' in PDF Reference Manual).
         *
         * Note: if the document does not nave associated action the returned Action
         * will be null (i.e. Action.IsValid() returns false)
         */
        getOpenAction(): Promise<PDFNet.Action>;
        /**
         * Sets the Action that will be triggered when the document is opened.
         * @param action - A new Action that will be triggered when the document is opened.
         * An example of such action is a GoTo Action that takes the user to a given
         * location in the document.
         */
        setOpenAction(action: PDFNet.Action): Promise<void>;
        /**
         * Associates a file attachment with the document.
         *
         * The file attachment will be displayed in the user interface of a viewer application
         * (in Acrobat this is File Attachment tab). The function differs from
         * Annot.CreateFileAttachment() because it associates the attachment with the
         * whole document instead of an annotation on a specific page.
         * @param file_key - A key/name under which the attachment will be stored.
         * @param embedded_file - Embedded file stream
         *
         * Note: Another way to associate a file attachment with the document is using SDF::NameTree:
         * <pre>
         *   SDF::NameTree names = SDF::NameTree::Create(doc, "EmbeddedFiles");
         *   names.Put(file_key, file_keysz, embedded_file.GetSDFObj());
         * </pre>
         */
        addFileAttachment(file_key: string, embedded_file: PDFNet.FileSpec): Promise<void>;
        /**
         * @param page_num - The page number. Because PDFNet indexes pages
         * starting from 1, page_num must be larger than 0.
         * @returns A promise that resolves to the PageLabel that is in effect for the given page.
         * If there is no label object in effect, this method returns an
         * invalid page label object.
         */
        getPageLabel(page_num: number): Promise<PDFNet.PageLabel>;
        /**
         * attaches a label to a page. This establishes the numbering scheme
         * for that page and all following it, until another page label is
         * encountered. This label allows PDF producers to define a page
         * numbering system other than the default.
         * @param page_num - The number of the page to label. If page_num is
         * less than 1 or greater than the number of pages in the document,
         * the method does nothing.
         */
        setPageLabel(page_num: number, label: PDFNet.PageLabel): Promise<void>;
        /**
         * removes the page label that is attached to the specified page,
         * effectively merging the specified range with the previous page
         * label sequence.
         * @param page_num - The page from which the page label is removed.
         * Because PDFNet indexes pages starting from 1, page_num must be
         * larger than 0.
         */
        removePageLabel(page_num: number): Promise<void>;
        /**
         * @returns A promise that resolves to the document's logical structure tree root.
         */
        getStructTree(): Promise<PDFNet.STree>;
        /**
         * @returns A promise that resolves to true if the optional content (OC) feature is associated with
         * the document. The document is considered to have optional content if
         * there is an OCProperties dictionary in the document's catalog, and
         * that dictionary has one or more entries in the OCGs array.
         */
        hasOC(): Promise<boolean>;
        /**
         * @returns A promise that resolves to the Obj array that contains optional-content groups (OCGs) for
         * the document, or NULL if the document does not contain any OCGs. The
         * order of the groups is not guaranteed to be the creation order, and is
         * not the same as the display order.
         */
        getOCGs(): Promise<PDFNet.Obj>;
        /**
         * @returns A promise that resolves to the default optional-content configuration for the document
         * from the OCProperties D entry.
         */
        getOCGConfig(): Promise<PDFNet.OCGConfig>;
        /**
         * This method creates an SDF/Cos indirect name object
         *
         * Unlike direct objects, indirect objects can be referenced by more than one
         * object (i.e. indirect objects can be shared).
         * @returns A promise that resolves to an object of type: "PDFNet.Obj"
         */
        createIndirectName(name: string): Promise<PDFNet.Obj>;
        /**
         * This method creates an SDF/Cos indirect array object
         *
         * Unlike direct objects, indirect objects can be referenced by more than one
         * object (i.e. indirect objects can be shared).
         * @returns A promise that resolves to returns a new indirect array object.
         */
        createIndirectArray(): Promise<PDFNet.Obj>;
        /**
         * This method creates an SDF/Cos indirect boolean object
         *
         * Unlike direct objects, indirect objects can be referenced by more than one
         * object (i.e. indirect objects can be shared).
         * @param value - the value with which to create the boolean object.
         * @returns A promise that resolves to returns a new indirect boolean object.
         */
        createIndirectBool(value: boolean): Promise<PDFNet.Obj>;
        /**
         * This method creates an SDF/Cos indirect dict object
         *
         * Unlike direct objects, indirect objects can be referenced by more than one
         * object (i.e. indirect objects can be shared).
         * @returns A promise that resolves to returns a new indirect dict object.
         */
        createIndirectDict(): Promise<PDFNet.Obj>;
        /**
         * This method creates an SDF/Cos indirect null object
         *
         * Unlike direct objects, indirect objects can be referenced by more than one
         * object (i.e. indirect objects can be shared).
         * @returns A promise that resolves to returns a new indirect null object.
         */
        createIndirectNull(): Promise<PDFNet.Obj>;
        /**
         * This method creates an SDF/Cos indirect number object
         *
         * Unlike direct objects, indirect objects can be referenced by more than one
         * object (i.e. indirect objects can be shared).
         * @param value - the value with which to create the number object.
         * @returns A promise that resolves to returns a new indirect number object.
         */
        createIndirectNumber(value: number): Promise<PDFNet.Obj>;
        /**
         * This method creates an SDF/Cos indirect string object
         *
         * Unlike direct objects, indirect objects can be referenced by more than one
         * object (i.e. indirect objects can be shared).
         * @param value - Unsigned char pointer with which to create the string object.
         * @param buf_size - length of string.
         * @returns A promise that resolves to returns a new indirect string object.
         */
        createIndirectString(value: number, buf_size: number): Promise<PDFNet.Obj>;
        /**
         * This method creates an SDF/Cos indirect string object
         *
         * Unlike direct objects, indirect objects can be referenced by more than one
         * object (i.e. indirect objects can be shared).
         * @param str - reference to string with which to create the string object.
         * @returns A promise that resolves to returns a new indirect string object.
         */
        createIndirectStringFromUString(str: string): Promise<PDFNet.Obj>;
        /**
         * @returns A promise that resolves to an object of type: "PDFNet.Obj"
         */
        createIndirectStreamFromFilter(data: PDFNet.FilterReader, filter_chain?: PDFNet.Filter): Promise<PDFNet.Obj>;
        /**
         * @returns A promise that resolves to an object of type: "PDFNet.Obj"
         */
        createIndirectStream(data_buf: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray, filter_chain: PDFNet.Filter): Promise<PDFNet.Obj>;
        /**
         * @returns A promise that resolves to document's SDF/Cos document
         */
        getSDFDoc(): Promise<PDFNet.SDFDoc>;
        /**
         * Removes the lock from the document.
         */
        unlock(): Promise<void>;
        /**
         * Removes the read lock from the document.
         */
        unlockRead(): Promise<void>;
        /**
         * addHighlights is used to highlight text in a document using 'Adobe's Highlight
         * File Format' (Technical Note #5172 ). The method will parse the character offset data
         * and modify the current document by adding new highlight annotations.
         * @param hilite - a string representing the filename for the highlight file or
         * or a data buffer containing XML data.
         */
        addHighlights(hilite: string): Promise<void>;
        /**
         * @returns A promise that resolves to true if this document is marked as Tagged PDF, false otherwise.
         */
        isTagged(): Promise<boolean>;
        /**
         * Indicates whether this documents contains any digital signatures.
         * @returns A promise that resolves to true if a digital signature is found in this PDFDoc.
         */
        hasSignatures(): Promise<boolean>;
        /**
         * Adds a signature handler to the signature manager.
         * @param signature_handler - The signature handler instance to add to the signature manager.
         * @returns A promise that resolves to a unique ID representing the SignatureHandler within the SignatureManager.
         */
        addSignatureHandler(signature_handler: PDFNet.SignatureHandler): Promise<number>;
        /**
         * @returns A promise that resolves to an object of type: "number"
         */
        addStdSignatureHandlerFromBuffer(pkcs12_buffer: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray, pkcs12_pass: string): Promise<number>;
        /**
         * Removes a signature handler from the signature manager.
         * @param signature_handler_id - The unique id of the signature handler to remove.
         */
        removeSignatureHandler(signature_handler_id: number): Promise<void>;
        /**
         * Gets the associated signature handler instance from the signature manager by looking it up with the handler name.
         * @param signature_handler_id - The unique id of the signature handler to get.
         * @returns A promise that resolves to the signature handler instance if found, otherwise NULL.
         */
        getSignatureHandler(signature_handler_id: number): Promise<PDFNet.SignatureHandler>;
        /**
         * Generates thumbnail images for all the pages in this PDF document.
         * @param size - The maximum dimension (width or height) that thumbnails will have.
         */
        generateThumbnails(size: number): Promise<void>;
        /**
         * Add a page representing the difference between two pdf pages to this document.
         * @param p1 - one of the two pages for comparing
         * @param p2 - the other page for comparing
         * @param [opts] - options for comparison results. This parameter is supposed to be an object,
         * which can be generated by 'PDFNet.createDiffOptions()'. If this parameter is omitted or
         * set to null, default settings will be used.
         */
        appendVisualDiff(p1: PDFNet.Page, p2: PDFNet.Page, opts?: PDFNet.PDFDoc.DiffOptions): Promise<void>;
        /**
         * @returns A promise that resolves to an object of type: "PDFNet.GeometryCollection"
         */
        getGeometryCollectionForPage(page_num: number): Promise<PDFNet.GeometryCollection>;
        /**
         * @returns A promise that resolves to the UndoManager object (one-to-one mapped to document)
         */
        getUndoManager(): Promise<PDFNet.UndoManager>;
        /**
         * Creates an unsigned digital signature form field inside the document.
         * @param [in_sig_field_name] - The fully-qualified name to give the digital signature field. If one is not provided, a unique name is created automatically.
         * @returns A promise that resolves to a DigitalSignatureField object representing the created digital signature field.
         */
        createDigitalSignatureField(in_sig_field_name?: string): Promise<PDFNet.DigitalSignatureField>;
        /**
         * Retrieves an iterator that iterates over digital signature fields.
         * @returns A promise that resolves to an iterator that iterates over digital signature fields.
         */
        getDigitalSignatureFieldIteratorBegin(): Promise<PDFNet.Iterator<PDFNet.DigitalSignatureField>>;
        /**
         * Retrieves the most restrictive document permissions locking level from
         * all of the signed digital signatures in the document.
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.DigitalSignatureField.DocumentPermissions = {
         * 	e_no_changes_allowed : 1
         * 	e_formfilling_signing_allowed : 2
         * 	e_annotating_formfilling_signing_allowed : 3
         * 	e_unrestricted : 4
         * }
         * </pre>
         * @returns A promise that resolves to an enumerated value representing the most restrictive document permission level found in the document.
         */
        getDigitalSignaturePermissions(): Promise<number>;
        /**
         * Applies optimizations to improve viewing speed and saves the document to a memory buffer.
         * The main optimizations used are linearization and embedding thumbnails for the
         * first page and any other pages that are slow to render.
         * @param opts - The optimization options
         * @returns A promise that resolves to an object of type: "Uint8Array"
         */
        saveViewerOptimizedBuffer(opts: PDFNet.Obj | PDFNet.PDFDoc.ViewerOptimizedOptions): Promise<Uint8Array>;
        /**
         * Attempts to verify all signed cryptographic digital signatures in the document, ignoring unsigned signatures.
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.PDFDoc.SignaturesVerificationStatus = {
         * 	e_unsigned : 0
         * 	e_failure : 1
         * 	e_untrusted : 2
         * 	e_unsupported : 3
         * 	e_verified : 4
         * }
         * </pre>
         * @returns A promise that resolves to an enumeration value representing the state of the document's signatures
         */
        verifySignedDigitalSignatures(opts: PDFNet.VerificationOptions): Promise<number>;
        mergeXFDF(stream: PDFNet.Filter, options?: PDFNet.PDFDoc.MergeXFDFOptions): Promise<void>;
        mergeXFDFString(xfdf: string, options?: PDFNet.PDFDoc.MergeXFDFOptions): Promise<void>;
        /**
         * Open a PDF document from a url. This function will fully download the file as a memory buffer and create a PDFDoc object.
         * @param url - The url from which to download the file
         * @param [options] - Additional options
         * @param options.withCredentials - Whether to set the withCredentials property on the XMLHttpRequest
         * @param options.customHeaders - An object containing custom HTTP headers to be used when downloading the document
         * @returns A promise that resolves to an object of type: "PDFDoc".
         */
        static createFromURL(url: string, options?: {
            withCredentials: boolean;
            customHeaders: any;
        }): Promise<PDFNet.PDFDoc>;
        /**
         * Generate a stream that incrementally converts the pdf to XOD format.
         * @param [options] - the conversion options
         * @returns A filter from which the file can be read incrementally.
         */
        convertToXodStream(options?: PDFNet.Obj | PDFNet.Convert.XODOutputOptions): PDFNet.Filter;
        /**
         * Initializes document's SecurityHandler. This version of InitSecurityHandler()
        works with Standard and Custom PDF security and can be used in situations where
        the password is obtained dynamically via user feedback. See EncTest sample for
        example code.
        
        This function should be called immediately after an encrypted
        document is opened. The function does not have any side effects on
        documents that are not encrypted.
        
        If the security handler was successfully initialized it can be later obtained
        using GetSecurityHandler() method.
         * @returns A promise that resolves to true if the SecurityHandler was successfully initialized (this
        may include authentication data collection, verification etc.),
        false otherwise.
         */
        initSecurityHandler(): Promise<boolean>;
        /**
         * Initializes document's SecurityHandler using the supplied
        password. This version of InitSecurityHandler() assumes that
        document uses Standard security and that a password is specified
        directly.
        
        This function should be called immediately after an encrypted
        document is opened. The function does not have any side effects on
        documents that are not encrypted.
        
        If the security handler was successfully initialized, it can be later
        obtained using GetSecurityHandler() method.
         * @param password - Specifies the password used to open the document without
        any user feedback.
         * @returns A promise that resolves to true if the given password successfully unlocked the document,
        false otherwise.
         */
        initStdSecurityHandler(password: string): Promise<boolean>;
        /**
         * Adds a standard (built-in) signature handler to the signature manager. This method will use cryptographic
        algorithm based on Adobe.PPKLite/adbe.pkcs7.detached filter to sign a PDF.
         * @param pkcs12_file - The private key certificate store to use.
         * @param pkcs12_pass - The passphrase for the provided private key.
         * @returns A promise that resolves to a unique ID representing the SignatureHandler within the SignatureManager.
         */
        addStdSignatureHandlerFromURL(pkcs12_file: string, pkcs12_pass: string): Promise<number>;
        /**
         * The function imports a list of pages to this document. Although a list of pages
        can be imported using repeated calls to PageInsert(), PageImport will not import
        duplicate copies of resources that are shared across pages (such as fonts, images,
        colorspaces etc). Therefore this method is recommended when a page import list
        consists of several pages that share the same resources.
         * @param page_arr - A list of pages to import. All pages should belong to the same source document.
         * @param [import_bookmarks] - An optional flag specifying whether any bookmark items
        pointing to pages in the import list should be merged with the target (i.e. this)
        document.
         * @returns A promise that resolves to a list of imported pages. Note that imported pages are not placed in the
        document page sequence. This can be done using methods such as PageInsert(),
        PagePushBack(), etc.
         */
        importPages(page_arr: PDFNet.Page[], import_bookmarks?: number): Promise<PDFNet.Page[]>;
        /**
         * Locks the document to prevent competing threads from accessing the document
        at the same time. Threads attempting to access the document will wait in
        suspended state until the thread that owns the lock calls doc.Unlock().
         */
        lock(): Promise<void>;
        /**
         * Locks the document to prevent competing write threads (using Lock()) from accessing the document
        at the same time. Other reader threads however, will be allowed to access the document.
        Threads attempting to obtain write access to the document will wait in
        suspended state until the thread that owns the lock calls doc.UnlockRead().
        Note: To avoid deadlocks obtaining a write lock while holding
        a read lock is not permitted and will throw an exception. If this situation is encountered
        please either unlock the read lock before the write lock is obtained
        or acquire a write lock (rather than read lock) in the first place.
         */
        lockRead(): Promise<void>;
        /**
         * Try locking the document.
         * @returns A promise that resolves to true if the document is locked for multi-threaded access, false otherwise.
         */
        tryLock(): Promise<boolean>;
        /**
         * Try locking the document, waiting no longer than specified number of milliseconds.
         * @param milliseconds - max number of milliseconds to wait for the document to lock
         * @returns A promise that resolves to true if the document is locked for multi-threaded access, false otherwise.
         */
        timedLock(milliseconds: number): Promise<boolean>;
        /**
         * Tries to obtain a read lock the document and returns true if the lock was
        successfully acquired
         * @returns A promise that resolves to true if the document is locked for multi-threaded access, false otherwise.
         */
        tryLockRead(): Promise<boolean>;
        /**
         * Tries to obtain a read lock the document for <milliseconds> duration, and returns
        true if the lock was successfully acquired
         * @param milliseconds - duration to obtain a read lock for.
         * @returns A promise that resolves to true if the document is locked for multi-threaded access, false otherwise.
         */
        timedLockRead(milliseconds: number): Promise<boolean>;
        /**
         * WebViewer only - Ensures that a particular page of the pdf document is finished loading
        before reading or writing from it. Recommended to be called before
        runGeneratorWithCleanup/WithoutCleanup is called. If the page(s) to be edited cannot be known
        until during the execution of the PDFNetJS script, all operations will need to be unlocked
        with PDFNet.finishOperation() and [PDFDoc].unlock() before [PDFDoc].requirePage() can be called,
        and relocked again with PDFNet.beginOperation() and [PDFDoc].lock()
        
        <pre>
        doc.unlock();
        yield PDFNet.finishOperation();
        yield doc.requirePage(pageCounter);
        yield PDFNet.beginOperation();
        doc.lock();
        </pre>
         * @param page_number - The page to ensure completion of.
         */
        requirePage(page_number: number): Promise<void>;
    }
    /**
     * PDFDocInfo is a high-level utility class that can be used
     * to read and modify document's metadata.
     */
    class PDFDocInfo {
        /**
         * @returns A promise that resolves to the document's title.
         */
        getTitle(): Promise<string>;
        /**
         * @returns A promise that resolves to sDF/Cos string object representing document's title.
         */
        getTitleObj(): Promise<PDFNet.Obj>;
        /**
         * Set document's title.
         * @param title - New title of the document.
         */
        setTitle(title: string): Promise<void>;
        /**
         * @returns A promise that resolves to the name of the person who created the document.
         */
        getAuthor(): Promise<string>;
        /**
         * @returns A promise that resolves to sDF/Cos string object representing document's author.
         */
        getAuthorObj(): Promise<PDFNet.Obj>;
        /**
         * Set the author of the document.
         * @param author - The name of the person who created the document.
         */
        setAuthor(author: string): Promise<void>;
        /**
         * @returns A promise that resolves to the subject of the document.
         */
        getSubject(): Promise<string>;
        /**
         * @returns A promise that resolves to sDF/Cos string object representing document's subject.
         */
        getSubjectObj(): Promise<PDFNet.Obj>;
        /**
         * Set the subject of the document
         * @param subject - The subject of the document.
         */
        setSubject(subject: string): Promise<void>;
        /**
         * @returns A promise that resolves to keywords associated with the document.
         */
        getKeywords(): Promise<string>;
        /**
         * @returns A promise that resolves to sDF/Cos string object representing document's keywords.
         */
        getKeywordsObj(): Promise<PDFNet.Obj>;
        /**
         * Set keywords associated with the document.
         * @param keywords - Keywords associated with the document.
         */
        setKeywords(keywords: string): Promise<void>;
        /**
         * @returns A promise that resolves to if the document was converted to PDF from another
         * format, the name of the application that created the original
         * document from which it was converted.
         */
        getCreator(): Promise<string>;
        /**
         * @returns A promise that resolves to sDF/Cos string object representing document's creator.
         */
        getCreatorObj(): Promise<PDFNet.Obj>;
        /**
         * Set document's creator.
         * @param creator - The name of the application that created
         * the original document.
         */
        setCreator(creator: string): Promise<void>;
        /**
         * @returns A promise that resolves to if the document was converted to PDF from another format,
         * the name of the application (for example, Distiller) that
         * converted it to PDF.
         */
        getProducer(): Promise<string>;
        /**
         * @returns A promise that resolves to sDF/Cos string object representing document's producer.
         */
        getProducerObj(): Promise<PDFNet.Obj>;
        /**
         * Set document's producer.
         * @param producer - The name of the application that generated PDF.
         */
        setProducer(producer: string): Promise<void>;
        /**
         * @returns A promise that resolves to the date and time the document was created,
         * in human-readable form.
         */
        getCreationDate(): Promise<PDFNet.Date>;
        /**
         * Set document's creation date.
         * @param creation_date - The date and time the document was created.
         */
        setCreationDate(creation_date: PDFNet.Date): Promise<void>;
        /**
         * @returns A promise that resolves to the date and time the document was most recently
         * modified, in human-readable form.
         */
        getModDate(): Promise<PDFNet.Date>;
        /**
         * Set document's modification date.
         * @param mod_date - The date and time the document was most
         * recently modified.
         */
        setModDate(mod_date: PDFNet.Date): Promise<void>;
        /**
         * @returns A promise that resolves to document's SDF/Cos 'Info' dictionary or NULL if
         * the info dictionary is not available.
         */
        getSDFObj(): Promise<PDFNet.Obj>;
        /**
         * PdFDocInfo constructor. Typically this constructor is
         * never used since it is easier to obtain DocInfo using
         * PDFDoc.GetDocInfo()
         * @returns A promise that resolves to an object of type: "PDFNet.PDFDocInfo"
         */
        static create(tr: PDFNet.Obj): Promise<PDFNet.PDFDocInfo>;
        /**
         * Copy Constructor
         * @returns A promise that resolves to an object of type: "PDFNet.PDFDocInfo"
         */
        copy(): Promise<PDFNet.PDFDocInfo>;
    }
    /**
     * PDFDocViewPrefs is a high-level utility class that can be
     * used to control the way the document is to be presented on
     * the screen or in print.
     *
     * PDFDocViewPrefs class corresponds to PageMode, PageLayout, and
     * ViewerPreferences entries in the document's catalog. For more
     * details please refer to section 8.1 'Viewer Preferences' in
     * PDF Reference Manual.
     */
    class PDFDocViewPrefs {
        /**
         * A utility method used to set the fist page displayed after
         * the document is opened. This method is equivalent to
         * PDFDoc::SetOpenAction(goto_action).
         *
         * If OpenAction is not specified the document should be
         * opened to the top of the first page at the default magnification
         * factor.
         * @param dest - A value specifying the page destination to be
         * displayed when the document is opened.
         *
         * Example:
         * <pre>
         * Destination dest = Destination::CreateFit(page);
         * pdfdoc.GetViewPrefs().SetInitialPage(dest);
         * </pre>
         */
        setInitialPage(dest: PDFNet.Destination): Promise<void>;
        /**
         * Sets PageMode property and change the value of the
         * PageMode key in the Catalog dictionary.
         * @param mode - <pre>
         * PDFNet.PDFDocViewPrefs.PageMode = {
         * 	e_UseNone : 0
         * 	e_UseThumbs : 1
         * 	e_UseBookmarks : 2
         * 	e_FullScreen : 3
         * 	e_UseOC : 4
         * 	e_UseAttachments : 5
         * }
         * </pre>
         * New PageMode setting. Default value is e_UseNone.
         */
        setPageMode(mode: number): Promise<void>;
        /**
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.PDFDocViewPrefs.PageMode = {
         * 	e_UseNone : 0
         * 	e_UseThumbs : 1
         * 	e_UseBookmarks : 2
         * 	e_FullScreen : 3
         * 	e_UseOC : 4
         * 	e_UseAttachments : 5
         * }
         * </pre>
         * @returns A promise that resolves to the value of currently selected PageMode property.
         */
        getPageMode(): Promise<number>;
        /**
         * Sets PageLayout property and change the value of the
         * PageLayout key in the Catalog dictionary.
         * @param mode - <pre>
         * PDFNet.PDFDocViewPrefs.PageLayout = {
         * 	e_Default : 0
         * 	e_SinglePage : 1
         * 	e_OneColumn : 2
         * 	e_TwoColumnLeft : 3
         * 	e_TwoColumnRight : 4
         * 	e_TwoPageLeft : 5
         * 	e_TwoPageRight : 6
         * }
         * </pre>
         * New PageLayout setting. Default value is
         * e_SinglePage.
         */
        setLayoutMode(mode: number): Promise<void>;
        /**
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.PDFDocViewPrefs.PageLayout = {
         * 	e_Default : 0
         * 	e_SinglePage : 1
         * 	e_OneColumn : 2
         * 	e_TwoColumnLeft : 3
         * 	e_TwoColumnRight : 4
         * 	e_TwoPageLeft : 5
         * 	e_TwoPageRight : 6
         * }
         * </pre>
         * @returns A promise that resolves to the value of currently selected PageLayout property.
         */
        getLayoutMode(): Promise<number>;
        /**
         * sets the value of given ViewerPref property.
         * @param pref - <pre>
         * PDFNet.PDFDocViewPrefs.ViewerPref = {
         * 	e_HideToolbar : 0
         * 	e_HideMenubar : 1
         * 	e_HideWindowUI : 2
         * 	e_FitWindow : 3
         * 	e_CenterWindow : 4
         * 	e_DisplayDocTitle : 5
         * }
         * </pre>
         * the ViewerPref property type to modify.
         * @param value - The new value for the property.
         */
        setPref(pref: number, value: boolean): Promise<void>;
        /**
         * @param pref - <pre>
         * PDFNet.PDFDocViewPrefs.ViewerPref = {
         * 	e_HideToolbar : 0
         * 	e_HideMenubar : 1
         * 	e_HideWindowUI : 2
         * 	e_FitWindow : 3
         * 	e_CenterWindow : 4
         * 	e_DisplayDocTitle : 5
         * }
         * </pre>
         * the ViewerPref property type to query.
         * @returns A promise that resolves to the value of given ViewerPref property.
         */
        getPref(pref: number): Promise<boolean>;
        /**
         * set the document's page mode, specifying how to display the
         * document on exiting full-screen mode.
         * @param mode - <pre>
         * PDFNet.PDFDocViewPrefs.PageMode = {
         * 	e_UseNone : 0
         * 	e_UseThumbs : 1
         * 	e_UseBookmarks : 2
         * 	e_FullScreen : 3
         * 	e_UseOC : 4
         * 	e_UseAttachments : 5
         * }
         * </pre>
         * PageMode used after exiting full-screen mode.
         * Default value: e_UseNone.
         *
         * Note: This entry is meaningful only if the value of the
         * PageMode is set to e_FullScreen; it is ignored otherwise.
         */
        setNonFullScreenPageMode(mode: number): Promise<void>;
        /**
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.PDFDocViewPrefs.PageMode = {
         * 	e_UseNone : 0
         * 	e_UseThumbs : 1
         * 	e_UseBookmarks : 2
         * 	e_FullScreen : 3
         * 	e_UseOC : 4
         * 	e_UseAttachments : 5
         * }
         * </pre>
         * @returns A promise that resolves to the PageMode used after exiting full-screen mode.
         * Note: This entry is meaningful only if the value of the
         * PageMode is set to e_FullScreen; it is ignored otherwise.
         */
        getNonFullScreenPageMode(): Promise<number>;
        /**
         * sets the predominant reading order for text.
         *
         * This flag has no direct effect on the document's contents
         * or page numbering but can be used to determine the relative
         * positioning of pages when displayed side by side or
         * printed n-up.
         * @param left_to_right - true if the predominant reading
         * order for text is from left to right and false if it is
         * right to left (including vertical writing systems, such
         * as Chinese, Japanese, and Korean).
         * Default value: left_to_right is true.
         */
        setDirection(left_to_right: boolean): Promise<void>;
        /**
         * @returns A promise that resolves to true is the predominant reading order for text
         * is left to right, false otherwise. See SetDirection() for
         * more information.
         */
        getDirection(): Promise<boolean>;
        /**
         * Sets the page boundary representing the area of a page
         * to be displayed when viewing the document on the screen.
         * @param box - <pre>
         * PDFNet.Page.Box = {
         * 	e_media : 0
         * 	e_crop : 1
         * 	e_bleed : 2
         * 	e_trim : 3
         * 	e_art : 4
         * 	e_user_crop : 5
         * }
         * </pre>
         * page boundary displayed when viewing the document
         * on the screen. By default, PDF viewers will display the
         * crop-box.
         */
        setViewArea(box: number): Promise<void>;
        /**
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.Page.Box = {
         * 	e_media : 0
         * 	e_crop : 1
         * 	e_bleed : 2
         * 	e_trim : 3
         * 	e_art : 4
         * 	e_user_crop : 5
         * }
         * </pre>
         * @returns A promise that resolves to the page boundary representing the area of a page
         * to be displayed when viewing the document on the screen.
         */
        getViewArea(): Promise<number>;
        /**
         * sets the page boundary to which the contents of a page are
         * to be clipped when viewing the document on the screen.
         * @param box - <pre>
         * PDFNet.Page.Box = {
         * 	e_media : 0
         * 	e_crop : 1
         * 	e_bleed : 2
         * 	e_trim : 3
         * 	e_art : 4
         * 	e_user_crop : 5
         * }
         * </pre>
         * screen clip region. The default value is
         * page crop-box.
         */
        setViewClip(box: number): Promise<void>;
        /**
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.Page.Box = {
         * 	e_media : 0
         * 	e_crop : 1
         * 	e_bleed : 2
         * 	e_trim : 3
         * 	e_art : 4
         * 	e_user_crop : 5
         * }
         * </pre>
         * @returns A promise that resolves to the page boundary to which the contents of a page
         * are to be clipped when viewing the document on the screen.
         */
        getViewClip(): Promise<number>;
        /**
         * sets the page boundary representing the area of a page to
         * be rendered when printing the document.
         * @param box - <pre>
         * PDFNet.Page.Box = {
         * 	e_media : 0
         * 	e_crop : 1
         * 	e_bleed : 2
         * 	e_trim : 3
         * 	e_art : 4
         * 	e_user_crop : 5
         * }
         * </pre>
         * printing region. The default value is page
         * crop-box.
         */
        setPrintArea(box: number): Promise<void>;
        /**
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.Page.Box = {
         * 	e_media : 0
         * 	e_crop : 1
         * 	e_bleed : 2
         * 	e_trim : 3
         * 	e_art : 4
         * 	e_user_crop : 5
         * }
         * </pre>
         * @returns A promise that resolves to the page boundary representing the area of a page
         * to be rendered when printing the document.
         */
        getPrintArea(): Promise<number>;
        /**
         * sets the page boundary to which the contents of a page are
         * to be clipped when printing the document.
         * @param box - <pre>
         * PDFNet.Page.Box = {
         * 	e_media : 0
         * 	e_crop : 1
         * 	e_bleed : 2
         * 	e_trim : 3
         * 	e_art : 4
         * 	e_user_crop : 5
         * }
         * </pre>
         * printing clip region. The default value is page
         * crop-box.
         */
        setPrintClip(box: number): Promise<void>;
        /**
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.Page.Box = {
         * 	e_media : 0
         * 	e_crop : 1
         * 	e_bleed : 2
         * 	e_trim : 3
         * 	e_art : 4
         * 	e_user_crop : 5
         * }
         * </pre>
         * @returns A promise that resolves to the page boundary to which the contents of a page
         * are to be clipped when printing the document.
         */
        getPrintClip(): Promise<number>;
        /**
         * @returns A promise that resolves to document's SDF/Cos 'ViewerPreferences' dictionary
         * or NULL if the object is not present.
         */
        getSDFObj(): Promise<PDFNet.Obj>;
        /**
         * PdFDocViewPrefs constructor. Typically this constructor is
         * never used since it is easier to obtain PDFDocViewPrefs using
         * PDFDoc.GetViewPrefs()
         * @returns A promise that resolves to an object of type: "PDFNet.PDFDocViewPrefs"
         */
        static create(tr: PDFNet.Obj): Promise<PDFNet.PDFDocViewPrefs>;
        /**
         * Copy Constructor
         * @returns A promise that resolves to an object of type: "PDFNet.PDFDocViewPrefs"
         */
        copy(): Promise<PDFNet.PDFDocViewPrefs>;
    }
    /**
     * PDFDraw contains methods for converting PDF pages to images and to Bitmap objects.
     * Utility methods are provided to export PDF pages to various raster formats as well
     * as to convert pages to GDI+ bitmaps for further manipulation or drawing.
     *
     * Note: This class is available on all platforms supported by PDFNet.
     */
    class PDFDraw extends PDFNet.Destroyable {
        /**
         * sets the Optional Content Group (OCG) context that should be used when
         * rendering the page. This function can be used to selectively render optional
         * content (such as PDF layers) based on the states of optional content groups
         * in the given context.
         * @param ctx - Optional Content Group (OCG) context, or NULL if the rasterizer
         * should render all content on the page.
         */
        setOCGContext(ctx: PDFNet.OCGContext): Promise<void>;
        /**
         * PdFDraw constructor and destructor
         * @param [dpi] - Default resolution used to rasterize pages. If the parameter is not
         * specified, the initial resolution is 92 dots per inch. DPI parameter can be
         * modified at any time using PDFDraw::SetDPI() method.
         * @returns A promise that resolves to an object of type: "PDFNet.PDFDraw"
         */
        static create(dpi?: number): Promise<PDFNet.PDFDraw>;
        /**
         * Sets the core graphics library used for rasterization and
         * rendering. Using this method it is possible to quickly switch
         * between different implementations. By default, PDFDraw uses
         * the built-in, platform independent rasterizer.
         * @param type - <pre>
         * PDFNet.PDFRasterizer.Type = {
         * 	e_BuiltIn : 0
         * 	e_GDIPlus : 1
         * }
         * </pre>
         * Rasterizer type.
         *
         * Note: This method is deprecated, since the GDI+ rasterizer itself is deprecated and will be removed in a future version of PDFNet.
         * It is strongly recommended to use the built-in rasterizer and to use the XPS print path where vector conversion is needed.
         */
        setRasterizerType(type: number): Promise<void>;
        /**
         * Sets the output image resolution.
         *
         * DPI stands for Dots Per Inch. This parameter is used to specify the output
         * image size and quality. A typical screen resolution for monitors these days is
         * 92 DPI, but printers could use 200 DPI or more.
         * @param dpi - value to set the image resolution to. Higher value = higher resolution.
         * Note: The size of resulting image is a function of DPI and the dimensions of
         * the source PDF page. For example, if DPI is 92 and page is 8 inches wide, the
         * output bitmap will have 92*8 = 736 pixels per line. If you know the dimensions
         * of the destination bitmap, but don't care about DPI of the image you can use
         * pdfdraw.SetImageSize() instead.
         *
         * Note: if you would like to rasterize extremely large bitmaps (e.g. with
         * resolutions of 2000 DPI or more) it is not practical to use PDFDraw directly
         * because of the memory required to store the entire image. In this case, you
         * can use PDFRasterizer directly to generate the rasterized image in stripes or
         * tiles.
         */
        setDPI(dpi: number): Promise<void>;
        /**
         * SetImageSize can be used instead of SetDPI() to adjust page  scaling so that
         * image fits into a buffer of given dimensions.
         *
         * If this function is used, DPI will be calculated dynamically for each
         * page so that every page fits into the buffer of given dimensions.
         * @param width - The width of the image, in pixels/samples.
         * @param height - The height of the image, in pixels/samples.
         * @param [preserve_aspect_ratio] - True to preserve the aspect ratio, false
         * otherwise. By default, preserve_aspect_ratio is true.
         */
        setImageSize(width: number, height: number, preserve_aspect_ratio?: boolean): Promise<void>;
        /**
         * Selects the page box/region to rasterize.
         * @param region - <pre>
         * PDFNet.Page.Box = {
         * 	e_media : 0
         * 	e_crop : 1
         * 	e_bleed : 2
         * 	e_trim : 3
         * 	e_art : 4
         * 	e_user_crop : 5
         * }
         * </pre>
         * Page box to rasterize. By default, PDFDraw will rasterize
         * page crop box.
         */
        setPageBox(region: number): Promise<void>;
        /**
         * clip the render region to the provided rect (in page space)
         * @param rect - clipping rect. By default, PDFDraw will rasterize
         * the entire page box.
         */
        setClipRect(rect: PDFNet.Rect): Promise<void>;
        /**
         * Flips the vertical (i.e. Y) axis of the image.
         * @param flip_y - true to flip the Y axis, false otherwise. For compatibility with
         * most raster formats 'flip_y' is true by default.
         */
        setFlipYAxis(flip_y: boolean): Promise<void>;
        /**
         * Sets the rotation value for this page.
         *
         * Note: This method is used only for drawing purposes and it does not modify
         * the document (unlike Page::SetRotate()).
         * @param angle - <pre>
         * PDFNet.Page.Rotate = {
         * 	e_0 : 0
         * 	e_90 : 1
         * 	e_180 : 2
         * 	e_270 : 3
         * }
         * </pre>
         * Rotation value to be set for a given page. Must be one
         * of the Page::Rotate values.
         */
        setRotate(angle: number): Promise<void>;
        /**
         * Enable or disable annotation and forms rendering. By default, all annotations
         * and form fields are rendered.
         * @param render_annots - True to draw annotations, false otherwise.
         */
        setDrawAnnotations(render_annots: boolean): Promise<void>;
        /**
         * Enable or disable highlighting form fields. Default is disabled.
         * @param highlight - true to highlight, false otherwise.
         */
        setHighlightFields(highlight: boolean): Promise<void>;
        /**
         * Enable or disable anti-aliasing.
         *
         * Anti-Aliasing is a technique used to improve the visual
         * quality of images when displaying them on low resolution
         * devices (for example, low DPI computer monitors).
         * @param enable_aa - if true anti-aliasing will be enabled.
         */
        setAntiAliasing(enable_aa: boolean): Promise<void>;
        /**
         * Enable or disable path hinting.
         * @param enable_hinting - if true path hinting will be enabled. Path hinting is used
         * to slightly adjust paths in order to avoid or alleviate artifacts of hair line
         * cracks between certain graphical elements. This option is turned on by default.
         */
        setPathHinting(enable_hinting: boolean): Promise<void>;
        /**
         * Set thin line adjustment parameters.
         * @param grid_fit - if true (horizontal/vertical) thin lines will be snapped to
         * integer pixel positions. This helps make thin lines look sharper and clearer. This
         * option is turned off by default and it only works if path hinting is enabled.
         * @param stroke_adjust - if true auto stroke adjustment is enabled. Currently, this would
         * make lines with sub-pixel width to be one-pixel wide. This option is turned on by default.
         */
        setThinLineAdjustment(grid_fit: boolean, stroke_adjust: boolean): Promise<void>;
        /**
         * Sets the gamma factor used for anti-aliased rendering.
         * @param exp - is the exponent value of gamma function. Typical values
         * are in the range from 0.1 to 3.
         *
         * Gamma correction can be used to improve the quality of anti-aliased
         * image output and can (to some extent) decrease the appearance common
         * anti-aliasing artifacts (such as pixel width lines between polygons).
         *
         * Note: Gamma correction is used only in the built-in rasterizer.
         */
        setGamma(exp: number): Promise<void>;
        /**
         * tells the rasterizer to render the page 'print' mode. Certain page elements
         * (such as annotations or OCG-s) are meant to be visible either on the screen or
         * on the printed paper but not both. A common example, is the "Submit" button on
         * electronic forms.
         * @param is_printing - set to true if the page should be rendered in print mode.
         */
        setPrintMode(is_printing: boolean): Promise<void>;
        /**
         * sets the page color to transparent.
         * @param is_transparent - If true, page's backdrop color will be transparent.
         * If false, the page's backdrop will be a opaque white.
         *
         * Note: If page transparency is enabled, the alpha channel will be preserved when
         * the image is exported as PNG, TIFF(when in RGB space), or RAW.
         */
        setPageTransparent(is_transparent: boolean): Promise<void>;
        /**
         * sets the default color of the page backdrop.
         * @param r - the red component of the page backdrop color.
         * @param g - the green component of the page backdrop color.
         * @param b - the blue component of the page backdrop color.
         *
         * Note: Only when the page backdrop is not set to transparent (SetPageTransparent), default
         * page color is used.
         */
        setDefaultPageColor(r: number, g: number, b: number): Promise<void>;
        /**
         * enable or disable support for overprint and overprint simulation.
         * Overprint is a device dependent feature and the results will vary depending on
         * the output color space and supported colorants (i.e. CMYK, CMYK+spot, RGB, etc).
         * @param op - <pre>
         * PDFNet.PDFRasterizer.OverprintPreviewMode = {
         * 	e_op_off : 0
         * 	e_op_on : 1
         * 	e_op_pdfx_on : 2
         * }
         * </pre>
         * e_op_on: always enabled; e_op_off: always disabled; e_op_pdfx_on: enabled for PDF/X files only.
         */
        setOverprint(op: number): Promise<void>;
        /**
         * Enable or disable image smoothing.
         *
         * The rasterizer allows a tradeoff between rendering quality and rendering speed.
         * This function can be used to indicate the preference between rendering speed and quality.
         *
         * Note: image smoothing option has effect only if the source image has higher resolution
         * that the output resolution of the image on the rasterized page. PDFNet automatically
         * controls at what resolution/zoom factor, 'image smoothing' needs to take effect.
         * @param [smoothing_enabled] - True to enable image smoothing, false otherwise.
         * @param [hq_image_resampling] - True to use a higher quality (but slower) smoothing algorithm
         */
        setImageSmoothing(smoothing_enabled?: boolean, hq_image_resampling?: boolean): Promise<void>;
        /**
         * enables or disables caching. Caching can improve the rendering performance in cases
         * where the same page will be drawn multiple times.
         * @param [enabled] - if true PDFRasterizer will cache frequently used graphics objects.
         */
        setCaching(enabled?: boolean): Promise<void>;
        /**
         * Set the color post processing transformation.
         * This transform is applied to the rasterized bitmap as the final step
         * in the rasterization process, and is applied directly to the resulting
         * bitmap (disregarding any color space information). Color post
         * processing only supported for RGBA output.
         * @param mode - <pre>
         * PDFNet.PDFRasterizer.ColorPostProcessMode = {
         * 	e_postprocess_none : 0
         * 	e_postprocess_invert : 1
         * 	e_postprocess_gradient_map : 2
         * 	e_postprocess_night_mode : 3
         * }
         * </pre>
         * is the specific transform to be applied
         */
        setColorPostProcessMode(mode: number): Promise<void>;
        /**
         * Returns a vector of rasterized separations for the given image.
         *
         * Note: This method is relatively low-level and is only available in PDFNet for C++.
         * If you are using PDFNet for .NET, you can use the function with the same name that
         * directly returns GDI+ Bitmap.
         * @param page - The source PDF page.
         * @returns A promise that resolves to separation has a pointer to the internal memory buffer containing the rasterized image
         * of the given page. The buffer size is at least 'out_height*out_stride' bytes.
         * The pixel data is stored in 8 bit per component, BGRA format.
         */
        getSeparationBitmaps(page: PDFNet.Page): Promise<PDFNet.Separation[]>;
        /**
         * Export the given PDF page to a buffer.
         * @param page - The source PDF page.
         * @param [format] - The file format of the output image. Currently supported formats
        are:
           - "RAW"   : RAW format. There are four possibilities:
                          e_rgba - if transparent and color page;
                          e_gray_alpha - if transparent and gray page;
                          e_rgb - if opaque and color page;
                          e_gray - if opaque and gray page.
                        NOTE that if page is set to be transparent (SetPageTransparent),
                        the output color channels are already multiplied by the alpha channel.
           - "BMP"   : Bitmap image format (BMP)
           - "JPEG"  : Joint Photographic Experts Group (JPEG) image format
           - "PNG"   : 24-bit W3C Portable Network Graphics (PNG) image format
           - "PNG8"  : 8-bit, palettized PNG format. The exported file size should be
                       smaller than the one generated using "PNG", possibly at the
                       expense of some image quality.
           - "TIFF"  : Tag Image File Format (TIFF) image format.
           - "TIFF8" : Tag Image File Format (TIFF) image format (with 8-bit palete).
        
        By default, the function exports to PNG.
         * @param [encoder_params] - An optional SDF dictionary object containing key/value
        pairs representing optional encoder parameters. The following table list possible
        parameters for corresponding export filters:
        
         <table border="1">
            <tr>
                <td>Parameter/Key</td>
                <td>Output Format</td>
                <td>Description/Value</td>
                <td>Example</td>
            </tr>
            <tr>
                <td>Quality</td>
                <td>JPEG</td>
                <td>The value for compression 'Quality' must be a number between 0 and 100
                    specifying the tradeoff between compression ratio and loss in image quality.
                    100 stands for best quality.</td>
                <td>
                    <P style="Z-INDEX: 0">hint.PutNumber("Quality", 60);</P>
                    <P>See the Example 2 in PDFDraw sample project.</P>
                </td>
            </tr>
            <tr>
                <td>Dither</td>
                <td>
                    PNG, PNG8, TIFF or TIFF8.</td>
                <td>A boolean used to enable or disable dithering. Relevent only for when the image
                    is exported in palettized or monochrome mode.</td>
                <td>hint.PutBool("Dither", true);</td>
            </tr>
            <tr>
                <td>ColorSpace</td>
                <td>PNG or TIFF for grayscale; TIFF for CMYK; PNG, BMP, JPEG, or TIFF for Separation.</td>
                <td>A name object used to select the rendering and export color space. Currently
                    supported values are "Gray", "RGB, "CMYK", and "Separation". The output image
                    format must support specified color space, otherwise the parameter will be ignored.
                    An example of image format that supports CMYK is TIFF. Image formats that support
                    grayscale are PNG and TIFF. Separation output is supported in either a single
                    N-Channel TIFF, or in separate single-channel files (either PNG, BMP, or JPEG).
                    Output in "Separation" space implies that overprint simulation is on.
                    By default, the image is rendered and exported in RGB color space.</td>
                <td>hint.PutName("ColorSpace", "CMYK");</td>
            </tr>
            <tr>
                <td>BPC</td>
                <td>PNG or TIFF.</td>
                <td>A number used to specify 'bits per pixel' in the output file. Currently
                    supported values are 1 and 8 (default is 8). To export monochrome (1 bit
                    per pixel) image, use 1 as the value of BPC parameter and use TIFF or PNG as the
                    export format for the image. By default, the image is not dithered when BPC is 1.
                    To enable dithering add 'Dither' option in the export hint.</td>
                <td>hint.PutNumber("BPC", 1);</td>
            </tr>
         </table>
         * @returns A promise that resolves to a Uint8Array containing the page data.
         */
        exportBuffer(page: PDFNet.Page, format?: string, encoder_params?: PDFNet.Obj): Promise<Uint8Array>;
    }
    /**
     * PDFRasterizer is a low-level PDF rasterizer.
     *
     * The main purpose of this class is to convert PDF pages to raster
     * images (or bitmaps).
     *
     * Note: PDFRasterizer is a relatively low-level class. If you need to
     * convert PDF page to an image format or a Bitmap, consider
     * using PDFNet.PDFDraw. Similarly, if you are building an interactive
     * PDF viewing application you may want to use PDFNet.PDFView instead.
     */
    class PDFRasterizer extends PDFNet.Destroyable {
        /**
         * PdFRasterizer constructor and destructor
         * @param [type] - <pre>
         * PDFNet.PDFRasterizer.Type = {
         * 	e_BuiltIn : 0
         * 	e_GDIPlus : 1
         * }
         * </pre>
         * @returns A promise that resolves to an object of type: "PDFNet.PDFRasterizer"
         */
        static create(type?: number): Promise<PDFNet.PDFRasterizer>;
        /**
         * Enable or disable annotation and forms rendering. By default, annotations and forms
         * are rendered.
         * @param render_annots - True to draw annotations, false otherwise.
         */
        setDrawAnnotations(render_annots: boolean): Promise<void>;
        /**
         * Enable or disable highlighting form fields. Default is disabled.
         * @param highlight - true to highlight, false otherwise.
         */
        setHighlightFields(highlight: boolean): Promise<void>;
        /**
         * Enable or disable anti-aliasing.
         *
         * Anti-Aliasing is a technique used to improve the visual
         * quality of images when displaying them on low resolution
         * devices (for example, low DPI computer monitors).
         */
        setAntiAliasing(enable_aa: boolean): Promise<void>;
        /**
         * Enable or disable path hinting.
         * @param enable_hinting - if true path hinting is enabled. Path hinting is used to slightly
         * adjust paths in order to avoid or alleviate artifacts of hair line cracks between
         * certain graphical elements. This option is turned on by default.
         */
        setPathHinting(enable_hinting: boolean): Promise<void>;
        /**
         * Set thin line adjustment parameters.
         * @param grid_fit - if true (horizontal/vertical) thin lines will be snapped to
         * integer pixel positions. This helps make thin lines look sharper and clearer. This
         * option is turned off by default and it only works if path hinting is enabled.
         * @param stroke_adjust - if true auto stroke adjustment is enabled. Currently, this would
         * make lines with sub-pixel width to be one-pixel wide. This option is turned on by default.
         */
        setThinLineAdjustment(grid_fit: boolean, stroke_adjust: boolean): Promise<void>;
        /**
         * sets the gamma factor used for anti-aliased rendering.
         * @param expgamma - is the exponent value of gamma function. Typical values
         * are in the range from 0.1 to 3.
         *
         * Gamma correction can be used to improve the quality of anti-aliased
         * image output and can (to some extent) decrease the appearance common
         * anti-aliasing artifacts (such as pixel width lines between polygons).
         *
         * Note: Gamma correction is used only in the built-in rasterizer.
         */
        setGamma(expgamma: number): Promise<void>;
        /**
         * sets the Optional Content Group (OCG) context that should be used when
         *  rendering the page. This function can be used to selectively render optional
         * content (such as PDF layers) based on the states of optional content groups
         * in the given context.
         * @param ctx - Optional Content Group (OCG) context, or NULL if the rasterizer
         * should render all content on the page.
         */
        setOCGContext(ctx: PDFNet.OCGContext): Promise<void>;
        /**
         * tells the rasterizer to render the page 'print' mode. Certain page elements
         * (such as annotations or OCG-s) are meant to be visible either on the screen or
         * on the printed paper but not both. A common example, is the "Submit" button on
         * electronic forms.
         * @param is_printing - set to true is the page should be rendered in print mode.
         */
        setPrintMode(is_printing: boolean): Promise<void>;
        /**
         * Enable or disable image smoothing.
         *
         * The rasterizer allows a tradeoff between rendering quality and rendering speed.
         * This function can be used to indicate the preference between rendering speed and quality.
         *
         * Note: image smoothing option has effect only if the source image has higher resolution
         * that the output resolution of the image on the rasterized page. PDFNet automatically
         * controls at what resolution/zoom factor, 'image smoothing' needs to take effect.
         * @param [smoothing_enabled] - True to enable image smoothing, false otherwise.
         * @param [hq_image_resampling] - True to use a higher quality (but slower) smoothing algorithm
         */
        setImageSmoothing(smoothing_enabled?: boolean, hq_image_resampling?: boolean): Promise<void>;
        /**
         * enable or disable support for overprint and overprint simulation.
         * Overprint is a device dependent feature and the results will vary depending on
         * the output color space and supported colorants (i.e. CMYK, CMYK+spot, RGB, etc).
         * @param op - <pre>
         * PDFNet.PDFRasterizer.OverprintPreviewMode = {
         * 	e_op_off : 0
         * 	e_op_on : 1
         * 	e_op_pdfx_on : 2
         * }
         * </pre>
         * e_op_on: always enabled; e_op_off: always disabled; e_op_pdfx_on: enabled for PDF/X files only.
         */
        setOverprint(op: number): Promise<void>;
        /**
         * enables or disables caching. Caching can improve the rendering performance in cases
         * where the same page will be drawn multiple times.
         * @param [enabled] - if true PDFRasterizer will cache frequently used graphics objects.
         */
        setCaching(enabled?: boolean): Promise<void>;
        /**
         * @param new_view_state - <pre>
         * PDFNet.Annot.State = {
         * 	e_normal : 0
         * 	e_rollover : 1
         * 	e_down : 2
         * }
         * </pre>
         */
        setAnnotationState(annot: PDFNet.Annot, new_view_state: number): Promise<void>;
        /**
         * Sets the core graphics library used for rasterization and
         * rendering. Using this method it is possible to quickly switch
         * between different implementations. By default, PDFNet uses a
         * built-in, high-quality, and platform independent rasterizer.
         * @param type - <pre>
         * PDFNet.PDFRasterizer.Type = {
         * 	e_BuiltIn : 0
         * 	e_GDIPlus : 1
         * }
         * </pre>
         * Rasterizer type.
         *
         * Note: This method is deprecated, since the GDI+ rasterizer itself is deprecated and will be removed in a future version of PDFNet.
         * It is strongly recommended to use the built-in rasterizer and to use the XPS print path where vector conversion is needed.
         */
        setRasterizerType(type: number): Promise<void>;
        /**
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.PDFRasterizer.Type = {
         * 	e_BuiltIn : 0
         * 	e_GDIPlus : 1
         * }
         * </pre>
         * @returns A promise that resolves to the type of current rasterizer.
         * Note: This method is deprecated, since the GDI+ rasterizer itself is deprecated and will be removed in a future version of PDFNet.
         * It is strongly recommended to use the built-in rasterizer and to use the XPS print path where vector conversion is needed.
         */
        getRasterizerType(): Promise<number>;
        /**
         * Set the color post processing transformation.
         * This transform is applied to the rasterized bitmap as the final step
         * in the rasterization process, and is applied directly to the resulting
         * bitmap (disregarding any color space information). Color post
         * processing only supported for RGBA output.
         * @param mode - <pre>
         * PDFNet.PDFRasterizer.ColorPostProcessMode = {
         * 	e_postprocess_none : 0
         * 	e_postprocess_invert : 1
         * 	e_postprocess_gradient_map : 2
         * 	e_postprocess_night_mode : 3
         * }
         * </pre>
         * is the specific transform to be applied
         */
        setColorPostProcessMode(mode: number): Promise<void>;
        /**
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.PDFRasterizer.ColorPostProcessMode = {
         * 	e_postprocess_none : 0
         * 	e_postprocess_invert : 1
         * 	e_postprocess_gradient_map : 2
         * 	e_postprocess_night_mode : 3
         * }
         * </pre>
         * @returns A promise that resolves to the current color post processing mode.
         */
        getColorPostProcessMode(): Promise<number>;
        enableDisplayListCaching(enabled: boolean): Promise<void>;
        /**
         * this function is typically called for progressive rendering, in which
         *  we don't want to stop the main rendering thread. Since the rendering thread may
         *  modify separation channels, we don't consider separations in progressive rendering.
         */
        updateBuffer(): Promise<void>;
        /**
         * @returns A promise that resolves to an object of type: "PDFNet.OwnedBitmap"
         */
        rasterizeAnnot(annot: PDFNet.Annot, page: PDFNet.Page, device_mtx: PDFNet.Matrix2D, demult: boolean, cancel: boolean): Promise<PDFNet.OwnedBitmap>;
        /**
         * Draws the page into a given memory buffer.
         *
         * Note: This method is available on all platforms and in all
         * rasterizer implementations.
         * @param page - The page to rasterize.
         * @param width - The width of the target image in pixels.
         * @param height - The height of the target image in pixels (the number of rows).
         * @param mtx - Device transformation matrix that maps PDF page from PDF user space
         * into device coordinate space (e.g. pixel space). PDF user space is represented in
         * page units, where one unit corresponds to 1/72 of an inch.
         * @param clip - Optional parameter defining the clip region for the page. If the parameter
         *  is null or is not specified, PDFRasterizer uses page's crop box as a default clip region.
         * @param cancel - An optional variable that can be used to stop the rendering thread.
         * @returns A promise that resolves to an object of type: "Array<PDFNet.Separation>"
         */
        rasterizeSeparations(page: PDFNet.Page, width: number, height: number, mtx: PDFNet.Matrix2D, clip: PDFNet.Rect, cancel: boolean): Promise<PDFNet.Separation[]>;
        /**
         * Draws the page into a given memory buffer.
         * @param page - The page to rasterize.
         * @param width - The width of the target image in pixels.
         * @param height - The height of the target image in pixels (the number of rows).
         * @param stride - Stride determines the physical width (in bytes) of one row in memory.
        If this value is negative the direction of the Y axis is inverted. The absolute
        value of stride is of importance, because it allows rendering in buffers where
        rows are padded in memory (e.g. in Windows bitmaps are padded on 4 byte boundaries).
        Besides allowing rendering on the whole buffer stride parameter can be used
        for rendering in a rectangular subset of a buffer.
         * @param num_comps - The number (4 or 5) representing the number of color components
        in the device color space. For BGR+Alpha set this parameter to 4, and for CMYK+Alpha use 5.
        If other values are set, exceptions will be thrown.
         * @param demult - Specifies if the alpha is de-multiplied from the resulting color components.
         * @param device_mtx - Device transformation matrix that maps PDF page from PDF user space
        into device coordinate space (e.g. pixel space). PDF user space is represented in
        page units, where one unit corresponds to 1/72 of an inch.
         * @param [clip] - Optional parameter defining the clip region for the page. If the parameter
         is null or is not specified, PDFRasterizer uses page's crop box as a default clip region.
         * @param [scrl_clp_regions] - Optional parameter reserved for a future use.
         * @returns a memory buffer. The buffer must contain
        at least (stride * height) bytes.
         */
        static rasterize(page: PDFNet.Page, width: number, height: number, stride: number, num_comps: number, demult: boolean, device_mtx: PDFNet.Matrix2D, clip?: PDFNet.Rect, scrl_clp_regions?: PDFNet.Rect): Promise<Uint8Array>;
    }
    /**
     * This class represents PDFTron Custom Security handler that applies PDFTron's custom encryption method on save.
     */
    class PDFTronCustomSecurityHandler {
        /**
         * constructor
         * @param custom_id - the user's custom ID. A random ID is suggested to make the custom security unique to the application.
         *
         * Note: Please refer to PDFNet::AddPDFTronCustomHandler(UInt32 custom_id) for more details.
         * @returns A promise that resolves to an object of type: "PDFNet.SecurityHandler"
         */
        static create(custom_id: number): Promise<PDFNet.SecurityHandler>;
    }
    /**
     * PDFView is a utility class that can be used for interactive rendering of PDF documents.
     *
     * In .NET environment PDFView is derived from System.Windows.Forms.Control and it can be
     * used like a regular form (see PDFViewForm.cs in PDFView sample for C# for a concrete
     * example).
     *
     * PDFView implements some essential features such as double-buffering, multi-threaded
     * rendering, scrolling, zooming, and page navigation that are essential in interactive
     * rendering applications (e.g. in client PDF viewing and editing applications).
     *
     * PDFView defines several coordinate spaces and it is important to understand their
     * differences:
     *
     * - Page Space refers to the space in which a PDF page is defined. It is determined by
     * a page itself and the origin is at the lower-left corner of the page. Note that Page
     * Space is independent of how a page is viewed in PDFView and each page has its own Page
     * space.
     *
     * - Canvas Space refers to the tightest axis-aligned bounding box of all the pages given
     * the current page presentation mode in PDFView. For example, if the page presentation
     * mode is e_single_continuous, all the pages are arranged vertically with one page in each
     * row, and therefore the Canvas Space is rectangle with possibly large height value. For
     * this reason, Canvas Space is also, like Page Space, independent of the zoom factor. Also
     * note that since PDFView adds gaps between adjacent pages, the Canvas Space is larger than
     * the space occupied by all the pages. The origin of the Canvas Space is located at the
     * upper-left corner.
     *
     * - Screen Space (or Client Space) is the space occupied by PDFView and its origin is at
     * the upper-left corner. Note that the virtual size of this space can extend beyond the
     * visible region.
     *
     * - Scrollable Space is the virtual space within which PDFView can scroll. It is determined
     * by the Canvas Space and the current zoom factor. Roughly speaking, the dimensions of the
     * Scrollable Space is the dimensions of the Canvas Space timed by the zoom. Therefore, a large
     * zoom factor will result in a larger Scrollable region given the same Canvas region. For this
     * reason, Scrollable Space might also be referred to as Zoomed Canvas Space. Note that since
     * PDFView adds gaps between pages in Canvas Space and these gaps are not scaled when rendered,
     * the scrollable range is not exactly what the zoom factor times the Canvas range. For
     * functions such as SetHScrollPos(), SetVScrollPos(), GetCanvasHeight(), and
     * GetCanvasWidth(), it is the Scrollable Space that is involved.
     *
     * Note: PDFView is available on all platforms supported by PDFNet.
     */
    class PDFView {
    }
    /**
     * PDFViewCtrl is a utility class that can be used for interactive rendering of PDF documents.
     *
     * In .NET environment PDFViewCtrl is derived from System.Windows.Forms.Control and it can be
     * used like a regular form (see PDFViewForm.cs in PDFView sample for C# for a concrete
     * example).
     *
     * Unlike PDFView, PDFViewCtrl is a control that implements a number of tool modes,
     * dialog boxes like find and password, has some built-in form filling capabilities
     * and a navigation panel for bookmarks, thumbview and layer views.
     *
     * PDFViewCtrl defines several coordinate spaces and it is important to understand their
     * differences:
     *
     * - Page Space refers to the space in which a PDF page is defined. It is determined by
     * a page itself and the origin is at the lower-left corner of the page. Note that Page
     * Space is independent of how a page is viewed in PDFView and each page has its own Page
     * space.
     *
     * - Canvas Space refers to the tightest axis-aligned bounding box of all the pages given
     * the current page presentation mode in PDFView. For example, if the page presentation
     * mode is e_single_continuous, all the pages are arranged vertically with one page in each
     * row, and therefore the Canvas Space is rectangle with possibly large height value. For
     * this reason, Canvas Space is also, like Page Space, independent of the zoom factor. Also
     * note that since PDFView adds gaps between adjacent pages, the Canvas Space is larger than
     * the space occupied by all the pages. The origin of the Canvas Space is located at the
     * upper-left corner.
     *
     * - Screen Space (or Client Space) is the space occupied by PDFView and its origin is at
     * the upper-left corner. Note that the virtual size of this space can extend beyond the
     * visible region.
     *
     * - Scrollable Space is the virtual space within which PDFView can scroll. It is determined
     * by the Canvas Space and the current zoom factor. Roughly speaking, the dimensions of the
     * Scrollable Space is the dimensions of the Canvas Space timed by the zoom. Therefore, a large
     * zoom factor will result in a larger Scrollable region given the same Canvas region. For this
     * reason, Scrollable Space might also be referred to as Zoomed Canvas Space. Note that since
     * PDFView adds gaps between pages in Canvas Space and these gaps are not scaled when rendered,
     * the scrollable range is not exactly what the zoom factor times the Canvas range. For
     * functions such as SetHScrollPos(), SetVScrollPos(), GetCanvasHeight(), and
     * GetCanvasWidth(), it is the Scrollable Space that is involved.
     */
    class PDFViewCtrl {
    }
    /**
     * Page is a high-level class representing PDF page object (see 'Page Objects' in
     * Section 3.6.2, 'Page Tree,' in PDF Reference Manual).
     *
     * Among other associated objects, a page object contains:
     *  - A series of objects representing the objects drawn on the page (See Element and
     *    ElementReader class for examples of how to extract page content).
     *  - A list of resources used in drawing the page
     *  - Annotations
     *  - Beads, private metadata, optional thumbnail image, etc.
     */
    class Page {
        /**
         * Initialize a page using an existing low-level Cos/SDF page object.
         * @param [page_dict] - a low-level (SDF/Cos) page dictionary.
         *
         * Note: This constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         *
         * Note: Because PDF::PDFDoc provides a complete high-level interface for Page creation
         * and traversal this constructor is rarely used.
         * @returns A promise that resolves to an object of type: "PDFNet.Page"
         */
        static create(page_dict?: PDFNet.Obj): Promise<PDFNet.Page>;
        /**
         * Copy Constructor
         * @returns A promise that resolves to an object of type: "PDFNet.Page"
         */
        copy(): Promise<PDFNet.Page>;
        /**
         * @returns A promise that resolves to true if this is a valid (non-null) page, false otherwise.
         * If the function returns false the underlying SDF/Cos object is null
         * or is not valid.
         */
        isValid(): Promise<boolean>;
        /**
         * @returns A promise that resolves to the Page number indication the position of this Page in document's page sequence.
         * Document's page sequence is indexed from 1. Page number 0 means that the page is not part
         * of document's page sequence or that the page is not valid.
         */
        getIndex(): Promise<number>;
        /**
         * Get the Action associated with the selected Page Trigger event.
         * @param trigger - <pre>
         * PDFNet.Page.EventType = {
         * 	e_action_trigger_page_open : 11
         * 	e_action_trigger_page_close : 12
         * }
         * </pre>
         * the type of trigger event to get
         * @returns A promise that resolves to the Action Obj if present, otherwise NULL
         */
        getTriggerAction(trigger: number): Promise<PDFNet.Obj>;
        /**
         * @param type - <pre>
         * PDFNet.Page.Box = {
         * 	e_media : 0
         * 	e_crop : 1
         * 	e_bleed : 2
         * 	e_trim : 3
         * 	e_art : 4
         * 	e_user_crop : 5
         * }
         * </pre>
         * The type of the page bounding box. Possible values are: e_media, e_crop,
         * e_bleed, e_trim, and e_art.
         *
         * If the value for 'type' is e_crop, this call is equivalent to GetCropBox().
         * If the value for 'type' is e_media, this call is equivalent to GetMediaBox().
         * @returns A promise that resolves to the box specified for the page object intersected with the media box.
         */
        getBox(type: number): Promise<PDFNet.Rect>;
        /**
         * Sets the page bounding box specified by 'page_region' for this page.
         * @param type - <pre>
         * PDFNet.Page.Box = {
         * 	e_media : 0
         * 	e_crop : 1
         * 	e_bleed : 2
         * 	e_trim : 3
         * 	e_art : 4
         * 	e_user_crop : 5
         * }
         * </pre>
         * The type of the page bounding box. Possible values are: e_media, e_crop,
         * e_bleed, e_trim, and e_art.
         * @param box - A rectangle specifying the coordinates to set for the box. The coordinates are
         * specified in user space units.
         */
        setBox(type: number, box: PDFNet.Rect): Promise<void>;
        /**
         * @returns A promise that resolves to the crop box for this page. The page dimensions are specified in user space
         * coordinates.
         *
         * The crop box is the region of the page to display and print.
         * Note: this method is equivalent to GetBox(Page::e_crop)
         */
        getCropBox(): Promise<PDFNet.Rect>;
        /**
         * Sets the crop box for this page. The crop box is the region of the page to
         * display and print.
         * @param box - the new crop box for this page. The page dimensions are specified in user space
         * coordinates.
         *
         * The crop box defines the region to which the contents of the page are to be clipped (cropped)
         * when displayed or printed.
         *
         * Note: this method is equivalent to SetBox(Page::e_crop)
         */
        setCropBox(box: PDFNet.Rect): Promise<void>;
        /**
         * @returns A promise that resolves to the media box for this page. The page dimensions are specified in user space
         * coordinates.
         *
         * The media box defines the boundaries of the physical medium on which the page is to
         * be printed. It may include any extended area surrounding the finished page for bleed,
         * printing marks, or other such purposes.
         *
         * Note: this method is equivalent to GetBox(Page::e_media)
         */
        getMediaBox(): Promise<PDFNet.Rect>;
        /**
         * Sets the media box for this page.
         * @param box - the new media box for this page. The page dimensions are specified in user space
         * coordinates.
         *
         * The media box defines the boundaries of the physical medium on which the page is to
         * be printed. It may include any extended area surrounding the finished page for bleed,
         * printing marks, or other such purposes.
         *
         * Note: this method is equivalent to SetBox(Page::e_media)
         */
        setMediaBox(box: PDFNet.Rect): Promise<void>;
        /**
         * @returns A promise that resolves to the bounding box for this page. The page dimensions are specified in user space
         * coordinates.
         *
         * The bounding box is defined as the smallest rectangle that includes all the visible content on the page.
         */
        getVisibleContentBox(): Promise<PDFNet.Rect>;
        /**
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.Page.Rotate = {
         * 	e_0 : 0
         * 	e_90 : 1
         * 	e_180 : 2
         * 	e_270 : 3
         * }
         * </pre>
         * @returns A promise that resolves to the rotation value for this page.
         */
        getRotation(): Promise<number>;
        /**
         * Sets the rotation value for this page.
         * @param angle - <pre>
         * PDFNet.Page.Rotate = {
         * 	e_0 : 0
         * 	e_90 : 1
         * 	e_180 : 2
         * 	e_270 : 3
         * }
         * </pre>
         * Rotation value to be set for a given page. Must be one
         * of the Page::Rotate values.
         */
        setRotation(angle: number): Promise<void>;
        /**
         * Rotate r0 clockwise by r1
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.Page.Rotate = {
         * 	e_0 : 0
         * 	e_90 : 1
         * 	e_180 : 2
         * 	e_270 : 3
         * }
         * </pre>
         * @param r0 - <pre>
         * PDFNet.Page.Rotate = {
         * 	e_0 : 0
         * 	e_90 : 1
         * 	e_180 : 2
         * 	e_270 : 3
         * }
         * </pre>
         * first rotation.
         * @param r1 - <pre>
         * PDFNet.Page.Rotate = {
         * 	e_0 : 0
         * 	e_90 : 1
         * 	e_180 : 2
         * 	e_270 : 3
         * }
         * </pre>
         * second rotation.
         * @returns A promise that resolves to returns r0 + r1
         */
        static addRotations(r0: number, r1: number): Promise<number>;
        /**
         * Rotate r0 counter clockwise by r1.
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.Page.Rotate = {
         * 	e_0 : 0
         * 	e_90 : 1
         * 	e_180 : 2
         * 	e_270 : 3
         * }
         * </pre>
         * @param r0 - <pre>
         * PDFNet.Page.Rotate = {
         * 	e_0 : 0
         * 	e_90 : 1
         * 	e_180 : 2
         * 	e_270 : 3
         * }
         * </pre>
         * first rotation.
         * @param r1 - <pre>
         * PDFNet.Page.Rotate = {
         * 	e_0 : 0
         * 	e_90 : 1
         * 	e_180 : 2
         * 	e_270 : 3
         * }
         * </pre>
         * second rotation.
         * @returns A promise that resolves to returns r0 r1
         */
        static subtractRotations(r0: number, r1: number): Promise<number>;
        /**
         * Convert a rotation to a number.
         * @param r - <pre>
         * PDFNet.Page.Rotate = {
         * 	e_0 : 0
         * 	e_90 : 1
         * 	e_180 : 2
         * 	e_270 : 3
         * }
         * </pre>
         * rotation to convert to number
         * @returns A promise that resolves to one of four numbers; 0, 90, 180 or 270.
         */
        static rotationToDegree(r: number): Promise<number>;
        /**
         * Convert a number that represents rotation in degrees to a rotation enum.
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.Page.Rotate = {
         * 	e_0 : 0
         * 	e_90 : 1
         * 	e_180 : 2
         * 	e_270 : 3
         * }
         * </pre>
         * @param r - degree to convert to rotation. Valid numbers are multiples of 90.
         * @returns A promise that resolves to one of four angles; e_0, e_90, e_180 or e_270. Returns e_0 if input is
         * not a multiple 90.
         */
        static degreeToRotation(r: number): Promise<number>;
        /**
         * @param [box_type] - <pre>
         * PDFNet.Page.Box = {
         * 	e_media : 0
         * 	e_crop : 1
         * 	e_bleed : 2
         * 	e_trim : 3
         * 	e_art : 4
         * 	e_user_crop : 5
         * }
         * </pre>
         * indicates the page box/region to query for width.
         * @returns A promise that resolves to the width for the given page region/box taking into account page
         * rotation attribute (i.e. /Rotate entry in page dictionary).
         */
        getPageWidth(box_type?: number): Promise<number>;
        /**
         * @param [box_type] - <pre>
         * PDFNet.Page.Box = {
         * 	e_media : 0
         * 	e_crop : 1
         * 	e_bleed : 2
         * 	e_trim : 3
         * 	e_art : 4
         * 	e_user_crop : 5
         * }
         * </pre>
         * indicates the page box/region to query for height.
         * @returns A promise that resolves to the height for the given page region/box taking into account page
         * rotation attribute (i.e. /Rotate entry in page dictionary).
         */
        getPageHeight(box_type?: number): Promise<number>;
        /**
         * @param [flip_y] - this parameter can be used to mirror the page. if 'flip_y' is true the Y
         * axis is not flipped and it is increasing, otherwise Y axis is decreasing.
         * @param [box_type] - <pre>
         * PDFNet.Page.Box = {
         * 	e_media : 0
         * 	e_crop : 1
         * 	e_bleed : 2
         * 	e_trim : 3
         * 	e_art : 4
         * 	e_user_crop : 5
         * }
         * </pre>
         * an optional parameter used to specify the page box/region that the matrix
         * should map to. By default, the function transforms user space coordinates to cropped
         * coordinates.
         * @param [angle] - <pre>
         * PDFNet.Page.Rotate = {
         * 	e_0 : 0
         * 	e_90 : 1
         * 	e_180 : 2
         * 	e_270 : 3
         * }
         * </pre>
         * an optional parameter used to specify page rotation in addition to the
         * rotation specified in the page dictionary. This parameter is usually used to rotate the
         * page without modifying the document itself.
         * @returns A promise that resolves to the matrix that transforms user space coordinates to rotated and cropped coordinates.
         * The origin of this space is the bottom-left of the rotated, cropped page.
         */
        getDefaultMatrix(flip_y?: boolean, box_type?: number, angle?: number): Promise<PDFNet.Matrix2D>;
        /**
         * Returns SDF/Cos array containing annotation dictionaries. See Section 8.4 in
         * the PDF Reference for a description of the annotation array.
         * @returns A promise that resolves to an array of annotation dictionaries representing annotations
         * associated with the page or NULL if page dictionary is not specified.
         */
        getAnnots(): Promise<PDFNet.Obj>;
        /**
         * Returns the number of annotations on a page. Widget annotations (form fields) are
         * included in the count.
         * @returns A promise that resolves to the number of annotations on a page.
         */
        getNumAnnots(): Promise<number>;
        /**
         * Returns the annotation on the page.
         * @param index - The index of the annotation to get on a page. The first annotation
         * on a page has an index of zero.
         * @returns A promise that resolves to annotation object. If the index is out of range returned Annot object
         * is not valid (i.e. annot.IsValid() returns false).
         */
        getAnnot(index: number): Promise<PDFNet.Annot>;
        /**
         * Adds an annotation at the specified location in a page's annotation array.
         * @param pos - The location in the array to insert the object. The object is inserted
         * before the specified location. The first element in an array has a pos of zero.
         * If pos >= GetNumAnnots(), the method appends the annotation to the array.
         * @param annot - The annotation to add.
         */
        annotInsert(pos: number, annot: PDFNet.Annot): Promise<void>;
        /**
         * Adds an annotation to the end of a page's annotation array.
         * @param annot - The annotation to prepend in a page's annotation array.
         */
        annotPushBack(annot: PDFNet.Annot): Promise<void>;
        /**
         * Adds an annotation to the beginning of a page's annotation array.
         * @param annot - The annotation to append in a page's annotation array.
         */
        annotPushFront(annot: PDFNet.Annot): Promise<void>;
        /**
         * Removes the given annotation from the page.
         * Note: Removing the annotation invalidates the given Annot object.
         * @param annot - The annotation to remove.
         */
        annotRemove(annot: PDFNet.Annot): Promise<void>;
        /**
         * Removes the annotation at a given location.
         * Note: Removing the annotation invalidates any associated Annot object.
         * @param index - A zero based index of the annotation to remove.
         */
        annotRemoveByIndex(index: number): Promise<void>;
        /**
         * A utility method used to scale physical dimensions of the page including
         * all page content.
         * @param scale - A number greater than 0 which is used as a scale factor.
         *  For example, calling page.Scale(0.5) will reduce physical dimensions of the
         *  page to half its original size, whereas page.Scale(2) will double the physical
         * dimensions of the page and will rescale all page content appropriately.
         *
         * Note: Unlike SetUserUnitSize(unit_size) which is only supported in PDF 1.6
         * (i.e. Acrobat 7) and above, page.Scale(sc) supports all PDF versions.
         */
        scale(scale: number): Promise<void>;
        /**
         * Flatten/Merge existing form field appearances with the page content and
         * remove widget annotation.
         *
         * Form 'flattening' refers to the operation that changes active form fields
         * into a static area that is part of the PDF document, just like the other
         * text and images in the document. A completely flattened PDF form does not
         * have any widget annotations or interactive fields.
         * @param field_to_flatten - field to flatten
         * Note: An alternative approach to set the field as read only is using
         * Field.SetFlag(Field::e_read_only, true) method. Unlike Field.SetFlag(...),
         * the result of FlattenField() operation can not be programatically reversed.
         */
        flattenField(field_to_flatten: PDFNet.Field): Promise<void>;
        /**
         * tests whether this page has a transition.
         * @returns A promise that resolves to an object of type: "boolean"
         */
        hasTransition(): Promise<boolean>;
        /**
         * Returns the UserUnit value for the page. A UserUnit is a positive number giving
         * the size of default user space units, in multiples of 1/72 inch.
         * @returns A promise that resolves to the UserUnit value for the page. If the key is not present in the
         * page dictionary the default of 1.0 is returned.
         */
        getUserUnitSize(): Promise<number>;
        /**
         * Sets the UserUnit value for a page.
         * @param unit_size - A positive number giving the size of default user space
         * units, in multiples of 1/72 inch.
         *
         * Note: This is a PDF 1.6 feature. See the implementation note 171 in
         * PDF Reference for details.
         */
        setUserUnitSize(unit_size: number): Promise<void>;
        /**
         * @returns A promise that resolves to a pointer to the page resource dictionary.
         */
        getResourceDict(): Promise<PDFNet.Obj>;
        /**
         * @returns A promise that resolves to nULL if page is empty, otherwise a single stream or an array of streams.
         */
        getContents(): Promise<PDFNet.Obj>;
        /**
         * @returns A promise that resolves to object representing the Image thumbnail.
         */
        getThumb(): Promise<PDFNet.Obj>;
        /**
         * Returns the page dictionary.
         * @returns A promise that resolves to the object to the underlying SDF/Cos object.
         */
        getSDFObj(): Promise<PDFNet.Obj>;
        /**
         * Some of the page attributes are designated as inheritable.
         * If such an attribute is omitted from a page object, its value is inherited
         * from an ancestor node in the page tree. If the attribute is a required one,
         * a value must be supplied in an ancestor node; if it is optional and no
         * inherited value is specified, the default value should be used.
         *
         * The function walks up the page inheritance tree in search for specified
         * attribute.
         * @param attrib - A string representing the attribute to search for.
         * @returns A promise that resolves to if the attribute was found return a pointer to the value. Otherwise
         * the function return NULL.
         *
         * 	Resources dictionary (Required; inheritable)
         *  MediaBox rectangle (Required; inheritable)
         *  CropBox rectangle (Optional; inheritable)
         *  Rotate integer (Optional; inheritable)
         */
        findInheritedAttribute(attrib: string): Promise<PDFNet.Obj>;
    }
    /**
     * PDF page labels can be used to describe a page. This is used to
     * allow for non-sequential page numbering or the addition of arbitrary
     * labels for a page (such as the inclusion of Roman numerals at the
     * beginning of a book). PDFNet PageLabel object can be used to specify
     * the numbering style to use (for example, upper- or lower-case Roman,
     * decimal, and so forth), the starting number for the first page,
     * and an arbitrary prefix to be pre-appended to each number (for
     * example, "A-" to generate "A-1", "A-2", "A-3", and so forth.)
     *
     * PageLabel corresponds to the PDF Page Label object (Section 8.3.1,
     * 'Page Labels' in the PDF Reference Manual.
     *
     * Each page in a PDF document is identified by an integer page index
     * that expresses the page's relative position within the document.
     * In addition, a document may optionally define page labels to identify
     * each page visually on the screen or in print. Page labels and page
     * indices need not coincide: the indices are fixed, running consecutively
     * through the document starting from 1 for the first page, but the
     * labels can be specified in any way that is appropriate for the particular
     * document. For example, if the document begins with 12 pages of front
     * matter numbered in roman numerals and the remainder of the document is
     * numbered in Arabic, the first page would have a page index of 1 and a
     * page label of i, the twelfth page would have index 12 and label xii,
     * and the thirteenth page would have index 13 and label 1.
     *
     * For purposes of page labeling, a document can be divided into labeling
     * ranges, each of which is a series of consecutive pages using the same
     * numbering system. Pages within a range are numbered sequentially in
     * ascending order. A page's label consists of a numeric portion based
     * on its position within its labeling range, optionally preceded by a
     * label prefix denoting the range itself. For example, the pages in an
     * appendix might be labeled with decimal numeric portions prefixed with
     * the string "A-" and the resulting page labels would be "A-1", "A-2",
     *
     * Note:
     * There is no default numbering style; if no 'S' (Style) entry is present,
     * page labels consist solely of a label prefix with no numeric portion.
     * For example, if the 'P' entry (Prefix) specifies the label prefix
     * "Appendix", each page is simply labeled "Appendix" with no page number.
     * If the 'P' entry is also missing or empty, the page label is an empty
     * string.
     *
     * Sample code (See PableLabelsTest sample project for examples):
     * <pre>
     * // Create a page labeling scheme that starts with the first page in
     * // the document (page 1) and is using uppercase roman numbering
     * // style.
     * doc.SetPageLabel(1, PageLabel::Create(doc, PageLabel::e_roman_uppercase, "My Prefix ", 1));
     *
     * // Create a page labeling scheme that starts with the fourth page in
     * // the document and is using decimal Arabic numbering style.
     * // Also the numeric portion of the first label should start with number
     * // 4 (otherwise the first label would be "My Prefix 1").
     * PageLabel L2 = PageLabel::Create(doc, PageLabel::e_decimal, "My Prefix ", 4);
     * doc.SetPageLabel(4, L2);
     *
     * // Create a page labeling scheme that starts with the seventh page in
     * // the document and is using alphabetic numbering style. The numeric
     * // portion of the first label should start with number 1.
     * PageLabel L3 = PageLabel::Create(doc, PageLabel::e_alphabetic_uppercase, "My Prefix ", 1);
     * doc.SetPageLabel(7, L3);
     *
     * // Read page labels from an existing PDF document.
     * PageLabel label;
     * for (int i=1; i<=doc.GetPageCount(); ++i) {
     * label = doc.GetPageLabel(i);
     * if (label.IsValid()) {
     *   UString title = label.GetLabelTitle(i);
     * }
     *
     * </pre>
     */
    class PageLabel {
        constructor(mp_obj?: PDFNet.Obj, m_first_page?: number, m_last_page?: number);
        /**
         * Creates a new PageLabel.
         * @param doc - A document to which the page label is added.
         * @param style - <pre>
         * PDFNet.PageLabel.Style = {
         * 	e_decimal : 0
         * 	e_roman_uppercase : 1
         * 	e_roman_lowercase : 2
         * 	e_alphabetic_uppercase : 3
         * 	e_alphabetic_lowercase : 4
         * 	e_none : 5
         * }
         * </pre>
         * The numbering style for the label.
         * @param [prefix] - The string used to prefix the numeric portion of the
         * page label.
         * @param [start_at] - the value to use when generating the numeric portion of the first
         * label in this range; must be greater than or equal to 1.
         * @returns A promise that resolves to newly created PageLabel object.
         */
        static create(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, style: number, prefix?: string, start_at?: number): Promise<PDFNet.PageLabel>;
        /**
         * Create a PageLabel and initialize it using given Cos/SDF object.
         * Note: The constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @returns A promise that resolves to an object of type: "PDFNet.PageLabel"
         */
        static createFromObj(l?: PDFNet.Obj, first_page?: number, last_page?: number): Promise<PDFNet.PageLabel>;
        /**
         * Compares two PageLabel-s for equality. The comparison will return true
         * only if both labels share the same underlying SDF/Cos object.
         * Two labels are also equivalent if they have the same style, starting
         * number (numeric value of the first page associated with the label),
         * and prefix strings which are the same byte-for-byte.
         * @returns A promise that resolves to an object of type: "boolean"
         */
        compare(d: PDFNet.PageLabel): Promise<boolean>;
        /**
         * @returns A promise that resolves to whether this is a valid (non-null) PageLabel. If the
         * function returns false the underlying SDF/Cos object is null or is
         * not valid and the PageLabel object should be treated as null as well.
         */
        isValid(): Promise<boolean>;
        /**
         * @returns A promise that resolves to the full label title that is in effect for the given page.
         * If there is no label object in effect, this method returns an
         * empty string.
         */
        getLabelTitle(page_num: number): Promise<string>;
        /**
         * Sets the numbering style for the label.
         * @param style - <pre>
         * PDFNet.PageLabel.Style = {
         * 	e_decimal : 0
         * 	e_roman_uppercase : 1
         * 	e_roman_lowercase : 2
         * 	e_alphabetic_uppercase : 3
         * 	e_alphabetic_lowercase : 4
         * 	e_none : 5
         * }
         * </pre>
         * the numbering style for the label.
         *
         * You may use label style to customize the page numbering schemes
         * used throughout a document. There are three numbering formats:
         *  decimal (often used for normal page ranges)
         *  roman (often used for front matter such as a preface)
         *  alphabetic (often used for back matter such as appendices)
         *
         * Note:
         * There is no default numbering style; if no 'S' (Style) entry is present,
         * page labels consist solely of a label prefix with no numeric portion.
         */
        setStyle(style: number): Promise<void>;
        /**
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.PageLabel.Style = {
         * 	e_decimal : 0
         * 	e_roman_uppercase : 1
         * 	e_roman_lowercase : 2
         * 	e_alphabetic_uppercase : 3
         * 	e_alphabetic_lowercase : 4
         * 	e_none : 5
         * }
         * </pre>
         * @returns A promise that resolves to page numbering style.
         */
        getStyle(): Promise<number>;
        /**
         * @returns A promise that resolves to the string used to prefix the numeric portion of
         * the page label
         */
        getPrefix(): Promise<string>;
        /**
         * @param prefix - the string used to prefix the numeric portion of
         * the page label.
         */
        setPrefix(prefix: string): Promise<void>;
        /**
         * @returns A promise that resolves to the value to use when generating the numeric portion of
         * the first label in this range; must be greater than or equal to 1.
         */
        getStart(): Promise<number>;
        /**
         * @param start_at - the value to use when generating the numeric
         * portion of the first label in this range; must be greater than
         * or equal to 1.
         */
        setStart(start_at: number): Promise<void>;
        /**
         * @returns A promise that resolves to the first page in the range associated with this label
         * or -1 if the label is not associated with any page.
         */
        getFirstPageNum(): Promise<number>;
        /**
         * @returns A promise that resolves to the last page in the range associated with this label
         * or -1 if the label is not associated with any page.
         */
        getLastPageNum(): Promise<number>;
        /**
         * @returns A promise that resolves to the pointer to the underlying SDF/Cos object.
         */
        getSDFObj(): Promise<PDFNet.Obj>;
        mp_obj: PDFNet.Obj;
        m_first_page: number;
        m_last_page: number;
    }
    /**
     * PageSet is a container of page numbers ordered following a linear sequence.
     * The page numbers are integers and must be greater than zero. Duplicates are allowed.
     *
     * (NOTE: This is not a mathematical set)
     */
    class PageSet extends PDFNet.Destroyable {
        /**
         * Default constructor. Constructs 'PageSet' with no pages
         * @returns A promise that resolves to an object of type: "PDFNet.PageSet"
         */
        static create(): Promise<PDFNet.PageSet>;
        /**
         * Construct a set of pages with just one number
         * @returns A promise that resolves to an object of type: "PDFNet.PageSet"
         */
        static createSinglePage(one_page: number): Promise<PDFNet.PageSet>;
        /**
         * @returns A promise that resolves to an object of type: "PDFNet.PageSet"
         */
        static createRange(range_start: number, range_end: number): Promise<PDFNet.PageSet>;
        /**
         * Construct a range of pages
         * @param [filter] - <pre>
         * PDFNet.PageSet.Filter = {
         * 	e_all : 0
         * 	e_even : 1
         * 	e_odd : 2
         * }
         * </pre>
         * @returns A promise that resolves to an object of type: "PDFNet.PageSet"
         */
        static createFilteredRange(range_start: number, range_end: number, filter?: number): Promise<PDFNet.PageSet>;
        /**
         * Add a value to the sequence.
         * @param one_page - The page number being added
         */
        addPage(one_page: number): Promise<void>;
        /**
         * Add a range of values to the sequence. Reverse ordering is legal.
         * @param range_start - The starting value in the range
         * @param range_end - The ending value in the range
         * @param [filter] - <pre>
         * PDFNet.PageSet.Filter = {
         * 	e_all : 0
         * 	e_even : 1
         * 	e_odd : 2
         * }
         * </pre>
         *
         * 		-e_all: Default, includes all pages in the range
         * 		-e_odd: Includes odd numbers in the range (discards even numbers)
         * 		-e_even: Includes even numbers in the range (discards odd numbers)
         */
        addRange(range_start: number, range_end: number, filter?: number): Promise<void>;
    }
    /**
     * Patterns are quite general, and have many uses; for example, they can be used
     * to create various graphical textures, such as weaves, brick walls, sunbursts,
     * and similar geometrical and chromatic effects.
     * Patterns are specified in a special family of color spaces named Pattern, whose
     * 'color values' are PatternColor objects instead of the numeric component values
     * used with other spaces. Therefore PatternColor is to pattern color space what is
     * ColorPt to all other color spaces.
     *
     * A tiling pattern consists of a small graphical figure called a pattern cell.
     * Painting with the pattern replicates the cell at fixed horizontal and vertical
     * intervals to fill an area. The effect is as if the figure were painted on the
     * surface of a clear glass tile, identical copies of which were then laid down
     * in an array covering the area and trimmed to its boundaries. This is called
     * tiling the area.
     *
     * The pattern cell can include graphical elements such as filled areas, text,
     * and sampled images. Its shape need not be rectangular, and the spacing of
     * tiles can differ from the dimensions of the cell itself.
     *
     * The order in which individual tiles (instances of the cell) are painted is
     * unspecified and unpredictable; it is inadvisable for the figures on adjacent
     * tiles to overlap.
     */
    class PatternColor extends PDFNet.Destroyable {
        /**
         * Create a PatternColor from the given SDF/Cos object listed under Pattern entry
         * in page Resource dictionary
         * @returns A promise that resolves to an object of type: "PDFNet.PatternColor"
         */
        static create(pattern: PDFNet.Obj): Promise<PDFNet.PatternColor>;
        /**
         * @returns A promise that resolves to an object of type: "number"
         * <pre>
         * PDFNet.PatternColor.Type = {
         * 	e_uncolored_tiling_pattern : 0
         * 	e_colored_tiling_pattern : 1
         * 	e_shading : 2
         * 	e_null : 3
         * }
         * </pre>
         */
        static getTypeFromObj(pattern: PDFNet.Obj): Promise<number>;
        /**
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.PatternColor.Type = {
         * 	e_uncolored_tiling_pattern : 0
         * 	e_colored_tiling_pattern : 1
         * 	e_shading : 2
         * 	e_null : 3
         * }
         * </pre>
         * @returns A promise that resolves to the pattern type
         */
        getType(): Promise<number>;
        /**
         * @returns A promise that resolves to the underlying SDF/Cos object
         */
        getSDFObj(): Promise<PDFNet.Obj>;
        /**
         * @returns A promise that resolves to pattern matrix, a transformation matrix that maps the pattern's
         * internal coordinate system to the default coordinate system of the pattern's
         * parent content stream (the content stream in which the pattern is defined as
         * a resource). The concatenation of the pattern matrix with that of the parent content
         * stream establishes the pattern coordinate space, within which all graphics objects
         * in the pattern are interpreted.
         */
        getMatrix(): Promise<PDFNet.Matrix2D>;
        /**
         * @returns A promise that resolves to the shading object defining the shading pattern's gradient fill.
         *
         * Note: for patterns other than Shading this method throws an exception.
         */
        getShading(): Promise<PDFNet.Shading>;
        /**
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.PatternColor.TilingType = {
         * 	e_constant_spacing : 0
         * 	e_no_distortion : 1
         * 	e_constant_spacing_fast_fill : 2
         * }
         * </pre>
         * @returns A promise that resolves to the tiling type identifier that controls adjustments to the spacing
         * of tiles relative to the device pixel grid:
         *
         * Note: for patterns other than Tiling this method throws an exception.
         */
        getTilingType(): Promise<number>;
        /**
         * @returns A promise that resolves to a rectangle in the pattern coordinate system giving the
         * coordinates of the left, bottom, right, and top edges, respectively,
         * of the pattern cell's bounding box. These boundaries are used to clip
         * the pattern cell.
         *
         * Note: for patterns other than Tiling this method throws an exception.
         */
        getBBox(): Promise<PDFNet.Rect>;
        /**
         * @returns A promise that resolves to the desired horizontal spacing between pattern cells, measured
         * in the pattern coordinate system.
         *
         * Note: that XStep and YStep may differ from the dimensions of the pattern
         * cell implied by the BBox entry. This allows tiling with irregularly shaped
         * figures. XStep and YStep may be either positive or negative, but not zero.
         *
         * Note: for patterns other than Tiling this method throws an exception.
         */
        getXStep(): Promise<number>;
        /**
         * @returns A promise that resolves to the desired vertical spacing between pattern cells, measured in
         * the pattern coordinate system.
         *
         * Note: for patterns other than Tiling this method throws an exception.
         */
        getYStep(): Promise<number>;
    }
    /**
     * This header defines classes for the Polygon and PolyLine annotations.
     * Polygon annotations (PDF 1.5) display closed polygons on the page.
     * Such polygons may have any number of vertices connected by straight lines.
     * Polyline annotations (PDF 1.5) are similar to polygons, except that the
     * first and last vertex are not implicitly connected.
     */
    class PolyLineAnnot extends PDFNet.LineAnnot {
        /**
         * creates a PolyLine annotation and initializes it using given Cos/SDF object.
         * @param [d] - The Cos/SDF object to initialze the annotation with.
         * Note: The constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @returns A promise that resolves to an object of type: "PDFNet.PolyLineAnnot"
         */
        static createFromObj(d?: PDFNet.Obj): Promise<PDFNet.PolyLineAnnot>;
        /**
         * creates a PolyLine annotation and initializes it using given annotation object.
         * @param ann - Annot object used to initialize the PolyLine annotation.
         * Note: The constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @returns A promise that resolves to an object of type: "PDFNet.PolyLineAnnot"
         */
        static createFromAnnot(ann: PDFNet.Annot): Promise<PDFNet.PolyLineAnnot>;
        /**
         * Creates a new PolyLine annotation in the specified document.
         * @param doc - A document to which the PolyLine annotation is added.
         * @param pos - A rectangle specifying the PolyLine annotation's bounds in default user space units.
         * @returns A promise that resolves to a newly created blank PolyLine annotation.
         */
        static create(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, pos: PDFNet.Rect): Promise<PDFNet.PolyLineAnnot>;
        static create(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, type: number, pos: PDFNet.Rect): Promise<PDFNet.Annot>;
        /**
         * Returns the number of vertices in the Vertices array.
         * @returns A promise that resolves to the number of vertices.
         * Note: The Vertices are the points between which the lines are drawn.
         * The viewer can draw either the straight lines or the smoothly connecting ones.
         */
        getVertexCount(): Promise<number>;
        /**
         * Returns the vertex(as a Point object) corresponding to the index
         * within the Vertices array.
         * @param idx - The index of the vertex, should be less than the value returned by GetVertexCount().
         * @returns A promise that resolves to a Point object corresponding to the vertex in the specified index position.
         * Note: The Vertices are the points between which the lines are drawn.
         * The viewer can draw either the straight lines or the smoothly connecting ones.
         */
        getVertex(idx: number): Promise<PDFNet.Point>;
        /**
         * sets the vertex(in Point object form) corresponding to the index
         * within the Vertices array.
         * @param idx - The index of the vertex.
         * @param pt - A Point object corresponding to the vertex to be added to the array.
         * Note: The Vertices are the points between which the lines are drawn.
         * The viewer can draw either the straight lines or the smoothly connecting ones.
         */
        setVertex(idx: number, pt: PDFNet.Point): Promise<void>;
        /**
         * @returns A promise that resolves to an object of type: "number"
         * <pre>
         * PDFNet.LineAnnot.EndingStyle = {
         * 	e_Square : 0
         * 	e_Circle : 1
         * 	e_Diamond : 2
         * 	e_OpenArrow : 3
         * 	e_ClosedArrow : 4
         * 	e_Butt : 5
         * 	e_ROpenArrow : 6
         * 	e_RClosedArrow : 7
         * 	e_Slash : 8
         * 	e_None : 9
         * 	e_Unknown : 10
         * }
         * </pre>
         */
        getStartStyle(): Promise<number>;
        /**
         * @param style - <pre>
         * PDFNet.LineAnnot.EndingStyle = {
         * 	e_Square : 0
         * 	e_Circle : 1
         * 	e_Diamond : 2
         * 	e_OpenArrow : 3
         * 	e_ClosedArrow : 4
         * 	e_Butt : 5
         * 	e_ROpenArrow : 6
         * 	e_RClosedArrow : 7
         * 	e_Slash : 8
         * 	e_None : 9
         * 	e_Unknown : 10
         * }
         * </pre>
         */
        setStartStyle(style: number): Promise<void>;
        /**
         * @returns A promise that resolves to an object of type: "number"
         * <pre>
         * PDFNet.LineAnnot.EndingStyle = {
         * 	e_Square : 0
         * 	e_Circle : 1
         * 	e_Diamond : 2
         * 	e_OpenArrow : 3
         * 	e_ClosedArrow : 4
         * 	e_Butt : 5
         * 	e_ROpenArrow : 6
         * 	e_RClosedArrow : 7
         * 	e_Slash : 8
         * 	e_None : 9
         * 	e_Unknown : 10
         * }
         * </pre>
         */
        getEndStyle(): Promise<number>;
        /**
         * @param style - <pre>
         * PDFNet.LineAnnot.EndingStyle = {
         * 	e_Square : 0
         * 	e_Circle : 1
         * 	e_Diamond : 2
         * 	e_OpenArrow : 3
         * 	e_ClosedArrow : 4
         * 	e_Butt : 5
         * 	e_ROpenArrow : 6
         * 	e_RClosedArrow : 7
         * 	e_Slash : 8
         * 	e_None : 9
         * 	e_Unknown : 10
         * }
         * </pre>
         */
        setEndStyle(style: number): Promise<void>;
        /**
         * Returns the intent name as a value of the "IntentName" enumeration type.
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.PolyLineAnnot.IntentType = {
         * 	e_PolygonCloud : 0
         * 	e_PolyLineDimension : 1
         * 	e_PolygonDimension : 2
         * 	e_Unknown : 3
         * }
         * </pre>
         * @returns A promise that resolves to the intent type of the annotation.
         */
        getIntentName(): Promise<number>;
        /**
         * Sets the Intent name as a value of the "IntentName" enumeration type.
         * (Optional; PDF 1.6 )
         * @param mode - <pre>
         * PDFNet.PolyLineAnnot.IntentType = {
         * 	e_PolygonCloud : 0
         * 	e_PolyLineDimension : 1
         * 	e_PolygonDimension : 2
         * 	e_Unknown : 3
         * }
         * </pre>
         * The intent name of the annotation.
         */
        setIntentName(mode: number): Promise<void>;
    }
    /**
     * A polygon annotation
     */
    class PolygonAnnot extends PDFNet.PolyLineAnnot {
        /**
         * creates a Polygon annotation and initializes it using given Cos/SDF object.
         * @param [d] - The Cos/SDF object to initialze the annotation with.
         * Note: The constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @returns A promise that resolves to an object of type: "PDFNet.PolygonAnnot"
         */
        static createFromObj(d?: PDFNet.Obj): Promise<PDFNet.PolygonAnnot>;
        /**
         * creates a Polygon annotation and initializes it using given annotation object.
         * @param ann - Annot object used to initialize the Polygon annotation.
         * Note: The constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @returns A promise that resolves to an object of type: "PDFNet.PolygonAnnot"
         */
        static createFromAnnot(ann: PDFNet.Annot): Promise<PDFNet.PolygonAnnot>;
        /**
         * Creates a new Polygon annotation in the specified document.
         * @param doc - A document to which the Polygon annotation is added.
         * @param pos - A rectangle specifying the Polygon annotation's bounds in default user space units.
         * @returns A promise that resolves to a newly created blank Polygon annotation.
         */
        static create(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, pos: PDFNet.Rect): Promise<PDFNet.PolygonAnnot>;
        static create(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, type: number, pos: PDFNet.Rect): Promise<PDFNet.Annot>;
    }
    /**
     * A pop-up annotation (PDF 1.3) displays text in a pop-up window for entry and
     * editing. It shall not appear alone but is associated with a markup annotation,
     * its parent annotation, and shall be used for editing the parent's text.
     * It shall have no appearance stream or associated actions of its own and
     * shall be identified by the Popup entry in the parent's annotation dictionary.
     */
    class PopupAnnot extends PDFNet.Annot {
        /**
         * creates a Popup annotation and initializes it using given Cos/SDF object.
         * @param [d] - The Cos/SDF object to initialze the annotation with.
         * Note: The constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @returns A promise that resolves to an object of type: "PDFNet.PopupAnnot"
         */
        static createFromObj(d?: PDFNet.Obj): Promise<PDFNet.PopupAnnot>;
        /**
         * creates a Popup annotation and initializes it using given annotation object.
         * @param ann - Annot object used to initialize the Popup annotation.
         * Note: The constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @returns A promise that resolves to an object of type: "PDFNet.PopupAnnot"
         */
        static createFromAnnot(ann: PDFNet.Annot): Promise<PDFNet.PopupAnnot>;
        /**
         * Creates a new Popup annotation in the specified document.
         * @param doc - A document to which the Popup annotation is added.
         * @param pos - A rectangle specifying the Popup annotation's bounds in default user space units.
         * @returns A promise that resolves to a newly created blank Popup annotation.
         */
        static create(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, pos: PDFNet.Rect): Promise<PDFNet.PopupAnnot>;
        static create(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, type: number, pos: PDFNet.Rect): Promise<PDFNet.Annot>;
        /**
         * Returns the parent annotation of the Popup annotation.
         * @returns A promise that resolves to an annot object which is the parent annotation of the Popup annotation.
         * Note: This annotation object represents the parent annotation with which this
         * pop-up annotation shall be associated.
         * Note: If this entry is present, the parent annotation's Contents, M, C, and T entries
         * shall override those of the pop-up annotation itself.
         */
        getParent(): Promise<PDFNet.Annot>;
        /**
         * sets the Parent annotation of the Popup annotation.
         * (Optional)
         * @param parent - An annot object which is the parent annotation of the Popup annotation.
         * Note: This annotation object represents the parent annotation with which this
         * pop-up annotation shall be associated.
         * Note: If this entry is present, the parent annotation's Contents, M, C, and T entries
         * shall override those of the pop-up annotation itself.
         */
        setParent(parent: PDFNet.Annot): Promise<void>;
        /**
         * Returns the initial opening condition of Popup.
         * @returns A promise that resolves to a bool indicating whether the Popup is initially open.
         * Note: This is a flag specifying whether the pop-up
         * annotation's window shall initially be displayed.
         * Default value: false (closed).
         */
        isOpen(): Promise<boolean>;
        /**
         * sets the initial opening condition of Popup.
         * (Optional)
         * @param isopen - A bool indicating whether the Popup is initially open.
         * Note: This is a flag specifying whether the pop-up
         * annotation's window shall initially be displayed.
         * Default value: false (closed).
         */
        setOpen(isopen: boolean): Promise<void>;
    }
    /**
     * [Missing documentation]
     */
    class PrinterMode {
    }
    /**
     * [Missing documentation]
     */
    class PushButtonWidget extends PDFNet.WidgetAnnot {
        /**
         * Constructor
         * @returns A promise that resolves to an object of type: "PDFNet.PushButtonWidget"
         */
        static create(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, pos: PDFNet.Rect, field_name?: string): Promise<PDFNet.PushButtonWidget>;
        static create(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, pos: PDFNet.Rect, field: PDFNet.Field): Promise<PDFNet.WidgetAnnot>;
        static create(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, type: number, pos: PDFNet.Rect): Promise<PDFNet.Annot>;
        /**
         * @returns A promise that resolves to an object of type: "PDFNet.PushButtonWidget"
         */
        static createWithField(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, pos: PDFNet.Rect, field: PDFNet.Field): Promise<PDFNet.PushButtonWidget>;
        /**
         * @returns A promise that resolves to an object of type: "PDFNet.PushButtonWidget"
         */
        static createFromObj(obj?: PDFNet.Obj): Promise<PDFNet.PushButtonWidget>;
        /**
         * @returns A promise that resolves to an object of type: "PDFNet.PushButtonWidget"
         */
        static createFromAnnot(annot: PDFNet.Annot): Promise<PDFNet.PushButtonWidget>;
    }
    /**
     * An object representing a Group of Radio Buttons that can be used to create new Radio Buttons.
     * If a group contains multiple buttons they will be connected.
     */
    class RadioButtonGroup extends PDFNet.Destroyable {
        /**
         * Creates a RadioButtonGroup and initialize it using given Field object.
         *
         * <p>
         * <b> Note: </b> The constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @param field - The field with which to initialize the RadioButtonGroup
         * @returns A promise that resolves to an object of type: "PDFNet.RadioButtonGroup"
         */
        static createFromField(field: PDFNet.Field): Promise<PDFNet.RadioButtonGroup>;
        /**
         * Creates a new RadioButtonGroup in the specified document.
         * @param doc - The document in which the RadioButtonGroup is created.
         * @param [field_name] - The name of the field to create and use in this RadioButtonGroup.
         * @returns A promise that resolves to a newly created RadioButtonGroup.
         */
        static create(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, field_name?: string): Promise<PDFNet.RadioButtonGroup>;
        /**
         * Copy Constructor
         * @returns A promise that resolves to an object of type: "PDFNet.RadioButtonGroup"
         */
        copy(): Promise<PDFNet.RadioButtonGroup>;
        /**
         * Adds a new RadioButtonWidget to the RadioButtonGroup
         * @param pos - A rectangle specifying the annotation's bounds, specified in
         * user space coordinates.
         * @param [onstate] - The onstate for this button. This will rarely need to be explicitly set. However, it can be used to allow
         * multiple radiobuttons in a group to be on at once if they have the same onstate.
         * @returns A promise that resolves to a newly created default RadioButtonWidget.
         */
        add(pos: PDFNet.Rect, onstate?: string): Promise<PDFNet.RadioButtonWidget>;
        /**
         * Gets the number of buttons in this RadioButtonGroup
         * @returns A promise that resolves to the number of buttons in this RadioButtonGroup
         */
        getNumButtons(): Promise<number>;
        /**
         * Retrieves the button at a given index.
         * @param index - The index to use.
         * @returns A promise that resolves to the RadioButtonWidget at the given index
         */
        getButton(index: number): Promise<PDFNet.RadioButtonWidget>;
        /**
         * Gets the field associated with this RadioButtonGroup
         * @returns A promise that resolves to the Field associated with this RadioButtonGroup
         */
        getField(): Promise<PDFNet.Field>;
        /**
         * Add all group buttons to the page
         * @param page - The page in which to add the buttons.
         */
        addGroupButtonsToPage(page: PDFNet.Page): Promise<void>;
    }
    /**
     * An object representing a Radio Button used in a PDF Form.
     */
    class RadioButtonWidget extends PDFNet.WidgetAnnot {
        /**
         * Creates a Radio Button Widget annotation and initialize it using given Cos/SDF object.
         *
         * <p>
         * <b> Note: </b> The constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @param [d] - the object to use to initialize the Radio Button Widget
         * @returns A promise that resolves to an object of type: "PDFNet.RadioButtonWidget"
         */
        static createFromObj(d?: PDFNet.Obj): Promise<PDFNet.RadioButtonWidget>;
        /**
         * Creates a Radio Button Widget annotation and initialize it using given annotation object.
         *
         * <p>
         * <b> Note: </b>  The constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @param annot - The annotation to use.
         * @returns A promise that resolves to an object of type: "PDFNet.RadioButtonWidget"
         */
        static createFromAnnot(annot: PDFNet.Annot): Promise<PDFNet.RadioButtonWidget>;
        /**
         * Determines whether this button is enabled.
         * @returns A promise that resolves to a boolean value indicating whether the Radio Button is enabled.
         */
        isEnabled(): Promise<boolean>;
        /**
         * Enable the current radio button. Note that this may disable other Radio Buttons in the same group.
         */
        enableButton(): Promise<void>;
        /**
         * Gets the group to which the current button is connected.
         * @returns A promise that resolves to the group containing this Radio Button.
         */
        getGroup(): Promise<PDFNet.RadioButtonGroup>;
    }
    /**
     * Rect is a struct used to manipulate PDF rectangle objects
     *
     * Note: - Rectangles are conventionally specified by their lower-left and
     * upper-right corners respectively.
     *
     * --------------------
     * Since Rect is a struct, it can be created by calling "new PDFNet.Rect(x1,y1,x2,y2)"
     * eg. var myfoo = new PDFNet.Rect(1,2,3,4);
     *
     * Default values for a rect are:
     * x1 = 0
     * y1 = 0
     * x2 = 0
     * y2 = 0
     * mp_rect = "0"
     */
    class Rect {
        constructor(x1?: number, y1?: number, x2?: number, y2?: number, mp_rect?: PDFNet.Obj);
        /**
         * Create a Rect and initialize it using specified parameters.
         * @param x1 - The left-most position of the rect.
         * @param y1 - The bottom-most position of the rect.
         * @param x2 - The right-most position of the rect.
         * @param y2 - The top-most position of the rect.
         * @returns A promise that resolves to a Rect (rectangle) object
         * The rect is not attached to any Cos/SDF object.
         */
        static init(x1: number, y1: number, x2: number, y2: number): Promise<PDFNet.Rect>;
        /**
         * attach the Cos/SDF object to the Rect.
         * @param obj - underlying Cos/SDF object. Must be an SDF::Array with four
         *  SDF::Number elements.
         */
        attach(obj: PDFNet.Obj): Promise<void>;
        /**
         * Saves changes made to the Rect object in the attached (or specified) SDF/Cos rectangle.
         * @param [obj] - an optional parameter indicating a SDF array that should be
         *  updated and attached to this Rect. If parameter rect is NULL or is omitted, update
         *  is performed on previously attached Cos/SDF rectangle.
         * @returns A promise that resolves to true if the attached Cos/SDF rectangle array was successfully updated,
         * false otherwise.
         */
        update(obj?: PDFNet.Obj): Promise<boolean>;
        /**
         * Get the coordinates of the rectangle
         * @returns A promise that resolves to an object of type: "Object"
         */
        get(): Promise<object>;
        /**
         * Set the coordinates of the rectangle
         * @param x1 - The left-most position of the rect.
         * @param y1 - The bottom-most position of the rect.
         * @param x2 - The right-most position of the rect.
         * @param y2 - The top-most position of the rect.
         * The rect is not attached to any Cos/SDF object.
         */
        set(x1: number, y1: number, x2: number, y2: number): Promise<void>;
        /**
         * @returns A promise that resolves to rectangle's width
         */
        width(): Promise<number>;
        /**
         * @returns A promise that resolves to rectangle's height
         */
        height(): Promise<number>;
        /**
         * Determines if the specified point is contained within the rectangular region
         * defined by this Rectangle
         * @param x - horizontal x value of the point to check
         * @param y - vertical y value of the point to check
         * @returns A promise that resolves to true is the point is in the rectangle, false otherwise.
         */
        contains(x: number, y: number): Promise<boolean>;
        /**
         * Makes a Rect equal to the intersection of two existing rectangles.
         * @param rect1 - A Rect object that contains a source rectangle.
         * @param rect2 - A Rect object that contains a source rectangle.
         * @returns A promise that resolves to true if the intersection is not empty; 0 if the intersection is empty.
         *
         * Note: The intersection is the largest rectangle contained in both existing rectangles.
         */
        intersectRect(rect1: PDFNet.Rect, rect2: PDFNet.Rect): Promise<boolean>;
        /**
         * Arrange the points in the rectangle so that the first point is the lower-left
         * corner and the second point is the upper-right corner of the rectangle.
         *
         * Note: Although rectangles are conventionally specified by their lower-left
         * and upper-right corners, it is acceptable to specify any two diagonally
         * opposite corners.
         */
        normalize(): Promise<void>;
        /**
         * Expands the rectangle by the specified size, in all directions.
         * @param amount - Specifies the amount to increase the rectangle in all directions.
         */
        inflate1(amount: number): Promise<void>;
        /**
         * Expands the rectangle by the specified size, in all directions.
         * @param x - Specifies the amount to increase the rectangle's Left (x1) and Right (x2) properties.
         * @param y - Specifies the amount to increase the rectangle's Top (y1) and Bottom (y2) properties.
         */
        inflate2(x: number, y: number): Promise<void>;
        x1: number;
        y1: number;
        x2: number;
        y2: number;
        mp_rect: PDFNet.Obj;
    }
    /**
     * A redaction annotation (PDF 1.7) identifies content that is intended to
     * be removed from the document. The intent of redaction annotations is to
     * enable the following:
     * a)Content identification. A user applies redact annotations that specify
     * the pieces or regions of content that should be removed. Up until the
     * next step is performed, the user can see, move and redefine these
     * annotations.
     * b)Content removal. The user instructs the viewer application to apply
     * the redact annotations, after which the content in the area specified
     * by the redact annotations is removed. In the removed content's place,
     * some marking appears to indicate the area has been redacted. Also, the
     * redact annotations are removed from the PDF document.
     * Redaction annotations provide a mechanism for the first step in the
     * redaction process (content identification). This allows content to be
     * marked for redaction in a non-destructive way, thus enabling a review
     * process for evaluating potential redactions prior to removing the
     * specified content.
     * Redaction annotations shall provide enough information to be used
     * in the second phase of the redaction process (content removal).
     * This phase is application-specific and requires the conforming reader
     * to remove all content identified by the redaction annotation, as well
     * as the annotation itself.
     * Conforming readers that support redaction annotations shall provide
     * a mechanism for applying content removal, and they shall remove all
     * traces of the specified content. If a portion of an image is contained
     * in a redaction region, that portion of the image data shall be destroyed;
     * clipping or image masks shall not be used to hide that data.
     * Such conforming readers shall also be diligent in their consideration
     * of all content that can exist in a PDF document, including XML Forms
     * Architecture (XFA) content and Extensible Metadata Platform (XMP)
     * content.
     */
    class Redaction {
    }
    /**
     * A redaction annotation (PDF 1.7) identifies content that is intended to
     * be removed from the document. The intent of redaction annotations is to
     * enable the following:
     * a)Content identification. A user applies redact annotations that specify
     * the pieces or regions of content that should be removed. Up until the
     * next step is performed, the user can see, move and redefine these
     * annotations.
     * b)Content removal. The user instructs the viewer application to apply
     * the redact annotations, after which the content in the area specified
     * by the redact annotations is removed. In the removed content's place,
     * some marking appears to indicate the area has been redacted. Also, the
     * redact annotations are removed from the PDF document.
     * Redaction annotations provide a mechanism for the first step in the
     * redaction process (content identification). This allows content to be
     * marked for redaction in a non-destructive way, thus enabling a review
     * process for evaluating potential redactions prior to removing the
     * specified content.
     * Redaction annotations shall provide enough information to be used
     * in the second phase of the redaction process (content removal).
     * This phase is application-specific and requires the conforming reader
     * to remove all content identified by the redaction annotation, as well
     * as the annotation itself.
     * Conforming readers that support redaction annotations shall provide
     * a mechanism for applying content removal, and they shall remove all
     * traces of the specified content. If a portion of an image is contained
     * in a redaction region, that portion of the image data shall be destroyed;
     * clipping or image masks shall not be used to hide that data.
     * Such conforming readers shall also be diligent in their consideration
     * of all content that can exist in a PDF document, including XML Forms
     * Architecture (XFA) content and Extensible Metadata Platform (XMP)
     * content.
     */
    class RedactionAnnot extends PDFNet.MarkupAnnot {
        /**
         * creates a Redaction annotation and initializes it using given Cos/SDF object.
         * @param [d] - The Cos/SDF object to initialze the annotation with.
         * Note: The constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @returns A promise that resolves to an object of type: "PDFNet.RedactionAnnot"
         */
        static createFromObj(d?: PDFNet.Obj): Promise<PDFNet.RedactionAnnot>;
        /**
         * creates an Redaction annotation and initializes it using given annotation object.
         * @param ann - Annot object used to initialize the Redaction annotation.
         * Note: The constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @returns A promise that resolves to an object of type: "PDFNet.RedactionAnnot"
         */
        static createFromAnnot(ann: PDFNet.Annot): Promise<PDFNet.RedactionAnnot>;
        /**
         * Creates a new Redaction annotation in the specified document.
         * @param doc - A document to which the annotation is added.
         * @param pos - A rectangle specifying the annotation's bounds, in user space coordinates.
         * @returns A promise that resolves to a newly created blank Circle annotation.
         */
        static create(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, pos: PDFNet.Rect): Promise<PDFNet.RedactionAnnot>;
        static create(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, type: number, pos: PDFNet.Rect): Promise<PDFNet.Annot>;
        /**
         * Returns the number of QuadPoints in the QuadPoints array of the Redaction annotation.
         * @returns A promise that resolves to the number of QuadPoints.
         * Note: An array of n QuadPoints that denote
         * the content region that is intended to be removed. If quad points are not present,
         * the Rect entry denotes the content region that is intended to be removed.
         */
        getQuadPointCount(): Promise<number>;
        /**
         * Returns the QuadPoint located at a certain index of the QuadPoint array of the Redaction
         * annotation.
         * @param idx - The index of the QuadPoint, starts at zero and must be less than return value of GetQuadPointCount().
         * @returns A promise that resolves to the QuadPoint located at a certain index of the QuadPoint array of the Redaction annotation.
         * Note: An array of n QuadPoints that denote
         * the content region that is intended to be removed. If quad points are not present,
         * the Rect entry denotes the content region that is intended to be removed.
         */
        getQuadPoint(idx: number): Promise<PDFNet.QuadPoint>;
        /**
         * Set the QuadPoint to be located at a certain index of the QuadPoint array of the Redaction
         * annotation.
         * (Optional; PDF 1.6 )
         * @param idx - The index position where the QuadPoint of interest is to be inserted, starting at 0.
         * @param qp - The QuadPoint to be inserted at that position.
         * Note:  For orientation purposes, the bottom of a quadrilateral is the line formed by p1 and p2 of the QuadPoint.
         * QuadPoints shall be ignored if any coordinate in the array lies outside the region specified by Rect.
         */
        setQuadPoint(idx: number, qp: PDFNet.QuadPoint): Promise<void>;
        /**
         * sets Overlay appearance of the Redaction annotation.
         * (Optional)
         * @param formxo - An SDF object that represents the overlay appearance of the Redaction annotation.
         * Note: This object is a form XObject specifying the overlay appearance for this
         * redaction annotation. After this redaction is applied and the affected content has been removed,
         * the overlay appearance should be drawn such that its origin lines up with the lower-left corner
         * of the annotation rectangle. This form XObject is not necessarily related to other annotation
         * appearances, and may or may not be present in the Appearance dictionary. This entry takes precedence over the Interior Color(IC),
         * OverlayText, OverlayTextAppearance(DA), and QuadPoint(Q) entries.
         */
        setAppFormXO(formxo: PDFNet.Obj): Promise<void>;
        /**
         * Returns Overlay text of the Redaction annotation.
         * @returns A promise that resolves to a string containing the overlay text of the annotation.
         * Note: The OverlayText string is a text string specifying the
         * overlay text that should be drawn over the redacted region
         * after the affected content has been removed.
         * This entry is ignored if the Overlay appearance(RO) entry is present.
         */
        getOverlayText(): Promise<string>;
        /**
         * sets Overlay text of the Redaction annotation.
         * @param title - A string containing the overlay text of the annotation.
         * Note: The OverlayText string is a text string specifying the
         * overlay text that should be drawn over the redacted region
         * after the affected content has been removed.
         * This entry is ignored if the Overlay appearance stream (RO) entry is present.
         */
        setOverlayText(title: string): Promise<void>;
        /**
         * Returns the option of whether to use repeat for the Redaction annotation.
         * @returns A promise that resolves to a bool indicating whether to repeat for the Redaction annotation.
         * Note: If userepeat value is true, then the text specified by OverlayText
         * should be repeated to fill the redacted region after the affected content
         * has been removed. This entry is ignored if the Overlay appearance stream
         * (RO) entry is present.
         * Default value: false.
         */
        getUseRepeat(): Promise<boolean>;
        /**
         * sets the option of whether to use repeat for the Redaction annotation.
         * @param [userepeat] - A bool indicating whether to repeat for the Redaction annotation.
         * Note: If userepeat value is true, then the text specified by OverlayText
         * should be repeated to fill the redacted region after the affected content
         * has been removed. This entry is ignored if the Overlay appearance stream
         * (RO) entry is present.
         */
        setUseRepeat(userepeat?: boolean): Promise<void>;
        /**
         * Returns Overlay text appearance of the Redaction annotation.
         * @returns A promise that resolves to a string containing the overlay text appearance of the annotation.
         * Note: The overlay text appearance is the appearance string to be used
         * in formatting the overlay text when it is drawn after the affected content
         * has been removed. This entry is ignored if the Overlay appearance stream
         * (RO) entry is present.
         */
        getOverlayTextAppearance(): Promise<string>;
        /**
         * sets Overlay text appearance of the Redaction annotation.
         * @param app - A string containing the overlay text appearance of the annotation.
         * Note: The overlay text appearance is the appearance string to be used
         * in formatting the overlay text when it is drawn after the affected content
         * has been removed. This entry is ignored if the Overlay appearance stream
         * (RO) entry is present.
         */
        setOverlayTextAppearance(app: string): Promise<void>;
        /**
         * Returns Overlay text quadding(justification) format of the Redaction annotation.
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.RedactionAnnot.QuadForm = {
         * 	e_LeftJustified : 0
         * 	e_Centered : 1
         * 	e_RightJustified : 2
         * 	e_None : 3
         * }
         * </pre>
         * @returns A promise that resolves to a value of the "QuadForm" enum type, indicating the
         * overlay text quadding(justification) format of the Redaction annotation's overlay text.
         */
        getQuadForm(): Promise<number>;
        /**
         * sets Overlay text quadding (justification) format of the Redaction annotation.
         * @param [form] - <pre>
         * PDFNet.RedactionAnnot.QuadForm = {
         * 	e_LeftJustified : 0
         * 	e_Centered : 1
         * 	e_RightJustified : 2
         * 	e_None : 3
         * }
         * </pre>
         * A value of the "QuadForm" enum type, indicating the
         * overlay text quadding(justification) format of the Redaction annotation.
         * Note: Quadding format specifies the form of justification to be
         * used in displaying the overlay text.
         */
        setQuadForm(form?: number): Promise<void>;
        /**
         * Returns Overlay appearance of the Redaction annotation.
         * @returns A promise that resolves to an SDF object that represents the overlay appearance of the Redaction annotation.
         * Note: This object is a form XObject specifying the overlay appearance for this
         * redaction annotation. After this redaction is applied and the affected content has been removed,
         * the overlay appearance should be drawn such that its origin lines up with the lower-left corner
         * of the annotation rectangle. This form XObject is not necessarily related to other annotation
         * appearances, and may or may not be present in the Appearance dictionary. This entry takes precedence over the Interior Color(IC),
         * OverlayText, OverlayTextAppearance(DA), and QuadPoint(Q) entries.
         */
        getAppFormXO(): Promise<PDFNet.Obj>;
    }
    /**
     * PDF Redactor is a separately licensable Add-on that offers options to remove
     * (not just covering or obscuring) content within a region of PDF.
     * With printed pages, redaction involves blacking-out or cutting-out areas of
     * the printed page. With electronic documents that use formats such as PDF,
     * redaction typically involves removing sensitive content within documents for
     * safe distribution to courts, patent and government institutions, the media,
     * customers, vendors or any other audience with restricted access to the content.
     *
     * The redaction process in PDFNet consists of two steps:
     *
     *  a) Content identification: A user applies redact annotations that specify the
     * pieces or regions of content that should be removed. The content for redaction
     * can be identified either interactively (e.g. using 'pdftron.PDF.PDFViewCtrl'
     * as shown in PDFView sample) or programmatically (e.g. using 'pdftron.PDF.TextSearch'
     * or 'pdftron.PDF.TextExtractor'). Up until the next step is performed, the user
     * can see, move and redefine these annotations.
     *  b) Content removal: Using 'pdftron.PDF.Redactor.Redact()' the user instructs
     * PDFNet to apply the redact regions, after which the content in the area specified
     * by the redact annotations is removed. The redaction function includes number of
     * options to control the style of the redaction overlay (including color, text,
     * font, border, transparency, etc.).
     *
     * PDFTron Redactor makes sure that if a portion of an image, text, or vector graphics
     * is contained in a redaction region, that portion of the image or path data is
     * destroyed and is not simply hidden with clipping or image masks. PDFNet API can also
     * be used to review and remove metadata and other content that can exist in a PDF
     * document, including XML Forms Architecture (XFA) content and Extensible Metadata
     * Platform (XMP) content.
     */
    class Redactor {
        /**
         * Constructor
         * @returns A promise that resolves to an object of type: "PDFNet.Redaction"
         */
        static redactionCreate(page_num: number, bbox: PDFNet.Rect, negative: boolean, text: string): Promise<PDFNet.Redaction>;
        /**
         * Destructor
         */
        static redactionDestroy(redaction: PDFNet.Redaction): Promise<void>;
        /**
         * Copy Constructor
         * @returns A promise that resolves to an object of type: "PDFNet.Redaction"
         */
        static redactionCopy(other: PDFNet.Redaction): Promise<PDFNet.Redaction>;
        /**
         * Apply the redactions specified in the array red_arr to the PDFDoc doc.
         * @param doc - the document to redact
         * @param red_arr - an array of redaction objects specifying the regions to redact.
         * @param [appearance] - optional parameter used to customize the appearance of the redaction overlay.
        To create an appearance object, create an empty javascript object {} and add entries
        containing values to it. The following entries are handled by redact:
        
        <pre>
        app.redaction_overlay = boolean
        If redaction_overlay is set to true, redactor will draw an overlay
        covering all redacted regions. The rest of properties in the
        appearance object defines visual properties of the overlay.
        If false the overlay region will not be drawn.
        Defaults to true.
        
        app.positive_overlay_color = ColorPt object
        positive_overlay_color defines the overlay background color in RGB color space for positive redactions.
        Defaults to white (PDFNet.ColorPt(1, 1, 1, 0));
        
        app.negative_overlay_color = ColorPt object
        negative_overlay_color defines the overlay background color in RGB color space for negative redactions.
        Defaults to white (PDFNet.ColorPt(1, 1, 1, 0));
        
        app.border = boolean
        border specifies if the overlay will be surrounded by a border.
        Defaults to true.
        
        app.font = Font object
        font specifies the font used to represent the text in the overlay.
        Defaults to true.
        
        app.min_font_size = int
        min_font_size specifies the minimum font size used to represent the text in the overlay
        Defaults to 2.
        
        app.max_font_size = int
        max_font_size specifies the maximum font size used to represent the text in the overlay
        Defaults to 24.
        
        app.text_color = ColorPt object
        text_color specifies the color used to paint the text in the overlay (in RGB).
        Defaults to dark green (PDFNet.ColorPt(0, 0.5, 0, 0));
        
        app.horiz_text_alignment = int
        horiz_text_alignment specifies the horizontal text alignment in the overlay:
            align<0	 -> text will be left aligned.
            align==0 -> text will be center aligned.
            align>0	 -> text will be right aligned.
        Defaults to -1.
        
        app.vert_text_alignment = int
        vert_text_alignment specifies the vertical text alignment in the overlay:
            align<0	 -> text will be top aligned.
            align==0 -> text will be center aligned.
            align>0	 -> text will be bottom aligned.
        Defaults to 1.
        
        app.show_redacted_content_regions = boolean
        show_redacted_content_regions specifies whether an overlay should be drawn in place of
        the redacted content. This option can be used to indicate the areas where the content
        was removed from without revealing the content itself. Defaults to false. Uses
        RedactedContentColor as a fill color.
        Defaults to false.
        
        app.redacted_content_color = ColorPt object
        Specifies the color used to paint the regions where content was removed.
        Only useful when ShowRedactedContentRegions == true.
        Defaults to gray (PDFNet.ColorPt(0.3, 0.3, 0.3, 0)).
        </pre>
         * @param [ext_neg_mode = true] - if true, negative redactions expand beyond the page to remove
        content from other pages in the document. if false, the redaction will be localized
        to the given page.
         * @param [page_coord_sys = true] - if true, redaction coordinates are relative to the lower-left corner of the page,
        otherwise the redaction coordinates are defined in PDF user coordinate system (which may or may not coincide with
        page coordinates).
         */
        static redact(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, red_arr: PDFNet.Redactor[], appearance?: any, ext_neg_mode?: boolean, page_coord_sys?: boolean): Promise<void>;
    }
    /**
     * The class Reflow.
     * Reflow annotations between PDF and HTML
     *
     * DocumentConversion instances are created through methods belonging to
     * the Convert class. See Convert.CreateReflow for an example.
     */
    class Reflow extends PDFNet.Destroyable {
        /**
         * Converts PDF to HTML.
         * @returns A promise that resolves to returns HTML as a string.
         */
        getHtml(): Promise<string>;
        /**
         * Gets PDF annotation(s) as JSON.
         * @param in_id - - an annotation ID, or an empty string.
         * @returns A promise that resolves to returns JSON string.
         */
        getAnnot(in_id: string): Promise<string>;
        /**
         * Updates PDF annotation.
         * @param in_json - - update instructions (JSON).
         * @returns A promise that resolves to returns JSON string.
         */
        setAnnot(in_json: string): Promise<string>;
        /**
         * Determines whether to include images in the output HTML. Default is false.
         * @param include - - if true images will be included in the output HTML.
         */
        setIncludeImages(include: boolean): Promise<void>;
        /**
         * Determines whether to write text markup tags into the output HTML. Default is false.
         * @param include - - if true text markup tags will be included in the output HTML..
         */
        setHTMLOutputTextMarkup(include: boolean): Promise<void>;
        /**
         * Sets the error message in the output HTML when the page doesn't contain reflowable text. Use it for localization purposes. Default: "This page doesn't contain reflowable text".
         * @param content - - the localized message.
         */
        setMessageWhenNoReflowContent(content: string): Promise<void>;
        /**
         * Sets the error message in the output HTML when reflow conversion fails. Use it for localization purposes. Default: "Could not reflow this page".
         * @param content - - the localized message.
         */
        setMessageWhenReflowFailed(content: string): Promise<void>;
        /**
         * Determines whether to hide background images. Default is false.
         * @param hide_background_images - - if true, background images will not be included in the output HTML.
         */
        setHideBackgroundImages(hide_background_images: boolean): Promise<void>;
        /**
         * Determines whether to hide images that are covered by text. Default is false.
         * @param hide_images_under_text - - if true, images that are covered by text will not be included in the output HTML.
         */
        setHideImagesUnderText(hide_images_under_text: boolean): Promise<void>;
        /**
         * Determines whether to hide images that are covered by invisible text (typically produced by OCR). Default is true.
         *
         * This options works only if SetHideImagesUnderText() is set to false. If SetHideImagesUnderText() is set to true,
         * then images that are covered by any text, whether visible or not, will not be included in the output HTML.
         *
         * If SetHideImagesUnderInvisibleText() is set to true while SetHideImagesUnderText() is set to false, then images
         * that are covered by invisible text will not be included in the output HTML. This can be useful when processing
         * scanned documents that are processed by OCR.
         * @param hide_images_under_invisible_text - - if true, images that are covered by invisible text will not be included in the output HTML.
         */
        setHideImagesUnderInvisibleText(hide_images_under_invisible_text: boolean): Promise<void>;
        /**
         * Determines whether to not reflow text that appears over images. Default is false.
         * @param do_not_reflow_text_over_images - - if true, text that appears over images will not be included in the output HTML.
         */
        setDoNotReflowTextOverImages(do_not_reflow_text_over_images: boolean): Promise<void>;
        /**
         * Overrides the font to use for reflowed content. If this property is empty, the default PDF font will be used. Default is no override.
         * @param font_family - - the font-family value that goes to the CSS in the output HTML.
         */
        setFontOverrideName(font_family: string): Promise<void>;
        /**
         * Appends custom CSS styles to the output HTML. Default is no custom styles.
         * @param styles - - the CSS code without any <style> tags to be inserted in the output HTML.
         */
        setCustomStyles(styles: string): Promise<void>;
        /**
         * Determines whether to include bounding box information (of the original PDF) in the output HTML. Default is false.
         *
         * The bounding box information will be stored using the attribute called "data-bbox" (value is written as "x1,y1,x2,y2", in PDF coordinates).
         *
         * Note: This option is only available when pre-recognized zoning information is set through SetRecognizedZones().
         * @param include - - if true bounding box information will be included in the output HTML.
         */
        setIncludeBBoxForRecognizedZones(include: boolean): Promise<void>;
    }
    /**
     * The class ResultSnapshot.
     * Represents a transition between two document states.
     */
    class ResultSnapshot extends PDFNet.Destroyable {
        /**
         * Retrieves the document state to which this transition has transitioned.
         * @returns A promise that resolves to the current document state.
         */
        currentState(): Promise<PDFNet.DocSnapshot>;
        /**
         * Retrieves the document state from which this transition has transitioned.
         * @returns A promise that resolves to the previous document state.
         */
        previousState(): Promise<PDFNet.DocSnapshot>;
        /**
         * Returns whether this transition is valid or a null transition.
         * @returns A promise that resolves to whether this transition is valid or a null transition.
         */
        isOk(): Promise<boolean>;
        /**
         * Returns whether this transition is a null transition.
         * @returns A promise that resolves to whether this transition is a null transition.
         */
        isNullTransition(): Promise<boolean>;
    }
    /**
     * RoleMap is a dictionary that maps the names of structure types used in the
     * document to their approximate equivalents in the set of standard structure
     * types.
     */
    class RoleMap {
        /**
         * Initialize a RoleMap using an existing low-level Cos/SDF role map dictionary.
         * @param dict - a low-level (SDF/Cos) RoleMap dictionary.
         *
         * Note: This constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @returns A promise that resolves to an object of type: "PDFNet.RoleMap"
         */
        static create(dict: PDFNet.Obj): Promise<PDFNet.RoleMap>;
        /**
         * Copy Constructor
         * @returns A promise that resolves to an object of type: "PDFNet.RoleMap"
         */
        copy(): Promise<PDFNet.RoleMap>;
        /**
         * @returns A promise that resolves to true if this is a valid (non-null) RoleMap, false otherwise.
         * If the function returns false the underlying SDF/Cos object is null or is
         * not valid and the RoleMap should be treated as NULL object.
         */
        isValid(): Promise<boolean>;
        /**
         * @param type - element type
         * @returns A promise that resolves to the direct mapping of given StructElement type, or NULL
         * if such mapping is not defined.
         */
        getDirectMap(type: string): Promise<string>;
        /**
         * Returns the RoleMap dictionary.
         * @returns A promise that resolves to the object to the underlying SDF/Cos dictionary.
         */
        getSDFObj(): Promise<PDFNet.Obj>;
    }
    /**
     * A RubberStamp annotation displays text or graphics intended
     * to look as if they were stamped on the page with a rubber stamp.
     */
    class RubberStampAnnot extends PDFNet.MarkupAnnot {
        /**
         * creates a RubberStamp annotation and initializes it using given Cos/SDF object.
         * @param [d] - The Cos/SDF object to initialze the annotation with.
         * Note: The constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @returns A promise that resolves to an object of type: "PDFNet.RubberStampAnnot"
         */
        static createFromObj(d?: PDFNet.Obj): Promise<PDFNet.RubberStampAnnot>;
        /**
         * creates a RubberStamp annotation and initializes it using given annotation object.
         * @param ann - Annot object used to initialize the RubberStamp annotation.
         * Note: The constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @returns A promise that resolves to an object of type: "PDFNet.RubberStampAnnot"
         */
        static createFromAnnot(ann: PDFNet.Annot): Promise<PDFNet.RubberStampAnnot>;
        /**
         * Constructor
         * @returns A promise that resolves to an object of type: "PDFNet.RubberStampAnnot"
         */
        static create(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, pos: PDFNet.Rect): Promise<PDFNet.RubberStampAnnot>;
        static create(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, type: number, pos: PDFNet.Rect): Promise<PDFNet.Annot>;
        /**
         * Creates a new RubberStamp annotation in the specified document.
         * @param doc - A document to which the annotation is added.
         * @param pos - A rectangle specifying the annotation's bounds in default user space units.
         * @param form_xobject - An object specifying a custom appearance for the annotation, containing
         *    TEXT as string (mandatory): The text to be displayed in rubber stamp
         *    TEXT_BELOW as string (optional): The text to be displayed below the first text
         *    FILL_COLOR as an array of three or four numbers between 0.0 to 1.0 (optional): The fill color
         *    TEXT_COLOR as an array of three or four numbers between 0.0 to 1.0 (optional): The text color
         *    BORDER_COLOR as an array of three or four numbers between 0.0 to 1.0 (optional): The border color
         *    FILL_COLOR_START as an array of three or four numbers between 0.0 to 1.0 (optional):
         *       The start fill color if background is gradient
         *    FILL_COLOR_END as an array of three or four numbers between 0.0 to 1.0 (optional):
         *       The end fill color if background is gradient
         *    FILL_OPACITY as a number (optional): the fill opacity
         *    TEXT_OPACITY as a number (optional): the text opacity
         *    ROTATION as a number (optional): rotation. valid numbers are {0, 90, 180, 270}
         *    POINTING_LEFT as a boolean (optional): if the stamp is pointing left
         *    POINTING_RIGHT as a boolean (optional): if the stamp is pointing right
         * @returns A promise that resolves to a newly created RubberStamp annotation.
         */
        static createCustom(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, pos: PDFNet.Rect, form_xobject: PDFNet.Obj): Promise<PDFNet.RubberStampAnnot>;
        /**
         * Returns the type of the icon associated with the RubberStamp annotation.
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.RubberStampAnnot.Icon = {
         * 	e_Approved : 0
         * 	e_Experimental : 1
         * 	e_NotApproved : 2
         * 	e_AsIs : 3
         * 	e_Expired : 4
         * 	e_NotForPublicRelease : 5
         * 	e_Confidential : 6
         * 	e_Final : 7
         * 	e_Sold : 8
         * 	e_Departmental : 9
         * 	e_ForComment : 10
         * 	e_TopSecret : 11
         * 	e_ForPublicRelease : 12
         * 	e_Draft : 13
         * 	e_Unknown : 14
         * }
         * </pre>
         * @returns A promise that resolves to a value of enum "Icon" that represents
         * the type of icon associated with the annotation.
         * Default value: e_Draft.
         */
        getIcon(): Promise<number>;
        /**
         * sets the type of the icon associated with the RubberStamp annotation.
         * @param [type] - <pre>
         * PDFNet.RubberStampAnnot.Icon = {
         * 	e_Approved : 0
         * 	e_Experimental : 1
         * 	e_NotApproved : 2
         * 	e_AsIs : 3
         * 	e_Expired : 4
         * 	e_NotForPublicRelease : 5
         * 	e_Confidential : 6
         * 	e_Final : 7
         * 	e_Sold : 8
         * 	e_Departmental : 9
         * 	e_ForComment : 10
         * 	e_TopSecret : 11
         * 	e_ForPublicRelease : 12
         * 	e_Draft : 13
         * 	e_Unknown : 14
         * }
         * </pre>
         * A value of enum "Icon" type that represents
         * the type of icon associated with the annotation.
         * Default value: e_Draft.
         */
        setIcon(type?: number): Promise<void>;
        setIconDefault(): Promise<void>;
        /**
         * Returns the name of the icon associated with the RubberStamp annotation.
         * @returns A promise that resolves to a string that is the name of the icon associated with
         * the RubberStamp annotation.
         * Note: The following icon names are equivalent
         * to predefined icon types from the enum "Icon":
         * "Approved" = e_Approved
         * "Experimental" = e_Experimental
         * "NotApproved" = e_NotApproved
         * "AsIs" = e_AsIs
         * "Expired" = e_Expired
         * "NotForPublicRelease" = e_NotForPublicRelease
         * "Confidential" = e_Confidential
         * "Final" = e_Final
         * "Sold" = e_Sold
         * "Departmental" = e_Departmental
         * "Format" = e_ForComment
         * "TopSecret" = e_TopSecret
         * "ForPublicRelease" = e_ForPublicRelease
         * "Draft" = e_Draft
         * "Unknown" = e_Unknown
         * Names other than mentioned above do not have predefined icon appearances.
         */
        getIconName(): Promise<string>;
        /**
         * sets the name of the icon associated with the RubberStamp annotation.
         * @param iconstring - the name of the icon associated with
         * the RubberStamp annotation.
         * Note: The following icon names are equivalent
         * to predefined icon types from the enum "Icon":
         * "Approved" = e_Approved
         * "Experimental" = e_Experimental
         * "NotApproved" = e_NotApproved
         * "AsIs" = e_AsIs
         * "Expired" = e_Expired
         * "NotForPublicRelease" = e_NotForPublicRelease
         * "Confidential" = e_Confidential
         * "Final" = e_Final
         * "Sold" = e_Sold
         * "Departmental" = e_Departmental
         * "Format" = e_ForComment
         * "TopSecret" = e_TopSecret
         * "ForPublicRelease" = e_ForPublicRelease
         * "Draft" = e_Draft
         * "Unknown" = e_Unknown
         * Names other than mentioned above do not have predefined icon appearances.
         */
        setIconName(iconstring: string): Promise<void>;
    }
    /**
     * SDFDoc is a low-level document representing a graph of SDF::Obj nodes that
     * can be used to build higher-level document models such as PDF (Portable Document
     * Format) or FDF (Forms Document Format).
     *
     * SDFDoc brings together document security, document utility methods, and all SDF
     * objects.
     *
     * A SDF document can be created from scratch using a default constructor:
     *
     * SDFDoc mydoc;
     * Obj trailer = mydoc.GetTrailer();
     *
     * SDF document can be also created from an existing file (e.g. an external PDF document):
     * <pre>
     * SDFDoc mydoc("in.pdf");
     * Obj trailer = mydoc.GetTrailer();
     * </pre>
     * or from a memory buffer or some other Filter/Stream such as a HTTP Filter connection:
     *
     * <pre>
     * MemoryFilter memory = ....
     * SDFDoc mydoc(memory);
     * Obj trailer = mydoc.GetTrailer();
     * </pre>
     *
     * Finally SDF document can be accessed from a high-level PDF document as follows:
     *
     * <pre>
     * PDFDoc doc("in.pdf");
     * SDFDoc& mydoc = doc.GetSDFDoc();
     * Obj trailer = mydoc.GetTrailer();
     * </pre>
     *
     * Note that the examples above used doc.GetTrailer() in order to access document
     * trailer, the starting SDF object (root node) in every document. Following the trailer
     * links, it is possible to visit all low-level objects in a document (e.g. all pages,
     * outlines, fonts, etc).
     *
     * SDFDoc also provides utility methods used to import objects and object collections
     * from one document to another. These methods can be useful for copy operations between
     * documents such as a high-level page merge and document assembly.
     */
    class SDFDoc {
        /**
         * Copy Constructor
         * @returns A promise that resolves to an object of type: "PDFNet.SDFDoc"
         */
        createShallowCopy(): Promise<PDFNet.SDFDoc>;
        releaseFileHandles(): Promise<void>;
        /**
         * @returns A promise that resolves to true if the document is/was originally encrypted false otherwise.
         */
        isEncrypted(): Promise<boolean>;
        /**
         * Initializes document's SecurityHandler using the supplied
         * password. This version of InitSecurityHandler() assumes that
         * document uses Standard security and that a password is specified
         * directly.
         *
         * This function should be called immediately after an encrypted
         * document is opened. The function does not have any side effects on
         * documents that are not encrypted.
         *
         * If the security handler was successfully initialized, it can be later
         * obtained using GetSecurityHandler() method.
         * @param password - Specifies the password used to open the document without
         * any user feedback. If you would like to dynamically obtain the password,
         * you need to derive a custom class from StdSecurityHandler() and use
         * InitSecurityHandler() without any parameters. See EncTest sample
         * for example code.
         * @returns A promise that resolves to true if the given password successfully unlocked the document,
         * false otherwise.
         */
        initStdSecurityHandlerUString(password: string): Promise<boolean>;
        /**
         * @returns A promise that resolves to true if document was modified, false otherwise
         */
        isModified(): Promise<boolean>;
        /**
         * Checks whether or not the underlying file has an XRef table that had to be repaired
         * when the file was opened. If the document had an invalid XRef table when opened,
         * PDFNet will have repaired the XRef table for its working representation of the document.
         * @returns A promise that resolves to true if document was found to be corrupted, and was repaired, during
         * opening and has not been saved since.
         *
         * Note: If this function returns true, it is not possible to incrementally save the document
         * (see http://www.pdftron.com/kb_corrupt_xref)
         */
        hasRepairedXRef(): Promise<boolean>;
        /**
         * @returns A promise that resolves to true if the document requires full save.
         */
        isFullSaveRequired(): Promise<boolean>;
        /**
         * @returns A promise that resolves to A dictionary representing the root of the document (i.e.
         * a document trailer dictionary)
         */
        getTrailer(): Promise<PDFNet.Obj>;
        /**
         * @param obj_num - object number of the object to retrieve.
         * @returns A promise that resolves to the latest version of the object matching specified object number.
         */
        getObj(obj_num: number): Promise<PDFNet.Obj>;
        /**
         * @param obj - an object to import.
         * @param deep_copy - a boolean indicating whether to perform a deep or shallow copy.
         * In case of shallow copy all indirect references will be set to null.
         *
         * If the object belongs to a document the function will perform deep or shallow
         * clone depending whether deep_copy flag was specified.
         *
         * If the object does not belong to any document ImportObj does not take the
         * object ownership. ImportObj copies the source object and it is users
         * responsibility to delete free objects.
         * @returns A promise that resolves to a pointer to the root indirect object in this document
         */
        importObj(obj: PDFNet.Obj, deep_copy: boolean): Promise<PDFNet.Obj>;
        /**
         * The function performs a deep copy of all objects specified in the 'obj_list'.
         * If objects in the list are directly or indirectly referring to the same object/s,
         * only one copy of the shared object/s will be copied. Therefore, unlike repeated calls
         * to ImportObj, this method will import only one copy of shared objects (objects
         * representing an intersection of graphs specified through 'obj_list' of root pointers.
         *
         * Note: All object in the import list must belong to the same source document.
         * Note: The function does not perform the shallow copy since ImportObj() can be used instead.
         * @param obj_list - a list of root objects to import. All directly or indirectly objects will be
         * imported as well.
         * @param exclude_list - a list of objects to not include in the deep copy.
         * @returns A promise that resolves to a list of imported root objects in this document.
         */
        importObjsWithExcludeList(obj_list: PDFNet.Obj[], exclude_list: PDFNet.Obj[]): Promise<PDFNet.Obj>;
        /**
         * @returns A promise that resolves to The size of cross reference table
         */
        xRefSize(): Promise<number>;
        /**
         * Removes 'marked' flag from all objects in cross reference table.
         */
        clearMarks(): Promise<void>;
        /**
         * Saves the document to a memory buffer.
         * @param flags - A bit field composed of an OR of the SDFDoc::SaveOptions values.
         * Note that this method ignores e_incremental flag.
         * @param header - File header. A new file header is set only during full save.
         * @returns A promise that resolves to the buffer containing the serialized version of the document.
         *
         * Note: Save will modify the SDFDoc object's internal representation.  As such,
         * 			  the user should acquire a write lock before calling save.
         */
        saveMemory(flags: number, header: string): Promise<Uint8Array>;
        /**
         * Saves the document to a stream.
         * @param stream - The output stream where to write data.
         * @param flags - A bit field composed of an OR of the SDFDoc::SaveOptions values.
         * @param header - File header. A new file header is set only during full save. See also GetHeader()
         *
         * Note: Save will modify the SDFDoc object's internal representation.  As such,
         * 			  the user should acquire a write lock before calling save.
         */
        saveStream(stream: PDFNet.Filter, flags: number, header: string): Promise<void>;
        /**
         * @returns A promise that resolves to the header string identifying the document version to which the file conforms.
         * For a file conforming to PDF version 1.4, the header should be %PDF-1.4.
         * In general header strings have the following syntax: %AAA-N.n where AAA identifies
         * document specification (such as PDF, FDF, PJTF etc), N is the major version and
         * n is the minor version. The new header string can be set during a full save (see SDFDoc::Save()).
         * For a document that is not serialized the function returns an empty string.
         */
        getHeader(): Promise<string>;
        /**
         * @returns A promise that resolves to currently selected SecurityHandler.
         *
         * Note: InitSecurityHandler() should be called before GetSecurityHandler()
         * in order to initialize the handler.
         *
         * Note: Returned security handler can be modified in order to change the
         * security settings of the existing document. Changes to the current handler
         * will not invalidate the access to the original file and will take effect
         * during document Save().
         *
         * Note: If the security handler is modified, document will perform a full save
         * even if e_incremental was given as a flag in Save() method.
         */
        getSecurityHandler(): Promise<PDFNet.SecurityHandler>;
        setSecurityHandler(handler: PDFNet.SecurityHandler): Promise<void>;
        /**
         * This function removes document security.
         */
        removeSecurity(): Promise<void>;
        /**
         * Sometimes it is desirable to modify all indirect references to a given
         * indirect object. It would be inefficient to manually search for all
         * indirect references to a given indirect object.
         *
         * A more efficient and less error prone method is to replace the indirect
         * object in the cross reference table with a new object. This way the object
         * that is referred to is modified (or replaced) and indirect references do
         * not have to be changed.
         * @param obj_num1 - object number of first object to be swapped.
         * @param obj_num2 - object number of second object to be swapped.
         */
        swap(obj_num1: number, obj_num2: number): Promise<void>;
        /**
         * Call this function to determine whether the document is represented in
         * linearized (fast web view) format.
         * @returns A promise that resolves to true if document is stored in fast web view format, false otherwise.
         *
         * Note: any changes to the document can invalidate linearization. The function will
         * return 'true' only if the original document is linearized and if it is not
         * modified.
         *
         * In order to provide good performance over relatively slow communication links,
         * PDFNet can generate PDF documents with linearized objects and hint tables that
         * can allow a PDF viewer application to download and view one page of a PDF file
         * at a time, rather than requiring the entire file (including fonts and images) to
         * be downloaded before any of it can be viewed.
         *
         * To save a document in linearized (fast web view) format you only need to pass
         * 'SDFDoc.SaveOptions.e_linearized' flag in the Save method.
         */
        isLinearized(): Promise<boolean>;
        /**
         * Returns document's initial linearization dictionary if it is available.
         * @returns A promise that resolves to the linearization dictionary of the original document or NULL
         * if the dictionary is not available.
         */
        getLinearizationDict(): Promise<PDFNet.Obj>;
        /**
         * Returns document's initial linearization hint stream if it is available.
         * @returns A promise that resolves to the linearization hint stream of the original document or NULL
         * if the hint stream is not available.
         */
        getHintStream(): Promise<PDFNet.Obj>;
        /**
         * A document uses a temporary file which is used to cache the contents
         * of any new stream object created in the document (that is the default behavior).
         * @param use_cache_flag - true to enable caching, false to disable caching.
         * Use this function to enable or disable this feature dynamically.
         */
        enableDiskCaching(use_cache_flag: boolean): Promise<void>;
        /**
         * Locks the document to prevent competing threads from accessing the document
         * at the same time. Threads attempting to access the document will wait in
         * suspended state until the thread that owns the lock calls doc.Unlock().
         */
        lock(): Promise<void>;
        /**
         * Removes the lock from the document.
         */
        unlock(): Promise<void>;
        /**
         * Locks the document to prevent competing write threads (using Lock()) from accessing the document
         * at the same time. Other reader threads however, will be allowed to access the document.
         * Threads attempting to obtain write access to the document will wait in
         * suspended state until the thread that owns the lock calls doc.UnlockRead().
         * Note: To avoid deadlocks obtaining a write lock while holding
         * a read lock is not permitted and will throw an exception. If this situation is encountered
         * please either unlock the read lock before the write lock is obtained
         * or acquire a write lock (rather than read lock) in the first place.
         */
        lockRead(): Promise<void>;
        /**
         * Removes the lock from the document.
         */
        unlockRead(): Promise<void>;
        /**
         * Try locking the document.
         * @returns A promise that resolves to true if the document is locked for multi-threaded access, false otherwise.
         */
        tryLock(): Promise<boolean>;
        /**
         * Tries to obtain a read lock the document and returns true if the lock was
         * successfully acquired
         * @returns A promise that resolves to true if the document is locked for multi-threaded access, false otherwise.
         */
        tryLockRead(): Promise<boolean>;
        /**
         * @returns A promise that resolves to the filename of the document if the document is loaded from disk,
         * or empty string if the document is not yet saved or is loaded from a memory
         * buffer.
         */
        getFileName(): Promise<string>;
        /**
         * Used to create SDF/Cos indirect object.
         *
         * Unlike direct objects, indirect objects can be referenced by more than one
         * object (i.e. indirect objects they can be shared).
         * @param name - indirect const char* object to create.
         * Note: In C++ doc.CreateIndirect???(...) is equivalent to ???::CreateIndirect(...).
         * @returns A promise that resolves to an object of type: "PDFNet.Obj"
         */
        createIndirectName(name: string): Promise<PDFNet.Obj>;
        /**
         * Used to create SDF/Cos indirect object.
         *
         * Unlike direct objects, indirect objects can be referenced by more than one
         * object (i.e. indirect objects they can be shared).
         *
         * Note: In C++ doc.CreateIndirect???(...) is equivalent to ???::CreateIndirect(...).
         * @returns A promise that resolves to an object of type: "PDFNet.Obj"
         */
        createIndirectArray(): Promise<PDFNet.Obj>;
        /**
         * Used to create SDF/Cos indirect object.
         *
         * Unlike direct objects, indirect objects can be referenced by more than one
         * object (i.e. indirect objects they can be shared).
         * @param value - indirect boolean to create.
         * Note: In C++ doc.CreateIndirect???(...) is equivalent to ???::CreateIndirect(...).
         * @returns A promise that resolves to an object of type: "PDFNet.Obj"
         */
        createIndirectBool(value: boolean): Promise<PDFNet.Obj>;
        /**
         * @returns A promise that resolves to an object of type: "PDFNet.Obj"
         */
        createIndirectDict(): Promise<PDFNet.Obj>;
        /**
         * @returns A promise that resolves to an object of type: "PDFNet.Obj"
         */
        createIndirectNull(): Promise<PDFNet.Obj>;
        /**
         * Used to create SDF/Cos indirect object.
         *
         * Unlike direct objects, indirect objects can be referenced by more than one
         * object (i.e. indirect objects they can be shared).
         * @param value - indirect boolean to create.
         * @returns A promise that resolves to the created indirect object.
         */
        createIndirectNumber(value: number): Promise<PDFNet.Obj>;
        /**
         * Used to create SDF/Cos indirect object.
         *
         * Unlike direct objects, indirect objects can be referenced by more than one
         * object (i.e. indirect objects they can be shared).
         * @param buf_value - indirect boolean to create.
         * @returns A promise that resolves to the created indirect object.
         */
        createIndirectString(buf_value: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray): Promise<PDFNet.Obj>;
        /**
         * Used to create SDF/Cos indirect object.
         *
         * Unlike direct objects, indirect objects can be referenced by more than one
         * object (i.e. indirect objects they can be shared).
         * @param str - indirect boolean to create.
         * @returns A promise that resolves to the created indirect object.
         */
        createIndirectStringFromUString(str: string): Promise<PDFNet.Obj>;
        /**
         * Note: After calling the following methods the filter object is invalidated and should not be used
         * @returns A promise that resolves to an object of type: "PDFNet.Obj"
         */
        createIndirectStreamFromFilter(data: PDFNet.FilterReader, filter_chain?: PDFNet.Filter): Promise<PDFNet.Obj>;
        /**
         * Used to create SDF/Cos indirect object.
         *
         * Unlike direct objects, indirect objects can be referenced by more than one
         * object (i.e. indirect objects they can be shared).
         * @param data_buf - indirect boolean to create.
         * @returns A promise that resolves to the created indirect object.
         * Note: After calling the following methods the filter object is invalidated and should not be used
         */
        createIndirectStream(data_buf: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray, filter_chain: PDFNet.Filter): Promise<PDFNet.Obj>;
        /**
         * Initializes document's SecurityHandler. This version of InitSecurityHandler()
        works with Standard and Custom PDF security and can be used in situations where
        the password is obtained dynamically via user feedback. See EncTest sample for
        example code.
        
        This function should be called immediately after an encrypted
        document is opened. The function does not have any side effects on
        documents that are not encrypted.
        
        If the security handler was successfully initialized it can be later obtained
        using GetSecurityHandler() method.
         * @returns A promise that resolves to true if the SecurityHandler was successfully initialized (this
        may include authentication data collection, verification etc.),
        false otherwise.
         */
        initSecurityHandler(): Promise<boolean>;
        /**
         * Initializes document's SecurityHandler using the supplied
        password. This version of InitSecurityHandler() assumes that
        document uses Standard security and that a password is specified
        directly.
        
        This function should be called immediately after an encrypted
        document is opened. The function does not have any side effects on
        documents that are not encrypted.
        
        If the security handler was successfully initialized, it can be later
        obtained using GetSecurityHandler() method.
         * @param password - Specifies the password used to open the document without
        any user feedback.
         * @returns A promise that resolves to true if the given password successfully unlocked the document,
        false otherwise.
         */
        initStdSecurityHandler(password: string): Promise<boolean>;
        applyCustomQuery(query: any): Promise<any>;
    }
    /**
     * SElement represents PDF structural elements, which are nodes in a tree
     * structure, defining a PDF document's logical structure.
     *
     * Unlike the StructTree, SElement can have two different kinds
     * of children: another SElement or a ContentItem (which can be marked
     * content (MC), or a PDF object reference (OBJR)).
     */
    class SElement {
        constructor(obj?: PDFNet.Obj, k?: PDFNet.Obj);
        /**
         * Initialize a SElement using an existing low-level Cos/SDF object.
         * @param [dict] - a low-level (SDF/Cos) dictionary representing the structural element.
         *
         * Note: This constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @returns A promise that resolves to an object of type: "PDFNet.SElement"
         */
        static create(dict?: PDFNet.Obj): Promise<PDFNet.SElement>;
        /**
         * Creates a new SElement.
         * @returns A promise that resolves to an object of type: "PDFNet.SElement"
         */
        static createFromPDFDoc(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, struct_type: string): Promise<PDFNet.SElement>;
        insert(kid: PDFNet.SElement, insert_before: number): Promise<void>;
        /**
         * @param doc - The document in which the new ContentItem will be created in.
         * @param page - The page object to insert the ContentItem in.
         * @param [insert_before] - The position after which the kid is inserted. If
         * element currently has no kids, insert_before is ignored.
         * @returns A promise that resolves to an object of type: "number"
         */
        createContentItem(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, page: PDFNet.Page, insert_before?: number): Promise<number>;
        /**
         * @returns A promise that resolves to true if this is a valid structure element object, false otherwise.
         */
        isValid(): Promise<boolean>;
        /**
         * @returns A promise that resolves to the element's structural element type. The type corresponds to
         * the 'S' (i.e. subtype) key in the structure element dictionary.
         *
         * The type identifies the nature of the structure element and its role
         * within the document (such as a chapter, paragraph, or footnote).
         */
        getType(): Promise<string>;
        /**
         * @returns A promise that resolves to the number of direct kids.
         */
        getNumKids(): Promise<number>;
        /**
         * @param index - The index of the kid type to obtain.
         *
         * To retrieve a content item at a given array index use GetAsContentItem(index),
         * otherwise use GetAsStructElem(index)
         * @returns A promise that resolves to true if the kid at a given array index is a content item,
         * false otherwise.
         */
        isContentItem(index: number): Promise<boolean>;
        /**
         * @param index - The index of the kid to obtain.
         * @returns A promise that resolves to the kid at a given array index assuming that the kid is a ContentItem.
         * Note: use IsContentItem(index) prior to calling this method to make sure that
         * the kid is indeed a ContentItem.
         */
        getAsContentItem(index: number): Promise<PDFNet.ContentItem>;
        /**
         * @param index - The index of the kid to obtain.
         * @returns A promise that resolves to the kid at a given array index assuming that the kid is a SElement.
         * Note: use IsContentItem(index) prior to calling this method to make sure that
         * the kid is not a ContentItem and is another SElement.
         */
        getAsStructElem(index: number): Promise<PDFNet.SElement>;
        /**
         * @returns A promise that resolves to the immediate ancestor element of the specified element in
         * the structure tree.
         *
         * Note: If the element's parent is the structure tree root, the returned
         * SElement will be not valid (i.e. element.IsValid() -> false) and the
         * underlying SDF/Cos object will be NULL.
         */
        getParent(): Promise<PDFNet.SElement>;
        /**
         * @returns A promise that resolves to the structure tree root of the document that directly or
         * indirectly contains this element.
         */
        getStructTreeRoot(): Promise<PDFNet.STree>;
        /**
         * @returns A promise that resolves to if this SElement has title.
         *
         * The title of the structure element, a text string representing it in
         * human-readable form.
         */
        hasTitle(): Promise<boolean>;
        /**
         * @returns A promise that resolves to the title of this structure element.
         */
        getTitle(): Promise<string>;
        /**
         * @returns A promise that resolves to the ID of an element, or NULL if the ID is not defined.
         */
        getID(): Promise<PDFNet.Obj>;
        /**
         * @returns A promise that resolves to if this structure element defines ActualText.
         *
         * ActualText is an exact replacement for the structure element and its children.
         * This replacement text is useful when extracting the document's contents in
         * support of accessibility to users with disabilities or for other purposes.
         */
        hasActualText(): Promise<boolean>;
        /**
         * @returns A promise that resolves to the ActualText associated with this element.
         *
         * Note: The ActualText can be defined as an empty string. To differentiate
         * between an ActualText string of zero length and no ActualText being defined,
         * use HasActualText().
         */
        getActualText(): Promise<string>;
        /**
         * @returns A promise that resolves to if this structure element defines Alt text.
         *
         * Alt text is an alternate description of the structure element and
         * its children in human-readable form, which is useful when extracting
         * the document's contents in support of accessibility.
         */
        hasAlt(): Promise<boolean>;
        /**
         * @returns A promise that resolves to the alternate text associated with this element.
         *
         * Note: The Alt text can be defined as an empty string. To differentiate
         * between an Alt text string of zero length and no Alt text being defined,
         * use HasAlt().
         */
        getAlt(): Promise<string>;
        /**
         * @returns A promise that resolves to pointer to the underlying SDF/Cos object.
         */
        getSDFObj(): Promise<PDFNet.Obj>;
        obj: PDFNet.Obj;
        k: PDFNet.Obj;
    }
    /**
     * STree is the root of the structure tree, which is a central repository
     * for information related to a PDF document's logical structure. There is at most
     * one structure tree in each document.
     */
    class STree {
        /**
         * Initialize a STree using an existing low-level Cos/SDF object.
         * @param struct_dict - a low-level (SDF/Cos) dictionary representing the .
         *
         * Note: This constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @returns A promise that resolves to an object of type: "PDFNet.STree"
         */
        static create(struct_dict: PDFNet.Obj): Promise<PDFNet.STree>;
        /**
         * Create a structure tree if it is missing, else return the existing
         * structure tree
         * @param doc - the document in which to create or get the structure tree from
         * @returns A promise that resolves to structure tree of the document
         */
        static createFromPDFDoc(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc): Promise<PDFNet.STree>;
        /**
         * Inserts the specified kid element after the given position as a kid of
         * the specified structure tree root.
         * @param kid - The kid element to insert.
         * @param insert_before - The position after which the kid is inserted. If
         * element currently has no kids, insert_before is ignored.
         */
        insert(kid: PDFNet.SElement, insert_before: number): Promise<void>;
        /**
         * Copy Constructor
         * @returns A promise that resolves to an object of type: "PDFNet.STree"
         */
        copy(): Promise<PDFNet.STree>;
        /**
         * @returns A promise that resolves to true if this is a valid STree object, false otherwise.
         */
        isValid(): Promise<boolean>;
        /**
         * @returns A promise that resolves to the number of kids of the structure tree root.
         */
        getNumKids(): Promise<number>;
        /**
         * @param index - The index of the kid to obtain.
         * @returns A promise that resolves to the kid at an array index in the structure tree root.
         */
        getKid(index: number): Promise<PDFNet.SElement>;
        /**
         * @returns A promise that resolves to the RoleMap object from the structure tree root.
         */
        getRoleMap(): Promise<PDFNet.RoleMap>;
        /**
         * @returns A promise that resolves to the ClassMap object from the structure tree root.
         */
        getClassMap(): Promise<PDFNet.ClassMap>;
        /**
         * @returns A promise that resolves to pointer to the underlying SDF/Cos object.
         */
        getSDFObj(): Promise<PDFNet.Obj>;
    }
    /**
     * A screen annotation (PDF 1.5) specifies a region of a page upon which
     * media clips may be played. It also serves as an object from which
     * actions can be triggered.
     */
    class ScreenAnnot extends PDFNet.Annot {
        /**
         * creates a Screen annotation and initializes it using given Cos/SDF object.
         * @param [d] - The Cos/SDF object to initialze the annotation with.
         * Note: The constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @returns A promise that resolves to an object of type: "PDFNet.ScreenAnnot"
         */
        static createFromObj(d?: PDFNet.Obj): Promise<PDFNet.ScreenAnnot>;
        /**
         * creates a Screen annotation and initializes it using given annotation object.
         * @param ann - Annot object used to initialize the Screen annotation.
         * Note: The constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @returns A promise that resolves to an object of type: "PDFNet.ScreenAnnot"
         */
        static createFromAnnot(ann: PDFNet.Annot): Promise<PDFNet.ScreenAnnot>;
        /**
         * Returns the title of the annotation.
         * @returns A promise that resolves to a string representing the title of the annotation.
         */
        getTitle(): Promise<string>;
        /**
         * sets the title of the Annotation.
         * (Optional)
         * @param title - A string representing the title of the annotation.
         */
        setTitle(title: string): Promise<void>;
        /**
         * Creates a new Screen annotation in the specified document.
         * @param doc - A document to which the annotation is added.
         * @param pos - A rectangle specifying the annotation's bounds in default user space units.
         * @returns A promise that resolves to a newly created blank Screen annotation.
         */
        static create(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, pos: PDFNet.Rect): Promise<PDFNet.ScreenAnnot>;
        static create(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, type: number, pos: PDFNet.Rect): Promise<PDFNet.Annot>;
        /**
         * Returns the action of the Screen annotation
         * @returns A promise that resolves to an action object representing the action of the annotation.
         * Note: The action is an action that shall be performed when the annotation is activated.
         */
        getAction(): Promise<PDFNet.Action>;
        /**
         * sets the action of the Screen annotation
         * (Optional; PDF 1.1 )
         * @param action - An action object representing the action of the annotation.
         * Note: The action is an action that shall be performed when the annotation is activated.
         */
        setAction(action: PDFNet.Action): Promise<void>;
        /**
         * Returns the border color of the annotation.
         * @returns A promise that resolves to a color object that denotes the color of the Screen border.
         * Note: The color can be in different color spaces: Gray, RGB, or CMYK.
         * Call "GetBorderColorCompNum" to access the color space information corresponding to the border color.
         */
        getBorderColor(): Promise<PDFNet.ColorPt>;
        /**
         * sets the border color of the annotation.
         * (Optional)
         * @param col - A color object that denotes the color of the screen border.
         * @param numcomp - An integer which value indicates the color space used for the parameter c.
         */
        setBorderColor(col: PDFNet.ColorPt, numcomp: number): Promise<void>;
        /**
         * Returns the number indicating border color space of the annotation.
         * @returns A promise that resolves to an integer indicating a color space value from the ColorSpace::Type enum.
         * That is, 1 corresponding to "e_device_gray",
         * 3 corresponding to "e_device_rgb", and 4 corresponding to "e_device_cmyk".
         * 0 means this annotation had no color assigned.
         */
        getBorderColorCompNum(): Promise<number>;
        /**
         * Returns the number indicating background color space of the annotation.
         * @returns A promise that resolves to an integer indicating a color space value from the ColorSpace::Type enum.
         * That is, 1 corresponding to "e_device_gray",
         * 3 corresponding to "e_device_rgb", and 4 corresponding to "e_device_cmyk" if color space is applicable,
         * 0 means no background color was assigned.
         */
        getBackgroundColorCompNum(): Promise<number>;
        /**
         * Returns the background color of the annotation.
         * @returns A promise that resolves to a color object that denotes the color of the Screen background.
         * Note: The color can be in different color spaces: Gray, RGB, or CMYK.
         * Call "GetBackgroundColorCompNum" to access the color space information corresponding to the border color.
         */
        getBackgroundColor(): Promise<PDFNet.ColorPt>;
        /**
         * sets the background color of the annotation.
         * (Optional)
         * @param col - A color point that denotes the color of the screen background.
         * @param numcomp - An integer which value indicates the color space used for the parameter c.
         */
        setBackgroundColor(col: PDFNet.ColorPt, numcomp: number): Promise<void>;
        /**
         * Returns static caption text of the annotation.
         * @returns A promise that resolves to a string containing the static caption text of the annotation.
         * Note: The static caption is the annotation's normal caption, which
         * shall be displayed when it is not interacting with the user.
         */
        getStaticCaptionText(): Promise<string>;
        /**
         * sets static caption text of the annotation.
         * (Optional; button fields only)
         * @param contents - A string containing the static caption text of the annotation.
         * Note: The static caption is the annotation's normal caption, which
         * shall be displayed when it is not interacting with the user.
         */
        setStaticCaptionText(contents: string): Promise<void>;
        /**
         * Returns the rollover caption text of the annotation.
         * @returns A promise that resolves to a string containing the rollover caption text of the annotation.
         * Note: The rollover caption shall be displayed when the user rolls the cursor
         * into its active area without pressing the mouse button.
         */
        getRolloverCaptionText(): Promise<string>;
        /**
         * sets the roll over caption text of the annotation.
         * (Optional; button fields only)
         * @param contents - A string containing the roll over caption text of the annotation.
         * Note: The rollover caption shall be displayed when the user rolls the cursor
         * into its active area without pressing the mouse button.
         */
        setRolloverCaptionText(contents: string): Promise<void>;
        /**
         * Returns the button down caption text of the annotation.
         * @returns A promise that resolves to a string containing the button down text of the annotation.
         * Note: The button down caption shall be displayed when the mouse button is
         * pressed within its active area.
         */
        getMouseDownCaptionText(): Promise<string>;
        /**
         * sets the button down caption text of the annotation.
         * (Optional; button fields only)
         * @param contents - A string containing the button down text of the annotation.
         * Note: The button down caption shall be displayed when the mouse button is
         * pressed within its active area.
         */
        setMouseDownCaptionText(contents: string): Promise<void>;
        /**
         * Returns the static icon associated with the annotation.
         * @returns A promise that resolves to an SDF object that represents the static icon
         * associated with the annotation.
         * Note: The static icon object is a form XObject defining the
         * annotation's normal icon, which shall be
         * displayed when it is not interacting with the user.
         */
        getStaticIcon(): Promise<PDFNet.Obj>;
        /**
         * sets the static icon associated with the annotation.
         * (Optional; button fields only)
         * @param icon - An SDF object that represents the static icon
         * associated with the annotation.
         * Note: The static icon object is a form XObject defining the
         * annotation's normal icon, which shall be
         * displayed when it is not interacting with the user.
         */
        setStaticIcon(icon: PDFNet.Obj): Promise<void>;
        /**
         * Returns the rollover icon associated with the annotation.
         * @returns A promise that resolves to an SDF object that represents the rollover icon
         * associated with the annotation.
         * Note: The rollover icon object is a form XObject defining the
         * annotation's rollover icon, which shall be displayed
         * when the user rolls the cursor into its active area without
         * pressing the mouse button.
         */
        getRolloverIcon(): Promise<PDFNet.Obj>;
        /**
         * sets the rollover icon associated with the annotation.
         * (Optional; button fields only)
         * @param icon - An SDF object that represents the rollover icon
         * associated with the annotation.
         * Note: The rollover icon object is a form XObject defining the
         * annotation's rollover icon, which shall be displayed
         * when the user rolls the cursor into its active area without
         * pressing the mouse button.
         */
        setRolloverIcon(icon: PDFNet.Obj): Promise<void>;
        /**
         * Returns the Mouse Down icon associated with the annotation.
         * @returns A promise that resolves to an SDF object that represents the Mouse Down icon
         * associated with the annotation.
         * Note: The Mouse Down icon object is a form XObject defining the
         * annotation's alternate (down) icon, which shall be displayed
         * when the mouse button is pressed within its active area.
         */
        getMouseDownIcon(): Promise<PDFNet.Obj>;
        /**
         * sets the Mouse Down icon associated with the annotation.
         * (Optional; button fields only)
         * @param icon - An SDF object that represents the Mouse Down icon
         * associated with the annotation.
         * Note: The Mouse Down icon object is a form XObject defining the
         * annotation's alternate (down) icon, which shall be displayed
         * when the mouse button is pressed within its active area.
         */
        setMouseDownIcon(icon: PDFNet.Obj): Promise<void>;
        /**
         * Returns the Scale Type of the annotation.
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.ScreenAnnot.ScaleType = {
         * 	e_Anamorphic : 0
         * 	e_Proportional : 1
         * }
         * </pre>
         * @returns A promise that resolves to a value of the "ScaleType" enum which represents the Scale Type of the annotation.
         * Default value: P.
         */
        getScaleType(): Promise<number>;
        /**
         * sets the Scale Type of the annotation.
         * (Optional)
         * @param st - <pre>
         * PDFNet.ScreenAnnot.ScaleType = {
         * 	e_Anamorphic : 0
         * 	e_Proportional : 1
         * }
         * </pre>
         * An entry of the "ScaleType" enum which represents the Scale Type of the annotation.
         * Default value: P.
         */
        setScaleType(st: number): Promise<void>;
        /**
         * Returns the Icon and caption relationship of the  annotation.
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.ScreenAnnot.IconCaptionRelation = {
         * 	e_NoIcon : 0
         * 	e_NoCaption : 1
         * 	e_CBelowI : 2
         * 	e_CAboveI : 3
         * 	e_CRightILeft : 4
         * 	e_CLeftIRight : 5
         * 	e_COverlayI : 6
         * }
         * </pre>
         * @returns A promise that resolves to a value of the "IconCaptionRelation" enum type.
         * Default value: e_NoIcon.
         */
        getIconCaptionRelation(): Promise<number>;
        /**
         * sets the Icon and caption relationship of the  annotation.
         * (Optional; pushbutton fields only)
         * @param icr - <pre>
         * PDFNet.ScreenAnnot.IconCaptionRelation = {
         * 	e_NoIcon : 0
         * 	e_NoCaption : 1
         * 	e_CBelowI : 2
         * 	e_CAboveI : 3
         * 	e_CRightILeft : 4
         * 	e_CLeftIRight : 5
         * 	e_COverlayI : 6
         * }
         * </pre>
         * A value of the "IconCaptionRelation" enum type.
         * Default value: e_NoIcon.
         */
        setIconCaptionRelation(icr: number): Promise<void>;
        /**
         * Returns the condition under which the icon should be scaled.
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.ScreenAnnot.ScaleCondition = {
         * 	e_Always : 0
         * 	e_WhenBigger : 1
         * 	e_WhenSmaller : 2
         * 	e_Never : 3
         * }
         * </pre>
         * @returns A promise that resolves to a value of the "ScaleCondition" enum type.
         * Default value: e_Always.
         */
        getScaleCondition(): Promise<number>;
        /**
         * sets the condition under which the icon should be scaled.
         * (Optional)
         * @param sc - <pre>
         * PDFNet.ScreenAnnot.ScaleCondition = {
         * 	e_Always : 0
         * 	e_WhenBigger : 1
         * 	e_WhenSmaller : 2
         * 	e_Never : 3
         * }
         * </pre>
         * A value of the "ScaleCondition" enum type.
         * Default value: e_Always.
         */
        setScaleCondition(sc: number): Promise<void>;
        /**
         * Returns the "fit full" flag.
         * @returns A promise that resolves to a boolean value indicating the "fit full" flag value.
         * Note: the fit full flag, if true, indicates that the button
         * appearance shall be scaled to fit fully within the bounds of
         * the annotation without taking into consideration the line
         * width of the border.
         * Default value: false.
         */
        getFitFull(): Promise<boolean>;
        /**
         * sets the "fit full" flag.
         * (Optional)
         * @param ff - A boolean value indicating the "fit full" flag value.
         * Note: the fit full flag, if true, indicates that the button
         * appearance shall be scaled to fit fully within the bounds of
         * the annotation without taking into consideration the line
         * width of the border. Default value: false.
         */
        setFitFull(ff: boolean): Promise<void>;
        /**
         * Returns the horizontal leftover space of the icon within the annotation.
         * @returns A promise that resolves to a number indicating the horizontal
         * leftover space of the icon within the annotation.
         * Note: the horizontal leftover is a number that shall be between
         * 0.0 and 1.0 indicating the fraction of leftover space to allocate at the left.
         * A value of 0.0 shall position the icon at the left of the annotation rectangle.
         * A value of 0.5 shall center it in the horizontal direction within the rectangle.
         * This entry shall be used only if the icon is scaled proportionally.
         * Default value: 0.5.
         */
        getHIconLeftOver(): Promise<number>;
        /**
         * sets the horizontal leftover space of the icon within the annotation.
         * (Optional)
         * @param hl - A number indicating the horizontal
         * leftover space of the icon within the annotation.
         * Note: the horizontal leftover space is a number that shall be between
         * 0.0 and 1.0 indicating the fraction of leftover space to allocate at the left.
         * A value of 0.0 shall position the icon at the left of the annotation rectangle.
         * A value of 0.5 shall center it in the horizontal direction within the rectangle.
         * This entry shall be used only if the icon is scaled proportionally.
         * Default value: 0.5.
         */
        setHIconLeftOver(hl: number): Promise<void>;
        /**
         * Returns the vertical leftover space of the icon within the annotation.
         * @returns A promise that resolves to a number indicating the vertical
         * leftover space of the icon within the annotation.
         * Note: the vertical leftover space is a number that
         * shall be between 0.0 and 1.0 indicating the fraction of leftover
         * space to allocate at the bottom of the icon.
         * A value of 0.0 shall position the icon at the bottom
         * of the annotation rectangle.
         * A value of 0.5 shall center it in the vertical direction within
         * the rectangle.
         * This entry shall be used only if the icon is scaled proportionally.
         * Default value: 0.5.
         */
        getVIconLeftOver(): Promise<number>;
        /**
         * sets the vertical leftover space of the icon within the annotation.
         * (Optional)
         * @param vl - A number indicating the vertical
         * leftover space of the icon within the annotation.
         * Note: the vertical leftover space is a number that
         * shall be between 0.0 and 1.0 indicating the fraction of leftover
         * space to allocate at the bottom of the icon.
         * A value of 0.0 shall position the icon at the bottom
         * of the annotation rectangle.
         * A value of 0.5 shall center it in the vertical direction within
         * the rectangle.
         * This entry shall be used only if the icon is scaled proportionally.
         * Default value: 0.5.
         */
        setVIconLeftOver(vl: number): Promise<void>;
    }
    /**
     * Standard Security Handler is a standard password-based security handler.
     */
    class SecurityHandler extends PDFNet.Destroyable {
        /**
         * @param p - <pre>
         * PDFNet.SecurityHandler.Permission = {
         * 	e_owner : 1
         * 	e_doc_open : 2
         * 	e_doc_modify : 3
         * 	e_print : 4
         * 	e_print_high : 5
         * 	e_extract_content : 6
         * 	e_mod_annot : 7
         * 	e_fill_forms : 8
         * 	e_access_support : 9
         * 	e_assemble_doc : 10
         * }
         * </pre>
         * A Permission to be granted.
         *
         * Note: in order to check for permission the method will repeatedly (up to three
         * times) attempt to GetAuthorizationData() and Authorize() permission. If the
         * permission is not granted AuthorizeFailed() callback will be called. This callback
         * method allows derived class to provide UI feedback for failed authorization.
         * @returns A promise that resolves to true if the SecurityHandler permits the specified action (Permission p)
         * on the document, or false if the permission was not granted.
         */
        getPermission(p: number): Promise<boolean>;
        /**
         * @returns A promise that resolves to the length of the encryption key in bytes.
         * Note: The returned key length is given in bytes.
         */
        getKeyLength(): Promise<number>;
        /**
         * @returns A promise that resolves to the encryption algorithm identifier. A code specifying the algorithm
         * to be used in encrypting and decrypting the document. Returned number corresponds
         * to V entry in encryption dictionary. Currently allowed values are from 0-4.
         * See PDF Reference Manual for more details.
         */
        getEncryptionAlgorithmID(): Promise<number>;
        /**
         * @returns A promise that resolves to the name of the security handler as it appears in the serialized file
         * as the value of /Filter key in /Encrypt dictionary.
         */
        getHandlerDocName(): Promise<string>;
        /**
         * @returns A promise that resolves to true if the SecurityHandler was modified (by calling SetModified())
         * or false otherwise.
         *
         * If the user changes SecurityHandler's settings (e.g. by changing a password),
         * IsModified() should return true.
         */
        isModified(): Promise<boolean>;
        /**
         * The method allows derived classes to set SecurityHandler is modified flag.
         * This method should be called whenever there are changes (e.g. a password change)
         * to the SecurityHandler
         * @param [is_modified] - Value to set the SecurityHandler's is modified flag to
         */
        setModified(is_modified?: boolean): Promise<void>;
        /**
         * create a Standard Security Handler.
         * @param crypt_type - <pre>
         * PDFNet.SecurityHandler.AlgorithmType = {
         * 	e_RC4_40 : 1
         * 	e_RC4_128 : 2
         * 	e_AES : 3
         * 	e_AES_256 : 4
         * }
         * </pre>
         * The encryption algorithm identifier.
         * @returns A promise that resolves to an object of type: "PDFNet.SecurityHandler"
         */
        static create(crypt_type: number): Promise<PDFNet.SecurityHandler>;
        /**
         * create a Standard Security Handler.
         * @param name - The name of the Standard Security Handler.
         * @param key_len - The bit length of the encryption key (40 or 128 bit).
         * @param enc_code - The encryption algorithm identifier. The number corresponds
         * to the V entry in encryption dictionary. Currently allowed values are (see
         * Table 3.18 in PDF Reference Manual v1.6 for more details):
         *   1 : Encryption using 40-bit RC4 algorithm.
         *   2 : Encryption using 128-bit RC4 algorithm. Available in PDF 1.4 and above.
         *   3 : This algorithm was deprecated by PDF standard and is not supported.
         *   4 : Encryption using Crypt filters and 128-bit AES (Advanced Encryption
         *         Standard) algorithm. Available in PDF 1.6 and above.
         * @returns A promise that resolves to an object of type: "PDFNet.SecurityHandler"
         */
        static createFromEncCode(name: string, key_len: number, enc_code: number): Promise<PDFNet.SecurityHandler>;
        /**
         * Create a default Security Handler.
         * @returns A promise that resolves to a SecurityHandler object.
         */
        static createDefault(): Promise<PDFNet.SecurityHandler>;
        /**
         * Set the permission setting of the StdSecurityHandler.
         * @param perm - <pre>
         * PDFNet.SecurityHandler.Permission = {
         * 	e_owner : 1
         * 	e_doc_open : 2
         * 	e_doc_modify : 3
         * 	e_print : 4
         * 	e_print_high : 5
         * 	e_extract_content : 6
         * 	e_mod_annot : 7
         * 	e_fill_forms : 8
         * 	e_access_support : 9
         * 	e_assemble_doc : 10
         * }
         * </pre>
         * indicates a permission to set or clear. It can be any of the
         * following values:
         *
         * 	e_print				// print the document.
         * 	e_doc_modify		// edit the document more than adding or modifying text notes.
         * 	e_extract_content	// enable content extraction
         * 	e_mod_annot			// allow modifications to annotations
         * 	e_fill_forms		// allow changes to fill in forms
         * 	e_access_support	// content access for the visually impaired.
         * 	e_assemble_doc		// allow document assembly
         * 	e_print_high		// high resolution print.
         * @param value - true if the permission/s should be granted, false otherwise.
         */
        setPermission(perm: number, value: boolean): Promise<void>;
        /**
         * Change the revision number and the encryption algorithm of the
         * standard security handler.
         * @param rev_num - the new revision number of the standard security
         * algorithm. Currently allowed values for the revision number are
         * (see Table 3.18 in PDF Reference Manual v1.6 for more details):
         *   2 : Encryption using 40-bit RC4 algorithm.
         *   3 : Encryption using 128-bit RC4 algorithm. Available in PDF 1.4 and above.
         *   4 : Encryption using Crypt filters and 128-bit AES (Advanced Encryption
         *         Standard) algorithm. Available in PDF 1.6 and above.
         */
        changeRevisionNumber(rev_num: number): Promise<void>;
        /**
         * Indicates whether the document-level metadata stream is to
         * be encrypted.
         * @param encrypt_metadata - true if metadata stream should be
         * encrypted, false otherwise.
         *
         * Note: EncryptMetadata flag affects only Crypt filters available
         * in PDF 1.5 (Acrobat 6) and later. By default, metadata stream
         * will be encrypted.
         */
        setEncryptMetadata(encrypt_metadata: boolean): Promise<void>;
        /**
         * @returns A promise that resolves to the revision number of the standard security algorithm.
         */
        getRevisionNumber(): Promise<number>;
        /**
         * @returns A promise that resolves to true if the SecurityHandler requires a user password.
         */
        isUserPasswordRequired(): Promise<boolean>;
        /**
         * @returns A promise that resolves to true if the SecurityHandler requires a master (owner) password.
         */
        isMasterPasswordRequired(): Promise<boolean>;
        /**
         * @returns A promise that resolves to true is this security handler uses 128 bit AES (Advanced Encryption Standard)
         * algorithm to encrypt strings or streams.
         */
        isAES(): Promise<boolean>;
        /**
         * The following function can be used to verify whether a given stream is
         * encrypted using AES.
         * @param stream - A pointer to an SDF::Stream object
         * @returns A promise that resolves to true if the given stream is encrypted using AES encryption.
         */
        isAESObj(stream: PDFNet.Obj): Promise<boolean>;
        /**
         * @returns A promise that resolves to true is this security handler uses RC4 algorithm to encrypt strings or streams.
         */
        isRC4(): Promise<boolean>;
        /**
         * Sets the new user password.
         * @param password - The new user password.
         */
        changeUserPasswordUString(password: string): Promise<void>;
        /**
         * Sets the new user password.
         * @param password - The new user password.
         */
        changeUserPasswordBuffer(password: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray): Promise<void>;
        /**
         * Sets the new master/owner password.
         * @param password - The new master/owner password.
         */
        changeMasterPasswordUString(password: string): Promise<void>;
        /**
         * Sets the new master/owner password.
         * @param password_buf - The new master/owner password.
         */
        changeMasterPasswordBuffer(password_buf: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray): Promise<void>;
        /**
         * this method can be called in GetAuthorizationData() callback to
         * specify user supplied password.
         */
        initPasswordUString(password: string): Promise<void>;
        /**
         * this method can be called in GetAuthorizationData() callback to
         * specify user supplied password.
         */
        initPasswordBuffer(password_buf: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray): Promise<void>;
        /**
         * Set the new user password to a binary string
         * @param password - the new user password
         */
        changeUserPasswordNonAscii(password: string): Promise<void>;
        /**
         * Set the new master password to a binary string
         * @param password - the new user password
         */
        changeMasterPasswordNonAscii(password: string): Promise<void>;
        /**
         * the method can be called in GetAuthorizationData() callback to
        specify user supplied ASCII password.
         * @param password - user supplied ASCII password
         */
        initPassword(password: string): Promise<void>;
        /**
         * the method can be called in GetAuthorizationData() callback to
        specify user supplied non-ASCII password.
         * @param password - user supplied non-ASCII password
         */
        initPasswordNonAscii(password: string): Promise<void>;
    }
    /**
     * Shading is a class that represents a flat interface around all PDF shading types:
     *
     *  - In Function-based (type 1) shadings, the color at every point in
     *    the domain is defined by a specified mathematical function. The function need
     *    not be smooth or continuous. This is the most general of the available shading
     *    types, and is useful for shadings that cannot be adequately described with any
     *    of the other types.
     *
     *  - Axial shadings (type 2) define a color blend along a line between two points,
     *    optionally extended beyond the boundary points by continuing the boundary
     *    colors.
     *
     *  - Radial shadings (type 3) define a color blend that varies between two circles.
     *    Shadings of this type are commonly used to depict three-dimensional spheres
     *    and cones.
     *
     *  - Free-form Gouraud-shaded triangle mesh shadings (type 4) and lattice Gouraud
     *    shadings (type 5) are commonly used to represent complex colored and shaded
     *    three-dimensional shapes. The area to be shaded is defined by a path composed entirely
     *    of triangles. The color at each vertex of the triangles is specified, and a technique
     *    known as Gouraud interpolation is used to color the interiors. The interpolation
     *    functions defining the shading may be linear or nonlinear.
     *
     *  - Coons patch mesh shadings (type 6) are constructed from one or more color
     *    patches, each bounded by four cubic Bezier curves.
     *
     *    A Coons patch generally has two independent aspects:
     *    - Colors are specified for each corner of the unit square, and bilinear
     *      interpolation is used to fill in colors over the entire unit square<BR>
     *    - Coordinates are mapped from the unit square into a four-sided patch whose
     *      sides are not necessarily linear. The mapping is continuous: the corners
     *      of the unit square map to corners of the patch and the sides of the unit
     *      square map to sides of the patch.
     *
     *  - Tensor-product patch mesh shadings (type 7) are identical to type 6
     *    (Coons mesh), except that they are based on a bicubic tensor-product
     *    patch defined by 16 control points, instead of the 12 control points
     *    that define a Coons patch. The shading Patterns dictionaries representing
     *    the two patch types differ only in the value of the Type entry and
     *    in the number of control points specified for each patch in the data stream.
     *    Although the Coons patch is more concise and easier to use, the tensor-
     *    product patch affords greater control over color mapping.
     */
    class Shading extends PDFNet.Destroyable {
        /**
         * Create a Shading from the given SDF/Cos object listed under /Shading entry
         * in the page Resource dictionary. If shading_dict dictionary is null, a non valid Shading
         * object is created.
         * @returns A promise that resolves to an object of type: "PDFNet.Shading"
         */
        static create(shading_dict?: PDFNet.Obj): Promise<PDFNet.Shading>;
        /**
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.Shading.Type = {
         * 	e_function_shading : 0
         * 	e_axial_shading : 1
         * 	e_radial_shading : 2
         * 	e_free_gouraud_shading : 3
         * 	e_lattice_gouraud_shading : 4
         * 	e_coons_shading : 5
         * 	e_tensor_shading : 6
         * 	e_null : 7
         * }
         * </pre>
         * @param shading_dict - SDF/Cos shading dictionary to get the Type from
         * @returns A promise that resolves to the Type of a given SDF/Cos shading dictionary, or e_null for if
         * SDF object is not a valid shading object
         */
        static getTypeFromObj(shading_dict: PDFNet.Obj): Promise<number>;
        /**
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.Shading.Type = {
         * 	e_function_shading : 0
         * 	e_axial_shading : 1
         * 	e_radial_shading : 2
         * 	e_free_gouraud_shading : 3
         * 	e_lattice_gouraud_shading : 4
         * 	e_coons_shading : 5
         * 	e_tensor_shading : 6
         * 	e_null : 7
         * }
         * </pre>
         * @returns A promise that resolves to the shading type
         */
        getType(): Promise<number>;
        /**
         * @returns A promise that resolves to the underlying SDF/Cos object
         */
        getSDFObj(): Promise<PDFNet.Obj>;
        /**
         * @returns A promise that resolves to the color space in which color values are expressed.
         * This may be any device, CIE-based, or special color space
         * except a Pattern space.
         */
        getBaseColorSpace(): Promise<PDFNet.ColorSpace>;
        /**
         * @returns A promise that resolves to true if shading has a bounding box, false otherwise.
         */
        hasBBox(): Promise<boolean>;
        /**
         * @returns A promise that resolves to a rectangle giving the left, bottom, right, and top
         * coordinates, respectively, of the shading's bounding box. The coordinates
         * are interpreted in the shading's target coordinate space. If present, this
         * bounding box is applied as a temporary clipping boundary when the shading
         * is painted, in addition to the current clipping path and any other clipping
         * boundaries in effect at that time.
         *
         * Note: Use HasBBox() method to determine whether the shading has a
         * background color.
         */
        getBBox(): Promise<PDFNet.Rect>;
        /**
         * @returns A promise that resolves to true if the shading has a background color or false otherwise.
         */
        hasBackground(): Promise<boolean>;
        /**
         * An color point represented in base color space specifying a single
         * background color value. If present, this color is used before
         * any painting operation involving the shading, to fill those portions of the
         * area to be painted that lie outside the bounds of the shading object itself.
         * In the opaque imaging model, the effect is as if the painting operation were
         * performed twice: first with the background color and then again with the
         * shading.
         *
         * Note: The background color is applied only when the shading is used as part
         * of a shading pattern, not when it is painted directly with the sh operator.
         *
         * Note: Use HasBackground() method to determine whether the shading has a
         * background color.
         * @returns A promise that resolves to an object of type: "PDFNet.ColorPt"
         */
        getBackground(): Promise<PDFNet.ColorPt>;
        /**
         * @returns A promise that resolves to a flag indicating whether to filter the shading function to prevent
         * aliasing artifacts. See Table 4.25
         */
        getAntialias(): Promise<boolean>;
        /**
         * @returns A promise that resolves to a number specifying the limiting value of a parametric variable t.
         * The variable is considered to vary linearly between GetParamStart() and
         * GetParamEnd() as the color gradient varies between the starting and ending points
         * of the axis for Axial shading or circles for Radial shading.
         * The variable t becomes the input argument to the color function(s).
         * Note: the returned value corresponds to the first value in Domain array.
         *
         * Note: for shadings other than Axial or Radial this method throws an exception.
         */
        getParamStart(): Promise<number>;
        /**
         * @returns A promise that resolves to a number specifying the limiting value of a parametric variable t.
         * The variable is considered to vary linearly between GetParamStart() and
         * GetParamEnd() as the color gradient varies between the starting and ending points
         * of the axis for Axial shading or circles for Radial shading.
         * The variable t becomes the input argument to the color function(s).
         * Note: the returned value corresponds to the second value in Domain array.
         *
         * Note: for shadings other than Axial or Radial this method throws an exception.
         */
        getParamEnd(): Promise<number>;
        /**
         * @returns A promise that resolves to a flag specifying whether to extend the shading beyond the starting
         * point of the axis for Axial shading or starting circle for Radial shading.
         *
         * Note: for shadings other than Axial or Radial this method throws an exception.
         */
        isExtendStart(): Promise<boolean>;
        /**
         * @returns A promise that resolves to a flag specifying whether to extend the shading beyond the ending
         * point of the axis for Axial shading or ending circle for Radial shading.
         *
         * Note: for shadings other than Axial or Radial this method throws an exception.
         */
        isExtendEnd(): Promise<boolean>;
        /**
         * @returns A promise that resolves to a color point for the given value of parametric variable t.
         *
         * Note: for shadings other than Axial or Radial this method throws an exception.
         */
        getColor(t: number): Promise<PDFNet.ColorPt>;
        /**
         * @returns A promise that resolves to an object of type: "Object"
         */
        getCoords(): Promise<object>;
        /**
         * @returns A promise that resolves to for Radial shading returns six numbers (x0 y0 r0 x1 y1 r1) specifying
         * the centers and radii of the starting and ending circles, expressed in the
         * shading's target coordinate space. The radii r0 and r1 must both be greater
         * than or equal to 0. If one radius is 0, the corresponding circle is treated
         * as a point; if both are 0, nothing is painted.
         *
         * Note: for shadings other than Radial this method throws an exception.
         */
        getCoordsRadial(): Promise<object>;
        /**
         * @returns A promise that resolves to an array of four numbers [xmin xmax ymin ymax] specifying the rectangular
         * domain of coordinates over which the color function(s) are defined.
         * If the function does not contain /Domain entry the function returns: [0 1 0 1].
         *
         * Note: for shadings other than Function this method throws an exception.
         */
        getDomain(): Promise<object>;
        /**
         * @returns A promise that resolves to a matrix specifying a mapping from the coordinate space specified
         * by the Domain entry into the shading's target coordinate space.
         *
         * Note: for shadings other than Function this method throws an exception.
         */
        getMatrix(): Promise<PDFNet.Matrix2D>;
        /**
         * @returns A promise that resolves to a color point for the given value of parametric variable (t1, t2).
         *
         * Note: for shadings other than Function this method throws an exception.
         */
        getColorForFunction(t1: number, t2: number): Promise<PDFNet.ColorPt>;
    }
    /**
     * The class ShapedText.
     * A sequence of positioned glyphs -- the visual representation of a
     * given text string
     */
    class ShapedText extends PDFNet.Destroyable {
        /**
         * Scaling factor of this shaped text relative to the em size. A scaling factor of 1 means that all units are relative to the em size. PDF scaling is typically 1000 units per em.
         * @returns A promise that resolves to returns the scaling factor for the glyph positions.
         */
        getScale(): Promise<number>;
        /**
         * Get the state of the shaping operation. Even if the shaping did not fully succeed, this object can be added to an elementbuilder, and will fallback to placing unshped text. See GetFailureReason() in the case this method returns something other than FullShaping.
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.ShapedText.ShapingStatus = {
         * 	e_FullShaping : 0
         * 	e_PartialShaping : 1
         * 	e_NoShaping : 2
         * }
         * </pre>
         * @returns A promise that resolves to .
         */
        getShapingStatus(): Promise<number>;
        /**
         * In the case where GetShapingStatus() returns something other than FullShaping, this method will return a more detailed reason behind the failure.
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.ShapedText.FailureReason = {
         * 	e_NoFailure : 0
         * 	e_UnsupportedFontType : 1
         * 	e_NotIndexEncoded : 2
         * 	e_FontDataNotFound : 3
         * }
         * </pre>
         * @returns A promise that resolves to .
         */
        getFailureReason(): Promise<number>;
        /**
         * The original source text string.
         * @returns A promise that resolves to returns the source text string.
         */
        getText(): Promise<string>;
        /**
         * Number of glyphs present in the shaped text. Might be different from the .
         * @returns A promise that resolves to returns the number of utf32 codepoints in this shaped text.
         */
        getNumGlyphs(): Promise<number>;
        /**
         * Get the glyph ID at the indicated place in the shaped sequence. This number is specific to the font file used to generate the shaping results, and does not always have a clean mapping to a particular Unicode codepoint in the original string.
         * @param index - - the index of the glyph to be retrieved. Must be less than GetNumGlyphs().
         * @returns A promise that resolves to returns the glyph ID for the indicated place in the shaped result.
         */
        getGlyph(index: number): Promise<number>;
        /**
         * The X position of the glyph at the requested index. This number has been scaled by GetScale().
         * @param index - - the index of the glyph position to be retrieved. Must be less than GetNumGlyphs().
         * @returns A promise that resolves to returns the X position for the glyph at the specified index.
         */
        getGlyphXPos(index: number): Promise<number>;
        /**
         * The Y position of the glyph at the requested index. This number has been scaled by GetScale().
         * @param index - - the index of the glyph position to be retrieved. Must be less than GetNumGlyphs().
         * @returns A promise that resolves to returns the Y position for the glyph at the specified index.
         */
        getGlyphYPos(index: number): Promise<number>;
    }
    /**
     * SignatureHandler instances are responsible for defining the digest and cipher algorithms to create
     * and/or validate a signed PDF document. SignatureHandlers are added to PDFDoc instances by
     * calling the [PDFDoc].addSignatureHandler method.
     */
    class SignatureHandler {
        /**
         * Gets the name of this SignatureHandler. The name of the SignatureHandler is what identifies this SignatureHandler
         * from all others. This name is also added to the PDF as the value of /Filter entry in the signature dictionary.
         * @returns A promise that resolves to the name of this SignatureHandler.
         */
        getName(): Promise<string>;
        /**
         * Resets any data appending and signature calculations done so far. This method should allow PDFNet to restart the
         * whole signature calculation process. It is important that when this method is invoked, any data processed with
         * the AppendData method should be discarded.
         * @returns A promise that resolves to true if there are no errors, otherwise false.
         */
        reset(): Promise<boolean>;
        /**
         * Destructor
         */
        destructor(): Promise<void>;
    }
    /**
     * An object representing a Signature used in a PDF Form. These Widgets can be signed directly, or signed using a DigitalSignatureField.
     */
    class SignatureWidget extends PDFNet.WidgetAnnot {
        /**
         * Creates a new SignatureWidget annotation in the specified document, and adds an associated signature form field to the document.
         * @param doc - The document to which the widget is to be added.
         * @param pos - A rectangle specifying the widget's bounds in default user space units.
         * @param [field_name] - The name of the digital signature field to create. Optional autogenerated by default.
         * @returns A promise that resolves to a newly-created blank SignatureWidget annotation.
         */
        static create(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, pos: PDFNet.Rect, field_name?: string): Promise<PDFNet.SignatureWidget>;
        static create(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, pos: PDFNet.Rect, field: PDFNet.Field): Promise<PDFNet.WidgetAnnot>;
        static create(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, type: number, pos: PDFNet.Rect): Promise<PDFNet.Annot>;
        /**
         * Creates a new SignatureWidget annotation associated with a particular form field in the specified document.
         * @param doc - The document to which the widget is to be added.
         * @param pos - A rectangle specifying the widget's bounds in default user space units.
         * @param field - The digital signature field for which to create a signature widget.
         * @returns A promise that resolves to a newly-created blank SignatureWidget annotation.
         */
        static createWithField(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, pos: PDFNet.Rect, field: PDFNet.Field): Promise<PDFNet.SignatureWidget>;
        /**
         * Creates a new SignatureWidget annotation associated with a particular DigitalSignatureField object (representing a signature-type form field) in the specified document.
         * @param doc - The document to which the widget is to be added.
         * @param pos - A rectangle specifying the widget's bounds in default user space units.
         * @param field - The digital signature field for which to create a signature widget.
         * @returns A promise that resolves to a newly-created blank SignatureWidget annotation.
         */
        static createWithDigitalSignatureField(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, pos: PDFNet.Rect, field: PDFNet.DigitalSignatureField): Promise<PDFNet.SignatureWidget>;
        /**
         * Creates a SignatureWidget annotation and initializes it using given Cos/SDF object.
         * @param [d] - the input Cos/SDF object
         * Note: The constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @returns A promise that resolves to an object of type: "PDFNet.SignatureWidget"
         */
        static createFromObj(d?: PDFNet.Obj): Promise<PDFNet.SignatureWidget>;
        /**
         * Creates a Widget annotation and initializes it using given annotation object.
         * @param annot - the annot
         * Note: The constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @returns A promise that resolves to an object of type: "PDFNet.SignatureWidget"
         */
        static createFromAnnot(annot: PDFNet.Annot): Promise<PDFNet.SignatureWidget>;
        /**
         * a function that will create and add an appearance to this widget
         * by centering an image within it.
         * @param img - A PDF::Image object representing the image to use.
         */
        createSignatureAppearance(img: PDFNet.Image): Promise<void>;
        /**
         * Retrieves the DigitalSignatureField associated with this SignatureWidget.
         * @returns A promise that resolves to a DigitalSignatureField object representing the digital signature form field associated with this signature widget annotation.
         */
        getDigitalSignatureField(): Promise<PDFNet.DigitalSignatureField>;
    }
    /**
     * A Sound annotation represents a sound recording attached to a point in
     * the PDF document. When closed, this annotation appear as an icon; when open
     * and activated, a sound record from the computer's microphone or imported from a file
     * associated with this annotation is played.The icon of this annotation by default
     * is a speaker.
     */
    class SoundAnnot extends PDFNet.MarkupAnnot {
        /**
         * creates a Sound annotation and initializes it using given Cos/SDF object.
         * @param [d] - The Cos/SDF object to initialze the annotation with.
         * Note: The constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @returns A promise that resolves to an object of type: "PDFNet.SoundAnnot"
         */
        static createFromObj(d?: PDFNet.Obj): Promise<PDFNet.SoundAnnot>;
        /**
         * creates a Sound annotation and initializes it using given annotation object.
         * @param ann - Annot object used to initialize the Sound annotation.
         * Note: The constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @returns A promise that resolves to an object of type: "PDFNet.SoundAnnot"
         */
        static createFromAnnot(ann: PDFNet.Annot): Promise<PDFNet.SoundAnnot>;
        /**
         * Constructor
         * @returns A promise that resolves to an object of type: "PDFNet.SoundAnnot"
         */
        static create(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, pos: PDFNet.Rect): Promise<PDFNet.SoundAnnot>;
        static create(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, type: number, pos: PDFNet.Rect): Promise<PDFNet.Annot>;
        /**
         * @returns A promise that resolves to an object of type: "PDFNet.SoundAnnot"
         */
        static createWithData(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, pos: PDFNet.Rect, stream: PDFNet.Filter, sample_bits: number, sample_freq: number, num_channels: number): Promise<PDFNet.SoundAnnot>;
        /**
         * @returns A promise that resolves to an object of type: "PDFNet.SoundAnnot"
         */
        static createAtPoint(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, pos: PDFNet.Point): Promise<PDFNet.SoundAnnot>;
        /**
         * Returns the sound object of the Sound annotation.
         * @returns A promise that resolves to an SDF object representing a sound stream.
         * Note: The sound stream is to be played when the Sound
         * annotation is activated.
         */
        getSoundStream(): Promise<PDFNet.Obj>;
        /**
         * sets the sound object of the Sound annotation.
         * @param icon - An SDF object representing a sound stream.
         * Note: The sound stream is to be played when the Sound
         * annotation is activated.
         */
        setSoundStream(icon: PDFNet.Obj): Promise<void>;
        /**
         * Returns the Icon of the Sound annotation.
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.SoundAnnot.Icon = {
         * 	e_Speaker : 0
         * 	e_Mic : 1
         * 	e_Unknown : 2
         * }
         * </pre>
         * @returns A promise that resolves to a value of the "Icon" enum.
         * Default value: e_Speaker.
         * Note: The Icon defines the appearance associated with the Sound annotation.
         * The annotation's appearance stream, if present, will take
         * precedence over this entry.
         */
        getIcon(): Promise<number>;
        /**
         * sets the Icon of the Sound annotation.
         * (Optional)
         * @param [type] - <pre>
         * PDFNet.SoundAnnot.Icon = {
         * 	e_Speaker : 0
         * 	e_Mic : 1
         * 	e_Unknown : 2
         * }
         * </pre>
         * A value of the "Icon" enumeration type specifying the icon to display.
         * Default value: e_Speaker.
         * Note: The Icon defines the appearance associated with the Sound annotation.
         * The annotation's appearance stream, if present, will take
         * precedence over this entry.
         */
        setIcon(type?: number): Promise<void>;
        /**
         * Returns the Icon name of the Sound annotation.
         * @returns A promise that resolves to a string denoting the Icon name of the Sound annotation.
         * Note: The following Icon names are equivalent
         * to predefined Icons from the enum "Icon":
         * "Speaker" = e_Speaker
         * "Mic" = e_Mic
         * "Unknown" = e_Unknown
         * The Icon defines the appearance associated with the Sound annotation.
         * Names other than mentioned above do not have predefined icon appearances.
         * The annotation's appearance stream, if present, will take
         * precedence over this entry.
         */
        getIconName(): Promise<string>;
        /**
         * sets the Icon name of the Sound annotation.
         * (Optional)
         * @param type - A string denoting the Icon name of the Sound annotation.
         * Note: The following Icon names are equivalent
         * to predefined types from the enum "Icon":
         * "Speaker" = e_Speaker
         * "Mic" = e_Mic
         * "Unknown" = e_Unknown
         * The Icon defines the appearance associated with the Sound annotation.
         * Names other than mentioned above do not have predefined icon appearances.
         * The annotation's appearance stream, if present, will take
         * precedence over this entry.
         */
        setIconName(type: string): Promise<void>;
    }
    /**
     * Square annotation is used to display a rectangle on the page. When opened,
     * a square annotation can display a pop-up window containing the text of the
     * associated note. The rectangle may be inscribed and possibly padded within the
     * annotation rectangle defined by the annotation dictionary's Rect entry.
     */
    class SquareAnnot extends PDFNet.MarkupAnnot {
        /**
         * creates an Square annotation and initializes it using given Cos/SDF object.
         * @param [d] - The Cos/SDF object to initialze the annotation with.
         * Note: The constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @returns A promise that resolves to an object of type: "PDFNet.SquareAnnot"
         */
        static createFromObj(d?: PDFNet.Obj): Promise<PDFNet.SquareAnnot>;
        /**
         * creates a Square annotation and initializes it using given annotation object.
         * @param ann - Annot object used to initialize the Square annotation.
         * Note: The constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @returns A promise that resolves to an object of type: "PDFNet.SquareAnnot"
         */
        static createFromAnnot(ann: PDFNet.Annot): Promise<PDFNet.SquareAnnot>;
        /**
         * Creates a new Square annotation in the specified document.
         * @param doc - A document to which the annotation is added.
         * @param pos - A rectangle specifying the annotation's bounds, in user space coordinates.
         * @returns A promise that resolves to a newly created blank Square annotation.
         */
        static create(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, pos: PDFNet.Rect): Promise<PDFNet.SquareAnnot>;
        static create(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, type: number, pos: PDFNet.Rect): Promise<PDFNet.Annot>;
        /**
         * @returns A promise that resolves to an object of type: "PDFNet.ColorPt"
         */
        getInteriorColor(): Promise<PDFNet.ColorPt>;
        /**
         * @returns A promise that resolves to an object of type: "number"
         */
        getInteriorColorCompNum(): Promise<number>;
        setInteriorColorDefault(col: PDFNet.ColorPt): Promise<void>;
        setInteriorColor(col: PDFNet.ColorPt, numcomp: number): Promise<void>;
        /**
         * @returns A promise that resolves to an object of type: "PDFNet.Rect"
         */
        getContentRect(): Promise<PDFNet.Rect>;
        setContentRect(cr: PDFNet.Rect): Promise<void>;
        /**
         * @returns A promise that resolves to an object of type: "PDFNet.Rect"
         */
        getPadding(): Promise<PDFNet.Rect>;
        setPadding(cr: PDFNet.Rect): Promise<void>;
    }
    /**
     * A Squiggly annotation shows as a wavy line segment across the bottom
     * of a word or a group of contiguous words.
     */
    class SquigglyAnnot extends PDFNet.TextMarkupAnnot {
        /**
         * creates a Squiggly annotation and initializes it using given Cos/SDF object.
         * @param d - The Cos/SDF object to initialze the annotation with.
         * Note: The constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @returns A promise that resolves to an object of type: "PDFNet.SquigglyAnnot"
         */
        static createFromObj(d: PDFNet.Obj): Promise<PDFNet.SquigglyAnnot>;
        /**
         * creates a Squiggly annotation and initializes it using given annotation object.
         * @param ann - Annot object used to initialize the Squiggly annotation.
         * Note: The constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @returns A promise that resolves to an object of type: "PDFNet.SquigglyAnnot"
         */
        static createFromAnnot(ann: PDFNet.Annot): Promise<PDFNet.SquigglyAnnot>;
        /**
         * Creates a new Squiggly annotation in the specified document.
         * @param doc - A document to which the Popup annotation is added.
         * @param pos - A rectangle specifying the Popup annotation's bounds in default user space units.
         * @returns A promise that resolves to a newly created blank Squiggly annotation.
         */
        static create(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, pos: PDFNet.Rect): Promise<PDFNet.SquigglyAnnot>;
        static create(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, type: number, pos: PDFNet.Rect): Promise<PDFNet.Annot>;
    }
    /**
     * Stamper is a utility class that can be used to stamp PDF pages with text, images,
     * or vector art (including another PDF page) in only a few lines of code.
     *
     * Although Stamper is very simple to use compared to ElementBuilder/ElementWriter
     * it is not as powerful or flexible. In case you need full control over PDF creation
     * use ElementBuilder/ElementWriter to add new content to existing PDF pages as
     * shown in the ElementBuilder sample project.
     */
    class Stamper extends PDFNet.Destroyable {
        /**
         * Stamper constructor
         * @param size_type - <pre>
         * PDFNet.Stamper.SizeType = {
         * 	e_relative_scale : 1
         * 	e_absolute_size : 2
         * 	e_font_size : 3
         * }
         * </pre>
         * Specifies how the stamp will be sized
         * 		-e_relative_scale: Stamp size is relative to the size of the crop box of
         * 		the destination page. 'a' is a percentage of the width of the crop box
         * 		(e.g.: 0.5 is 50% of the width of the crop box) 'b' is a percentage of the
         * 		height of the crop box. If 'a' <= 0 then only b will be used. If 'b' <= 0
         * 		then only 'a' will be used.
         *
         * 		-e_absolute_scale: Stamp size is explicitly set. 'a' sets the width of
         * 		of the stamp's bounding box. 'b' sets the height of the stamp's bounding
         * 		box. The width and height are constant, regardless of the size of the
         * 		destination page's bounding box.
         *
         * 		-e_font_size: This type only applies to text stamps. 'a' sets the font
         * 		size. 'b' is ignored.
         * @param a - @see size_type
         * @param b - @see size_type
         * @returns A promise that resolves to an object of type: "PDFNet.Stamper"
         */
        static create(size_type: number, a: number, b: number): Promise<PDFNet.Stamper>;
        /**
         * Stamps an image to the given destination document at the set of page numbers
         * @param dest_doc - The document being stamped
         * @param img - The image that is being stamped to the document
         * @param dest_pages - The set of pages in the document being stamped
         */
        stampImage(dest_doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, img: PDFNet.Image, dest_pages: PDFNet.PageSet): Promise<void>;
        /**
         * Stamps a PDF page to the given destination document at the set of page numbers
         * @param dest_doc - The document being stamped
         * @param page - The page that is being stamped to the document
         * @param dest_pages - The set of pages in the document being stamped
         */
        stampPage(dest_doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, page: PDFNet.Page, dest_pages: PDFNet.PageSet): Promise<void>;
        /**
         * Stamps text to the given destination document at the set of page numbers
         * @param dest_doc - The document being stamped
         * @param txt - The image that is being stamped to the document
         * @param dest_pages - The set of pages in the document being stamped
         */
        stampText(dest_doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, txt: string, dest_pages: PDFNet.PageSet): Promise<void>;
        /**
         * Defines the font of the stamp. (This only applies to text-based stamps)
         * @param font - The font of the text stamp
         */
        setFont(font: PDFNet.Font): Promise<void>;
        /**
         * Sets the font color (This only effects text-based stamps)
         * @param font_color - The color of the font
         */
        setFontColor(font_color: PDFNet.ColorPt): Promise<void>;
        /**
         * Sets the text alignment (note: this only applies to text watermarks)
         * @param text_alignment - <pre>
         * PDFNet.Stamper.TextAlignment = {
         * 	e_align_left : -1
         * 	e_align_center : 0
         * 	e_align_right : 1
         * }
         * </pre>
         * Enumerator for text alignment (e_left, e_center, e_right)
         */
        setTextAlignment(text_alignment: number): Promise<void>;
        /**
         * Sets the opacity value for the stamp
         * @param opacity - The opacity value of the stamp
         */
        setOpacity(opacity: number): Promise<void>;
        /**
         * Rotates the stamp by the given number of degrees
         * @param rotation - Rotation in degrees
         */
        setRotation(rotation: number): Promise<void>;
        /**
         * Specifies if the stamp is to be stamped in the background or the foreground.
         * @param background - A flag specifying if the stamp should be added
         * as a background layer to the destination page
         */
        setAsBackground(background: boolean): Promise<void>;
        /**
         * Specifies if the stamp is to be stamped as an annotation.
         * @param annotation - A flag specifying if the stamp should be added
         * as an annotation or not
         *
         * Note: Stamps created with this setting do not work with SetAsBackground,
         * HasStamps, and DeleteStamps, if annotation is true.
         */
        setAsAnnotation(annotation: boolean): Promise<void>;
        /**
         * @param on_screen - Specifies if the watermark will be displayed on screen
         */
        showsOnScreen(on_screen: boolean): Promise<void>;
        /**
         * @param on_print - Specifies if the watermark will be displayed when printed
         */
        showsOnPrint(on_print: boolean): Promise<void>;
        /**
         * Sets the alignment for the x and y variables.
         * @param horizontal_alignment - <pre>
         * PDFNet.Stamper.HorizontalAlignment = {
         * 	e_horizontal_left : -1
         * 	e_horizontal_center : 0
         * 	e_horizontal_right : 1
         * }
         * </pre>
         * Can be set to e_left, e_center or e_right
         * 		e_left:	horizontal_distance measures the distance between the left edge of the stamp's
         * 			bounding box and the left edge of the crop box
         * 		e_center: horizontal_distance measures the distance between the horizontal bisector of the
         * 			stamp's bounding box and the horizontal bisector of the crop box
         * 		e_right: horizontal_distance measures the distance between the right edge of the stamp's
         * 			bounding box and the right edge of the crop box
         * @param vertical_alignment - <pre>
         * PDFNet.Stamper.VerticalAlignment = {
         * 	e_vertical_bottom : -1
         * 	e_vertical_center : 0
         * 	e_vertical_top : 1
         * }
         * </pre>
         * Can be set to e_top, e_center or e_bottom
         * 		e_bottom: vertical_distance measures the distance between the bottom edge of the stamp's
         * 			bounding box and the bottom edge of the crop box
         * 		e_center: vertical_distance measures the distance between the vertical bisector of the
         * 			stamp's bounding box and the vertical bisector of the crop box
         * 		e_top: vertical_distance measures the distance between the top edge of the stamp's
         * 			bounding box and the top edge of the crop box
         */
        setAlignment(horizontal_alignment: number, vertical_alignment: number): Promise<void>;
        /**
         * Sets the horizontal and vertical position of the stamp.
         * @param horizontal_distance - Horizontal distance from left, right or center of crop box
         * @param vertical_distance - Vertical distance from top, bottom or center of crop box
         * @param [use_percentage] - If true, horizontal_distance is a percentage of the crop
         * box width (e.g.: 0.5 is 50% of the width of the crop box) and vertical_distance
         * is a percentage of the crop box height. If false, horizontal_distance and
         * vertical_distance is measured in points.
         */
        setPosition(horizontal_distance: number, vertical_distance: number, use_percentage?: boolean): Promise<void>;
        /**
         * sets the size of the stamp
         * @param size_type - <pre>
         * PDFNet.Stamper.SizeType = {
         * 	e_relative_scale : 1
         * 	e_absolute_size : 2
         * 	e_font_size : 3
         * }
         * </pre>
         * Specifies how the stamp will be sized
         * 		-e_relative_scale: Stamp size is relative to the size of the crop box of
         * 		the destination page. 'a' is a percentage of the width of the crop box
         * 		(e.g.: 0.5 is 50% of the width of the crop box) 'b' is a percentage of the
         * 		height of the crop box. If 'a' <= 0 then only b will be used. If 'b' <= 0
         * 		then only 'a' will be used.
         *
         * 		-e_absolute_scale: Stamp size is explicitly set. 'a' sets the width of
         * 		of the stamp's bounding box. 'b' sets the height of the stamp's bounding
         * 		box. The width and height are constant, regardless of the size of the
         * 		destination page's bounding box.
         *
         * 		-e_font_size: This type only applies to text stamps. 'a' sets the font
         * 		size. 'b' is ignored.
         * @param a - Generally the horizontal component of the size. See size_type for more details.
         * @param b - Generally the vertical component of the size. See size_type for more details.
         */
        setSize(size_type: number, a: number, b: number): Promise<void>;
        /**
         * Deletes PDFTron stamps from document at given page numbers
         * @param doc - The document to delete stamps from
         * @param page_set - The set of pages to delete stamps from
         */
        static deleteStamps(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, page_set: PDFNet.PageSet): Promise<void>;
        /**
         * Returns true if the given set of pages has at least one stamp
         * @param doc - The document that's being checked
         * @param page_set - The set of page that's being checked
         * @returns A promise that resolves to an object of type: "boolean"
         */
        static hasStamps(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, page_set: PDFNet.PageSet): Promise<boolean>;
    }
    /**
     * A StrikeOut annotation shows as a line segment crossing out
     * a word or a group of contiguous words.
     */
    class StrikeOutAnnot extends PDFNet.TextMarkupAnnot {
        /**
         * creates a StrikeOut annotation and initializes it using given Cos/SDF object.
         * @param d - The Cos/SDF object to initialze the annotation with.
         * Note: The constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @returns A promise that resolves to an object of type: "PDFNet.StrikeOutAnnot"
         */
        static createFromObj(d: PDFNet.Obj): Promise<PDFNet.StrikeOutAnnot>;
        /**
         * creates a StrikeOut annotation and initializes it using given annotation object.
         * @param ann - Annot object used to initialize the StrikeOut annotation.
         * Note: The constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @returns A promise that resolves to an object of type: "PDFNet.StrikeOutAnnot"
         */
        static createFromAnnot(ann: PDFNet.Annot): Promise<PDFNet.StrikeOutAnnot>;
        /**
         * Creates a new StrikeOut annotation in the specified document.
         * @param doc - A document to which the Popup annotation is added.
         * @param pos - A rectangle specifying the Popup annotation's bounds in default user space units.
         * @returns A promise that resolves to a newly created blank StrikeOut annotation.
         */
        static create(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, pos: PDFNet.Rect): Promise<PDFNet.StrikeOutAnnot>;
        static create(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, type: number, pos: PDFNet.Rect): Promise<PDFNet.Annot>;
    }
    /**
     * A text annotation represents a "sticky note" attached to a point in
     * the PDF document. When closed, the annotation shall appear as an icon;
     * when open, it shall display a pop-up window containing the text of
     * the note in a font and size chosen by the conforming reader.
     * Text annotations do not scale and rotate with the page (i.e. they should
     * behave as if the NoZoom and NoRotate annotation flags).
     */
    class TextAnnot extends PDFNet.MarkupAnnot {
        /**
         * creates a Text annotation and initializes it using given Cos/SDF object.
         * @param [d] - The Cos/SDF object to initialze the annotation with.
         * Note: The constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @returns A promise that resolves to an object of type: "PDFNet.TextAnnot"
         */
        static createFromObj(d?: PDFNet.Obj): Promise<PDFNet.TextAnnot>;
        /**
         * creates a Text annotation and initializes it using given annotation object.
         * @param ann - Annot object used to initialize the Text annotation.
         * Note: The constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @returns A promise that resolves to an object of type: "PDFNet.TextAnnot"
         */
        static createFromAnnot(ann: PDFNet.Annot): Promise<PDFNet.TextAnnot>;
        /**
         * @returns A promise that resolves to an object of type: "PDFNet.TextAnnot"
         */
        static createAtPoint(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, pos: PDFNet.Point): Promise<PDFNet.TextAnnot>;
        /**
         * Constructor
         * @returns A promise that resolves to an object of type: "PDFNet.TextAnnot"
         */
        static create(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, pos: PDFNet.Rect): Promise<PDFNet.TextAnnot>;
        static create(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, type: number, pos: PDFNet.Rect): Promise<PDFNet.Annot>;
        /**
         * Returns the initial status of the Text annotation.
         * @returns A promise that resolves to a boolean value that specifies whether the annotation shall
         * initially be displayed as opened.
         * Default value: false.
         */
        isOpen(): Promise<boolean>;
        /**
         * sets the initial status of the Text annotation.
         * (Optional)
         * @param isopen - A boolean value that specifies whether the annotation shall
         * initially be displayed as opened.
         * Default value: false.
         */
        setOpen(isopen: boolean): Promise<void>;
        /**
         * Returns the type of the icon associated with the Text annotation.
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.TextAnnot.Icon = {
         * 	e_Comment : 0
         * 	e_Key : 1
         * 	e_Help : 2
         * 	e_NewParagraph : 3
         * 	e_Paragraph : 4
         * 	e_Insert : 5
         * 	e_Note : 6
         * 	e_Unknown : 7
         * }
         * </pre>
         * @returns A promise that resolves to a value of the enumeration type "Icon".
         * Default value: e_Note.
         * Note: The annotation's appearance stream,
         * if present, will take precedence over this entry.
         */
        getIcon(): Promise<number>;
        /**
         * sets the type of the icon associated with the Text annotation.
         * (Optional)
         * @param [icon] - <pre>
         * PDFNet.TextAnnot.Icon = {
         * 	e_Comment : 0
         * 	e_Key : 1
         * 	e_Help : 2
         * 	e_NewParagraph : 3
         * 	e_Paragraph : 4
         * 	e_Insert : 5
         * 	e_Note : 6
         * 	e_Unknown : 7
         * }
         * </pre>
         * A value of the enum "Icon" type.
         * Default value: e_Note.
         * Note: The annotation's appearance stream,
         * if present, will take precedence over this entry.
         */
        setIcon(icon?: number): Promise<void>;
        setIconDefault(): Promise<void>;
        /**
         * Returns the name of the icon associated with the Text annotation.
         * @returns A promise that resolves to a string denoting the name of the icon.
         * Note: The following icon names are equivalent
         * to predefined icon types from the enum "Icon":
         * "Comment" = e_Comment
         * "Key" = e_Key
         * "Help" = e_Help
         * "NewParagraph" = e_NewParagraph
         * "Paragraph" = e_Paragraph
         * "Insert" = e_Insert
         * "Note" = e_Note
         * "Unknown" = e_Unknown
         * Names other than mentioned above do not have predefined icon appearances.
         * Note: The annotation's appearance stream,
         * if present, will take precedence over this entry.
         */
        getIconName(): Promise<string>;
        /**
         * sets the name of the icon associated with the Text annotation.
         * (Optional)
         * @param icon - A string denoting the name of the icon.
         * Note: The following icon names are equivalent
         * to predefined icon types from the enum "Icon":
         * "Comment" = e_Comment
         * "Key" = e_Key
         * "Help" = e_Help
         * "NewParagraph" = e_NewParagraph
         * "Paragraph" = e_Paragraph
         * "Insert" = e_Insert
         * "Note" = e_Note
         * "Unknown" = e_Unknown
         * Names other than mentioned above do not have predefined icon appearances.
         * Note: The annotation's appearance stream,
         * if present, will take precedence over this entry.
         */
        setIconName(icon: string): Promise<void>;
        /**
         * Returns the string indicating the state of the Text annotation.
         * (PDF 1.5)
         * @returns A promise that resolves to a string that indicates the state of the Text annotation when first loaded.
         * Default: "Unmarked" if StateModel is "Marked"; "None" if StateModel is "Review".
         */
        getState(): Promise<string>;
        /**
         * Sets the string indicating the state of the Text annotation.
         * (Optional; PDF 1.5 )
         * @param [state] - A string that indicates the state of the Text annotation when first loaded.
         * Default: "Unmarked" if StateModel is "Marked"; "None" if StateModel is "Review".
         */
        setState(state?: string): Promise<void>;
        /**
         * Returns the string indicating the state model of the Text annotation.
         * (PDF 1.5)
         * @returns A promise that resolves to a string containing the state model name either "Marked" or "Review".
         */
        getStateModel(): Promise<string>;
        /**
         * Sets the string indicating the state model of the Text annotation.
         * (Required if State is present, otherwise optional; PDF 1.5 )
         * @param sm - A string containing the state model name either "Marked" or "Review".
         */
        setStateModel(sm: string): Promise<void>;
        getAnchorPosition(anchor: PDFNet.Point): Promise<void>;
        setAnchorPosition(anchor: PDFNet.Point): Promise<void>;
    }
    /**
     * TextExtractor is used to analyze a PDF page and extract words and logical
     * structure within a given region. The resulting list of lines and words can
     * be traversed element by element or accessed as a string buffer. The class
     * also includes utility methods to extract PDF text as HTML or XML.
     *
     * Possible use case scenarios for TextExtractor include:
     *  - Converting PDF pages to text or XML for content repurposing.
     *  - Searching PDF pages for specific words or keywords.
     *  - Indexing large PDF repositories for indexing or content
     *    retrieval purposes (i.e. implementing a PDF search engine).
     *  - Classifying or summarizing PDF documents based on their text content.
     *  - Finding specific words for content editing purposes (such as splitting pages
     *    based on keywords etc).
     *
     * The main task of TextExtractor is to interpret PDF pages and offer a
     * simple to use API to:
     *  - Normalize all text content to Unicode.
     *  - Extract inferred logical structure (word by word, line by line,
     *    or paragraph by paragraph).
     *  - Extract positioning information for every line, word, or a glyph.
     *  - Extract style information (such as information about the font, font size,
     *    font styles, etc) for every line, word, or a glyph.
     *  - Control the content analysis process. A number of options (such as
     *    removal of text obscured by images) is available to let the user
     *    direct the flow of content recognition algorithms that will meet their
     *    requirements.
     *  - Offer utility methods to convert PDF page content to text, XML, or HTML.
     *
     * Note: TextExtractor is analyzing only textual content of the page.
     * This means that the rasterized (e.g. in scanned pages) or vectorized
     * text (where glyphs are converted to path outlines) will not be recognized
     * as text. Please note that it is still possible to extract this content
     * using pdftron.PDF.ElementReader interface.
     *
     * In some cases TextExtractor may extract text that does not appear to
     * be on the visible page (e.g. when text is obscured by an image or a
     * rectangle). In these situations it is possible to use processing flags
     * such as 'e_remove_hidden_text' and 'e_no_invisible_text' to remove
     * hidden text.
     *
     * A sample use case (in C++):
     *
     * <pre>
     * ... Initialize PDFNet ...
     * PDFDoc doc(filein);
     * doc.InitSecurityHandler();
     * Page page = *doc.PageBegin();
     * TextExtractor txt;
     * txt.Begin(page, 0, TextExtractor::e_remove_hidden_text);
     * UString text;
     * txt.GetAsText(text);
     * // or traverse words one by one...
     * TextExtractor::Line line = txt.GetFirstLine(), lend;
     * TextExtractor::Word word, wend;
     * for (; line!=lend; line=line.GetNextLine()) {
     *  for (word=line.GetFirstWord(); word!=wend; word=word.GetNextWord()) {
     *    text.Assign(word.GetString(), word.GetStringLen());
     *    cout << text << '\n';
     *  }
     * }
     * </pre>
     *
     * A sample use case (in C#):
     *
     * <pre>
     * ... Initialize PDFNet ...
     * PDFDoc doc = new PDFDoc(filein);
     * doc.InitSecurityHandler();
     * Page page = doc.PageBegin().Current();
     * TextExtractor txt = new TextExtractor();
     * txt.Begin(page, 0, TextExtractor.ProcessingFlags.e_remove_hidden_text);
     * string text = txt.GetAsText();
     * // or traverse words one by one...
     * TextExtractor.Word word;
     * for (TextExtractor.Line line = txt.GetFirstLine(); line.IsValid(); line=line.GetNextLine()) {
     *   for (word=line.GetFirstWord(); word.IsValid(); word=word.GetNextWord()) {
     *     Console.WriteLine(word.GetString());
     *   }
     * }
     * </pre>
     *
     * For full sample code, please take a look at TextExtract sample project.
     */
    class TextExtractor extends PDFNet.Destroyable {
        /**
         * Constructor and destructor
         * @returns A promise that resolves to an object of type: "PDFNet.TextExtractor"
         */
        static create(): Promise<PDFNet.TextExtractor>;
        /**
         * Sets the Optional Content Group (OCG) context that should be used when
         * processing the document. This function can be used to change the current
         * OCG context. Optional content (such as PDF layers) will be selectively
         * processed based on the states of optional content groups in the given
         * context.
         * @param ctx - Optional Content Group (OCG) context, or NULL if TextExtractor
         * should process all content on the page.
         */
        setOCGContext(ctx: PDFNet.OCGContext): Promise<void>;
        /**
         * Start reading the page.
         * @param page - Page to read.
         * @param [clip_ptr] - An optional clipping rectangle. This
         * parameter can be used to selectively read text from a given rectangle.
         * @param [flags] - A list of ProcessingFlags used to control text extraction
         * algorithm.
         */
        begin(page: PDFNet.Page, clip_ptr?: PDFNet.Rect, flags?: number): Promise<void>;
        /**
         * @returns A promise that resolves to the number of words on the page.
         */
        getWordCount(): Promise<number>;
        /**
         * Sets the directionality of text extractor.
         * Must be called before the processing of a page started.
         * @param rtl - mode reverses the directionality of TextExtractor algorithm.
         */
        setRightToLeftLanguage(rtl: boolean): Promise<void>;
        /**
         * @returns A promise that resolves to the directionality of text extractor.
         */
        getRightToLeftLanguage(): Promise<boolean>;
        /**
         * get all words in the current selection as a single string.
         * @param [dehyphen] - If true, finds and removes hyphens that split words
         * across two lines. Hyphens are often used a the end of lines as an
         * indicator that a word spans two lines. Hyphen detection enables removal
         * of hyphen character and merging of text runs to form a single word.
         * This option has no effect on Tagged PDF files.
         * @returns A promise that resolves to an object of type: "string"
         */
        getAsText(dehyphen?: boolean): Promise<string>;
        /**
         * Get all the characters that intersect an annotation.
         * @param annot - The annotation to intersect with.
         * @returns A promise that resolves to an object of type: "string"
         */
        getTextUnderAnnot(annot: PDFNet.Annot): Promise<string>;
        /**
         * get text content in a form of an XML string.
         * @param [xml_output_flags] - flags controlling XML output. For more
         * information, please see TextExtract::XMLOutputFlags.
         *
         * XML output will be encoded in UTF-8 and will have the following
         * structure:
         * <pre>
         * <Page num="1 crop_box="0, 0, 612, 792" media_box="0, 0, 612, 792" rotate="0">
         *  <Flow id="1">
         *   <Para id="1">
         *    <Line box="72, 708.075, 467.895, 10.02" style="font-family:Calibri; font-size:10.02; color: #000000;">
         *      <Word box="72, 708.075, 30.7614, 10.02">PDFNet</Word>
         *      <Word box="106.188, 708.075, 15.9318, 10.02">SDK</Word>
         *      <Word box="125.617, 708.075, 6.22242, 10.02">is</Word>
         *      ...
         *    </Line>
         *   </Para>
         *  </Flow>
         * </Page>
         * </pre>
         *
         * The above XML output was generated by passing the following union of
         * flags in the call to GetAsXML():
         *   (TextExtractor::e_words_as_elements | TextExtractor::e_output_bbox | TextExtractor::e_output_style_info)
         *
         * In case 'xml_output_flags' was not specified, the default XML output
         * would look as follows:
         *
         * <Page num="1 crop_box="0, 0, 612, 792" media_box="0, 0, 612, 792" rotate="0">
         * <Flow id="1">
         * <Para id="1">
         *     <Line>PDFNet SDK is an amazingly comprehensive, high-quality PDF developer toolkit...</Line>
         *     <Line>levels. Using the PDFNet PDF library, ...</Line>
         *     ...
         *   </Para>
         *  </Flow>
         * </Page>
         * </pre>
         * @returns A promise that resolves to an object of type: "string"
         */
        getAsXML(xml_output_flags?: number): Promise<string>;
        /**
         * @returns A promise that resolves to the number of lines of text on the selected page.
         */
        getNumLines(): Promise<number>;
        /**
         * @returns A promise that resolves to the first line of text on the selected page.
         *
         * Note: To traverse the list of all text lines on the page use line.GetNextLine().
         * Note: To traverse the list of all word on a given line use line.GetFirstWord().
         */
        getFirstLine(): Promise<PDFNet.TextExtractorLine>;
        /**
         * [CURRENTLY BUGGED]
         * @param mtx - The quadrilateral representing a tight bounding box
         * @param quads - n
         * @param quads_size - n
         * for this word (in unrotated page coordinates).
         */
        getQuads(mtx: PDFNet.Matrix2D, quads: number, quads_size: number): Promise<void>;
        /**
         * Get a Highlights object based on an array of character ranges.
         * @param char_ranges - an array of character ranges to be highlighted, such as [{ "index": 1, "length": 10 }, { "index": 100, "length": 20 }]
         * @returns A promise that resolves to an object of type: "Highlights", containing the selected characters.
         */
        getHighlights(char_ranges: object[]): Promise<PDFNet.Highlights>;
    }
    /**
     * TextExtractor::Line object represents a line of text on a PDF page.
     * Each line consists of a sequence of words, and each words in one or
     * more styles.
     */
    class TextExtractorLine {
        constructor(line?: number, uni?: number, num?: number, cur_num?: number, m_direction?: number, mp_bld?: any);
        /**
         * @returns A promise that resolves to the number of words in this line.
         */
        getNumWords(): Promise<number>;
        /**
         * @returns A promise that resolves to true is this line is not rotated (i.e. if the
         * quadrilaterals returned by GetBBox() and GetQuad() coincide).
         */
        isSimpleLine(): Promise<boolean>;
        /**
         * @returns A promise that resolves to the first word in the line.
         * Note: To traverse the list of all words on this line use word.GetNextWord().
         */
        getFirstWord(): Promise<PDFNet.TextExtractorWord>;
        /**
         * @param word_idx - A integer representing the index of the word to get.
         * @returns A promise that resolves to the i-th word in this line.
         */
        getWord(word_idx: number): Promise<PDFNet.TextExtractorWord>;
        /**
         * @returns A promise that resolves to the next line on the page.
         */
        getNextLine(): Promise<PDFNet.TextExtractorLine>;
        /**
         * @returns A promise that resolves to the index of this line of the current page.
         */
        getCurrentNum(): Promise<number>;
        /**
         * @returns A promise that resolves to predominant style for this line.
         */
        getStyle(): Promise<PDFNet.TextExtractorStyle>;
        /**
         * @returns A promise that resolves to the unique identifier for a paragraph or column
         * that this line belongs to. This information can be used to
         * identify which lines belong to which paragraphs.
         */
        getParagraphID(): Promise<number>;
        /**
         * @returns A promise that resolves to the unique identifier for a paragraph or column
         * that this line belongs to. This information can be used to
         * identify which lines/paragraphs belong to which flows.
         */
        getFlowID(): Promise<number>;
        /**
         * @returns A promise that resolves to true is this line of text ends with a hyphen (i.e. '-'),
         * false otherwise.
         */
        endsWithHyphen(): Promise<boolean>;
        /**
         * Comparison function.
         * Determines if parameter object is equal to current object.
         * @returns A promise that resolves to True if the two objects are equivalent, False otherwise
         */
        compare(line2: PDFNet.TextExtractorLine): Promise<boolean>;
        /**
         * Constructor
         * @returns A promise that resolves to an object of type: "PDFNet.TextExtractorLine"
         */
        static create(): Promise<PDFNet.TextExtractorLine>;
        /**
         * @returns A promise that resolves to true if this is a valid line, false otherwise.
         */
        isValid(): Promise<boolean>;
        /**
         * @returns A promise that resolves to the bounding box for this line (in unrotated page
        coordinates).
         */
        getBBox(): Promise<PDFNet.Rect>;
        /**
         * Gets the quadrilateral bounding box for the line (in unrotated page coordinates)
         * @returns A promise that resolves to an object of type: "PDFNet.QuadPoint"
         */
        getQuad(): Promise<PDFNet.QuadPoint>;
        line: number;
        uni: number;
        num: number;
        cur_num: number;
        m_direction: number;
        mp_bld: any;
    }
    /**
     * A class representing predominant text style associated with a
     * given Line, a Word, or a Glyph. The class includes information about
     * the font, font size, font styles, text color, etc.
     */
    class TextExtractorStyle {
        constructor(mp_imp?: any);
        /**
         * @returns A promise that resolves to low-level PDF font object. A high level font object can
         * be instantiated as follows:
         * In C++: pdftron.PDF.Font f(style.GetFont())
         * In C#: pdftron.PDF.Font f = new pdftron.PDF.Font(style.GetFont());
         */
        getFont(): Promise<PDFNet.Obj>;
        /**
         * @returns A promise that resolves to the font name used to draw the selected text.
         */
        getFontName(): Promise<string>;
        /**
         * @returns A promise that resolves to the font size used to draw the selected text as it
         * appears on the output page.
         * Note: Unlike the 'font size' in the graphics state (pdftron.PDF.GState)
         * the returned font size accounts for the effects CTM, text matrix,
         * and other graphics state attributes that can affect the appearance of
         * text.
         */
        getFontSize(): Promise<number>;
        /**
         * @returns A promise that resolves to the weight (thickness) component of the fully-qualified font name
         * or font specifier. The possible values are 100, 200, 300, 400, 500, 600, 700,
         * 800, or 900, where each number indicates a weight that is at least as dark as
         * its predecessor. A value of 400 indicates a normal weight; 700 indicates bold.
         * Note: The specific interpretation of these values varies from font to font.
         * For example, 300 in one font may appear most similar to 500 in another.
         */
        getWeight(): Promise<number>;
        /**
         * @returns A promise that resolves to true if glyphs have dominant vertical strokes that are slanted.
         * Note: the return value corresponds to the state of 'italic' flag in the 'Font Descriptor'.
         */
        isItalic(): Promise<boolean>;
        /**
         * @returns A promise that resolves to true if glyphs have serifs, which are short strokes drawn at an angle on the top
         * and bottom of glyph stems.
         * Note: the return value corresponds to the state of 'serif' flag in the 'Font Descriptor'.
         */
        isSerif(): Promise<boolean>;
        /**
         * Comparison function.
         * Determines if parameter object is equal to current object.
         * @returns A promise that resolves to True if the two objects are equivalent, False otherwise
         */
        compare(s: PDFNet.TextExtractorStyle): Promise<boolean>;
        /**
         * Constructor
         * @returns A promise that resolves to an object of type: "PDFNet.TextExtractorStyle"
         */
        static create(): Promise<PDFNet.TextExtractorStyle>;
        /**
         * Copy Constructor
         * @returns A promise that resolves to an object of type: "PDFNet.TextExtractorStyle"
         */
        copy(): Promise<PDFNet.TextExtractorStyle>;
        /**
         * @returns A promise that resolves to text color in RGB color space.
         */
        getColor(): Promise<ColorPt>;
        mp_imp: any;
    }
    /**
     * TextExtractor::Word object represents a word on a PDF page.
     * Each word contains a sequence of characters in one or more styles
     * (see TextExtractor::Style).
     */
    class TextExtractorWord {
        constructor(line?: number, word?: number, uni?: number, num?: number, cur_num?: number, mp_bld?: any);
        /**
         * @returns A promise that resolves to the number of glyphs in this word.
         */
        getNumGlyphs(): Promise<number>;
        /**
         * @param char_idx - The index of a character in this word.
         * @returns A promise that resolves to the style associated with a given character.
         */
        getCharStyle(char_idx: number): Promise<PDFNet.TextExtractorStyle>;
        /**
         * @returns A promise that resolves to predominant style for this word.
         */
        getStyle(): Promise<PDFNet.TextExtractorStyle>;
        /**
         * @returns A promise that resolves to the number of characters in this word.
         */
        getStringLen(): Promise<number>;
        /**
         * @returns A promise that resolves to the next word on the current line.
         */
        getNextWord(): Promise<PDFNet.TextExtractorWord>;
        /**
         * @returns A promise that resolves to the index of this word of the current line. A word that
         * starts the line will return 0, whereas the last word in the line
         * will return (line.GetNumWords()-1).
         */
        getCurrentNum(): Promise<number>;
        /**
         * Comparison function.
         * Determines if parameter object is equal to current object.
         * @returns A promise that resolves to True if the two objects are equivalent, False otherwise
         */
        compare(word: PDFNet.TextExtractorWord): Promise<boolean>;
        /**
         * Constructor
         * @returns A promise that resolves to an object of type: "PDFNet.TextExtractorWord"
         */
        static create(): Promise<PDFNet.TextExtractorWord>;
        /**
         * @returns A promise that resolves to true if this is a valid word, false otherwise.
         */
        isValid(): Promise<boolean>;
        /**
         * @returns A promise that resolves to the bounding box for this word (in unrotated page
        coordinates).
         */
        getBBox(): Promise<PDFNet.Rect>;
        /**
         * @returns A promise that resolves to the quadrilateral representing a tight
        bounding box for this word (in unrotated page coordinates).
         */
        getQuad(): Promise<PDFNet.QuadPoint>;
        /**
         * @returns A promise that resolves to the content of this word represented as a string.
         */
        getString(): Promise<string>;
        line: number;
        word: number;
        uni: number;
        num: number;
        cur_num: number;
        mp_bld: any;
    }
    /**
     * A TextMarkup is a base class for highlight, underline,
     * strikeout, and squiggly annotations.
     */
    class TextMarkupAnnot extends PDFNet.MarkupAnnot {
        /**
         * creates a TextMarkup annotation and initializes it using given Cos/SDF object.
         * @param d - The Cos/SDF object to initialze the annotation with.
         * Note: The constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @returns A promise that resolves to an object of type: "PDFNet.TextMarkupAnnot"
         */
        static createFromObj(d: PDFNet.Obj): Promise<PDFNet.TextMarkupAnnot>;
        /**
         * creates a TextMarkup annotation and initializes it using given annotation object.
         * @param ann - Annot object used to initialize the TextMarkup annotation.
         * Note: The constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @returns A promise that resolves to an object of type: "PDFNet.TextMarkupAnnot"
         */
        static createFromAnnot(ann: PDFNet.Annot): Promise<PDFNet.TextMarkupAnnot>;
        /**
         * Returns the number of QuadPoints in the QuadPoints array of the TextMarkup annotation
         * (PDF 1.6)
         * @returns A promise that resolves to the number of QuadPoints.
         * Note: QuadPoints specify the coordinates of quadrilaterals in default user space. Each quadrilateral
         * encompasses a word or group of contiguous words in the text underlying the annotation.
         * The four points(p1, p2, p3, p4) of a QuadPoint specify the quadrilateral's four vertices
         * in counterclockwise order.
         * The text needs to be oriented with respect to the edge connecting points (p1) and (p2).
         * The annotation dictionary's Appearance entry, if present, takes precedence over QuadPoints.
         */
        getQuadPointCount(): Promise<number>;
        /**
         * Returns the QuadPoint located at a certain index of the QuadPoint array.
         * (PDF 1.6)
         * @param idx - The index where the QuadPoint is located. The index starts at zero and must be less than return value of GetQuadPointCount().
         * @returns A promise that resolves to the QuadPoint located at a certain index of the QuadPoint array of the TextMarkup annotation.
         * Note: QuadPoints specify the coordinates of quadrilaterals in default user space. Each quadrilateral
         * encompasses a word or group of contiguous words in the text underlying the annotation.
         * The four points(p1, p2, p3, p4) of a QuadPoint specify the quadrilateral's four vertices
         * in counterclockwise order.
         * The text needs to be oriented with respect to the edge connecting points (p1) and (p2).
         * The annotation dictionary's Appearance entry, if present, takes precedence over QuadPoints.
         */
        getQuadPoint(idx: number): Promise<PDFNet.QuadPoint>;
        /**
         * sets the QuadPoint to be located at a certain index of the QuadPoint array.
         * (Optional; PDF 1.6 )
         * @param idx - The index where the QuadPoint is to be located (the index is counted from 0).
         * @param qp - The QuadPoint to be located at a certain index of the QuadPoint array of the TextMarkup annotation.
         * Attention: To make this QuadPoint compatible with Adobe Acrobat|Reader, you can use either clockwise or counterclockwise order,
         * but the points p3 and p4 must be swapped. This is because those readers do not follow the PDF specification for TextMarkup QuadPoints.
         * Note: An array of n QuadPoints specifying the coordinates of n quadrilaterals in default user space. Each quadrilateral shall
         * encompasses a word or group of contiguous words in the text underlying the annotation. The coordinates for each quadrilateral
         * shall be given in the order p1, p2, p3, p4 specifying the quadrilateral's four vertices in counterclockwise order.
         * The text shall be oriented with respect to the edge connecting points (p1) and (p2).
         * The annotation dictionary's Appearance(AP) entry, if present, shall take precedence over QuadPoints.
         */
        setQuadPoint(idx: number, qp: PDFNet.QuadPoint): Promise<void>;
    }
    /**
     * [Missing documentation]
     */
    class TextRange {
    }
    /**
     * TextSearch searches through a PDF document for a user-given search pattern.
     * The current implementation supports both verbatim search and the search
     * using regular expressions, whose detailed syntax can be found at:
     *
     * http://www.boost.org/doc/libs/release/libs/regex/doc/html/boost_regex/syntax/perl_syntax.html
     *
     * TextSearch also provides users with several useful search modes and extra
     * information besides the found string that matches the pattern. TextSearch
     * can either keep running until a matched string is found or be set to return
     * periodically in order for the caller to perform any necessary updates
     * (e.g., UI updates). It is also worth mentioning that the search modes can be
     * changed on the fly while searching through a document.
     *
     * Possible use case scenarios for TextSearch include:
     *  - Guide users of a PDF viewer (e.g. implemented by PDFViewCtrl) to places
     *    where they are intersted in;
     *  - Find interested PDF documents which contain certain patterns;
     *  - Extract interested information (e.g., credit card numbers) from a set of files;
     *  - Extract Highlight information (refer to the Highlights class for details) from
     *    files for external use.
     *
     * Note:
     *  - Since hyphens ('-') are frequently used in PDF documents to concatenate the two
     *    broken pieces of a word at the end of a line, for example
     *
     * 	  "TextSearch is powerful for finding patterns in PDF files; yes, it is really pow-
     *     erful."
     *
     *    a search for "powerful" should return both instances. However, not all end-of-line
     *    hyphens are hyphens added to connect a broken word; some of them could be "real"
     *    hyphens. In addition, an input search pattern may also contain hyphens that complicate
     *    the situation. To tackle this problem, the following conventions are adopted:
     *
     *    a)When in the verbatim search mode and the pattern contains no hyphen, a matching
     *      string is returned if it is exactly the same or it contains end-of-line
     *      or start-of-line hyphens. For example, as mentioned above, a search for "powerful"
     *      would return both instances.
     *    b)When in verbatim search mode and the pattern contains one or multiple hyphens, a
     *      matching string is returned only if the string matches the pattern exactly. For
     *      example, a search for "pow-erful" will only return the second instance, and a search
     *      for "power-ful" will return nothing.
     *    c)When searching using regular expressions, hyphens are not taken care implicitly.
     *      Users should take care of it themselves. For example, in order to find both the
     *      "powerful" instances, the input pattern can be "pow-{0,1}erful".
     *
     * A sample use case (in C++):
     *
     * <pre>
     * //... Initialize PDFNet ...
     * PDFDoc doc(filein);
     * doc.InitSecurityHandler();
     * int page_num;
     * char buf[32];
     * UString result_str, ambient_string;
     * Highlights hlts;
     * TextSearch txt_search;
     * TextSearch::Mode mode = TextSearch::e_whole_word | TextSearch::e_page_stop;
     * UString pattern( "joHn sMiTh" );
     *
     * //PDFDoc doesn't allow simultaneous access from different threads. If this
     * //document could be used from other threads (e.g., the rendering thread inside
     * //PDFView/PDFViewCtrl, if used), it is good practice to lock it.
     * //Notice: don't forget to call doc.Unlock() to avoid deadlock.
     * doc.Lock();
     *
     * txt_search.Begin( doc, pattern, mode );
     * while ( true )
     * {
     * 	   SearchResult result = code = txt_search.Run(page_num, result_str, ambient_string, hlts );
     * 	   if ( code == TextSearch::e_found )
     * 	   {
     * 		   result_str.ConvertToAscii(buf, 32, true);
     * 		   cout << "found one instance: " << char_buf << endl;
     * 	   }
     * 	   else
     * 	   {
     * 		   break;
     * 	   }
     * }
     *
     * //unlock the document to avoid deadlock.
     * doc.UnLock();
     * </pre>
     *
     *
     * For a full sample, please take a look at the TextSearch sample project.
     */
    class TextSearch extends PDFNet.Destroyable {
        /**
         * Constructor and destructor.
         * @returns A promise that resolves to an object of type: "PDFNet.TextSearch"
         */
        static create(): Promise<PDFNet.TextSearch>;
        /**
         * Initialize for search process. This should be called before starting the actual search
         * with method Run().
         * @param doc - the PDF document to search in.
         * @param pattern - the pattern to search for. When regular expression is used, it contains
         *        the expression, and in verbatim mode, it is the exact string to search for.
         * @param mode - the mode of the search process.
         * @param [start_page] - the start page of the page range to search in. The default value is -1
         *        indicating the range starts from the first page.
         * @param [end_page] - the end page of the page range to search in. The default value is -1
         *        indicating the range ends at the last page.
         * @returns A promise that resolves to true if the initialization has succeeded.
         */
        begin(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, pattern: string, mode: number, start_page?: number, end_page?: number): Promise<boolean>;
        /**
         * Set the current search pattern. Note that it is not necessary to call this method since
         * the search pattern is already set when calling the Begin() method. This method is provided
         * for users to change the search pattern while searching through a document.
         * @param pattern - the search pattern to set.
         * @returns A promise that resolves to true if the setting has succeeded.
         */
        setPattern(pattern: string): Promise<boolean>;
        /**
         * Retrieve the current search mode.
         * @returns A promise that resolves to the current search mode.
         */
        getMode(): Promise<number>;
        /**
         * set the current search mode. For example, the following code turns on the regular
         * expressions:
         *
         * 	TextSearch ts;
         *   ...
         *   TextSearch::Mode mode = ts.GetMode();
         *   mode |= TextSearch::e_reg_expression;
         *   ts.SetMode(mode);
         *   ...
         * @param mode - the search mode to set.
         */
        setMode(mode: number): Promise<void>;
        /**
         * Tells TextSearch that language is from right to left.
         * @param flag - Set to true if the language is right to left.
         */
        setRightToLeftLanguage(flag: boolean): Promise<void>;
        /**
         * Retrieve the number of the current page that is searched in.
         * If the returned value is -1, it indicates the search process has not been initialized
         * (e.g., Begin() is not called yet); if the returned value is 0, it indicates the search
         * process has finished, and if the returned value is positive, it is a valid page number.
         * @returns A promise that resolves to the current page number.
         */
        getCurrentPage(): Promise<number>;
        /**
         * Sets the Optional Content Group (OCG) context that should be used when
         * processing the document. This function can be used to change the current
         * OCG context. Optional content (such as PDF layers) will be selectively
         * processed based on the states of optional content groups in the given
         * context.
         * @param ctx - Optional Content Group (OCG) context, or NULL if TextSearch
         * should process all content on the page.
         */
        setOCGContext(ctx: PDFNet.OCGContext): Promise<void>;
        /**
         * Runs a search on the document for a certain string. Make sure to call
        TextSearch.begin(doc, pattern, mode) with the proper parameters
        before calling TextSearch.run()
        
        The resolved object that TextSearch.run() returns contains the following objects:
        page_num - The number of the page with the match
        out_str - The string that matches the search parameter
        ambient_str - The ambient string of the found string (computed only if e_ambient_string is set)
        highlights - The Highlights info associated with the match (computed only if 'e_highlight' is set)
        code - Number representing the status of the search.
            - 0 - e_done, reached end of document.
            - 1 - e_page, reached end of page. (if set to return by specifying mode 'e_page_stop')
            - 2 - e_found, found an instance matching the search pattern
         * @returns A promise that resolves to an object containing the page_num, out_str
        ambient_str, highlights, and result code.
         */
        run(): Promise<any>;
    }
    /**
     * An object representing a Text Box used in a PDF Form.
     */
    class TextWidget extends PDFNet.WidgetAnnot {
        /**
         * Creates a new Text Widget annotation, in the specified document.
         * @param doc - The document to which the annotation is added.
         * @param pos - A rectangle specifying the annotation's bounds, specified in
         * user space coordinates.
         * @param [field_name] - The name of the field for which to create a Text widget.
         * @returns A promise that resolves to a newly created blank Text Widget annotation.
         */
        static create(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, pos: PDFNet.Rect, field_name?: string): Promise<PDFNet.TextWidget>;
        static create(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, pos: PDFNet.Rect, field: PDFNet.Field): Promise<PDFNet.WidgetAnnot>;
        static create(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, type: number, pos: PDFNet.Rect): Promise<PDFNet.Annot>;
        /**
         * Creates a new Text Widget annotation, in the specified document.
         * @param doc - The document to which the annotation is added.
         * @param pos - A rectangle specifying the annotation's bounds, specified in
         * user space coordinates.
         * @param field - the field for which to create a Text Widget.
         * @returns A promise that resolves to a newly created blank Widget annotation.
         */
        static createWithField(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, pos: PDFNet.Rect, field: PDFNet.Field): Promise<PDFNet.TextWidget>;
        /**
         * Creates a Text Widget annotation and initialize it using given Cos/SDF object.
         *
         * <p>
         * <b> Note: </b> The constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @param [d] - The object to use to initialize the Text Widget
         * @returns A promise that resolves to an object of type: "PDFNet.TextWidget"
         */
        static createFromObj(d?: PDFNet.Obj): Promise<PDFNet.TextWidget>;
        /**
         * Creates a Text Widget annotation and initialize it using given annotation object.
         *
         * <b> Note: </b>  The constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @param annot - The annotation object to use.
         * @returns A promise that resolves to an object of type: "PDFNet.TextWidget"
         */
        static createFromAnnot(annot: PDFNet.Annot): Promise<PDFNet.TextWidget>;
        /**
         * Sets the text content of the Text Widget.
         * @param text - The text to be displayed in the Text Widget.
         */
        setText(text: string): Promise<void>;
        /**
         * Retrieves the text content of the Text Widget.
         * @returns A promise that resolves to  The Text Widget contents.
         */
        getText(): Promise<string>;
    }
    /**
     * A class representing a set of options for timestamping a document.
     */
    class TimestampingConfiguration extends PDFNet.Destroyable {
        /**
         * Constructor.
         * @param in_url - - a string representing a URL of a timestamp authority (TSA) to use during timestamping
         * @returns A promise that resolves to an object of type: "PDFNet.TimestampingConfiguration"
         */
        static createFromURL(in_url: string): Promise<PDFNet.TimestampingConfiguration>;
        /**
         * Setter to change the timestamp authority (TSA) URL to use during timestamping.
         * @param in_url - - a string representing a URL of a timestamp authority.
         */
        setTimestampAuthorityServerURL(in_url: string): Promise<void>;
        /**
         * Setter for a username to use during timestamping.
         * @param in_username - - a string representing a username.
         */
        setTimestampAuthorityServerUsername(in_username: string): Promise<void>;
        /**
         * Setter for a password to use during timestamping.
         * @param in_password - - a string representing a password.
         */
        setTimestampAuthorityServerPassword(in_password: string): Promise<void>;
        /**
         * Setter for whether to use a nonce (unique random number) during timestamping.
         * This is on by default, and should be on whenever a timestamp authority
         * supports it, because it helps prevent replay attacks.
         * @param in_use_nonce - - a boolean value representing whether or not to use a nonce
         */
        setUseNonce(in_use_nonce: boolean): Promise<void>;
        /**
         * Tests a timestamping configuration for usability and reports any failures. This function
         * does not throw on many common failures, unlike the real signing, thereby allowing early
         * diagnosis of things like connectivity issues with timestamp authorities.
         * @param in_opts - - a set of verification options to try to use
         * @returns A promise that resolves to a result object containing information about the status of the configuration test
         * and any errors that occurred during it.
         */
        testConfiguration(in_opts: PDFNet.VerificationOptions): Promise<PDFNet.TimestampingResult>;
    }
    /**
     * A class representing the result of testing a timestamping configuration.
     */
    class TimestampingResult extends PDFNet.Destroyable {
        /**
         * Retrieves the overall status of the timestamping configuration testing operation.
         * @returns A promise that resolves to a boolean value representing the status.
         */
        getStatus(): Promise<boolean>;
        /**
         * Retrieves a result message regarding the timestamping configuration testing operation.
         * @returns A promise that resolves to a string result message.
         * Note: Output may change in future versions.
         */
        getString(): Promise<string>;
        /**
         * Returns whether a timestamp response verification result is available. This means
         * that false will be returned when a timestamp response was not received or was empty
         * (e.g. network failures, improper server configuration, bad URL, etc.). This function
         * should be called to check for the availability of a verification result before actually
         * attempting to retrieve one using GetResponseVerificationResult (which throws if a result is not
         * available).
         * @returns A promise that resolves to whether a timestamp response verification result is available
         */
        hasResponseVerificationResult(): Promise<boolean>;
        /**
         * If a timestamp response was successfully retrieved from a timestamp authority, returns
         * the result of verifying it. If a timestamp response was not received, throws. One should
         * call HasResponseVerificationResult first to see if a detailed result is available before calling
         * this function.
         * @returns A promise that resolves to a timestamp response verification result
         */
        getResponseVerificationResult(): Promise<PDFNet.EmbeddedTimestampVerificationResult>;
        /**
         * If GetStatus gives true, returns the data from the completed timestamping operation, otherwise throws.
         * If this result was returned from TimestampOnNextSave, then this data is the timestamp token.
         * However, if this result was returned from GenerateContentsWithEmbeddedTimestamp, then this data is the main
         * document CMS signature of the DigitalSignatureField but with a newly-added embedded
         * timestamp (unsigned signature-time-stamp attribute as specified in PAdES and PDF 2.0).
         * @returns A promise that resolves to the data representing the result of the timestamping operation, if GetStatus gives true
         */
        getData(): Promise<Uint8Array>;
    }
    /**
     * The detailed result of a trust verification step of a verification
     * operation performed on a digital signature.
     */
    class TrustVerificationResult extends PDFNet.Destroyable {
        /**
         * Retrieves the trust verification status.
         * @returns A promise that resolves to a boolean representing whether or not the trust verification operation was successful. Whether trust-related warnings are treated as errors or not depend on the VerificationOptions used for the verification operation.
         */
        wasSuccessful(): Promise<boolean>;
        /**
         * Retrieves a string representation of the details of the trust verification status.
         * @returns A promise that resolves to a string.
         *
         * Note: Output may change in future versions.
         */
        getResultString(): Promise<string>;
        /**
         * Retrieves the reference-time used for trust verification as an epoch time.
         * @returns A promise that resolves to an integral value representing an epoch time.
         */
        getTimeOfTrustVerification(): Promise<number>;
        /**
         * Retrieves the type of reference-time used for trust verification.
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.VerificationOptions.TimeMode = {
         * 	e_signing : 0
         * 	e_timestamp : 1
         * 	e_current : 2
         * }
         * </pre>
         * @returns A promise that resolves to an enumerated value representing the type of reference-time used for trust verification.
         */
        getTimeOfTrustVerificationEnum(): Promise<number>;
        /**
         * Returns whether this TrustVerificationResult has a detailed timestamp result inside.
         * @returns A promise that resolves to a boolean value representing whether this TrustVerificationResult has a detailed timestamp result inside.
         */
        hasEmbeddedTimestampVerificationResult(): Promise<boolean>;
        /**
         * Returns the detailed timestamp result inside this TrustVerificationResult. One must call HasEmbeddedTimestampVerificationResult first to check whether the result is available.
         * @returns A promise that resolves to an EmbeddedTimestampVerificationResult object.
         */
        getEmbeddedTimestampVerificationResult(): Promise<PDFNet.EmbeddedTimestampVerificationResult>;
        /**
         * Retrieves the certificate path that was used for verification.
         * @returns A promise that resolves to a container of X509Certificate objects
         */
        getCertPath(): Promise<PDFNet.X509Certificate[]>;
    }
    /**
     * An Underline annotation shows as a line segment across the bottom
     * of a word or a group of contiguous words.
     */
    class UnderlineAnnot extends PDFNet.TextMarkupAnnot {
        /**
         * creates an Underline annotation and initializes it using given Cos/SDF object.
         * @param d - The Cos/SDF object to initialze the annotation with.
         * Note: The constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @returns A promise that resolves to an object of type: "PDFNet.UnderlineAnnot"
         */
        static createFromObj(d: PDFNet.Obj): Promise<PDFNet.UnderlineAnnot>;
        /**
         * creates an Underline annotation and initializes it using given annotation object.
         * @param ann - Annot object used to initialize the Underline annotation.
         * Note: The constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @returns A promise that resolves to an object of type: "PDFNet.UnderlineAnnot"
         */
        static createFromAnnot(ann: PDFNet.Annot): Promise<PDFNet.UnderlineAnnot>;
        /**
         * Creates a new Underline annotation in the specified document.
         * @param doc - A document to which the Underline annotation is added.
         * @param pos - A rectangle specifying the Underline annotation's bounds in default user space units.
         * @returns A promise that resolves to a newly created blank Underline annotation.
         */
        static create(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, pos: PDFNet.Rect): Promise<PDFNet.UnderlineAnnot>;
        static create(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, type: number, pos: PDFNet.Rect): Promise<PDFNet.Annot>;
    }
    /**
     * The class UndoManager.
     * Undo-redo interface; one-to-one mapped to document
     */
    class UndoManager extends PDFNet.Destroyable {
        /**
         * Forget all changes in this manager (without changing the document).
         * @returns A promise that resolves to an invalid DocSnapshot.
         */
        discardAllSnapshots(): Promise<PDFNet.DocSnapshot>;
        /**
         * Restores to the previous snapshot point, if there is one.
         * @returns A promise that resolves to the resulting snapshot id.
         */
        undo(): Promise<PDFNet.ResultSnapshot>;
        /**
         * Returns whether it is possible to undo from the current snapshot.
         * @returns A promise that resolves to whether it is possible to undo from the current snapshot.
         */
        canUndo(): Promise<boolean>;
        /**
         * Gets the previous state of the document. This state may be invalid if it is impossible to undo.
         * @returns A promise that resolves to the previous state of the document. This state may be invalid if it is impossible to undo.
         */
        getNextUndoSnapshot(): Promise<PDFNet.DocSnapshot>;
        /**
         * Restores to the next snapshot, if there is one.
         * @returns A promise that resolves to a representation of the transition to the next snapshot, if there is one.
         */
        redo(): Promise<PDFNet.ResultSnapshot>;
        /**
         * Returns a boolean indicating whether it is possible to redo from the current snapshot.
         * @returns A promise that resolves to a boolean indicating whether it is possible to redo from the current snapshot.
         */
        canRedo(): Promise<boolean>;
        /**
         * Gets the next state of the document. This state may be invalid if it is impossible to redo.
         * @returns A promise that resolves to the next state of the document. This state may be invalid if it is impossible to redo.
         */
        getNextRedoSnapshot(): Promise<PDFNet.DocSnapshot>;
        /**
         * Creates a snapshot of document state, transitions to the new snapshot.
         * @returns A promise that resolves to a representation of the transition.
         */
        takeSnapshot(): Promise<PDFNet.ResultSnapshot>;
    }
    /**
     * Options pertaining to digital signature verification.
     */
    class VerificationOptions extends PDFNet.Destroyable {
        /**
         * Constructs a set of options for digital signature verification.
         * @param in_level - <pre>
         * PDFNet.VerificationOptions.SecurityLevel = {
         * 	e_compatibility_and_archiving : 0
         * 	e_maximum : 1
         * }
         * </pre>
         * -- the general security level to use. Sets other security settings internally.
         * @returns A promise that resolves to an object of type: "PDFNet.VerificationOptions"
         */
        static create(in_level: number): Promise<PDFNet.VerificationOptions>;
        /**
         * Adds a certificate to the store of trusted certificates inside this options object.
         * @param in_certificate_buf - - a buffer consisting of the data of an X.509 public-key
         * certificate encoded in binary DER (Distinguished Encoding Rules) format, or in PEM
         * (appropriate Privacy-Enhanced Mail header+Base64 encoded DER+appropriate footer) format
         * @param [in_trust_flags] - - a combination of trust flags (see enum CertificateTrustFlag)
         * that determine for which situations this certificate should be trusted during trust verification.
         * There is a default parameter value, the e_default_trust CertificateTrustFlag, which matches Acrobat's behaviour for this parameter.
         */
        addTrustedCertificate(in_certificate_buf: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray, in_trust_flags?: number): Promise<void>;
        /**
         * Bulk trust list loading API from P7C. Attempts to decode the input data as binary DER and trust multiple trusted
         * root certificates from it. Compatible with Acrobat's .P7C format, which is a variation on PKCS #7/CMS that only
         * contains certificates (i.e. no CRLs, no signature, etc.). If a certificate cannot be decoded, this is ignored
         * and an attempt is made to decode the next certificate. This overload takes no account of trust-level flags
         * because none are available in the P7C format. Therefore, when this function is used, all certificates in the
         * P7C file will be loaded as if trusted for everything, which may lead to false positives when compared to other PDF software.
         * (Most applications use the FDF Cert Exchange format.) The FDF-trust-list-loading function "LoadTrustList" should be
         * used instead whenever possible.
         * @param in_P7C_binary_DER_certificates_file_data - - the P7C-format bulk certificate data, encoded in binary DER (Distinguished Encoding Rules)
         */
        addTrustedCertificates(in_P7C_binary_DER_certificates_file_data: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray): Promise<void>;
        /**
         * Bulk trust list loading API with trust flag support. Loads a trust list that is
         * structured in Acrobat's FDF Data/Cert Exchange format into the VerificationOptions
         * certificate store. Use of this function is strongly recommended instead of the P7C
         * API (i.e. AddTrustedCertificates). Certificates inside the FDF trust list that
         * cannot be decoded and loaded, will be skipped.
         * @param in_fdf_cert_exchange_data - - an FDFDoc from the FDF cert exchange data
         */
        loadTrustList(in_fdf_cert_exchange_data: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc): Promise<void>;
        /**
         * Sets a flag that can turn on or off the verification of the permissibility of any modifications made to the document after the signing of the digital signature being verified, in terms of the document and field permissions specified by the digital signature being verified.
         * @param in_on_or_off - - A boolean.
         */
        enableModificationVerification(in_on_or_off: boolean): Promise<void>;
        /**
         * Sets a flag that can turn on or off the verification of the digest (cryptographic hash) component of a digital signature.
         * @param in_on_or_off - - A boolean.
         */
        enableDigestVerification(in_on_or_off: boolean): Promise<void>;
        /**
         * Sets a flag that can turn on or off the verification of the trust status of a digital signature.
         * @param in_on_or_off - - A boolean.
         */
        enableTrustVerification(in_on_or_off: boolean): Promise<void>;
        /**
         * Sets a URI prefix to use for online revocation requests during digital signature verification.
         * Useful for Emscripten platform -- used to avoid CORS-related errors. The default value is https://proxy.pdftron.com
         * @param in_str - the proxy prefix URL string to use for revocation requests
         */
        setRevocationProxyPrefix(in_str: string): Promise<void>;
        /**
         * Enables/disables online CRL revocation checking. The default setting is
         * for it to be turned off, but this may change in future versions.
         *
         * Note: CRL checking is off by default because the technology is inherently complicated
         * and resource-intensive, but may help improve verification rate when files are verified against
         * a recent reference-time (e.g. maximum security mode), because online CRLs will be valid within
         * that time. This mode will not be useful for old archival-type ('LTV') documents
         * verified in archiving-and-compatibility security mode, because their online OCSP and/or CRL
         * responder servers may not be alive anymore. However, such LTV documents can be created
         * (if the CRL responder servers are still active) by enabling online checking, verifying, and then
         * embedding the data using DigitalSignatureField.EnableLTVOfflineVerification.
         * @param in_on_or_off - - what setting to use
         */
        enableOnlineCRLRevocationChecking(in_on_or_off: boolean): Promise<void>;
        /**
         * Enables/disables online OCSP revocation checking. The default setting is for it to be turned on.
         * @param in_on_or_off - - what setting to use.
         */
        enableOnlineOCSPRevocationChecking(in_on_or_off: boolean): Promise<void>;
        /**
         * enables/disables all online revocation checking modes. The default settings are that
         * online OCSP is turned on and online CRL is turned off, but the default CRL setting may change in
         * future versions.
         *
         *  Note: CRL checking is off by default because the technology is inherently complicated
         * and resource-intensive, but may help improve verification rate when files are verified against
         * a recent reference-time (e.g. maximum security mode), because online CRLs will be valid within
         * that time. This mode will not be useful for old archival-type ('LTV') documents
         * verified in archiving-and-compatibility security mode, because their online OCSP and/or CRL
         * responder servers may not be alive anymore. However, such LTV documents can be created
         * (if the CRL responder servers are still active) by enabling online checking, verifying, and then
         * embedding the data using DigitalSignatureField.EnableLTVOfflineVerification.
         * @param in_on_or_off - - what setting to use
         */
        enableOnlineRevocationChecking(in_on_or_off: boolean): Promise<void>;
        /**
         * Adds a certificate from a url to the store of trusted certificates inside this options object.
         * @param url - The url from which to download the file
         * @param [options] - Additional options
         * @param options.withCredentials - Whether to set the withCredentials property on the XMLHttpRequest
         * @param options.customHeaders - An object containing custom HTTP headers to be used when downloading the document
         */
        static addTrustedCertificateFromURL(url: string, options?: {
            withCredentials: boolean;
            customHeaders: any;
        }): Promise<void>;
    }
    /**
     * The result of a verification operation performed on a digital signature.
     */
    class VerificationResult extends PDFNet.Destroyable {
        /**
         * @returns A promise that resolves to an object of type: "PDFNet.DigitalSignatureField"
         */
        getDigitalSignatureField(): Promise<PDFNet.DigitalSignatureField>;
        /**
         * Retrieves the main verification status. The main status is determined based on the other statuses.
         * Verification may fail for many reasons; some of these reasons are the presence of features that are
         * not supported yet. It may be desirable for you to report unsupported signatures differently (for example,
         * using a question mark rather than an X mark). Any unsupported features encountered can be retrieved
         * by the use of the function GetUnsupportedFeatures on this class.
         * @returns A promise that resolves to a boolean representing whether or not the verification operation was completely successful.
         */
        getVerificationStatus(): Promise<boolean>;
        /**
         * Retrieves the document-related result condition associated with a digital signature verification operation.
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.VerificationResult.DocumentStatus = {
         * 	e_no_error : 0
         * 	e_corrupt_file : 1
         * 	e_unsigned : 2
         * 	e_bad_byteranges : 3
         * 	e_corrupt_cryptographic_contents : 4
         * }
         * </pre>
         * @returns A promise that resolves to a DocumentStatus-type enumeration value.
         */
        getDocumentStatus(): Promise<number>;
        /**
         * Retrieves the digest-related result condition associated with a digital signature verification operation.
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.VerificationResult.DigestStatus = {
         * 	e_digest_invalid : 0
         * 	e_digest_verified : 1
         * 	e_digest_verification_disabled : 2
         * 	e_weak_digest_algorithm_but_digest_verifiable : 3
         * 	e_no_digest_status : 4
         * 	e_unsupported_encoding : 5
         * }
         * </pre>
         * @returns A promise that resolves to a DigestStatus-type enumeration value.
         */
        getDigestStatus(): Promise<number>;
        /**
         * Retrieves the trust-related result condition associated with a digital signature verification operation.
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.VerificationResult.TrustStatus = {
         * 	e_trust_verified : 0
         * 	e_untrusted : 1
         * 	e_trust_verification_disabled : 2
         * 	e_no_trust_status : 3
         * }
         * </pre>
         * @returns A promise that resolves to a TrustStatus-type enumeration value.
         */
        getTrustStatus(): Promise<number>;
        /**
         * Retrieves the result condition about permissions checks performed on any unsigned modifications associated with a digital signature verification operation.
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.VerificationResult.ModificationPermissionsStatus = {
         * 	e_invalidated_by_disallowed_changes : 0
         * 	e_has_allowed_changes : 1
         * 	e_unmodified : 2
         * 	e_permissions_verification_disabled : 3
         * 	e_no_permissions_status : 4
         * }
         * </pre>
         * @returns A promise that resolves to a ModificationPermissionsStatus-type enumeration value.
         */
        getPermissionsStatus(): Promise<number>;
        /**
         * Retrieves the detailed result associated with the trust step of the verification operation that returned this VerificationResult, if such a detailed trust result is available. Must call HasTrustVerificationResult first and check for a true result.
         * @returns A promise that resolves to a TrustVerificationResult object
         *
         * Note: This function will throw if no TrustVerificationResult is available.
         */
        getTrustVerificationResult(): Promise<PDFNet.TrustVerificationResult>;
        /**
         * Returns whether there is a detailed TrustVerificationResult in this VerificationResult or not.
         * @returns A promise that resolves to a boolean.
         */
        hasTrustVerificationResult(): Promise<boolean>;
        /**
         * Retrieves a list of informational structures regarding any disallowed changes that have been made to the document since the signature associated with this verification result was signed.
         * @returns A promise that resolves to a collection of DisallowedChange objects.
         */
        getDisallowedChanges(): Promise<PDFNet.DisallowedChange[]>;
        /**
         * Retrieves an enumeration value representing the digest algorithm used to sign the signature that is associated with this verification result.
         * For DocTimeStamp signatures, returns the weakest algorithm found (between the CMS and message imprint digests).
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.DigestAlgorithm.Type = {
         * 	e_SHA1 : 0
         * 	e_SHA256 : 1
         * 	e_SHA384 : 2
         * 	e_SHA512 : 3
         * 	e_RIPEMD160 : 4
         * 	e_unknown_digest_algorithm : 5
         * }
         * </pre>
         * @returns A promise that resolves to a DigestAlgorithm enumeration value.
         */
        getDigestAlgorithm(): Promise<number>;
        /**
         * Retrieves the document-related result condition associated with a digital signature verification operation, as a descriptive string.
         * @returns A promise that resolves to a string.
         */
        getDocumentStatusAsString(): Promise<string>;
        /**
         * Retrieves the digest-related result condition associated with a digital signature verification operation, as a descriptive string.
         * @returns A promise that resolves to a string.
         */
        getDigestStatusAsString(): Promise<string>;
        /**
         * Retrieves the trust-related result condition associated with a digital signature verification operation, as a descriptive string.
         * @returns A promise that resolves to a string.
         */
        getTrustStatusAsString(): Promise<string>;
        /**
         * Retrieves the result condition about permissions checks performed on any unsigned modifications associated with a digital signature verification operation, as a descriptive string.
         * @returns A promise that resolves to a string.
         */
        getPermissionsStatusAsString(): Promise<string>;
        /**
         * Retrieves reports about unsupported features encountered during verification.
         * This function is the canonical source of information about all unsupported features encountered.
         * Current possible values:
         * 	"unsupported signature encoding",
         * 	"usage rights signature",
         * 	"legal content attestations",
         * 	"unsupported digest algorithm"
         * @returns A promise that resolves to a container of strings representing unsupported features encountered during verification
         *
         * Note: Output may change in future versions.
         */
        getUnsupportedFeatures(): Promise<string[]>;
    }
    /**
     * [Missing documentation]
     */
    class ViewChangeCollection extends PDFNet.Destroyable {
        /**
         * Constructor
         * @returns A promise that resolves to an object of type: "PDFNet.ViewChangeCollection"
         */
        static create(): Promise<PDFNet.ViewChangeCollection>;
    }
    /**
     * A Watermark annotation is an annotation that is printed at a fixed
     * size and position on a page, regardless of the dimensions of the printed page.
     */
    class WatermarkAnnot extends PDFNet.Annot {
        /**
         * creates a Watermark annotation and initializes it using given Cos/SDF object.
         * @param [d] - The Cos/SDF object to initialze the annotation with.
         * Note: The constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @returns A promise that resolves to an object of type: "PDFNet.WatermarkAnnot"
         */
        static createFromObj(d?: PDFNet.Obj): Promise<PDFNet.WatermarkAnnot>;
        /**
         * creates a Watermark annotation and initializes it using given annotation object.
         * @param ann - Annot object used to initialize the Watermark annotation.
         * Note: The constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @returns A promise that resolves to an object of type: "PDFNet.WatermarkAnnot"
         */
        static createFromAnnot(ann: PDFNet.Annot): Promise<PDFNet.WatermarkAnnot>;
        /**
         * Creates a new Watermark annotation in the specified document.
         * @param doc - A document to which the annotation is added.
         * @param pos - A rectangle specifying the annotation's bounds in default user space units.
         * @returns A promise that resolves to a newly created blank Watermark annotation.
         */
        static create(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, pos: PDFNet.Rect): Promise<PDFNet.WatermarkAnnot>;
        static create(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, type: number, pos: PDFNet.Rect): Promise<PDFNet.Annot>;
    }
    /**
     * The class WebFontDownloader.
     * static interface to control the behaviour of PDFNet web font downloading
     */
    class WebFontDownloader {
        /**
         * Find out whether the web font downloader is available in version of PDFNet.
         * @returns A promise that resolves to returns true if web font downloading can be done.
         */
        static isAvailable(): Promise<boolean>;
        /**
         * Allow PDFNet to access the network to download missing fonts when possible.
         */
        static enableDownloads(): Promise<void>;
        /**
         * Prevent PDFNet from accessing the network to download missing fonts. It may still use previously downloaded fonts (which are cached on disk).
         */
        static disableDownloads(): Promise<void>;
        /**
         * download and cache a base collection of fonts in a background thread. Will not do anything if downloading is currently disabled.
         */
        static preCacheAsync(): Promise<void>;
        /**
         * clear any pre-cached font files residing in persistent storage.
         */
        static clearCache(): Promise<void>;
        /**
         * Set the root path into which the web font downloader will make requests.
         * @param url - - The root path into which the web font downloader will make requests.
         */
        static setCustomWebFontURL(url: string): Promise<void>;
    }
    /**
     * Interactive forms use widget annotations (PDF 1.2) to represent the appearance
     * of fields and to manage user interactions. As a convenience, when a field has
     * only a single associated widget annotation, the contents of the field dictionary
     * and the annotation dictionary may be merged into a single dictionary containing
     * entries that pertain to both a field and an annotation.
     * NOTE This presents no ambiguity, since the contents of the two kinds of
     * dictionaries do not conflict.
     */
    class WidgetAnnot extends PDFNet.Annot {
        /**
         * Creates a new widget annotation in the specified document.
         * @param doc - A document to which the annotation is added.
         * @param pos - A rectangle specifying the annotation's bounds in default user space units.
         * @param field - A form field associated with this widget.
         * @returns A promise that resolves to a newly created blank widget annotation.
         */
        static create(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, pos: PDFNet.Rect, field: PDFNet.Field): Promise<PDFNet.WidgetAnnot>;
        static create(doc: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, type: number, pos: PDFNet.Rect): Promise<PDFNet.Annot>;
        /**
         * creates a widget annotation and initializes it using given Cos/SDF object.
         * @param [d] - The Cos/SDF object to initialze the annotation with.
         * Note: The constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @returns A promise that resolves to an object of type: "PDFNet.WidgetAnnot"
         */
        static createFromObj(d?: PDFNet.Obj): Promise<PDFNet.WidgetAnnot>;
        /**
         * creates a widget annotation and initializes it using given annotation object.
         * @param ann - Annot object used to initialize the Widget annotation.
         * Note: The constructor does not copy any data, but is instead the logical
         * equivalent of a type cast.
         * @returns A promise that resolves to an object of type: "PDFNet.WidgetAnnot"
         */
        static createFromAnnot(ann: PDFNet.Annot): Promise<PDFNet.WidgetAnnot>;
        /**
         * Returns the field associated with the Widget.
         * @returns A promise that resolves to a Field object.
         */
        getField(): Promise<PDFNet.Field>;
        /**
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.WidgetAnnot.HighlightingMode = {
         * 	e_none : 0
         * 	e_invert : 1
         * 	e_outline : 2
         * 	e_push : 3
         * 	e_toggle : 4
         * }
         * </pre>
         * @returns A promise that resolves to the HighlightingMode of the widget annotation.
         * Note: The annotation's highlighting mode is the visual effect that shall be used
         * when the mouse button is pressed or held down inside its active area
         * Note: A highlighting mode other than e_push will override any down appearance
         * defined for the annotation.
         */
        getHighlightingMode(): Promise<number>;
        /**
         * sets the HighlightingMode for the widget annotation.
         * Note: The annotation's highlighting mode is the visual effect that shall be used
         * when the mouse button is pressed or held down inside its active area
         * @param [value] - <pre>
         * PDFNet.WidgetAnnot.HighlightingMode = {
         * 	e_none : 0
         * 	e_invert : 1
         * 	e_outline : 2
         * 	e_push : 3
         * 	e_toggle : 4
         * }
         * </pre>
         * New highlighting mode for the widget.
         * Note: A highlighting mode other than e_push shall override any down appearance defined
         * for the annotation.
         * Default value: e_invert.
         */
        setHighlightingMode(value?: number): Promise<void>;
        /**
         * Returns the action of the widget annotation
         * @returns A promise that resolves to an action object representing the action of the widget annotation
         * that should be performed when the annotation is activated.
         */
        getAction(): Promise<PDFNet.Action>;
        /**
         * Sets the action of the widget annotation
         * (Optional; PDF 1.2 )
         * @param action - An action object representing the action of the widget annotation
         * that should be performed when the annotation is activated.
         */
        setAction(action: PDFNet.Action): Promise<void>;
        /**
         * Returns the border color of the annotation.
         * @returns A promise that resolves to a color object that denotes the color of the Screen border.
         * Note: The color can be in different color spaces: Gray, RGB, or CMYK.
         * Call "GetBorderColorCompNum" to access the color space information corresponding to the border color.
         */
        getBorderColor(): Promise<PDFNet.ColorPt>;
        /**
         * sets the border color of the annotation.
         * (Optional)
         * @param col - A color object that denotes the color of the screen border.
         * @param compnum - An integer which value indicates the color space used for the parameter c.
         */
        setBorderColor(col: PDFNet.ColorPt, compnum: number): Promise<void>;
        /**
         * Returns the number indicating border color space of the annotation.
         * @returns A promise that resolves to an integer indicating a color space value from the ColorSpace::Type enum.
         * That is, 1 corresponding to "e_device_gray",
         * 3 corresponding to "e_device_rgb", and 4 corresponding to "e_device_cmyk".
         * 0 means this annotation had no color assigned.
         */
        getBorderColorCompNum(): Promise<number>;
        /**
         * Returns the number indicating background color space of the annotation.
         * @returns A promise that resolves to an integer indicating a color space value from the ColorSpace::Type enum.
         * That is, 1 corresponding to "e_device_gray",
         * 3 corresponding to "e_device_rgb", and 4 corresponding to "e_device_cmyk" if color space is applicable,
         * 0 means no background color was assigned.
         */
        getBackgroundColorCompNum(): Promise<number>;
        /**
         * Returns the background color of the annotation.
         * @returns A promise that resolves to a color object that denotes the color of the Screen background.
         * Note: The color can be in different color spaces: Gray, RGB, or CMYK.
         * Call "GetBackgroundColorCompNum" to access the color space information corresponding to the border color.
         */
        getBackgroundColor(): Promise<PDFNet.ColorPt>;
        /**
         * sets the background color of the annotation.
         * (Optional)
         * @param col - A color point that denotes the color of the screen background.
         * @param compnum - An integer which value indicates the color space used for the parameter c.
         */
        setBackgroundColor(col: PDFNet.ColorPt, compnum: number): Promise<void>;
        /**
         * Returns static caption text of the annotation.
         * @returns A promise that resolves to a string containing the static caption text of the annotation.
         * Note: The static caption is the annotation's normal caption, which
         * shall be displayed when it is not interacting with the user.
         * Unlike the remaining entries with the captions, which apply only to widget
         * annotations associated with pushbutton fields, the Static Caption(CA) entry may be used
         * with any type of button field, including check boxes.
         * Note: This property is part of the Widget appearance characteristics dictionary, this dictionary
         * that shall be used in constructing a dynamic appearance stream specifying the annotation's visual
         * presentation on the page.
         */
        getStaticCaptionText(): Promise<string>;
        /**
         * sets static caption text of the annotation.
         * (Optional; button fields only)
         * @param contents - A string containing the static caption text of the annotation.
         * Note: The static caption is the annotation's normal caption, which
         * shall be displayed when it is not interacting with the user.
         * Unlike the remaining entries with the captions, which apply only to widget
         * annotations associated with pushbutton fields, the Static Caption(CA) entry may be used
         * with any type of button field, including check boxes.
         * Note: This property is part of the Widget appearance characteristics dictionary, this dictionary
         * that shall be used in constructing a dynamic appearance stream specifying the annotation's visual
         * presentation on the page.
         */
        setStaticCaptionText(contents: string): Promise<void>;
        /**
         * Returns the rollover caption text of the annotation.
         * @returns A promise that resolves to a string containing the rollover caption text of the annotation.
         * Note: The rollover caption shall be displayed when the user rolls the cursor
         * into its active area without pressing the mouse button.
         */
        getRolloverCaptionText(): Promise<string>;
        /**
         * sets the roll over caption text of the annotation.
         * (Optional; button fields only)
         * @param contents - A string containing the roll over caption text of the annotation.
         * Note: The rollover caption shall be displayed when the user rolls the cursor
         * into its active area without pressing the mouse button.
         */
        setRolloverCaptionText(contents: string): Promise<void>;
        /**
         * Returns the button down caption text of the annotation.
         * @returns A promise that resolves to a string containing the button down text of the annotation.
         * Note: The button down caption shall be displayed when the mouse button is
         * pressed within its active area.
         */
        getMouseDownCaptionText(): Promise<string>;
        /**
         * sets the button down caption text of the annotation.
         * (Optional; button fields only)
         * @param contents - A string containing the button down text of the annotation.
         * Note: The button down caption shall be displayed when the mouse button is
         * pressed within its active area.
         */
        setMouseDownCaptionText(contents: string): Promise<void>;
        /**
         * Returns the static icon associated with the annotation.
         * @returns A promise that resolves to an SDF object that represents the static icon
         * associated with the annotation.
         * Note: The static icon object is a form XObject defining the
         * annotation's normal icon, which shall be
         * displayed when it is not interacting with the user.
         */
        getStaticIcon(): Promise<PDFNet.Obj>;
        /**
         * sets the static icon associated with the annotation.
         * (Optional; button fields only)
         * @param icon - An SDF object that represents the static icon
         * associated with the annotation.
         * Note: The static icon object is a form XObject defining the
         * annotation's normal icon, which shall be
         * displayed when it is not interacting with the user.
         */
        setStaticIcon(icon: PDFNet.Obj): Promise<void>;
        /**
         * Returns the rollover icon associated with the annotation.
         * @returns A promise that resolves to an SDF object that represents the rollover icon
         * associated with the annotation.
         * Note: The rollover icon object is a form XObject defining the
         * annotation's rollover icon, which shall be displayed
         * when the user rolls the cursor into its active area without
         * pressing the mouse button.
         */
        getRolloverIcon(): Promise<PDFNet.Obj>;
        /**
         * sets the rollover icon associated with the annotation.
         * (Optional; button fields only)
         * @param icon - An SDF object that represents the rollover icon
         * associated with the annotation.
         * Note: The rollover icon object is a form XObject defining the
         * annotation's rollover icon, which shall be displayed
         * when the user rolls the cursor into its active area without
         * pressing the mouse button.
         */
        setRolloverIcon(icon: PDFNet.Obj): Promise<void>;
        /**
         * Returns the Mouse Down icon associated with the annotation.
         * @returns A promise that resolves to an SDF object that represents the Mouse Down icon
         * associated with the annotation.
         * Note: The Mouse Down icon object is a form XObject defining the
         * annotation's alternate (down) icon, which shall be displayed
         * when the mouse button is pressed within its active area.
         */
        getMouseDownIcon(): Promise<PDFNet.Obj>;
        /**
         * sets the Mouse Down icon associated with the annotation.
         * (Optional; button fields only)
         * @param icon - An SDF object that represents the Mouse Down icon
         * associated with the annotation.
         * Note: The Mouse Down icon object is a form XObject defining the
         * annotation's alternate (down) icon, which shall be displayed
         * when the mouse button is pressed within its active area.
         */
        setMouseDownIcon(icon: PDFNet.Obj): Promise<void>;
        /**
         * Returns the Scale Type of the annotation.
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.WidgetAnnot.ScaleType = {
         * 	e_Anamorphic : 0
         * 	e_Proportional : 1
         * }
         * </pre>
         * @returns A promise that resolves to a value of the "ScaleType" enum which represents the Scale Type of the annotation.
         * Default value: P.
         */
        getScaleType(): Promise<number>;
        /**
         * sets the Scale Type of the annotation.
         * (Optional)
         * @param st - <pre>
         * PDFNet.WidgetAnnot.ScaleType = {
         * 	e_Anamorphic : 0
         * 	e_Proportional : 1
         * }
         * </pre>
         * An entry of the "ScaleType" enum which represents the Scale Type of the annotation.
         * Default value: P.
         */
        setScaleType(st: number): Promise<void>;
        /**
         * Returns the Icon and caption relationship of the  annotation.
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.WidgetAnnot.IconCaptionRelation = {
         * 	e_NoIcon : 0
         * 	e_NoCaption : 1
         * 	e_CBelowI : 2
         * 	e_CAboveI : 3
         * 	e_CRightILeft : 4
         * 	e_CLeftIRight : 5
         * 	e_COverlayI : 6
         * }
         * </pre>
         * @returns A promise that resolves to a value of the "IconCaptionRelation" enum type.
         * Default value: e_NoIcon.
         */
        getIconCaptionRelation(): Promise<number>;
        /**
         * sets the Icon and caption relationship of the  annotation.
         * (Optional; pushbutton fields only)
         * @param icr - <pre>
         * PDFNet.WidgetAnnot.IconCaptionRelation = {
         * 	e_NoIcon : 0
         * 	e_NoCaption : 1
         * 	e_CBelowI : 2
         * 	e_CAboveI : 3
         * 	e_CRightILeft : 4
         * 	e_CLeftIRight : 5
         * 	e_COverlayI : 6
         * }
         * </pre>
         * A value of the "IconCaptionRelation" enum type.
         * Default value: e_NoIcon.
         */
        setIconCaptionRelation(icr: number): Promise<void>;
        /**
         * Returns the condition under which the icon should be scaled.
         * @example
         * Return value enum:
         * <pre>
         * PDFNet.WidgetAnnot.ScaleCondition = {
         * 	e_Always : 0
         * 	e_WhenBigger : 1
         * 	e_WhenSmaller : 2
         * 	e_Never : 3
         * }
         * </pre>
         * @returns A promise that resolves to a value of the "ScaleCondition" enum type.
         * Default value: e_Always.
         */
        getScaleCondition(): Promise<number>;
        /**
         * sets the condition under which the icon should be scaled.
         * (Optional)
         * @param sd - <pre>
         * PDFNet.WidgetAnnot.ScaleCondition = {
         * 	e_Always : 0
         * 	e_WhenBigger : 1
         * 	e_WhenSmaller : 2
         * 	e_Never : 3
         * }
         * </pre>
         * A value of the "ScaleCondition" enum type.
         * Default value: e_Always.
         */
        setScaleCondition(sd: number): Promise<void>;
        /**
         * Returns the "fit full" flag.
         * @returns A promise that resolves to a boolean value indicating the "fit full" flag value.
         * Note: the fit full flag, if true, indicates that the button
         * appearance shall be scaled to fit fully within the bounds of
         * the annotation without taking into consideration the line
         * width of the border.
         * Default value: false.
         */
        getFitFull(): Promise<boolean>;
        /**
         * sets the "fit full" flag.
         * (Optional)
         * @param ff - A boolean value indicating the "fit full" flag value.
         * Note: the fit full flag, if true, indicates that the button
         * appearance shall be scaled to fit fully within the bounds of
         * the annotation without taking into consideration the line
         * width of the border. Default value: false.
         */
        setFitFull(ff: boolean): Promise<void>;
        /**
         * Returns the horizontal leftover space of the icon within the annotation.
         * @returns A promise that resolves to a number indicating the horizontal
         * leftover space of the icon within the annotation.
         * Note: the horizontal leftover is a number that shall be between
         * 0.0 and 1.0 indicating the fraction of leftover space to allocate at the left.
         * A value of 0.0 shall position the icon at the left of the annotation rectangle.
         * A value of 0.5 shall center it in the horizontal direction within the rectangle.
         * This entry shall be used only if the icon is scaled proportionally.
         * Default value: 0.5.
         */
        getHIconLeftOver(): Promise<number>;
        /**
         * sets the horizontal leftover space of the icon within the annotation.
         * (Optional)
         * @param hl - A number indicating the horizontal
         * leftover space of the icon within the annotation.
         * Note: the horizontal leftover space is a number that shall be between
         * 0.0 and 1.0 indicating the fraction of leftover space to allocate at the left.
         * A value of 0.0 shall position the icon at the left of the annotation rectangle.
         * A value of 0.5 shall center it in the horizontal direction within the rectangle.
         * This entry shall be used only if the icon is scaled proportionally.
         * Default value: 0.5.
         */
        setHIconLeftOver(hl: number): Promise<void>;
        /**
         * Returns the vertical leftover space of the icon within the annotation.
         * @returns A promise that resolves to a number indicating the vertical
         * leftover space of the icon within the annotation.
         * Note: the vertical leftover space is a number that
         * shall be between 0.0 and 1.0 indicating the fraction of leftover
         * space to allocate at the bottom of the icon.
         * A value of 0.0 shall position the icon at the bottom
         * of the annotation rectangle.
         * A value of 0.5 shall center it in the vertical direction within
         * the rectangle.
         * This entry shall be used only if the icon is scaled proportionally.
         * Default value: 0.5.
         */
        getVIconLeftOver(): Promise<number>;
        /**
         * sets the vertical leftover space of the icon within the annotation.
         * (Optional)
         * @param vl - A number indicating the vertical
         * leftover space of the icon within the annotation.
         * Note: the vertical leftover space is a number that
         * shall be between 0.0 and 1.0 indicating the fraction of leftover
         * space to allocate at the bottom of the icon.
         * A value of 0.0 shall position the icon at the bottom
         * of the annotation rectangle.
         * A value of 0.5 shall center it in the vertical direction within
         * the rectangle.
         * This entry shall be used only if the icon is scaled proportionally.
         * Default value: 0.5.
         */
        setVIconLeftOver(vl: number): Promise<void>;
        /**
         * Sets the font size of the Widget Annotation.
         * @param font_size - the new font size
         * Note: A font size of 0 specifies that the text should be autosized to fit in the Widget.
         */
        setFontSize(font_size: number): Promise<void>;
        /**
         * Sets the text color of the Widget Annotation.
         * @param color - ColorPt object representing the color.
         * @param col_comp - An integer indicating a color space value from the ColorSpace::Type enum. That is,
         * 1 corresponding to "e_device_gray", 3 corresponding to "e_device_rgb", and 4 corresponding to "e_device_cmyk".
         */
        setTextColor(color: PDFNet.ColorPt, col_comp: number): Promise<void>;
        /**
         * Specifies a font to be used for text in this Widget.
         * @param font - the font to use.
         */
        setFont(font: PDFNet.Font): Promise<void>;
        /**
         * Returns the font size used in this Widget Annotation.
         * @returns A promise that resolves to the font size
         * Note: A font size of 0 specifies that the text should be autosized to fit in the Widget.
         */
        getFontSize(): Promise<number>;
        /**
         * Returns the text color of the Widget Annotation.
         * @returns A promise that resolves to the text color.
         * Note: the color can be in different color spaces: Gray, RGB, or CMYK. Call "GetTextColorCompNum"
         * to access the color space information corresponding to the border color.
         */
        getTextColor(): Promise<object>;
        /**
         * Retrieves the font used for displaying text in this Widget.
         * @returns A promise that resolves to the font used by this Widget.
         */
        getFont(): Promise<PDFNet.Font>;
    }
    /**
     * This class represents an AttributeTypeAndValue as mentioned in RFC 5280 in the context of DistinguishedNames and as defined in ITU X.501.
     */
    class X501AttributeTypeAndValue extends PDFNet.Destroyable {
        /**
         * Retrieves the OID (i.e. one of the object identifiers from the X.500 attribute types) in the form of integer components in a container.
         * @returns A promise that resolves to an ObjectIdentifier object.
         */
        getAttributeTypeOID(): Promise<PDFNet.ObjectIdentifier>;
        /**
         * Retrieves the value associated with the contained OID (object identifier) as a string, if the value is defined by the OID to be of a string type.
         * @returns A promise that resolves to a string containing the string value.
         */
        getStringValue(): Promise<string>;
    }
    /**
     * This class represents a distinguished name (DN) as defined in X.501.
     * See the X.500 standards, RFC 5280, and an OID repository for more information.
     */
    class X501DistinguishedName extends PDFNet.Destroyable {
        /**
         * Returns whether this distinguished name contains a particular attribute, identified by its object identifier (OID).
         * @param in_oid - the object identifier representing the sought attribute.
         * @returns A promise that resolves to a boolean value representing whether this distinguished name contains the supplied attribute.
         */
        hasAttribute(in_oid: PDFNet.ObjectIdentifier): Promise<boolean>;
        /**
         * Returns a container full of string representations of all the values in this distinguished name that match a particular attribute's object identifier (OID).
         * If an attribute's OID defines the corresponding value to not be of a string type, then that value will not be returned from this function.
         * @param in_oid - the object identifier representing the sought attribute.
         * @returns A promise that resolves to a container of string values containing any strings associated with the supplied attribute
         */
        getStringValuesForAttribute(in_oid: PDFNet.ObjectIdentifier): Promise<string[]>;
        /**
         * Retrieves all of the attribute-type-to-value pairs in this distinguished name.
         * @returns A promise that resolves to a container of X501AttributeTypeAndValue objects
         */
        getAllAttributesAndValues(): Promise<PDFNet.X501AttributeTypeAndValue[]>;
    }
    /**
     * This class represents an X509 public-key certificate, as specified in RFC 5280.
     */
    class X509Certificate extends PDFNet.Destroyable {
        /**
         * Constructor from buffer. The input must be in DER, BER, or PEM encoding. The certificate must be in X.509 format.
         * @param in_cert_buf - - a buffer containing the certificate
         * @returns A promise that resolves to an object of type: "PDFNet.X509Certificate"
         */
        static createFromBuffer(in_cert_buf: ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray): Promise<PDFNet.X509Certificate>;
        /**
         * Retrieves the names of the certificate issuer as a map of OIDs (i.e. one of the
         * object identifiers from the X.500 attribute types) to string values. The issuer field
         * identifies the entity that has signed and issued the certificate. The returned value
         * will contain all of the AttributeTypeAndValue items from all of the
         * RelativeDistinguishedNames in the Name of the issuer. See RFC 5280, section 4.1.2.4
         * and Appendix A.1 (page 116).
         * @returns A promise that resolves to an X501DistinguishedName object
         */
        getIssuerField(): Promise<PDFNet.X501DistinguishedName>;
        /**
         * Retrieves the names of the certificate subject as a map of OIDs (i.e. one of the
         * object identifiers from the X.500 attribute types) to string values. The subject field
         * represents the identity of the entity associated with the certificate's public key. The
         * returned value will contain all of the AttributeTypeAndValue items from all of the
         * RelativeDistinguishedNames in the Name of the subject. See RFC 5280, section 4.1.2.6
         * and Appendix A.1 (page 116).
         * @returns A promise that resolves to an X501DistinguishedName object
         */
        getSubjectField(): Promise<PDFNet.X501DistinguishedName>;
        /**
         * Retrieves the notBefore time from the certificate's Validity entry in the form of an
         * integral value representing an epoch time.
         * @returns A promise that resolves to an integer containing an epoch time
         */
        getNotBeforeEpochTime(): Promise<number>;
        /**
         * Retrieves the notAfter time from the certificate's Validity entry in the form of an
         * integral value representing an epoch time.
         * @returns A promise that resolves to an integer containing an epoch time
         */
        getNotAfterEpochTime(): Promise<number>;
        /**
         * Retrieves the version number representing which version of X509 the certificate corresponds to, from the certificate.
         * @returns A promise that resolves to an integer containing the version number
         *
         * Note: The X509 version number in the certificate, which we return unchanged here, is zero-indexed and therefore is one less in value than the actual version. e.g. X509v3 is represented by a returned version number of 2.
         */
        getRawX509VersionNumber(): Promise<number>;
        /**
         * Returns a string representation of the certificate.
         * @returns A promise that resolves to a string representation of the certificate.
         *
         * Note: Output may change in future versions.
         */
        toString(): Promise<string>;
        /**
         * Retrieves, in a string, a text representation of a cryptographically-secure digest of the certificate that can be used to identify it uniquely.
         * @param [in_digest_algorithm] - <pre>
         * PDFNet.DigestAlgorithm.Type = {
         * 	e_SHA1 : 0
         * 	e_SHA256 : 1
         * 	e_SHA384 : 2
         * 	e_SHA512 : 3
         * 	e_RIPEMD160 : 4
         * 	e_unknown_digest_algorithm : 5
         * }
         * </pre>
         * An enumeration representing the digest algorithm to use. Currently supported are SHA-1 (SHA-160), SHA-256, SHA-384, and SHA-512.
         * @returns A promise that resolves to a string representation of the fingerprint, in the form of double ASCII characters representing hex bytes, separated by colons
         *
         * Note: Default algorithm parameter is currently SHA-256, but may change in future without further warning, pursuant to security needs.
         */
        getFingerprint(in_digest_algorithm?: number): Promise<string>;
        /**
         * Retrieves the serialNumber entry from the certificate.
         * @returns A promise that resolves to a big-integer-style container holding bytes representing the components of an integral serial number in big-endian order.
         */
        getSerialNumber(): Promise<Uint8Array>;
        /**
         * Retrieves all extensions (as first specified in V3 of X509, see RFC 5280) from the certificate.
         * @returns A promise that resolves to a container of X509Extension objects.
         */
        getExtensions(): Promise<PDFNet.X509Extension[]>;
        /**
         * Retrieves the certificate as binary DER-encoded data. (DER is short for Distinguished Encoding Rules.).
         * @returns A promise that resolves to a container of bytes representing the certificate, encoded as binary DER.
         */
        getData(): Promise<Uint8Array>;
    }
    /**
     * This class represents an X509v3 certificate extension. See RFC 5280 as a specification.
     */
    class X509Extension extends PDFNet.Destroyable {
        /**
         * Retrieves whether the extension is 'critical'. See RFC 5280 for an explanation of what this means.
         * @returns A promise that resolves to a boolean representing the criticality flag of the extension.
         */
        isCritical(): Promise<boolean>;
        /**
         * Retrieves the OID (object identifier) of the extension in the form of integer components in a container. The meaning of an OID can be determined from an OID repository.
         * @returns A promise that resolves to an ObjectIdentifier object.
         */
        getObjectIdentifier(): Promise<PDFNet.ObjectIdentifier>;
        /**
         * Returns a string representation of the extension.
         * @returns A promise that resolves to a string representation of the extension.
         *
         * Note: Output may change in future versions.
         */
        toString(): Promise<string>;
        /**
         * Retrieves the raw binary DER-encoded data of the extension. (DER is short for Distinguished Encoding Rules.)
         * @returns A promise that resolves to a container holding the bytes of the extension in the form of binary DER-encoded data
         */
        getData(): Promise<Uint8Array>;
    }
    namespace PDFDoc {
        /**
         * Options for PDFNet.PDFDoc.RefreshAnnotAppearances or PDFNet.Annot.refreshAppearanceRefreshOptions
         */
        class RefreshOptions {
            /**
             * Gets the value DrawBackgroundOnly from the options object
             * If true draw only the background and border, which can be useful when generating the rest of the annotation content elsewhere. Off by default.
             * @returns the current value for DrawBackgroundOnly.
             */
            getDrawBackgroundOnly(): boolean;
            /**
             * Sets the value for DrawBackgroundOnly in the options object
             * If true draw only the background and border, which can be useful when generating the rest of the annotation content elsewhere. Off by default.
             * @param value - the new value for DrawBackgroundOnly
             * @returns this object, for call chaining
             */
            setDrawBackgroundOnly(value: boolean): PDFNet.PDFDoc.RefreshOptions;
            /**
             * Gets the value RefreshExisting from the options object
             * Whether we should refresh annotations with existing appearances. Defaults to false when used in PDFDoc.RefreshAnnotAppearances and true when used in Annot.RefreshAppearance.
             * @returns the current value for RefreshExisting.
             */
            getRefreshExisting(): boolean;
            /**
             * Sets the value for RefreshExisting in the options object
             * Whether we should refresh annotations with existing appearances. Defaults to false when used in PDFDoc.RefreshAnnotAppearances and true when used in Annot.RefreshAppearance.
             * @param value - the new value for RefreshExisting
             * @returns this object, for call chaining
             */
            setRefreshExisting(value: boolean): PDFNet.PDFDoc.RefreshOptions;
            /**
             * Gets the value UseNonStandardRotation from the options object
             * Whether we should use rotation in the annotation even if it is not a multiple of 90. Off by default.
             * @returns the current value for UseNonStandardRotation.
             */
            getUseNonStandardRotation(): boolean;
            /**
             * Sets the value for UseNonStandardRotation in the options object
             * Whether we should use rotation in the annotation even if it is not a multiple of 90. Off by default.
             * @param value - the new value for UseNonStandardRotation.
             * @returns this object, for call chaining
             */
            setUseNonStandardRotation(value: boolean): PDFNet.PDFDoc.RefreshOptions;
            /**
             * Gets the value UseRoundedCorners from the options object
             * Whether we should use the corner radii specified in Annot.BorderStyle. Off by default.
             * @returns the current value for UseRoundedCorners.
             */
            getUseRoundedCorners(): boolean;
            /**
             * Sets the value for UseRoundedCorners in the options object
             * Whether we should use the corner radii specified in Annot.BorderStyle. Off by default.
             * @param value - the new value for UseRoundedCorners.
             * @returns this object, for call chaining
             */
            setUseRoundedCorners(value: boolean): PDFNet.PDFDoc.RefreshOptions;
        }
        /**
         * Options for PDFNet.PDFDoc.appendVisualDiff
         */
        class DiffOptions {
            /**
             * Gets the value AddGroupAnnots from the options object
             * Whether we should add an annot layer indicating the difference regions
             * @returns a bool, the current value for AddGroupAnnots.
             */
            getAddGroupAnnots(): boolean;
            /**
             * Sets the value for AddGroupAnnots in the options object
             * Whether we should add an annot layer indicating the difference regions
             * @param value - the new value for AddGroupAnnots
             * @returns this object, for call chaining
             */
            setAddGroupAnnots(value: boolean): PDFNet.PDFDoc.DiffOptions;
            /**
             * Gets the value BlendMode from the options object
             * How the two colors should be blended.
             * @example
             * Return value:
             * <pre>
             * PDFNet.GState.BlendMode = {
             * 	e_bl_compatible : 0
             * 	e_bl_normal : 1
             * 	e_bl_multiply : 2
             * 	e_bl_screen : 3
             * 	e_bl_difference : 4
             * 	e_bl_darken : 5
             * 	e_bl_lighten : 6
             * 	e_bl_color_dodge : 7
             * 	e_bl_color_burn : 8
             * 	e_bl_exclusion : 9
             * 	e_bl_hard_light : 10
             * 	e_bl_overlay : 11
             * 	e_bl_soft_light : 12
             * 	e_bl_luminosity : 13
             * 	e_bl_hue : 14
             * 	e_bl_saturation : 15
             * 	e_bl_color : 16
             * }
             * </pre>
             * @returns the current value for BlendMode.
             */
            getBlendMode(): number;
            /**
             * Sets the value for BlendMode in the options object
             * How the two colors should be blended.
             * @param value - the new value for BlendMode
             * <pre>
             * PDFNet.GState.BlendMode = {
             * 	e_bl_compatible : 0
             * 	e_bl_normal : 1
             * 	e_bl_multiply : 2
             * 	e_bl_screen : 3
             * 	e_bl_difference : 4
             * 	e_bl_darken : 5
             * 	e_bl_lighten : 6
             * 	e_bl_color_dodge : 7
             * 	e_bl_color_burn : 8
             * 	e_bl_exclusion : 9
             * 	e_bl_hard_light : 10
             * 	e_bl_overlay : 11
             * 	e_bl_soft_light : 12
             * 	e_bl_luminosity : 13
             * 	e_bl_hue : 14
             * 	e_bl_saturation : 15
             * 	e_bl_color : 16
             * }
             * </pre>
             * @returns this object, for call chaining
             */
            setBlendMode(value: number): PDFNet.PDFDoc.DiffOptions;
            /**
             * Gets the value ColorA from the options object
             * The difference color for the first page.
             * @returns an object in form {A: number, R: number, G: number, B: number}, the current value for ColorA.
             */
            getColorA(): any;
            /**
             * Sets the value for ColorA in the options object
             * The difference color for the first page.
             * @param value - the new value for ColorA, in form {A: number, R: number, G: number, B: number}
             * @returns this object, for call chaining
             */
            setColorA(value: any): PDFNet.PDFDoc.DiffOptions;
            /**
             * Gets the value ColorB from the options object
             * The difference color for the second page
             * @returns an object in form {A: number, R: number, G: number, B: number}, the current value for ColorB.
             */
            getColorB(): any;
            /**
             * Sets the value for ColorB in the options object
             * The difference color for the second page
             * @param value - the new value for ColorB, in form {A: number, R: number, G: number, B: number}
             * @returns this object, for call chaining
             */
            setColorB(value: any): PDFNet.PDFDoc.DiffOptions;
            /**
             * Gets the value LuminosityCompression from the options object
             * @returns the current value for LuminosityCompression.
             */
            getLuminosityCompression(): number;
            /**
             * Sets the value for LuminosityCompression in the options object
             * @param value - the new value for LuminosityCompression.
             * @returns this object, for call chaining
             */
            setLuminosityCompression(value: number): PDFNet.PDFDoc.DiffOptions;
        }
        /**
         * Options for PDFNet.PDFDoc.appendTextDiffDocOpt
         */
        class TextDiffOptions {
            /**
             * Gets the value ColorA from the options object
             * The difference color for deletions
             * @returns an object in form {R: number, G: number, B: number}, the current value for ColorA.
             */
            getColorA(): any;
            /**
             * Sets the value for ColorA in the options object
             * The difference color for deletions
             * @param color - the new value for ColorA, in form {R: number, G: number, B: number}
             * @returns this object, for call chaining
             */
            setColorA(color: any): PDFNet.PDFDoc.TextDiffOptions;
            /**
             * Gets the value OpacityA from the options object
             * The difference opacity for deletions
             * @returns the current value for OpacityA in between 0.0 (transparent) and 1.0 (opaque).
             */
            getOpacityA(): number;
            /**
             * Sets the value for OpacityA in the options object
             * The difference opacity for deletions
             * @param opacity - the new value for OpacityA in between 0.0 (transparent) and 1.0 (opaque)
             * @returns this object, for call chaining
             */
            setOpacityA(opacity: number): PDFNet.PDFDoc.TextDiffOptions;
            /**
             * Gets the value ColorB from the options object
             * The difference color for insertions
             * @returns an object in form {R: number, G: number, B: number}, the current value for ColorB.
             */
            getColorB(): any;
            /**
             * Sets the value for ColorB in the options object
             * The difference color for insertions
             * @param color - the new value for ColorB, in form {R: number, G: number, B: number}
             * @returns this object, for call chaining
             */
            setColorB(color: any): PDFNet.PDFDoc.TextDiffOptions;
            /**
             * Gets the value OpacityB from the options object
             * The difference opacity for deletions
             * @returns the current value for OpacityB in between 0.0 (transparent) and 1.0 (opaque).
             */
            getOpacityB(): number;
            /**
             * Sets the value for OpacityB in the options object
             * The difference opacity for deletions
             * @param opacity - the new value for OpacityB in between 0.0 (transparent) and 1.0 (opaque)
             * @returns this object, for call chaining
             */
            setOpacityB(opacity: number): PDFNet.PDFDoc.TextDiffOptions;
            /**
             * Adds a collection of ignorable regions for the given page,
             * an optional list of page areas not to be included in analysis
             * @param regions - the zones to be added to the ignore list
             * @param page_num - the page number the added regions belong to
             * @returns this object, for call chaining
             */
            addIgnoreZonesForPage(regions: PDFNet.Rect[], page_num: number): PDFNet.PDFDoc.TextDiffOptions;
        }
        /**
         * Options for PDFNet.PDFDoc.saveAsXFDFWithOptions and PDFNet.PDFDoc.saveAsXFDFAsStringWithOptions
         */
        class MergeXFDFOptions {
            /**
             * Gets the value Force from the options object
             * If true, merge will be performed even if the conditions below are true. If false, the MergeXFDF operation will be aborted with exception if one of these conditions is true: 1)xfdf contains annotations with no 'name' attribute 2)annotations in pdf or xfdf have names that are not unique, i.e. multiple annotations in the same document have the same name. In order for the merge operation to work correctly, all the annotations in xfdf need to have a unique 'name' attribute. If pdf document has unnamed annotatations (no 'NM' attribute), xfdf files generated using PDFTron SDK will still have names that will allow the MergeXFDF algorithm to work.
             * @returns the current value for Force.
             */
            getForce(): boolean;
            /**
             * Sets the value for Force in the options object
             * If true, merge will be performed even if the conditions below are true. If false, the MergeXFDF operation will be aborted with exception if one of these conditions is true: 1)xfdf contains annotations with no 'name' attribute 2)annotations in pdf or xfdf have names that are not unique, i.e. multiple annotations in the same document have the same name. In order for the merge operation to work correctly, all the annotations in xfdf need to have a unique 'name' attribute. If pdf document has unnamed annotatations (no 'NM' attribute), xfdf files generated using PDFTron SDK will still have names that will allow the MergeXFDF algorithm to work.
             * @param value - the new value for Force
             * @returns this object, for call chaining
             */
            setForce(value: boolean): PDFNet.PDFDoc.MergeXFDFOptions;
        }
        /**
         * An object containing options for PDFDoc.saveViewerOptimized function
         */
        class ViewerOptimizedOptions {
            /**
             * For any pages that are not forced to include thumbnails this
            function adjusts whether we should include them depending on the
            complexity of the page. This can be used to include fewer or more thumbnails
            as required by the use case. In particular reducing this value
            will tend to increase the number of page thumbnails included and vice versa.
             * @param threshold - A number from 0 (include all thumbnails) to 100
            (include only the first thumbnail) representing the complexity at which
            SaveViewerOptimized would include the thumbnail. The default value is 50.
             * @returns this object, for call chaining
             */
            setThumbnailRenderingThreshold(threshold: number): PDFNet.PDFDoc.ViewerOptimizedOptions;
            /**
             * Set the number of pages starting from the first for which to guarantee thumbnails regardless of page complexity.
            This can help improve the viewing experience on the first few pages without increasing the file size dramatically.
            If this number is greater than the number of pages in the document all of the pages will have thumbnails.
             * @param initial_thumbs - The number of pages starting with the first which are guaranteed to have thumbnails. The default value is 1,
            which means only the first page is guaranteed to have a thumbnail.
             * @returns this object, for call chaining
             */
            setMinimumInitialThumbnails(initial_thumbs: number): PDFNet.PDFDoc.ViewerOptimizedOptions;
            /**
             * The maximum allowed length for the thumbnail's height/width.
            The default thumbnail size is 1024.
             * @param size - the maximum dimension (width or height) that thumbnails will have.
             * @returns this object, for call chaining
             */
            setThumbnailSize(size: number): PDFNet.PDFDoc.ViewerOptimizedOptions;
            /**
             * Enable or disable support for overprint and overprint simulation in generated thumbnails.
            Overprint is a device dependent feature and the results will vary depending on
            the output color space and supported colorants (i.e. CMYK, CMYK+spot, RGB, etc).
            Default is e_op_pdfx_on.
             * @param mode - <pre>
            PDFNet.PDFRasterizer.OverprintPreviewMode = {
                e_op_off : 0
                e_op_on : 1
                e_op_pdfx_on : 2
            }
            </pre>
            e_op_on: always enabled; e_op_off: always disabled; e_op_pdfx_on: enabled for PDF/X files only.
             * @returns this object, for call chaining
             */
            setOverprint(mode: number): PDFNet.PDFDoc.ViewerOptimizedOptions;
        }
        enum EventType {
            e_action_trigger_doc_will_close,
            e_action_trigger_doc_will_save,
            e_action_trigger_doc_did_save,
            e_action_trigger_doc_will_print,
            e_action_trigger_doc_did_print
        }
        enum InsertFlag {
            e_none,
            e_insert_bookmark
        }
        enum ExtractFlag {
            e_forms_only,
            e_annots_only,
            e_both
        }
        enum SignaturesVerificationStatus {
            e_unsigned,
            e_failure,
            e_untrusted,
            e_unsupported,
            e_verified
        }
    }
    namespace FDFDoc {
        /**
         * Options for PDFNet.FDFDoc.saveAsXFDFWithOptions and PDFNet.FDFDoc.saveAsXFDFAsStringWithOptions
         */
        class XFDFExportOptions {
            /**
             * Gets the value WriteAnnotationAppearance from the options object
             * When the option is enabled, the appearance wil be written for the annotations with custom appearance (i.e. different from that generated by RefreshAppearance()). Note, that if WriteImagedata is enabled, appearance will not be written for the annotations that support imagedata. In order to preserve vector information, WriteImagedata needs to be disabled
             * @returns the current value for WriteAnnotationAppearance.
             */
            getWriteAnnotationAppearance(): boolean;
            /**
             * Sets the value for WriteAnnotationAppearance in the options object
             * When the option is enabled, the appearance wil be written for the annotations with custom appearance (i.e. different from that generated by RefreshAppearance()). Note, that if WriteImagedata is enabled, appearance will not be written for the annotations that support imagedata. In order to preserve vector information, WriteImagedata needs to be disabled
             * @param value - the new value for WriteAnnotationAppearance
             * @returns this object, for call chaining
             */
            setWriteAnnotationAppearance(value: boolean): PDFNet.FDFDoc.XFDFExportOptions;
            /**
             * Gets the value WriteImagedata from the options object
             * If true, rasterized appearance will be written for the image-based annotations (stamps and signature fields) to xfdf
             * @returns the current value for WriteImagedata.
             */
            getWriteImagedata(): boolean;
            /**
             * Sets the value for WriteImagedata in the options object
             * If true, rasterized appearance will be written for the image-based annotations (stamps and signature fields) to xfdf
             * @param value - the new value for WriteImagedata
             * @returns this object, for call chaining
             */
            setWriteImagedata(value: boolean): PDFNet.FDFDoc.XFDFExportOptions;
        }
    }
    namespace Convert {
        /**
         * An object containing options for fromDICOM functions
         */
        class AdvancedImagingConvertOptions {
            /**
             * Gets the value DefaultDPI from the options object
             * Default dpi used when rendering content when resolution is not provided in the image file.
             * No image pixel data is lost by specifiying this option. Note: In case of DICOM images,
             * we assume that the resolution is specified by Pixel Spacing attribute.
             * @returns the current value for DefaultDPI.
             */
            getDefaultDPI(): number;
            /**
             * Sets the value for DefaultDPI in the options object
             * Default dpi used when rendering content when resolution is not provided in the image file.
             * No image pixel data is lost by specifiying this option. Note: In case of DICOM images,
             * we assume that the resolution is specified by Pixel Spacing attribute.
             * @param value - the new value for DefaultDPI
             * @returns this object, for call chaining
             */
            setDefaultDPI(value: number): PDFNet.Convert.AdvancedImagingConvertOptions;
            /**
             * Gets the value EnableAutoLevel from the options object
             * When the option is enabled, the maximum and minimum pixel values of the entire image
             * are calculated and all the image pixel values are streched to make use of the full range
             * of values. In effect, this option enables normalization of the entire image and can
             * potentially improve its brightness and contrast.
             * @returns the current value for EnableAutoLevel.
             */
            getEnableAutoLevel(): boolean;
            /**
             * Sets the value for DefaultDPI in the options object
             * Default dpi used when rendering content when resolution is not provided in the image file.
             * No image pixel data is lost by specifiying this option. Note: In case of DICOM images,
             * we assume that the resolution is specified by Pixel Spacing attribute.
             * @param value - the new value for DefaultDPI
             * @returns this object, for call chaining
             */
            setDefaultDPI(value: number): PDFNet.Convert.AdvancedImagingConvertOptions;
        }
        /**
         * An object containing options for wordToPdf functions
         * @param [json] - options in JSON format.
         */
        class ConversionOptions {
            constructor(json?: string);
        }
        /**
         * An object containing options for wordToPdf functions
         * @param [json] - options in JSON format.
         */
        class OfficeToPDFOptions extends ConversionOptions {
            constructor(json?: string);
            /**
             * Sets the value for ApplyPageBreaksToSheet in the options object
            Whether we should split Excel workheets into pages so that the output resembles print output.
             * @param value - the new value for ApplyPageBreaksToSheet
             * @returns this object, for call chaining
             */
            setApplyPageBreaksToSheet(value: boolean): PDFNet.Convert.OfficeToPDFOptions;
            /**
             * Sets the value for DisplayChangeTracking in the options object
            If this option is true, will display office change tracking markup present in the
            document (i.e, red strikethrough of deleted content and underlining of new content).
            Otherwise displays the resolved document content, with no markup. Defaults to true.
             * @param value - the new value for DisplayChangeTracking
             * @returns this object, for call chaining
             */
            setDisplayChangeTracking(value: boolean): PDFNet.Convert.OfficeToPDFOptions;
            /**
             * Sets the value for ExcelDefaultCellBorderWidth in the options object
            Cell border width for table cells that would normally be drawn with no border.
            In units of points. Can be used to achieve a similar effect to the "show gridlines"
            display option within Microsoft Excel.
             * @param width - the new value for ExcelDefaultCellBorderWidth
             * @returns this object, for call chaining
             */
            setExcelDefaultCellBorderWidth(width: number): PDFNet.Convert.OfficeToPDFOptions;
            /**
             * Sets the value for ExcelMaxAllowedCellCount in the options object
            Conversion will throw an exception if the number of cells in a Microsoft Excel
            document is above the set MaxAllowedCellCount. Used for early termination of resource
            intensive conversions. Setting this value to 250000 will allow the vast majority of
            Excel documents to convert without issue, while keeping RAM usage to a reasonable level.
            By default there is no limit to the number of allowed cells.
             * @param value - the new value for ExcelMaxAllowedCellCount
             * @returns this object, for call chaining
             */
            setExcelMaxAllowedCellCount(value: number): PDFNet.Convert.OfficeToPDFOptions;
            /**
             * Sets the value for Locale in the options object
            ISO 639-1 code of the current system locale. For example: 'en-US', 'ar-SA', 'de-DE', etc.
             * @param value - the new value for Locale
             * @returns this object, for call chaining
             */
            setLocale(value: string): PDFNet.Convert.OfficeToPDFOptions;
            /**
             * Sets the value for TemplateParamsJson in the options object
            JSON string representing the data to be merged into a PDFTron office template
             * @param value - the new value for TemplateParamsJson
             * @returns this object, for call chaining
             */
            setTemplateParamsJson(value: string): PDFNet.Convert.OfficeToPDFOptions;
        }
        enum OverprintPreviewMode {
            e_op_off,
            e_op_on,
            e_op_pdfx_on
        }
        /**
         * An object containing options common to ToXps and ToXod functions
         */
        class XPSOutputCommonOptions {
            /**
             * Sets whether ToXps should be run in print mode.
            Default is false.
             * @param print_mode - if true print mode is enabled
             * @returns this object, for call chaining
             */
            setPrintMode(print_mode: boolean): PDFNet.Convert.XPSOutputCommonOptions;
            /**
             * The output resolution, from 1 to 1000, in Dots Per Inch (DPI) at which to
            render elements which cannot be directly converted.
            Default is 140.
             * @param dpi - the resolution in Dots Per Inch
             * @returns this object, for call chaining
             */
            setDPI(dpi: number): PDFNet.Convert.XPSOutputCommonOptions;
            /**
             * Sets whether rendering of pages should be permitted when necessary to guarantee output.
            Default is true.
             * @param render - if false rendering is not permitted under any circumstance
             * @returns this object, for call chaining
             */
            setRenderPages(render: boolean): PDFNet.Convert.XPSOutputCommonOptions;
            /**
             * Sets whether thin lines should be thickened.
            Default is true for XPS and false for XOD.
             * @param thicken - if true then thin lines will be thickened
             * @returns this object, for call chaining
             */
            setThickenLines(thicken: boolean): PDFNet.Convert.XPSOutputCommonOptions;
            /**
             * Sets whether links should be generated from urls found in the document.
            Default is false.
             * @param generate - if true links will be generated from urls
             * @returns this object, for call chaining
             */
            generateURLLinks(generate: boolean): PDFNet.Convert.XPSOutputCommonOptions;
            /**
             * Enable or disable support for overprint and overprint simulation.
            Overprint is a device dependent feature and the results will vary depending on
            the output color space and supported colorants (i.e. CMYK, CMYK+spot, RGB, etc).
            Default is e_op_pdfx_on.
             * @param mode - <pre>
            PDFNet.Convert.OverprintPreviewMode = {
                e_op_off : 0
                e_op_on : 1
                e_op_pdfx_on : 2
            }
            </pre>
            e_op_on: always enabled; e_op_off: always disabled; e_op_pdfx_on: enabled for PDF/X files only.
             * @returns this object, for call chaining
             */
            setOverprint(mode: number): PDFNet.Convert.XPSOutputCommonOptions;
        }
        /**
         * An object containing options for ToXps functions
         */
        class XPSOutputOptions extends PDFNet.Convert.XPSOutputCommonOptions {
            /**
             * Sets whether the output format should be open xps.
            Default is Microsoft xps output.
             * @param openxps - if true open xps output is used
             * @returns this object, for call chaining
             */
            setOpenXps(openxps: boolean): PDFNet.Convert.XPSOutputOptions;
        }
        enum FlattenFlag {
            e_off,
            e_simple,
            e_fast,
            e_high_quality
        }
        enum FlattenThresholdFlag {
            e_very_strict,
            e_strict,
            e_default,
            e_keep_most,
            e_keep_all
        }
        enum AnnotationOutputFlag {
            e_internal_xfdf,
            e_external_xfdf,
            e_flatten
        }
        /**
         * An object containing options for ToXod functions
         */
        class XODOutputOptions extends PDFNet.Convert.XPSOutputCommonOptions {
            /**
             * Sets whether per page thumbnails should be included in the file.
            Default is true.
             * @param include_thumbs - if true thumbnails will be included
             * @returns this object, for call chaining
             */
            setOutputThumbnails(include_thumbs: boolean): PDFNet.Convert.XODOutputOptions;
            /**
             * Sets whether per page thumbnails should be included in the file.
            Default is true.
             * @param include_thumbs - if true thumbnails will be included
             * @returns this object, for call chaining
             */
            setOutputThumbnails(include_thumbs: boolean): PDFNet.Convert.XODOutputOptions;
            /**
             * The width and height of a square in which thumbnails will be contained.
            Default is 400 for normal pages and 1500 for large pages.
            Note: A large page is a page larger than twice the area of the standard page size (8.5 X 11).
             * @param regular_size - the maximum dimension that thumbnails for regular size pages will have.
             * @param [large_size = regular_size] - the maximum dimension that thumbnails for large pages will have.
             * @returns this object, for call chaining
             */
            setThumbnailSize(regular_size: number, large_size?: number): PDFNet.Convert.XODOutputOptions;
            /**
             * If rendering is permitted, sets the maximum number of page elements before that page will be rendered.
            Default is 2000000000 which will never cause pages to be completely rendered in this manner.
             * @param element_limit - the maximum number of elements before a given page will be rendered
             * @returns this object, for call chaining
             */
            setElementLimit(element_limit: number): PDFNet.Convert.XODOutputOptions;
            /**
             * If rendering is permitted, sets whether pages containing opacity masks should be rendered.
            This option is used as a workaround to a bug in Silverlight where opacity masks are transformed incorrectly.
            Default is false.
             * @param opacity_render - if true pages with opacity masks will be rendered
             * @returns this object, for call chaining
             */
            setOpacityMaskWorkaround(opacity_render: boolean): PDFNet.Convert.XODOutputOptions;
            /**
             * Specifies the maximum image slice size in pixels.
            Default is 2000000.
            Note: This setting now will no longer reduce the total number of image pixels.
            Instead a lower value will just produce more slices and vice versa.
            Note: Since image compression works better with more pixels a larger
            max pixels should generally create smaller files.
             * @param max_pixels - the maximum number of pixels an image can have
             * @returns this object, for call chaining
             */
            setMaximumImagePixels(max_pixels: number): PDFNet.Convert.XODOutputOptions;
            /**
             * Flatten images and paths into a single background image overlaid with
            vector text. This option can be used to improve speed on devices with
            little processing power such as iPads. Default is e_high_quality.
             * @param flatten - <pre>
            PDFNet.Convert.FlattenFlag = {
                e_off : 0
                e_simple : 1
                e_fast : 2
                e_high_quality : 3
            }
            </pre>
             * @returns this object, for call chaining
             */
            setFlattenContent(flatten: number): PDFNet.Convert.XODOutputOptions;
            /**
             * Used to control how precise or relaxed text flattening is. When some text is
            preserved (not flattened to image) the visual appearance of the document may be altered.
             * @param threshold - <pre>
            PDFNet.PDFNet.Convert.FlattenThresholdFlag = {
                e_very_strict : 0
                e_strict : 1
                e_default : 2
                e_keep_most : 3
                e_keep_all : 4
            }
            </pre>
             * @returns this object, for call chaining
             */
            setFlattenThreshold(threshold: number): PDFNet.Convert.XODOutputOptions;
            /**
             * Where possible output JPG files rather than PNG. This will apply to both thumbnails and document images.
            Default is true.
             * @param prefer_jpg - if true JPG images will be used whenever possible.
             * @returns this object, for call chaining
             */
            setPreferJPG(prefer_jpg: boolean): PDFNet.Convert.XODOutputOptions;
            /**
             * Specifies the compression quality to use when generating JPEG images.
             * @param quality - the JPEG compression quality, from 0(highest compression) to 100(best quality).
             * @returns this object, for call chaining
             */
            setJPGQuality(quality: number): PDFNet.Convert.XODOutputOptions;
            /**
             * Outputs rotated text as paths. This option is used as a workaround to a bug in Silverlight
            where pages with rotated text could cause the plugin to crash.
            Default is false.
             * @param workaround - if true rotated text will be changed to paths
             * @returns this object, for call chaining
             */
            setSilverlightTextWorkaround(workaround: boolean): PDFNet.Convert.XODOutputOptions;
            /**
             * Choose how to output annotations.
            Default is e_internal_xfdf.
             * @param annot_output - <pre>
            PDFNet.PDFNet.Convert.AnnotationOutputFlag = {
                e_internal_xfdf : 0
                e_external_xfdf : 1
                e_flatten : 2
            }
            </pre>
             * @returns this object, for call chaining
             */
            setAnnotationOutput(annot_output: number): PDFNet.Convert.XODOutputOptions;
            /**
             * Output XOD as a collection of loose files rather than a zip archive.
            This option should be used when using the external part retriever in Webviewer.
            Default is false.
             * @param generate - if true XOD is output as a collection of loose files
             * @returns this object, for call chaining
             */
            setExternalParts(generate: boolean): PDFNet.Convert.XODOutputOptions;
            /**
             * Encrypt XOD parts with AES 128 encryption using the supplied password.
            This option is not available when using setExternalParts(true)
             * @param pass - the encryption password
             * @returns this object, for call chaining
             */
            setEncryptPassword(pass: string): PDFNet.Convert.XODOutputOptions;
            /**
             * The latest XOD format is only partially supported in Silverlight and Flash
            due to various optimizations in the text format and the addition of blend mode support.
            This option forces the converter to use an older version of XOD that is Silverlight/Flash
            compatible but does not have these improvements.
            By default the latest XOD format is generated.
             * @param compatible - if true will use the older XOD format which is not compatible with Silverlight/Flash
             * @returns this object, for call chaining
             */
            useSilverlightFlashCompatible(compatible: boolean): PDFNet.Convert.XODOutputOptions;
        }
        /**
         * An object containing options for ToTiff functions
         */
        class TiffOutputOptions {
            /**
             * Specifies the page box/region to rasterize.
            By default, page crop region will be rasterized.
             * @param type - <pre>
            PDFNet.Page.Box = {
                e_media : 0
                e_crop : 1
                e_bleed : 2
                e_trim : 3
                e_art : 4
            }
            </pre>
             * @returns this object, for call chaining
             */
            setBox(type: number): PDFNet.Convert.TiffOutputOptions;
            /**
             * Rotates all pages by a given number of degrees counterclockwise. The allowed
            values are 0, 90, 180, and 270. The default value is 0.
             * @param rotation - <pre>
            PDFNet.Page.Rotate = {
                e_0 : 0
                e_90 : 1
                e_180 : 2
                e_270 : 3
            }
            </pre>
             * @returns this object, for call chaining
             */
            setRotate(rotation: number): PDFNet.Convert.TiffOutputOptions;
            /**
             * User definable clip box.
            By default, the clip region is identical to current page 'box'.
             * @returns this object, for call chaining
             */
            setClip(x1: number, y1: number, x2: number, y2: number): PDFNet.Convert.TiffOutputOptions;
            /**
             * Specifies the list of pages to convert.
            By default, all pages are converted.
             * @returns this object, for call chaining
             */
            setPages(page_desc: string): PDFNet.Convert.TiffOutputOptions;
            /**
             * Enable or disable support for overprint and overprint simulation.
            Overprint is a device dependent feature and the results will vary depending on
            the output color space and supported colorants (i.e. CMYK, CMYK+spot, RGB, etc).
            Default is e_op_pdfx_on.
             * @param mode - <pre>
            PDFNet.PDFRasterizer.OverprintPreviewMode = {
                e_op_off : 0
                e_op_on : 1
                e_op_pdfx_on : 2
            }
            </pre>
             * @returns this object, for call chaining
             */
            setOverprint(mode: number): PDFNet.Convert.TiffOutputOptions;
            /**
             * Render and export the image in CMYK mode.
            By default, the image is rendered and exported in RGB color space.
             * @returns this object, for call chaining
             */
            setCMYK(enable: boolean): PDFNet.Convert.TiffOutputOptions;
            /**
             * Enables dithering when the image is exported in palletized or monochrome mode.
            This option is disabled by default.
             * @returns this object, for call chaining
             */
            setDither(enable: boolean): PDFNet.Convert.TiffOutputOptions;
            /**
             * Render and export the image in grayscale mode. Sets pixel format to 8 bits per pixel grayscale.
            By default, the image is rendered and exported in RGB color space.
             * @returns this object, for call chaining
             */
            setGray(enable: boolean): PDFNet.Convert.TiffOutputOptions;
            /**
             * Export the rendered image as 1 bit per pixel (monochrome) image. The image will be
            compressed using G4 CCITT compression algorithm. By default, the image is not dithered.
            To enable dithering use 'SetDither' option.
            This option is disabled by default.
             * @returns this object, for call chaining
             */
            setMono(enable: boolean): PDFNet.Convert.TiffOutputOptions;
            /**
             * Enables or disables drawing of annotations.
            This option is enabled by default.
             * @returns this object, for call chaining
             */
            setAnnots(enable: boolean): PDFNet.Convert.TiffOutputOptions;
            /**
             * Enables or disables image smoothing (default: enabled).
             * @returns this object, for call chaining
             */
            setSmooth(enable: boolean): PDFNet.Convert.TiffOutputOptions;
            /**
             * Renders annotations in the print mode. This option can be used to render 'Print Only'
            annotations and to hide 'Screen Only' annotations.
            This option is disabled by default.
             * @returns this object, for call chaining
             */
            setPrintmode(enable: boolean): PDFNet.Convert.TiffOutputOptions;
            /**
             * Sets the page color to transparent. By default, Convert assumes that the page
            is drawn directly on an opaque white surface. Some applications may need to
            draw the page on a different backdrop. In this case any pixels that are not
            covered during rendering will be transparent.
            This option is disabled by default.
             * @returns this object, for call chaining
             */
            setTransparentPage(enable: boolean): PDFNet.Convert.TiffOutputOptions;
            /**
             * Enabled the output of palettized TIFFs.
            This option is disabled by default.
             * @returns this object, for call chaining
             */
            setPalettized(enable: boolean): PDFNet.Convert.TiffOutputOptions;
            /**
             * The output resolution, from 1 to 1000, in Dots Per Inch (DPI). The higher
            the DPI, the larger the image. Resolutions larger than 1000 DPI can be
            achieved by rendering image in tiles or stripes. The default resolution is 92 DPI.
             * @returns this object, for call chaining
             */
            setDPI(dpi: number): PDFNet.Convert.TiffOutputOptions;
            /**
             * Sets the gamma factor used for anti-aliased rendering. Typical values are in
            the range from 0.1 to 3. Gamma correction can be used to improve the quality
            of anti-aliased image output and can (to some extent) decrease the appearance
            common anti-aliasing artifacts (such as pixel width lines between polygons).
            The default gamma is 0.
             * @returns this object, for call chaining
             */
            setGamma(gamma: number): PDFNet.Convert.TiffOutputOptions;
            /**
             * Sets the width of the output image, in pixels.
             * @returns this object, for call chaining
             */
            setHRes(hres: number): PDFNet.Convert.TiffOutputOptions;
            /**
             * Sets the height of the output image, in pixels.
             * @returns this object, for call chaining
             */
            setVRes(vres: number): PDFNet.Convert.TiffOutputOptions;
        }
        /**
         * An object containing options common to ToHtml and ToEpub functions
         */
        class HTMLOutputOptions {
            /**
             * Use JPG files rather than PNG. This will apply to all generated images.
            Default is true.
            Note: This option is only available for e_fixed_position and e_reflow_paragraphs modes.
             * @param prefer_jpg - if true JPG images will be used whenever possible.
             * @returns this object, for call chaining
             */
            setPreferJPG(prefer_jpg: boolean): PDFNet.Convert.HTMLOutputOptions;
            /**
             * Specifies the compression quality to use when generating JPEG images.
            Note: This option is only available for e_fixed_position and e_reflow_paragraphs modes.
            In e_reflow_full mode, the optimal JPEG quality is chosen automatically for best balance between size and quality.
             * @param quality - the JPEG compression quality, from 0(highest compression) to 100(best quality).
             * @returns this object, for call chaining
             */
            setJPGQuality(quality: number): PDFNet.Convert.HTMLOutputOptions;
            /**
             * The output resolution, from 1 to 1000, in Dots Per Inch (DPI) at which to render elements which cannot be directly converted.
            Default is 140.
            Note: This option is only available for e_fixed_position mode.
             * @param dpi - the resolution in Dots Per Inch
             * @returns this object, for call chaining
             */
            setDPI(dpi: number): PDFNet.Convert.HTMLOutputOptions;
            /**
             * Specifies the maximum image slice size in pixels. Default is 2000000.
            Note: This setting now will no longer reduce the total number of image pixels.
            Instead a lower value will just produce more slices and vice versa.
            Note: Since image compression works better with more pixels a larger
            max pixels should generally create smaller files.
            Note: This option is only available for e_fixed_position mode.
             * @param max_pixels - the maximum number of pixels an image can have
             * @returns this object, for call chaining
             */
            setMaximumImagePixels(max_pixels: number): PDFNet.Convert.HTMLOutputOptions;
            /**
             * Set an overall scaling of the generated HTML pages. Default is 1.0.
            Note: This option is only available for e_fixed_position mode.
             * @param scale - a number greater than 0 which is used as a scale factor.
            For example, calling SetScale(0.5) will reduce the HTML body of the page to half
            its original size, whereas SetScale(2) will double the HTML body dimensions of
            the page and will rescale all page content appropriately.
             * @returns this object, for call chaining
             */
            setScale(scale: number): PDFNet.Convert.HTMLOutputOptions;
            /**
             * Enable the conversion of external URL navigation.
            Default is false.
            Note: This option is only available for e_fixed_position mode.
             * @param enable - if true, links that specify external URL's are converted into HTML.
             * @returns this object, for call chaining
             */
            setExternalLinks(enable: boolean): PDFNet.Convert.HTMLOutputOptions;
            /**
             * Enable the conversion of internal document navigation.
            Default is false.
            Note: This option is only available for e_fixed_position mode.
             * @param enable - if true, links that specify page jumps are converted into HTML.
             * @returns this object, for call chaining
             */
            setInternalLinks(enable: boolean): PDFNet.Convert.HTMLOutputOptions;
            /**
             * Controls whether converter optimizes DOM or preserves text placement accuracy.
            Default is false.
            Note: This option is only available for e_fixed_position mode.
             * @param enable - If true, converter will try to reduce DOM complexity at the expense of text placement accuracy.
             * @returns this object, for call chaining
             */
            setSimplifyText(enable: boolean): PDFNet.Convert.HTMLOutputOptions;
        }
        /**
         * An object containing options common to ToEpub functions
         */
        class EPUBOutputOptions {
            /**
             * Create the EPUB in expanded format.
            Default is false.
             * @param expanded - if false a single EPUB file will be generated,
            otherwise, the generated EPUB will be in unzipped (expanded) format
             * @returns this object, for call chaining
             */
            setExpanded(expanded: boolean): PDFNet.Convert.EPUBOutputOptions;
            /**
             * Set whether the first content page in the EPUB uses the cover image or not. If this
            is set to true, then the first content page will simply wrap the cover image in HTML.
            Otherwise, the page will be converted the same as all other pages in the EPUB.
            Default is false.
             * @param reuse - if true the first page will simply be EPUB cover image,
            otherwise, the first page will be converted the same as the other pages
             * @returns this object, for call chaining
             */
            setReuseCover(reuse: boolean): PDFNet.Convert.EPUBOutputOptions;
        }
        /**
         * An object containing options for ToSvg functions
         */
        class SVGOutputOptions {
            /**
             * Sets whether to embed all images
             * @param embed_images - if true, images will be embedded.
            Default is false.
             * @returns this object, for call chaining
             */
            setEmbedImages(embed_images: boolean): PDFNet.Convert.SVGOutputOptions;
            /**
             * Sets whether to disable conversion of font data to SVG
             * @param no_fonts - if true, font data conversion is disabled.
            Default is false.
             * @returns this object, for call chaining
             */
            setNoFonts(no_fonts: boolean): PDFNet.Convert.SVGOutputOptions;
            /**
             * Sets whether to convert all fonts to SVG or not.
             * @param svg_fonts - if true, fonts are converted to SVG. Otherwise they are converted to OpenType.
            Default is false.
             * @returns this object, for call chaining
             */
            setSvgFonts(svg_fonts: boolean): PDFNet.Convert.SVGOutputOptions;
            /**
             * Sets whether to embed fonts into each SVG page file, or to have them shared.
             * @param embed_fonts - if true, fonts are injected into each SVG page.
            Otherwise they are created as separate files that are shared between SVG pages.
            Default is false.
             * @returns this object, for call chaining
             */
            setEmbedFonts(embed_fonts: boolean): PDFNet.Convert.SVGOutputOptions;
            /**
             * Sets whether to disable mapping of text to public Unicode region.
            Instead text will be converted using a custom encoding
             * @param no_unicode - if true, mapping of text to public Unicode region is disabled
             * @returns this object, for call chaining
             */
            setNoUnicode(no_unicode: boolean): PDFNet.Convert.SVGOutputOptions;
            /**
             * Some viewers do not support the default text positioning correctly.
            This option works around this issue to place text correctly,
            but produces verbose output. This option will override SetRemoveCharPlacement
             * @param individual_char_placement - if true, text will be positioned correctly
             * @returns this object, for call chaining
             */
            setIndividualCharPlacement(individual_char_placement: boolean): PDFNet.Convert.SVGOutputOptions;
            /**
             * Sets whether to disable the output of character positions.
            This will produce slightly smaller output files than the default
            setting, but many viewers do not support the output correctly
             * @param remove_char_placement - if true, the output of character positions is disabled
             * @returns this object, for call chaining
             */
            setRemoveCharPlacement(remove_char_placement: boolean): PDFNet.Convert.SVGOutputOptions;
            /**
             * Flatten images and paths into a single background image overlaid with
            vector text. This option can be used to improve speed on devices with
            little processing power such as iPads. Default is e_fast.
             * @param flatten - <pre>
            PDFNet.Convert.FlattenFlag = {
                e_off : 0
                e_simple : 1
                e_fast : 2
                e_high_quality : 3
            }
            </pre>
             * @returns this object, for call chaining
             */
            setFlattenContent(flatten: number): PDFNet.Convert.SVGOutputOptions;
            /**
             * Used to control how precise or relaxed text flattening is. When some text is
            preserved (not flattened to image) the visual appearance of the document may be altered.
             * @param threshold - <pre>
            PDFNet.PDFNet.Convert.FlattenThresholdFlag = {
                e_very_strict : 0
                e_strict : 1
                e_default : 2
                e_keep_most : 3
                e_keep_all : 4
            }
            </pre>
             * @returns this object, for call chaining
             */
            setFlattenThreshold(threshold: number): PDFNet.Convert.SVGOutputOptions;
            /**
             * The output resolution, from 1 to 1000, in Dots Per Inch (DPI) at which to render elements which cannot be directly converted.
            Default is 140.
             * @param dpi - the resolution in Dots Per Inch
             * @returns this object, for call chaining
             */
            setFlattenDPI(dpi: number): PDFNet.Convert.SVGOutputOptions;
            /**
             * Specifies the maximum image slice size in pixels. Default is 2000000.
            Note: This setting now will no longer reduce the total number of image pixels.
            Instead a lower value will just produce more slices and vice versa.
            Note: Since image compression works better with more pixels a larger
            max pixels should generally create smaller files.
             * @param max_pixels - the maximum number of pixels an image can have
             * @returns this object, for call chaining
             */
            setFlattenMaximumImagePixels(max_pixels: number): PDFNet.Convert.SVGOutputOptions;
            /**
             * Compress output SVG files using SVGZ.
             * @param svgz - if true, SVG files are written in compressed format.
            Default is false.
             * @returns this object, for call chaining
             */
            setCompress(svgz: boolean): PDFNet.Convert.SVGOutputOptions;
            /**
             * Sets whether per page thumbnails should be included in the file.
            Default is true.
             * @param include_thumbs - if true thumbnails will be included
             * @returns this object, for call chaining
             */
            setOutputThumbnails(include_thumbs: boolean): PDFNet.Convert.SVGOutputOptions;
            /**
             * The maximum dimension for thumbnails.
             * @param size - the maximum dimension (width or height) that thumbnails will have.
            Default is 400.
             * @returns this object, for call chaining
             */
            setThumbnailSize(size: number): PDFNet.Convert.SVGOutputOptions;
            /**
             * Create a XML document that contains metadata of the SVG document created.
             * @param xml - if true, XML wrapper is created. Default is true.
             * @returns this object, for call chaining
             */
            setCreateXmlWrapper(xml: boolean): PDFNet.Convert.SVGOutputOptions;
            /**
             * Set whether the DTD declaration is included in the SVG files.
             * @param dtd - if false, no DTD is added to SVG files.
            Default is true.
             * @returns this object, for call chaining
             */
            setDtd(dtd: boolean): PDFNet.Convert.SVGOutputOptions;
            /**
             * Control generation of form fields and annotations in SVG.
             * @param annots - if false, no form fields or annotations are converted.
            Default is true
             * @returns this object, for call chaining
             */
            setAnnots(annots: boolean): PDFNet.Convert.SVGOutputOptions;
            /**
             * Enable or disable support for overprint and overprint simulation.
            Overprint is a device dependent feature and the results will vary depending on
            the output color space and supported colorants (i.e. CMYK, CMYK+spot, RGB, etc).
            Default is e_op_pdfx_on.
             * @param op - <pre>
            PDFNet.PDFRasterizer.OverprintPreviewMode = {
                e_op_off : 0
                e_op_on : 1
                e_op_pdfx_on : 2
            }
            </pre>
            e_op_on: always enabled; e_op_off: always disabled; e_op_pdfx_on: enabled for PDF/X files only.
             * @returns this object, for call chaining
             */
            setOverprint(op: number): PDFNet.Convert.SVGOutputOptions;
        }
        enum PrinterMode {
            e_auto,
            e_interop_only,
            e_printer_only,
            e_prefer_builtin_converter
        }
    }
    /**
     * QuadPoint
    
    A QuadpPoint struct contains 8 values representing the (x,y) coordinates of four points in a rectangle..
    
    --------------------
    Since QuadPoint is a struct, it can be created manually by calling "new PDFNet.QuadPoint(p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y)"
    eg. var myfoo = new PDFNet.QuadPoint(1, 2, 3, 4, 5, 6, 7, 8)
    
    Default values for a Point struct are:
    p1x = 0
    p1y = 0
    p2x = 0
    p2y = 0
    p3x = 0
    p3y = 0
    p4x = 0
    p4y = 0
     */
    class QuadPoint {
        constructor(p1x?: number, p1y?: number, p2x?: number, p2y?: number, p3x?: number, p3y?: number, p4x?: number, p4y?: number);
        p1x: number;
        p1y: number;
        p2x: number;
        p2y: number;
        p3x: number;
        p3y: number;
        p4x: number;
        p4y: number;
    }
    /**
     * 2D Point
    
    A Point represents an (x,y) coordinate point.
    
    --------------------
    Since Point is a struct, it can be created manually by calling "new PDFNet.Point(x, y)"
    eg. var myfoo = new PDFNet.Point(1,2);
    
    Default values for a Point struct are:
    x = 0
    y = 0
     */
    class Point {
        constructor(x?: number, y?: number);
        x: number;
        y: number;
    }
    /**
     * CharData is a data structure returned by PDFNet.Iterator<CharData>.current() that is
    used to provide extra information about a character within a text run. The extra
    information includes positioning information, the character data and a number of
    bytes taken by the character.
     * @property char_code - 'Char code' For SimpleFonts char_code := char_data[0],
    for composite fonts char_code is the numeric value of data stored in char_data buffer.
     * @property x - glyph horizontal position
     * @property y - glyph vertical position
     * @property char_data - the buffer containing character data. For simple fonts
    each character is represented by a single byte. For multi-byte (CID or Type0) fonts
    each character may take more than one byte.
     * @property bytes - Number of bytes representing this character in char_data buffer.
    For simple fonts 'bytes' will equal 1. For multi-byte (CID or Type0) fonts 'bytes' may
    be larger than 1. Should not be less than 0.
     * @param charData - An object to construct PDFNet.CharData with
     */
    class CharData {
        constructor(charData: any);
        /**
         * 'Char code' For SimpleFonts char_code := char_data[0],
         * for composite fonts char_code is the numeric value of data stored in char_data buffer.
        */
        char_code: number;
        /**
         * glyph horizontal position
        */
        x: number;
        /**
         * glyph vertical position
        */
        y: number;
        /**
         * the buffer containing character data. For simple fonts
         * each character is represented by a single byte. For multi-byte (CID or Type0) fonts
         * each character may take more than one byte.
        */
        char_data: Uint8Array;
        /**
         * Number of bytes representing this character in char_data buffer.
         * For simple fonts 'bytes' will equal 1. For multi-byte (CID or Type0) fonts 'bytes' may
         * be larger than 1. Should not be less than 0.
        */
        bytes: number;
    }
    /**
     * This class is used to store separations in PDFRasterize and PDFDraw
     * @property data - the buffer containing separation data.
     * @property data_size - number of bytes in data buffer.
     * @property separation_name - name of the separation.
     * @property c - separation cyan value
     * @property m - separation magenta value
     * @property y - separation yellow value
     * @property k - separation key value
     */
    class Separation {
        /**
         * the buffer containing separation data.
        */
        data: Uint8Array;
        /**
         * number of bytes in data buffer.
        */
        data_size: number;
        /**
         * name of the separation.
        */
        separation_name: string;
        /**
         * separation cyan value
        */
        c: number;
        /**
         * separation magenta value
        */
        m: number;
        /**
         * separation yellow value
        */
        y: number;
        /**
         * separation key value
        */
        k: number;
    }
    namespace Optimizer {
        /**
         * An object that stores downsampling/recompression settings for color and grayscale images.
         */
        class ImageSettings {
            /**
             * Sets the maximum and resampling dpi for images.
            By default these are set to 225 and 150 respectively.
             * @param maximum - the highest dpi of an image before it will be resampled
             * @param resampling - the image dpi to resample to if an image is encountered over the maximum dpi
             * @returns this object, for call chaining
             */
            setImageDPI(maximum: number, resampling: number): PDFNet.Optimizer.ImageSettings;
            /**
             * Sets the output compression mode for this type of image
            The default value is e_retain
             * @param mode - the compression mode to set
            <pre>
            PDFNet.Optimizer.ImageSettings.CompressionMode = {
             e_retain : 0,
             e_flate : 1,
             e_jpeg : 2,
             e_jpeg2000 : 3,
             e_none : 4
            }
            </pre>
             * @returns this object, for call chaining
             */
            setCompressionMode(mode: number): PDFNet.Optimizer.ImageSettings;
            /**
             * Sets the downsample mode for this type of image
            The default value is e_default which will allow downsampling of images
             * @param mode - the compression mode to set
            <pre>
            PDFNet.Optimizer.ImageSettings.DownsampleMode = {
             e_off : 0,
                e_default : 1
            }
            </pre>
             * @returns this object, for call chaining
             */
            setDownsampleMode(mode: number): PDFNet.Optimizer.ImageSettings;
            /**
             * Sets the quality for lossy compression modes.
            from 1 to 10 where 10 is lossless (if possible)
            the default value is 5
             * @param quality - the quality for lossy compression modes.
             * @returns this object, for call chaining
             */
            setQuality(quality: number): PDFNet.Optimizer.ImageSettings;
            /**
             * Sets whether recompression to the specified compression method, should be forced when the image is not downsampled.
            By default the compression method for these images will not be changed.
             * @param force - if true the compression method for all
             * @returns this object, for call chaining
             */
            forceRecompression(force: boolean): PDFNet.Optimizer.ImageSettings;
            /**
             * Sets whether image changes that grow the PDF file should be kept.
            This is off by default.
             * @param force - if true all image changes will be kept.
             * @returns this object, for call chaining
             */
            forceChanges(force: boolean): PDFNet.Optimizer.ImageSettings;
        }
        /**
         * An object that stores downsampling/recompression settings for monochrome images.
         */
        class MonoImageSettings {
            /**
             * Sets the maximum and resampling dpi for monochrome images.
            By default these are set to 450 and 300 respectively.
             * @param maximum - the highest dpi of an image before it will be resampled
             * @param resampling - the image dpi to resample to if an image is encountered over the maximum dpi
             * @returns this object, for call chaining
             */
            setImageDPI(maximum: number, resampling: number): PDFNet.Optimizer.MonoImageSettings;
            /**
             * Sets the output compression mode for monochrome images
            The default value is e_jbig2
             * @param mode - the compression mode to set
            <pre>
            PDFNet.Optimizer.MonoImageSettings.CompressionMode = {
                e_jbig2 : 0,
                e_flate : 1,
                e_none : 2
            }
            </pre>
             * @returns this object, for call chaining
             */
            setCompressionMode(mode: number): PDFNet.Optimizer.MonoImageSettings;
            /**
             * Sets the downsample mode for monochrome images
            The default value is e_default
             * @param mode - the compression mode to set
            <pre>
            PDFNet.Optimizer.MonoImageSettings.DownsampleMode = {
             e_off : 0,
                e_default : 1
            }
            </pre>
             * @returns this object, for call chaining
             */
            setDownsampleMode(mode: number): PDFNet.Optimizer.MonoImageSettings;
            /**
             * Sets the quality for lossy JBIG2Decode compression mode.
            The threshold is a floating point number in the range from 4 to 9
            The default value for JBIG2 is 8.5.  The setting is ignored for FLATE.
             * @param jbig2_threshold - the quality for lossy compression modes.
             * @returns this object, for call chaining
             */
            setJBIG2Threshold(jbig2_threshold: number): PDFNet.Optimizer.MonoImageSettings;
            /**
             * Sets whether recompression to the specified compression method, should be forced when the image is not downsampled.
            By default the compression method for these images will not be changed.
             * @param force - if true the compression method for all
             * @returns this object, for call chaining
             */
            forceRecompression(force: boolean): PDFNet.Optimizer.MonoImageSettings;
            /**
             * Sets whether image changes that grow the PDF file should be kept.
            This is off by default.
             * @param force - if true all image changes will be kept.
             * @returns this object, for call chaining
             */
            forceChanges(force: boolean): PDFNet.Optimizer.MonoImageSettings;
        }
        /**
         * An object that stores image text optimization settings.
         */
        class TextSettings {
            /**
             * Sets whether embedded fonts will be subset. This will generally reduce the size of fonts,
            but will strip font hinting.
            Subsetting is off by default.
             * @param subset - if true all embedded fonts will be subsetted.
             * @returns this object, for call chaining
             */
            subsetFonts(subset: boolean): PDFNet.Optimizer.TextSettings;
            /**
             * Sets whether fonts should be embedded. This will generally increase the size of the file,
            but will make the file appear the same on different machines.
            Font embedding is off by default.
             * @param embed - if true all fonts will be embedded.
             * @returns this object, for call chaining
             */
            embedFonts(embed: boolean): PDFNet.Optimizer.TextSettings;
        }
        /**
         * An object that stores settings for the optimizer
         */
        class OptimizerSettings {
            /**
             * updates the settings for color image processing
             * @param settings - settings for color image processing
             * @returns this object, for call chaining
             */
            setColorImageSettings(settings: PDFNet.Optimizer.ImageSettings): PDFNet.Optimizer.OptimizerSettings;
            /**
             * updates the settings for grayscale image processing
             * @param settings - settings for grayscale image processing
             * @returns this object, for call chaining
             */
            setGrayscaleImageSettings(settings: PDFNet.Optimizer.ImageSettings): PDFNet.Optimizer.OptimizerSettings;
            /**
             * updates the settings for monochrome image processing
             * @param settings - settings for monochrome image processing
             * @returns this object, for call chaining
             */
            setMonoImageSettings(settings: PDFNet.Optimizer.MonoImageSettings): PDFNet.Optimizer.OptimizerSettings;
            /**
             * updates the settings for text processing
             * @param settings - settings for text processing
             * @returns this object, for call chaining
             */
            setTextSettings(settings: PDFNet.Optimizer.TextSettings): PDFNet.Optimizer.OptimizerSettings;
            /**
             * Enable or disable removal of custom entries in the PDF.
            By default custom entries are removed.
             * @param should_remove - if true custom entries will be removed.
             * @returns this object, for call chaining
             */
            removeCustomEntries(should_remove: boolean): PDFNet.Optimizer.OptimizerSettings;
        }
        namespace ImageSettings {
            enum CompressionMode {
                e_retain,
                e_flate,
                e_jpeg,
                e_jpeg2000,
                e_none
            }
            enum DownsampleMode {
                e_off,
                e_default
            }
        }
        namespace MonoImageSettings {
            enum CompressionMode {
                e_jbig2,
                e_flate,
                e_none
            }
            enum DownsampleMode {
                e_off,
                e_default
            }
        }
    }
    namespace PrinterMode {
        enum PaperSize {
            e_custom,
            e_letter,
            e_letter_small,
            e_tabloid,
            e_ledger,
            e_legal,
            e_statement,
            e_executive,
            e_a3,
            e_a4,
            e_a4_mall,
            e_a5,
            e_b4_jis,
            e_b5_jis,
            e_folio,
            e_quarto,
            e_10x14,
            e_11x17,
            e_note,
            e_envelope_9,
            e_envelope_10,
            e_envelope_11,
            e_envelope_12,
            e_envelope_14,
            e_c_size_sheet,
            e_d_size_sheet,
            e_e_size_sheet,
            e_envelope_dl,
            e_envelope_c5,
            e_envelope_c3,
            e_envelope_c4,
            e_envelope_c6,
            e_envelope_c65,
            e_envelope_b4,
            e_envelope_b5,
            e_envelope_b6,
            e_envelope_italy,
            e_envelope_monarch,
            e_6_3_quarters_envelope,
            e_us_std_fanfold,
            e_german_std_fanfold,
            e_german_legal_fanfold,
            e_b4_iso,
            e_japanese_postcard,
            e_9x11,
            e_10x11,
            e_15x11,
            e_envelope_invite,
            e_reserved_48,
            e_reserved_49,
            e_letter_extra,
            e_legal_extra,
            e_tabloid_extra,
            e_a4_extra,
            e_letter_transverse,
            e_a4_transverse,
            e_letter_extra_transverse,
            e_supera_supera_a4,
            e_Superb_Superb_a3,
            e_letter_plus,
            e_a4_plus,
            e_a5_transverse,
            e_b5_jis_transverse,
            e_a3_extra,
            e_a5_extra,
            e_b5_iso_extra,
            e_a2,
            e_a3_transverse,
            e_a3_extra_transverse,
            e_japanese_double_postcard,
            e_a6,
            e_japanese_envelope_kaku_2,
            e_japanese_envelope_kaku_3,
            e_japanese_envelope_chou_3,
            e_japanese_envelope_chou_4,
            e_letter_rotated,
            e_a3_rotated,
            e_a4_rotated,
            e_a5_rotated,
            e_b4_jis_rotated,
            e_b5_jis_rotated,
            e_japanese_postcard_rotated,
            e_double_japanese_postcard_rotated,
            e_a6_rotated,
            e_japanese_envelope_kaku_2_rotated,
            e_japanese_envelope_kaku_3_rotated,
            e_japanese_envelope_chou_3_rotated,
            e_japanese_envelope_chou_4_rotated,
            e_b6_jis,
            e_b6_jis_rotated,
            e_12x11,
            e_japanese_envelope_you_4,
            e_japanese_envelope_you_4_rotated,
            e_PrinterMode_prc_16k,
            e_prc_32k,
            e_prc_32k_big,
            e_prc_envelop_1,
            e_prc_envelop_2,
            e_prc_envelop_3,
            e_prc_envelop_4,
            e_prc_envelop_5,
            e_prc_envelop_6,
            e_prc_envelop_7,
            e_prc_envelop_8,
            e_prc_envelop_9,
            e_prc_envelop_10,
            e_prc_16k_rotated,
            e_prc_32k_rotated,
            e_prc_32k_big__rotated,
            e_prc_envelop_1_rotated,
            e_prc_envelop_2_rotated,
            e_prc_envelop_3_rotated,
            e_prc_envelop_4_rotated,
            e_prc_envelop_5_rotated,
            e_prc_envelop_6_rotated,
            e_prc_envelop_7_rotated,
            e_prc_envelop_8_rotated,
            e_prc_envelop_9_rotated,
            e_prc_envelop_10_rotated
        }
    }
    namespace Field {
        enum EventType {
            e_action_trigger_keystroke,
            e_action_trigger_format,
            e_action_trigger_validate,
            e_action_trigger_calculate
        }
        enum Type {
            e_button,
            e_check,
            e_radio,
            e_text,
            e_choice,
            e_signature,
            e_null
        }
        enum Flag {
            e_read_only,
            e_required,
            e_no_export,
            e_pushbutton_flag,
            e_radio_flag,
            e_toggle_to_off,
            e_radios_in_unison,
            e_multiline,
            e_password,
            e_file_select,
            e_no_spellcheck,
            e_no_scroll,
            e_comb,
            e_rich_text,
            e_combo,
            e_edit,
            e_sort,
            e_multiselect,
            e_commit_on_sel_change
        }
        enum TextJustification {
            e_left_justified,
            e_centered,
            e_right_justified
        }
    }
    namespace Filter {
        enum StdFileOpenMode {
            e_read_mode,
            e_write_mode,
            e_append_mode
        }
        enum ReferencePos {
            e_begin,
            e_end,
            e_cur
        }
    }
    namespace OCGContext {
        enum OCDrawMode {
            e_VisibleOC,
            e_AllOC,
            e_NoOC
        }
    }
    namespace OCMD {
        enum VisibilityPolicyType {
            e_AllOn,
            e_AnyOn,
            e_AnyOff,
            e_AllOff
        }
    }
    namespace PDFACompliance {
        enum Conformance {
            e_Level1A,
            e_Level1B,
            e_Level2A,
            e_Level2B,
            e_Level2U,
            e_Level3A,
            e_Level3B,
            e_Level3U
        }
        enum ErrorCode {
            e_PDFA0_1_0,
            e_PDFA0_1_1,
            e_PDFA0_1_2,
            e_PDFA0_1_3,
            e_PDFA0_1_4,
            e_PDFA0_1_5,
            e_PDFA1_2_1,
            e_PDFA1_2_2,
            e_PDFA1_3_1,
            e_PDFA1_3_2,
            e_PDFA1_3_3,
            e_PDFA1_3_4,
            e_PDFA1_4_1,
            e_PDFA1_4_2,
            e_PDFA1_6_1,
            e_PDFA1_7_1,
            e_PDFA1_7_2,
            e_PDFA1_7_3,
            e_PDFA1_7_4,
            e_PDFA1_8_1,
            e_PDFA1_8_2,
            e_PDFA1_8_3,
            e_PDFA1_8_4,
            e_PDFA1_8_5,
            e_PDFA1_8_6,
            e_PDFA1_10_1,
            e_PDFA1_11_1,
            e_PDFA1_11_2,
            e_PDFA1_12_1,
            e_PDFA1_12_2,
            e_PDFA1_12_3,
            e_PDFA1_12_4,
            e_PDFA1_12_5,
            e_PDFA1_12_6,
            e_PDFA1_13_1,
            e_PDFA2_2_1,
            e_PDFA2_3_2,
            e_PDFA2_3_3,
            e_PDFA2_3_3_1,
            e_PDFA2_3_3_2,
            e_PDFA2_3_4_1,
            e_PDFA2_4_1,
            e_PDFA2_4_2,
            e_PDFA2_4_3,
            e_PDFA2_4_4,
            e_PDFA2_5_1,
            e_PDFA2_5_2,
            e_PDFA2_6_1,
            e_PDFA2_7_1,
            e_PDFA2_8_1,
            e_PDFA2_9_1,
            e_PDFA2_10_1,
            e_PDFA3_2_1,
            e_PDFA3_3_1,
            e_PDFA3_3_2,
            e_PDFA3_3_3_1,
            e_PDFA3_3_3_2,
            e_PDFA3_4_1,
            e_PDFA3_5_1,
            e_PDFA3_5_2,
            e_PDFA3_5_3,
            e_PDFA3_5_4,
            e_PDFA3_5_5,
            e_PDFA3_5_6,
            e_PDFA3_6_1,
            e_PDFA3_7_1,
            e_PDFA3_7_2,
            e_PDFA3_7_3,
            e_PDFA4_1,
            e_PDFA4_2,
            e_PDFA4_3,
            e_PDFA4_4,
            e_PDFA4_5,
            e_PDFA4_6,
            e_PDFA5_2_1,
            e_PDFA5_2_2,
            e_PDFA5_2_3,
            e_PDFA5_2_4,
            e_PDFA5_2_5,
            e_PDFA5_2_6,
            e_PDFA5_2_7,
            e_PDFA5_2_8,
            e_PDFA5_2_9,
            e_PDFA5_2_10,
            e_PDFA5_2_11,
            e_PDFA5_3_1,
            e_PDFA5_3_2_1,
            e_PDFA5_3_2_2,
            e_PDFA5_3_2_3,
            e_PDFA5_3_2_4,
            e_PDFA5_3_2_5,
            e_PDFA5_3_3_1,
            e_PDFA5_3_3_2,
            e_PDFA5_3_3_3,
            e_PDFA5_3_3_4,
            e_PDFA5_3_4_0,
            e_PDFA5_3_4_1,
            e_PDFA5_3_4_2,
            e_PDFA5_3_4_3,
            e_PDFA6_1_1,
            e_PDFA6_1_2,
            e_PDFA6_2_1,
            e_PDFA6_2_2,
            e_PDFA6_2_3,
            e_PDFA7_2_1,
            e_PDFA7_2_2,
            e_PDFA7_2_3,
            e_PDFA7_2_4,
            e_PDFA7_2_5,
            e_PDFA7_3_1,
            e_PDFA7_3_2,
            e_PDFA7_3_3,
            e_PDFA7_3_4,
            e_PDFA7_3_5,
            e_PDFA7_3_6,
            e_PDFA7_3_7,
            e_PDFA7_3_8,
            e_PDFA7_3_9,
            e_PDFA7_5_1,
            e_PDFA7_8_1,
            e_PDFA7_8_2,
            e_PDFA7_8_3,
            e_PDFA7_8_4,
            e_PDFA7_8_5,
            e_PDFA7_8_6,
            e_PDFA7_8_7,
            e_PDFA7_8_8,
            e_PDFA7_8_9,
            e_PDFA7_8_10,
            e_PDFA7_8_11,
            e_PDFA7_8_12,
            e_PDFA7_8_13,
            e_PDFA7_8_14,
            e_PDFA7_8_15,
            e_PDFA7_8_16,
            e_PDFA7_8_17,
            e_PDFA7_8_18,
            e_PDFA7_8_19,
            e_PDFA7_8_20,
            e_PDFA7_8_21,
            e_PDFA7_8_22,
            e_PDFA7_8_23,
            e_PDFA7_8_24,
            e_PDFA7_8_25,
            e_PDFA7_8_26,
            e_PDFA7_8_27,
            e_PDFA7_8_28,
            e_PDFA7_8_29,
            e_PDFA7_8_30,
            e_PDFA7_8_31,
            e_PDFA7_11_1,
            e_PDFA7_11_2,
            e_PDFA7_11_3,
            e_PDFA7_11_4,
            e_PDFA7_11_5,
            e_PDFA9_1,
            e_PDFA9_2,
            e_PDFA9_3,
            e_PDFA9_4,
            e_PDFA3_8_1,
            e_PDFA8_2_2,
            e_PDFA8_3_3_1,
            e_PDFA8_3_3_2,
            e_PDFA8_3_4_1,
            e_PDFA1_2_3,
            e_PDFA1_10_2,
            e_PDFA1_10_3,
            e_PDFA1_12_10,
            e_PDFA1_13_5,
            e_PDFA2_3_10,
            e_PDFA2_4_2_10,
            e_PDFA2_4_2_11,
            e_PDFA2_4_2_12,
            e_PDFA2_4_2_13,
            e_PDFA2_5_10,
            e_PDFA2_5_11,
            e_PDFA2_5_12,
            e_PDFA2_8_3_1,
            e_PDFA2_8_3_2,
            e_PDFA2_8_3_3,
            e_PDFA2_8_3_4,
            e_PDFA2_8_3_5,
            e_PDFA2_10_20,
            e_PDFA2_10_21,
            e_PDFA11_0_0,
            e_PDFA6_2_11_8,
            e_PDFA8_1,
            e_PDFA_3E1,
            e_PDFA_3E2,
            e_PDFA_3E3,
            e_PDFA_LAST
        }
    }
    namespace ContentItem {
        enum Type {
            e_MCR,
            e_MCID,
            e_OBJR,
            e_Unknown
        }
    }
    namespace Action {
        enum Type {
            e_GoTo,
            e_GoToR,
            e_GoToE,
            e_Launch,
            e_Thread,
            e_URI,
            e_Sound,
            e_Movie,
            e_Hide,
            e_Named,
            e_SubmitForm,
            e_ResetForm,
            e_ImportData,
            e_JavaScript,
            e_SetOCGState,
            e_Rendition,
            e_Trans,
            e_GoTo3DView,
            e_RichMediaExecute,
            e_Unknown
        }
        enum FormActionFlag {
            e_exclude,
            e_include_no_value_fields,
            e_export_format,
            e_get_method,
            e_submit_coordinates,
            e_xfdf,
            e_include_append_saves,
            e_include_annotations,
            e_submit_pdf,
            e_canonical_format,
            e_excl_non_user_annots,
            e_excl_F_key,
            e_embed_form
        }
    }
    namespace Page {
        enum EventType {
            e_action_trigger_page_open,
            e_action_trigger_page_close
        }
        enum Box {
            e_media,
            e_crop,
            e_bleed,
            e_trim,
            e_art,
            e_user_crop
        }
        enum Rotate {
            e_0,
            e_90,
            e_180,
            e_270
        }
    }
    namespace Annot {
        enum EventType {
            e_action_trigger_activate,
            e_action_trigger_annot_enter,
            e_action_trigger_annot_exit,
            e_action_trigger_annot_down,
            e_action_trigger_annot_up,
            e_action_trigger_annot_focus,
            e_action_trigger_annot_blur,
            e_action_trigger_annot_page_open,
            e_action_trigger_annot_page_close,
            e_action_trigger_annot_page_visible,
            e_action_trigger_annot_page_invisible
        }
        enum Type {
            e_Text,
            e_Link,
            e_FreeText,
            e_Line,
            e_Square,
            e_Circle,
            e_Polygon,
            e_Polyline,
            e_Highlight,
            e_Underline,
            e_Squiggly,
            e_StrikeOut,
            e_Stamp,
            e_Caret,
            e_Ink,
            e_Popup,
            e_FileAttachment,
            e_Sound,
            e_Movie,
            e_Widget,
            e_Screen,
            e_PrinterMark,
            e_TrapNet,
            e_Watermark,
            e_3D,
            e_Redact,
            e_Projection,
            e_RichMedia,
            e_Unknown
        }
        enum Flag {
            e_invisible,
            e_hidden,
            e_print,
            e_no_zoom,
            e_no_rotate,
            e_no_view,
            e_annot_read_only,
            e_locked,
            e_toggle_no_view,
            e_locked_contents
        }
        enum State {
            e_normal,
            e_rollover,
            e_down
        }
    }
    namespace AnnotBorderStyle {
        enum Style {
            e_solid,
            e_dashed,
            e_beveled,
            e_inset,
            e_underline
        }
    }
    namespace LineAnnot {
        enum EndingStyle {
            e_Square,
            e_Circle,
            e_Diamond,
            e_OpenArrow,
            e_ClosedArrow,
            e_Butt,
            e_ROpenArrow,
            e_RClosedArrow,
            e_Slash,
            e_None,
            e_Unknown
        }
        enum IntentType {
            e_LineArrow,
            e_LineDimension,
            e_null,
            e_PolygonCloud,
            e_PolyLineDimension,
            e_PolygonDimension,
            e_Unknown
        }
        enum CapPos {
            e_Inline,
            e_Top
        }
    }
    namespace FileAttachmentAnnot {
        enum Icon {
            e_Graph,
            e_PushPin,
            e_Paperclip,
            e_Tag,
            e_Unknown
        }
    }
    namespace FreeTextAnnot {
        enum IntentName {
            e_FreeText,
            e_FreeTextCallout,
            e_FreeTextTypeWriter,
            e_Unknown
        }
    }
    namespace LinkAnnot {
        enum HighlightingMode {
            e_none,
            e_invert,
            e_outline,
            e_push
        }
    }
    namespace MarkupAnnot {
        enum BorderEffect {
            e_None,
            e_Cloudy
        }
    }
    namespace RedactionAnnot {
        enum QuadForm {
            e_LeftJustified,
            e_Centered,
            e_RightJustified,
            e_None
        }
    }
    namespace RubberStampAnnot {
        enum Icon {
            e_Approved,
            e_Experimental,
            e_NotApproved,
            e_AsIs,
            e_Expired,
            e_NotForPublicRelease,
            e_Confidential,
            e_Final,
            e_Sold,
            e_Departmental,
            e_ForComment,
            e_TopSecret,
            e_ForPublicRelease,
            e_Draft,
            e_Unknown
        }
    }
    namespace ScreenAnnot {
        enum ScaleType {
            e_Anamorphic,
            e_Proportional
        }
        enum ScaleCondition {
            e_Always,
            e_WhenBigger,
            e_WhenSmaller,
            e_Never
        }
        enum IconCaptionRelation {
            e_NoIcon,
            e_NoCaption,
            e_CBelowI,
            e_CAboveI,
            e_CRightILeft,
            e_CLeftIRight,
            e_COverlayI
        }
    }
    namespace SoundAnnot {
        enum Icon {
            e_Speaker,
            e_Mic,
            e_Unknown
        }
    }
    namespace TextAnnot {
        enum Icon {
            e_Comment,
            e_Key,
            e_Help,
            e_NewParagraph,
            e_Paragraph,
            e_Insert,
            e_Note,
            e_Unknown
        }
    }
    namespace WidgetAnnot {
        enum HighlightingMode {
            e_none,
            e_invert,
            e_outline,
            e_push,
            e_toggle
        }
        enum ScaleType {
            e_Anamorphic,
            e_Proportional
        }
        enum IconCaptionRelation {
            e_NoIcon,
            e_NoCaption,
            e_CBelowI,
            e_CAboveI,
            e_CRightILeft,
            e_CLeftIRight,
            e_COverlayI
        }
        enum ScaleCondition {
            e_Always,
            e_WhenBigger,
            e_WhenSmaller,
            e_Never
        }
    }
    namespace ColorSpace {
        enum Type {
            e_device_gray,
            e_device_rgb,
            e_device_cmyk,
            e_cal_gray,
            e_cal_rgb,
            e_lab,
            e_icc,
            e_indexed,
            e_pattern,
            e_separation,
            e_device_n,
            e_null
        }
    }
    namespace Destination {
        enum FitType {
            e_XYZ,
            e_Fit,
            e_FitH,
            e_FitV,
            e_FitR,
            e_FitB,
            e_FitBH,
            e_FitBV
        }
    }
    namespace GState {
        enum Attribute {
            e_transform,
            e_rendering_intent,
            e_stroke_cs,
            e_stroke_color,
            e_fill_cs,
            e_fill_color,
            e_line_width,
            e_line_cap,
            e_line_join,
            e_flatness,
            e_miter_limit,
            e_dash_pattern,
            e_char_spacing,
            e_word_spacing,
            e_horizontal_scale,
            e_leading,
            e_font,
            e_font_size,
            e_text_render_mode,
            e_text_rise,
            e_text_knockout,
            e_text_pos_offset,
            e_blend_mode,
            e_opacity_fill,
            e_opacity_stroke,
            e_alpha_is_shape,
            e_soft_mask,
            e_smoothnes,
            e_auto_stoke_adjust,
            e_stroke_overprint,
            e_fill_overprint,
            e_overprint_mode,
            e_transfer_funct,
            e_BG_funct,
            e_UCR_funct,
            e_halftone,
            e_null
        }
        enum LineCap {
            e_butt_cap,
            e_round_cap,
            e_square_cap
        }
        enum LineJoin {
            e_miter_join,
            e_round_join,
            e_bevel_join
        }
        enum TextRenderingMode {
            e_fill_text,
            e_stroke_text,
            e_fill_stroke_text,
            e_invisible_text,
            e_fill_clip_text,
            e_stroke_clip_text,
            e_fill_stroke_clip_text,
            e_clip_text
        }
        enum RenderingIntent {
            e_absolute_colorimetric,
            e_relative_colorimetric,
            e_saturation,
            e_perceptual
        }
        enum BlendMode {
            e_bl_compatible,
            e_bl_normal,
            e_bl_multiply,
            e_bl_screen,
            e_bl_difference,
            e_bl_darken,
            e_bl_lighten,
            e_bl_color_dodge,
            e_bl_color_burn,
            e_bl_exclusion,
            e_bl_hard_light,
            e_bl_overlay,
            e_bl_soft_light,
            e_bl_luminosity,
            e_bl_hue,
            e_bl_saturation,
            e_bl_color
        }
    }
    namespace Element {
        enum Type {
            e_null,
            e_path,
            e_text_begin,
            e_text,
            e_text_new_line,
            e_text_end,
            e_image,
            e_inline_image,
            e_shading,
            e_form,
            e_group_begin,
            e_group_end,
            e_marked_content_begin,
            e_marked_content_end,
            e_marked_content_point
        }
        enum PathSegmentType {
            e_moveto,
            e_lineto,
            e_cubicto,
            e_conicto,
            e_rect,
            e_closepath
        }
    }
    namespace ShapedText {
        enum ShapingStatus {
            e_FullShaping,
            e_PartialShaping,
            e_NoShaping
        }
        enum FailureReason {
            e_NoFailure,
            e_UnsupportedFontType,
            e_NotIndexEncoded,
            e_FontDataNotFound
        }
    }
    namespace ElementWriter {
        enum WriteMode {
            e_underlay,
            e_overlay,
            e_replacement
        }
    }
    namespace Flattener {
        enum Threshold {
            e_very_strict,
            e_strict,
            e_default,
            e_keep_most,
            e_keep_all
        }
        enum Mode {
            e_simple,
            e_fast
        }
    }
    namespace Font {
        enum StandardType1Font {
            e_times_roman,
            e_times_bold,
            e_times_italic,
            e_times_bold_italic,
            e_helvetica,
            e_helvetica_bold,
            e_helvetica_oblique,
            e_helvetica_bold_oblique,
            e_courier,
            e_courier_bold,
            e_courier_oblique,
            e_courier_bold_oblique,
            e_symbol,
            e_zapf_dingbats,
            e_null
        }
        enum Encoding {
            e_IdentityH,
            e_Indices
        }
        enum Type {
            e_Type1,
            e_TrueType,
            e_MMType1,
            e_Type3,
            e_Type0,
            e_CIDType0,
            e_CIDType2
        }
    }
    namespace Function {
        enum Type {
            e_sampled,
            e_exponential,
            e_stitching,
            e_postscript
        }
    }
    namespace Image {
        enum InputFilter {
            e_none,
            e_jpeg,
            e_jp2,
            e_flate,
            e_g3,
            e_g4,
            e_ascii_hex
        }
    }
    namespace PageLabel {
        enum Style {
            e_decimal,
            e_roman_uppercase,
            e_roman_lowercase,
            e_alphabetic_uppercase,
            e_alphabetic_lowercase,
            e_none
        }
    }
    namespace PageSet {
        enum Filter {
            e_all,
            e_even,
            e_odd
        }
    }
    namespace PatternColor {
        enum Type {
            e_uncolored_tiling_pattern,
            e_colored_tiling_pattern,
            e_shading,
            e_null
        }
        enum TilingType {
            e_constant_spacing,
            e_no_distortion,
            e_constant_spacing_fast_fill
        }
    }
    namespace GeometryCollection {
        enum SnappingMode {
            e_DefaultSnapMode,
            e_PointOnLine,
            e_LineMidpoint,
            e_LineIntersection,
            e_PathEndpoint
        }
    }
    namespace DigestAlgorithm {
        enum Type {
            e_SHA1,
            e_SHA256,
            e_SHA384,
            e_SHA512,
            e_RIPEMD160,
            e_unknown_digest_algorithm
        }
    }
    namespace ObjectIdentifier {
        enum Predefined {
            e_commonName,
            e_surname,
            e_countryName,
            e_localityName,
            e_stateOrProvinceName,
            e_streetAddress,
            e_organizationName,
            e_organizationalUnitName,
            e_SHA1,
            e_SHA256,
            e_SHA384,
            e_SHA512,
            e_RIPEMD160,
            e_RSA_encryption_PKCS1
        }
    }
    namespace DigitalSignatureField {
        enum SubFilterType {
            e_adbe_x509_rsa_sha1,
            e_adbe_pkcs7_detached,
            e_adbe_pkcs7_sha1,
            e_ETSI_CAdES_detached,
            e_ETSI_RFC3161,
            e_unknown,
            e_absent
        }
        enum DocumentPermissions {
            e_no_changes_allowed,
            e_formfilling_signing_allowed,
            e_annotating_formfilling_signing_allowed,
            e_unrestricted
        }
        enum FieldPermissions {
            e_lock_all,
            e_include,
            e_exclude
        }
    }
    namespace PDFDocViewPrefs {
        enum PageMode {
            e_UseNone,
            e_UseThumbs,
            e_UseBookmarks,
            e_FullScreen,
            e_UseOC,
            e_UseAttachments
        }
        enum PageLayout {
            e_Default,
            e_SinglePage,
            e_OneColumn,
            e_TwoColumnLeft,
            e_TwoColumnRight,
            e_TwoPageLeft,
            e_TwoPageRight
        }
        enum ViewerPref {
            e_HideToolbar,
            e_HideMenubar,
            e_HideWindowUI,
            e_FitWindow,
            e_CenterWindow,
            e_DisplayDocTitle
        }
    }
    namespace PDFRasterizer {
        enum Type {
            e_BuiltIn,
            e_GDIPlus
        }
        enum OverprintPreviewMode {
            e_op_off,
            e_op_on,
            e_op_pdfx_on
        }
        enum ColorPostProcessMode {
            e_postprocess_none,
            e_postprocess_invert,
            e_postprocess_gradient_map,
            e_postprocess_night_mode
        }
    }
    namespace PDFDraw {
        enum PixelFormat {
            e_rgba,
            e_bgra,
            e_rgb,
            e_bgr,
            e_gray,
            e_gray_alpha,
            e_cmyk
        }
    }
    enum CMSType {
        e_lcms,
        e_icm,
        e_no_cms
    }
    enum CharacterOrdering {
        e_Identity,
        e_Japan1,
        e_Japan2,
        e_GB1,
        e_CNS1,
        e_Korea1
    }
    enum LogLevel {
        e_LogLevel_Off,
        e_LogLevel_Fatal,
        e_LogLevel_Error,
        e_LogLevel_Warning,
        e_LogLevel_Info,
        e_LogLevel_Trace,
        e_LogLevel_Debug
    }
    enum ConnectionErrorHandlingMode {
        e_continue,
        e_continue_unless_switching_to_demo,
        e_stop
    }
    namespace Shading {
        enum Type {
            e_function_shading,
            e_axial_shading,
            e_radial_shading,
            e_free_gouraud_shading,
            e_lattice_gouraud_shading,
            e_coons_shading,
            e_tensor_shading,
            e_null
        }
    }
    namespace Stamper {
        enum SizeType {
            e_relative_scale,
            e_absolute_size,
            e_font_size
        }
        enum TextAlignment {
            e_align_left,
            e_align_center,
            e_align_right
        }
        enum HorizontalAlignment {
            e_horizontal_left,
            e_horizontal_center,
            e_horizontal_right
        }
        enum VerticalAlignment {
            e_vertical_bottom,
            e_vertical_center,
            e_vertical_top
        }
    }
    namespace TextExtractor {
        enum ProcessingFlags {
            e_no_ligature_exp,
            e_no_dup_remove,
            e_punct_break,
            e_remove_hidden_text,
            e_no_invisible_text,
            e_no_watermarks,
            e_extract_using_zorder
        }
        enum XMLOutputFlags {
            e_words_as_elements,
            e_output_bbox,
            e_output_style_info
        }
    }
    namespace TextSearch {
        enum ResultCode {
            e_done,
            e_page,
            e_found
        }
        enum Mode {
            e_reg_expression,
            e_case_sensitive,
            e_whole_word,
            e_search_up,
            e_page_stop,
            e_highlight,
            e_ambient_string
        }
    }
    namespace Obj {
        enum Type {
            e_null,
            e_bool,
            e_number,
            e_name,
            e_string,
            e_dict,
            e_array,
            e_stream
        }
    }
    namespace SDFDoc {
        enum SaveOptions {
            e_incremental,
            e_remove_unused,
            e_hex_strings,
            e_omit_xref,
            e_linearized,
            e_compatibility
        }
    }
    namespace SecurityHandler {
        enum Permission {
            e_owner,
            e_doc_open,
            e_doc_modify,
            e_print,
            e_print_high,
            e_extract_content,
            e_mod_annot,
            e_fill_forms,
            e_access_support,
            e_assemble_doc
        }
        enum AlgorithmType {
            e_RC4_40,
            e_RC4_128,
            e_AES,
            e_AES_256
        }
    }
    namespace VerificationOptions {
        enum SecurityLevel {
            e_compatibility_and_archiving,
            e_maximum
        }
        enum TimeMode {
            e_signing,
            e_timestamp,
            e_current
        }
        enum CertificateTrustFlag {
            e_signing_trust,
            e_certification_trust,
            e_dynamic_content,
            e_javascript,
            e_identity,
            e_trust_anchor,
            e_default_trust,
            e_complete_trust
        }
    }
    namespace VerificationResult {
        enum DocumentStatus {
            e_no_error,
            e_corrupt_file,
            e_unsigned,
            e_bad_byteranges,
            e_corrupt_cryptographic_contents
        }
        enum DigestStatus {
            e_digest_invalid,
            e_digest_verified,
            e_digest_verification_disabled,
            e_weak_digest_algorithm_but_digest_verifiable,
            e_no_digest_status,
            e_unsupported_encoding
        }
        enum TrustStatus {
            e_trust_verified,
            e_untrusted,
            e_trust_verification_disabled,
            e_no_trust_status
        }
        enum ModificationPermissionsStatus {
            e_invalidated_by_disallowed_changes,
            e_has_allowed_changes,
            e_unmodified,
            e_permissions_verification_disabled,
            e_no_permissions_status
        }
    }
    namespace DisallowedChange {
        enum Type {
            e_form_filled,
            e_digital_signature_signed,
            e_page_template_instantiated,
            e_annotation_created_or_updated_or_deleted,
            e_other,
            e_unknown
        }
    }
    /**
     * @returns A promise that resolves to an object of type: "string"
     */
    function getNormalizedUrl(url: string): Promise<string>;
    /**
     * @param annot_state - <pre>
     * PDFNet.Annot.State = {
     * 	e_normal : 0
     * 	e_rollover : 1
     * 	e_down : 2
     * }
     * </pre>
     * @returns A promise that resolves to an unknown type
     */
    function convertPageToAnnotAppearance(docWithAppearance: PDFNet.PDFDoc | PDFNet.SDFDoc | PDFNet.FDFDoc, objNum: number, annot_state: number, appearance_state: string): any;
    /**
     * A switch that can be used to turn on/off JavaScript engine
     * @param enable - true to enable JavaScript engine, false to disable.
     */
    function enableJavaScript(enable: boolean): Promise<void>;
    /**
     * Test whether JavaScript is enabled
     * @returns A promise that resolves to true if it is enabled, false otherwise
     */
    function isJavaScriptEnabled(): Promise<boolean>;
    /**
     * terminates PDFNet library.
     * Terminate() is usually called once, when the process is terminated.
     * @param termination_level - Optional termination level used to decide what operations need to be included
     *
     * Note: it is unsafe to call any other PDFNet API after you terminate
     * the library.
     */
    function terminateEx(termination_level: number): Promise<void>;
    /**
     * used to set a specific Color Management System (CMS) for
     * use during color conversion operators, image rendering, etc.
     * @param [t] - <pre>
     * PDFNet.CMSType = {
     * 	e_lcms : 0
     * 	e_icm : 1
     * 	e_no_cms : 2
     * }
     * </pre>
     * identifies the type of color management to use.
     */
    function setColorManagement(t?: number): Promise<void>;
    /**
     * sets the default ICC color profile for DeviceCMYK color space.
     *
     * Note: You can use this method to override default PDFNet settings.
     * For more information on default color spaces please refer to
     * section 'Default Color Spaces' in Chapter 4.5.4 of PDF Reference Manual.
     */
    function setDefaultDeviceCMYKProfileFromFilter(stream: PDFNet.Filter): Promise<void>;
    /**
     * sets the default ICC color profile for DeviceRGB color space.
     *
     * Note: You can use this method to override default PDFNet settings.
     * For more information on default color spaces please refer to
     * section 'Default Color Spaces' in Chapter 4.5.4 of PDF Reference Manual.
     */
    function setDefaultDeviceRGBProfileFromFilter(stream: PDFNet.Filter): Promise<void>;
    /**
     * sets the default compression level for Flate (ZLib).
     * @param level - An integer in range 0-9 representing the compression value to use as
     *  a default for any Flate streams (e.g used to compress content streams, PNG images, etc).
     *  The library normally uses the default compression level (Z_DEFAULT_COMPRESSION).
     *  For most images, compression values in the range 3-6 compress nearly as well as higher
     *  levels, and do so much faster. For on-line applications it may be desirable to have
     *  maximum speed Z_BEST_SPEED = 1). You can also specify no compression (Z_NO_COMPRESSION = 0).
     */
    function setDefaultFlateCompressionLevel(level: number): Promise<void>;
    /**
     * Sets the default parameters for the viewer cache. Any subsequently created documents
     * 	will use these parameters.
     * @param max_cache_size - The maximum size, in bytes, of the entire document's page cache. Set to zero to disable the viewer cache.
     * @param on_disk - If set to 'true', cache will be stored on the local filesystem. If set to 'false', cache will be stored in heap memory.
     */
    function setViewerCache(max_cache_size: number, on_disk: boolean): Promise<void>;
    /**
     * @returns A promise that resolves to pDFNet version number.
     */
    function getVersion(): Promise<number>;
    /**
     * @param [level] - <pre>
     * PDFNet.LogLevel = {
     * 	e_LogLevel_Off : -1
     * 	e_LogLevel_Fatal : 5
     * 	e_LogLevel_Error : 4
     * 	e_LogLevel_Warning : 3
     * 	e_LogLevel_Info : 2
     * 	e_LogLevel_Trace : 1
     * 	e_LogLevel_Debug : 0
     * }
     * </pre>
     */
    function setLogLevel(level?: number): Promise<void>;
    /**
     * Get available fonts on the system.
     * @returns A promise that resolves to a JSON list of fonts accessible to PDFNet
     */
    function getSystemFontList(): Promise<string>;
    function addPDFTronCustomHandler(custom_id: number): Promise<void>;
    /**
     * @returns A promise that resolves to an object of type: "string"
     */
    function getVersionString(): Promise<string>;
    /**
     * Sets the connection error handling behaviour for PDFTron SDK
     * The default for this method is e_continue
     * @param mode - <pre>
     * PDFNet.ConnectionErrorHandlingMode = {
     * 	e_continue : 0
     * 	e_continue_unless_switching_to_demo : 1
     * 	e_stop : 2
     * }
     * </pre>
     * Rules that PDFTron SDK will follow after a connection error.
     */
    function setConnectionErrorHandlingMode(mode: number): Promise<void>;
    /**
     * This function is a utility method which will initialize PDFNet and
    execute an action defined by the first parameter generator. Unlike
    runGeneratorWithCleanup this method will not clean up PDFNet resources
    which can be useful when the user wishes to keep all of the objects alive.
     * @param generator - The generator object function to execute.
     * @param [license_key] - the license key used to initialize PDFNet.
     * @returns a promise that resolves to the return value of the generator.
     */
    function runGeneratorWithoutCleanup(generator: any, license_key?: string): Promise<any>;
    /**
     * This function is a utility method which will initialize PDFNet, begin a PDFNet operation
    execute an action defined by the first parameter generator and then finish this operation.
    This method will also clean up all PDFNet resources that are allocated within the
    generator which can greatly simplify user code. In some cases the user may wish to keep
    some PDFNet objects alive out of the scope of this generator function in which case
    takeOwnership should called on these objects. In case the user wishes to keep all the
    PDFNet objects alive, runGeneratorWithoutCleanup should be used instead.
     * @param generator - The generator object function to execute.
     * @param [license_key] - the license key used to initialize PDFNet.
     * @returns a promise that resolves to the return value of the generator.
     */
    function runGeneratorWithCleanup(generator: any, license_key?: string): Promise<any>;
    /**
     * Displays in the console a list of objects still in memory in the form of their type and ID.
     */
    function displayAllocatedObjects(): void;
    /**
     * startDeallocateStack initializes a deallocation point. All functions which create objects that take up
    memory after the most recent startDeallocateStack call will be deallocated upon calling
    PDFNet.endDeallocateStack().
     */
    function startDeallocateStack(): Promise<void>;
    /**
     * Deallocates all objects in memory that were created after the most recent startDeallocateStack call.
     */
    function endDeallocateStack(): Promise<void>;
    /**
     * Gets the number of PDFNet.startDeallocateStack() calls made that have not yet been ended.
     * @returns A promise that resolves to the number of PDFNet.startDeallocateStack() calls
    not yet ended.
     */
    function getStackCount(): Promise<number>;
    /**
     * Removes all PDFNetJS objects from memory.
     */
    function deallocateAllObjects(): Promise<void>;
    /**
     * beginOperation locks all Emscripten worker operations on PDFNet so as to avoid
    potential editing conflicts. Calling beginOperation a second time before
    finishOperation is called will result in an exception being thrown. This can be
    disabled allowing multiple beginOperations to be called by passing in an options
    object (a default javascript object {}) with its parameter "allowMultipleInstances"
    set to "true".
     * @param [optionsObj.allowMultipleInstances = false] - If allowMultipleInstances
    set to true, multiple instances of beginOperation will be allowed.
     */
    function beginOperation(optionsObj?: {
        allowMultipleInstances?: boolean;
    }): Promise<void>;
    /**
     * finishOperation releases the lock on all Emscripten worker operations on PDFNet.
    Will do nothing if PDFNet.beginOperation has not been called earlier.
     */
    function finishOperation(): Promise<void>;
    /**
     * This function is a utility method which will initialize PDFNet, begin a PDFNet operation
    and run a callback function passed in. This method will also clean up all PDFNet resources
    that are allocated within the function which can greatly simplify user code. In some cases
    the user may wish to keep some PDFNet objects alive out of the scope of this function in
    which case takeOwnership should called on these objects. In case the user wishes to keep
    all the PDFNet objects alive, runWithoutCleanup should be used instead.
     * @param callback - A callback function to execute
     * @param license_key - the license key used to initialize PDFNet.
     * @returns a promise that resolves to the return value (if there is one) of the input function
     */
    function runWithCleanup(callback: (...params: any[]) => any, license_key: string): Promise<any>;
    /**
     * This function is a utility method which will initialize PDFNet and
    execute an input. Unlike runWithCleanup this method will not clean up PDFNet resources
    which can be useful if the user wishes to keep all of the objects alive.
     * @param callback - A callback function to execute
     * @param license_key - the license key used to initialize PDFNet.
     * @returns a promise that resolves to the return value (if there is one) of the input function
     */
    function runWithoutCleanup(callback: (...params: any[]) => any, license_key: string): Promise<any>;
    /**
     * Initializes PDFNet library.
    Initialize() is usually called once, during initialization.
     * @param [licenseKey] - Optional license key used to activate the product.
     If the licenseKey is not specified or is null, the product will work in the
     demo mode.
     * @param [pdfBackendType] - A string representing the "backend type" for
     rendering PDF documents. Pass "ems" to force the use of the ASM.js/WebAssembly
     worker and "wasm-threads" to use threaded WebAssembly
     */
    function initialize(licenseKey?: string, pdfBackendType?: string): Promise<void>;
}


    
    /**
 * Set the zoom step size for zooming in/out.
 * @example
 * WebViewer(...)
 *   .then(function(instance) {
 *     const documentViewer = instance.Core.documentViewer;
 *
 *     // you must have a document loaded when calling this api
 *     documentViewer.addEventListener('documentLoaded', function() {
 *       instance.UI.setZoomStepFactors([
 *         {
 *           step: 50,
 *           startZoom: 0
 *         }
 *       ]);
 *     });
 *   });
 * @param zoomStepFactors - an array that contains objects of zoomStep and zoom start level. zoomStepFactors must contain at least one zoomStepFactor object that has startZoom: 0
 */
declare type zoomStepFactor = {};

/**
 * WebViewer Instance Core namespace.
 * The namespace containing WebViewer's core user controls, including DocumentViewer control and the Document class.
 * @example
 * webViewerInstance.Core.someProperty
 * webViewerInstance.Core.someAPI()
 */
declare namespace Core {
    /**
     * The namespace for anything to do with PDF actions and action dispatch.
     * Actions can be defined by providing a JavaScript object that has the desired properties, and a name property defining the action subtype it represents. See documentation for specific action types for allowable properties.
     */
    namespace Actions {
        /**
         * A generic action.
         * @property name - Get the action's name.
         * @param options - A map of properties to set on the Action
         */
        class Action {
            constructor(options: any);
            /**
             * Called when the action is triggered.
             * @param owner - The dispatcher to which this action is attached
             * @param event - The PDFJS event to use when executing the action
             * @param documentViewer - The DocumentViewer to use as context for the action execution
             */
            onTriggered(owner: Annotations.Forms.Field | Core.DocumentViewer, event: any, documentViewer: Core.DocumentViewer): void;
            /**
             * Get the action's name.
            */
            name: string;
        }
        /**
         * The onTriggered function for actions.
         * @param target - The dispatcher to which this action is attached
         * @param event - The embedded JS event that is used when executing the action
         * @param documentViewer - The DocumentViewer to use as context for the action execution
         */
        type ActionOnTriggeredHandler = (target: Core.Annotations.Forms.Field | Core.DocumentViewer, event: any, documentViewer: Core.DocumentViewer) => void;
        /**
         * Additional options passed to the onTriggered handler.
         * @property originalOnTriggered - The original onTriggered function of this action
         * @property action - The action that is being triggered
         */
        var OnTriggeredAdditionalOptions: {
            /**
             * The original onTriggered function of this action
             */
            originalOnTriggered: Core.Actions.ActionOnTriggeredHandler;
            /**
             * The action that is being triggered
             */
            action: Core.Actions.Action;
        };
        /**
         * Handler function that gets passed to {@link Core.Actions.setCustomOnTriggeredHandler}.
         * The signature is similar to {@link Core.Actions.Action#onTriggered onTriggered} except with an additional options parameter.
         * @param target - The object that the action has been triggered on
         * @param event - The embedded JS event that is used when executing the action
         * @param documentViewer - The DocumentViewer to use as context for the action execution
         * @param options - Additional options and parameters
         * @param options.action - The action object that is being triggered
         * @param options.originalOnTriggered - The original onTriggered function of this action
         */
        type CustomActionOnTriggeredHandler = (target: Core.Annotations.Forms.Field | Core.DocumentViewer, event: any, documentViewer: Core.DocumentViewer, options: {
            action: Core.Actions.Action;
            originalOnTriggered: Core.Actions.ActionOnTriggeredHandler;
        }) => void;
        /**
         * Sets a custom handler function that will be called when an action of the specified type is triggered.
         * @example
         * Actions.setCustomOnTriggeredHandler(Actions.URI, (target, event, documentViewer, options) => {
         *    if (target instanceof Annotations.Link) {
         *    // Don't do anything if the action is triggered by a link
         *      return;
         *    }
         *    options.originalOnTriggered(target, event, documentViewer)
         * });
         * @param actionClass - The class (constructor) of the action
         * @param onTriggeredHandler - A handler function that will be called when the an action of the specified type is triggered
         */
        function setCustomOnTriggeredHandler(actionClass: Core.Actions.Action, onTriggeredHandler: Core.Actions.CustomActionOnTriggeredHandler): void;
        /**
         * A PDF Destination object, representing a location and fitting strategy.
         * @property page - Gets and sets the 1-based page number to go to.
         * @property fit - Gets the fit style (One of XYZ, FitBH, FitH, FitBV, FitV, FitR, FitB, Fit)
         * @property top - Gets the top of the destination rectangle
         * @property left - Gets the left hand side of the destination rectangle
         * @property bottom - Gets the bottom of the destination rectangle
         * @property right - Gets the right hand side of the destination rectangle
         * @property zoom - Gets the zoom at which to view the destination
         * @property name - Gets the name of the destination
         * @param options - A map of properties to initialize on the Dest object
         */
        class Dest {
            constructor(options: any);
            /**
             * Gets and sets the 1-based page number to go to.
            */
            page: number;
            /**
             * Gets the fit style (One of XYZ, FitBH, FitH, FitBV, FitV, FitR, FitB, Fit)
            */
            fit: string;
            /**
             * Gets the top of the destination rectangle
            */
            top: number | undefined;
            /**
             * Gets the left hand side of the destination rectangle
            */
            left: number | undefined;
            /**
             * Gets the bottom of the destination rectangle
            */
            bottom: number | undefined;
            /**
             * Gets the right hand side of the destination rectangle
            */
            right: number | undefined;
            /**
             * Gets the zoom at which to view the destination
            */
            zoom: number | undefined;
            /**
             * Gets the name of the destination
            */
            name: string | undefined;
        }
        /**
         * Creates a dispatcher.
         * A mixin that enables many different classes to construct and dispatch PDF Actions.
         */
        interface Dispatcher {
        }
        /**
         * A GoTo Action. Navigates to a specific page of the document with various fit options.
         * @property dest - Gets the destination object.
         * @param options - A map of properties to set on the Action.
         */
        class GoTo extends Core.Actions.Action {
            constructor(options: any);
            /**
             * Gets the destination object.
            */
            dest: Core.Actions.Dest;
        }
        /**
         * A GoToR Action. Navigates to a destination in another document.
         * @property dest - Gets the destination object.
         * @property filename - Gets the original filename of the remote document.
         * @property newWindow - Gets whether the document should be opened in a new window or not.
         * @param options - A map of properties to set on the Action.
         */
        class GoToR extends Core.Actions.Action {
            constructor(options: any);
            /**
             * Gets the destination object.
            */
            dest: Core.Actions.Dest;
            /**
             * Gets the original filename of the remote document.
            */
            filename: string;
            /**
             * Gets whether the document should be opened in a new window or not.
            */
            newWindow: boolean;
        }
        /**
         * Creates a hide action.
         * @property fields - The names of the fields on which the action should operate
         * @property hide - If true, hide the fields in fields, otherwise show them
         * @param options - A map of properties to set on the Action
         */
        class Hide extends Core.Actions.Action {
            constructor(options: any);
            /**
             * The names of the fields on which the action should operate
            */
            fields: string[];
            /**
             * If true, hide the fields in fields, otherwise show them
            */
            hide: boolean;
        }
        /**
         * A JavaScript action.
         * @property javascript - The JavaScript string to execute when the action is triggered
         * @param options - A map of properties to set on the Action
         */
        class JavaScript extends Core.Actions.Action {
            constructor(options: any);
            /**
             * The JavaScript string to execute when the action is triggered
            */
            javascript: string;
        }
        /**
         * A named action (currently one of NextPage, PrevPage, FirstPage, LastPage)
         * @property action - The name of the action to perform.
         * @param options - A map of properties to set on the Action
         */
        class Named extends Core.Actions.Action {
            constructor(options: any);
            /**
             * The name of the action to perform.
            */
            action: string;
        }
        /**
         * An action that resets form fields to their default values.
         * @property fields - The names of the fields on which the action should operate
         * @property exclude - Whether the action should reset only the fields specified in fields, or all the fields except those.
         * @param options - A map of properties to set on the Action
         */
        class ResetForm extends Core.Actions.Action {
            constructor(options: any);
            /**
             * The names of the fields on which the action should operate
            */
            fields: string[];
            /**
             * Whether the action should reset only the fields specified in fields, or all the fields except those.
            */
            exclude: boolean;
        }
        /**
         * Creates a submit-form action.
         * @property url - The URL to submit the form to
         * @property fields - A list of the names of the fields to operate on
         * @property format - The format in which to submit the fields (one of fdf, html, xfdf)
         * @property includeEmpty - Whether to include empty fields
         * @property flags - A flags object exposing all flags on the action
         * @property method - The HTTP method to submit with (either POST or GET)
         * @property exclude - Whether to include or exclude the fields named in fields
         * @param options - A map of properties to set on the Action
         */
        class SubmitForm extends Core.Actions.Action {
            constructor(options: any);
            /**
             * The URL to submit the form to
            */
            url: string;
            /**
             * A list of the names of the fields to operate on
            */
            fields: string[];
            /**
             * The format in which to submit the fields (one of fdf, html, xfdf)
            */
            format: string;
            /**
             * Whether to include empty fields
            */
            includeEmpty: boolean;
            /**
             * A flags object exposing all flags on the action
            */
            flags: Annotations.WidgetFlags;
            /**
             * The HTTP method to submit with (either POST or GET)
            */
            method: string;
            /**
             * Whether to include or exclude the fields named in fields
            */
            exclude: boolean;
        }
        /**
         * An URI Action.
         * @property uri - The URI to launch when the action is triggered
         * @param options - A map of properties to set on the Action
         */
        class URI extends Core.Actions.Action {
            constructor(options: any);
            /**
             * The URI to launch when the action is triggered
            */
            uri: string;
        }
    }
    /**
     * Disables the execution of embedded JavaScript
     */
    function disableEmbeddedJavaScript(): void;
    /**
     * The namespace for anything to do with PDF annotations.
     */
    namespace Annotations {
        namespace Forms {
            /**
             * Contains functions for changing the default behavior of embedded PDF JavaScript
             */
            class EmbeddedJS {
                /**
                 * Hook into the existing embedded JS functions and update their implementations
                 * @param callback - Function that is called with the embedded global object
                 */
                update(callback: (...params: any[]) => any): void;
                /**
                 * Gets the keypress value of the active field after applying the latest keystroke
                 * @param globalEvent - The global event object in the embedded JS context
                 * @returns The current keypress value of the active field
                 */
                getFinalKeypressValue(globalEvent: any): string;
            }
            /**
             * Represents a tree of PDF Forms fields. @see Core.Annotations.Forms.Field
             * Allows adding, getting and visiting fields.
             */
            class FieldManager {
                constructor(annotationManager: Core.AnnotationManager);
                /**
                 * Set the calculation order - use this if you need changes in one field to trigger calculation events on other fields.
                 * If the name of field that is changed is before the name of another field, that other field is recalculated.
                 * If the name of the field that has changed is not in the array, all the fields named by the arrya are recalculated in order.
                 * @param order - An array of field names.
                 */
                setCalculationOrder(order: string[]): void;
                /**
                 * Returns an array of all field objects in the document
                 */
                getFields(): Core.Annotations.Forms.Field[];
                /**
                 * Gets a field whose full name matches the one that is given. If No field matches, and the last part of the field name is a number, returns that index of the field's widget array.
                 * @param name - The full name of the field to search for.
                 * @returns The field or widget, or null if no field matches.
                 */
                getField(name: string): Core.Annotations.Forms.Field | Core.Annotations.WidgetAnnotation;
                /**
                 * Renames the field that is passed to the name passed in.
                 * @param field - The field that should be renamed.
                 * @param name - The name of the field to be renamed. Cannot be blank.
                 * @returns The renamed field.
                 */
                updateFieldName(field: Core.Annotations.Forms.Field | any, name: string): Core.Annotations.Forms.Field | Core.Annotations.WidgetAnnotation;
                /**
                 * Adds the given field object to the field tree, either replacing or merging with any existing field.
                 * Note: if the field is merged, it is the equivalent of performing Annotations.Forms.Field.set on the existing field, followed by setting all the field's widgets' fields to the original field.
                 * @param field - The field or field-like object to add.
                 * @returns The field that was inserted into the field tree (may not be the field originally provided).
                 */
                addField(field: Core.Annotations.Forms.Field | any, update?: boolean): Core.Annotations.Forms.Field;
                /**
                 * Equivalent to the given field's value changing, if it was at position index in the calculation order.
                 * @param field - The field to set as source for the calculation event. May be null.
                 * @param [index = 0] - The index at which to start running the calculation order.
                 */
                calculate(field: Core.Annotations.Forms.Field, index?: number): void;
                /**
                 * Listener for field value changes.
                 * @param field - The field whose value changed.
                 */
                fieldChanged(field: Core.Annotations.Forms.Field): void;
                /**
                 * iterate over every field and check if it's required and if it has a value
                 * @returns Returns True if there is no required field or all fields are filled out, false otherwise
                 */
                areRequiredFieldsFilled(): boolean;
                /**
                 * Calls the specified callback for each of the root fields in the document.
                 *
                 * If there is a tree of form fields, then this will only iterate over root fields. Please use {@link Core.Annotations.Forms.Field.children} and a tree traversal algorithm to traverse the fields. If you know the name of your field, you can use {@link Core.Annotations.Forms.FieldManager.getField}.
                 * @example
                 * const stack = [];
                 *         fieldManager.forEachField(function(field) {
                 *          stack.push(field); // Push root fields
                 *        });
                 *         while (stack.length > 0) {
                 *          const current = stack.pop();
                 *          if (current.isTerminal()) {
                 *            // Work with terminal/leaf fields
                 *          }
                 *          else {
                 *            // Traverse children
                 *            stack = stack.concat(current.children);
                 *          }
                 *        }
                 * @param callback - The function that will be called for each field. The callback is passed the field object.
                 */
                forEachField(callback: (...params: any[]) => any): void;
                /**
                 * Invokes the available print handler to print the document
                 *
                 * Note: This method requires Embedded JavaScript to not have been disabled
                 * with Core.disableEmbeddedJavaScript
                 */
                print(): void;
                /**
                 * Updates the function to be used for handling alert messages for field validation.
                 * @param handler - The function that will handle alert messages. It will be called with a string representing the alert message.
                 */
                setAlertHandler(handler: (...params: any[]) => any): void;
                /**
                 * Sets the function to be used to handle the print API called by embedded PDF JavaScript
                 */
                setPrintHandler(): void;
            }
            interface Field extends Core.Actions.Dispatcher {
            }
            /**
             * Represents a PDF Form field.
             * @property type - Returns the field's type. One of ('Tx', 'Btn', 'Ch' or 'Sig')
             * @property [children = []] - The field's children
             * @property [widgets = []] - The field's child widgets
             * @property [actions = {}] - Gets the field's actions.
             * @property [defaultValue = null] - The field's default value
             * @property [exportValue = null] - The field's export value. Defaults to the field's value if not set.
             * @property [flags = new Core.Annotations.WidgetFlags()] - The field's flags object
             * @property [font = new Core.Annotations.Font()] - Returns the field's associated font object
             * @property [IsModified = false] - Is field is modified?
             * @property [maxLen = -1] - The field's maximum length. -1 means infinite.
             * @property name - The full name of the field.
             * @property [options = []] - The field's options (or permanently null if the field type does not support options).
             * @property [quadding = 'Left-justified'] - Returns the field's quadding. (One of 'Left-justified', 'Right-justified', 'Centered')
             * @property [value = null] - The field's value.
             * @property tooltipName - The text to be displayed when hovering over the field.
             * @param name - The field's full name.
             * @param [options] - The options with which to construct the field. If options is a Field, the constructor returns the existing object.
             * @param [options.type] - The field's type. One of ('Tx', 'Btn', 'Ch' or 'Sig').
             * @param [options.value] - The value of the field
             * @param [options.flags] - The flags for the field
             * @param [options.children] - The field's children.
             * @param [options.widgets] - The field's child widgets.
             * @param [options.fieldManager] - The field's field manager.
             * @param [options.font] - The font that is used by the field.
             * @param [options.maxLen] - The field's maximum length. -1 means infinite.
             * @param [options.tooltipName] - The text to be displayed when hovering over the field.
             * @param [options.options] - The field's options (or permanently null if the field type does not support options).
             */
            class Field implements Core.Actions.Dispatcher {
                constructor(name: string, options?: {
                    type?: string;
                    value?: string;
                    flags?: Core.Annotations.WidgetFlags;
                    children?: Core.Annotations.Forms.Field[];
                    widgets?: Core.Annotations.WidgetAnnotation[];
                    fieldManager?: Core.Annotations.Forms.FieldManager;
                    font?: Core.Annotations.Font;
                    maxLen?: number;
                    tooltipName?: string;
                    options?: object[];
                });
                /**
                 * A signal that the field should fire its own calculation events.
                 * @param source - The field that caused the calculation event.
                 */
                on(event: 'calculate', callback: (source: Core.Annotations.Forms.Field) => void): void;
                /**
                 * A signal that the field should fire its own calculation events.
                 * @param source - The field that caused the calculation event.
                 */
                one(event: 'calculate', callback: (source: Core.Annotations.Forms.Field) => void): void;
                off(event?: 'calculate', callback?: (source: Core.Annotations.Forms.Field) => void): void;
                /**
                 * The field's value has been changed by the user. Sets a new value.
                 * @param value - The new field value.
                 */
                on(event: 'commit', callback: (value: string | number) => void): void;
                /**
                 * The field's value has been changed by the user. Sets a new value.
                 * @param value - The new field value.
                 */
                one(event: 'commit', callback: (value: string | number) => void): void;
                off(event?: 'commit', callback?: (value: string | number) => void): void;
                /**
                 * An event that represents a field's value having changed.
                 * @param field - The field that has changed.
                 */
                on(event: 'change', callback: (field: Core.Annotations.Forms.Field) => void): void;
                /**
                 * An event that represents a field's value having changed.
                 * @param field - The field that has changed.
                 */
                one(event: 'change', callback: (field: Core.Annotations.Forms.Field) => void): void;
                off(event?: 'change', callback?: (field: Core.Annotations.Forms.Field) => void): void;
                /**
                 * Set all field properties form the given object.
                 * @param options - The object to set properties from.
                 */
                set(options: Core.Annotations.Forms.Field | any): void;
                /**
                 * Sets the field's type. Tries to retain as much type-specific information as possible across type changes.
                 * @param type - The new field type, one of Tx, Ch, Btn or Sig.
                 */
                setType(type: string): void;
                /**
                 * Sets the visibility of all child widgets
                 * @param visible - Should the field be visible?
                 */
                setVisible(visible: boolean): void;
                /**
                 * Enable visibility of all child widgets
                 */
                show(): void;
                /**
                 * Disable visibility of all child widgets
                 */
                hide(): void;
                /**
                 * Checks whether the current field is a terminal/leaf node (no children).
                 * @returns Whether this field is terminal/leaf node
                 */
                isTerminal(): boolean;
                /**
                 * Sets the field's value, following any type-specific constraints, and updating all widgets.
                 * @param value - The value to set.
                 * @param [widget] - Optionally a particular widget annotation associated with the field
                 */
                setValue(value: string | number, widget?: Core.Annotations.WidgetAnnotation): void;
                /**
                 * Gets the field's value
                 * @returns The value of the field
                 */
                getValue(): string | number;
                /**
                 * Refresh the appearance of each widget in the current field.
                 */
                refreshAppearances(): void;
                /**
                 * Commits the new value to the field (triggers Validate action, and updates all widgets)
                 * @param event - Ignored.
                 * @param value - The new value.
                 * @param [widget] - Optionally a particular widget annotation associated with the field
                 */
                commit(event: any, value: string | number, widget?: Core.Annotations.WidgetAnnotation): void;
                /**
                 * Returns the field's type
                 * @returns The field type as defined by the FormFieldTypes enum
                 */
                getFieldType(): string;
                /**
                 * Returns the field's type. One of ('Tx', 'Btn', 'Ch' or 'Sig')
                */
                type: string;
                /**
                 * The field's children
                */
                children?: Core.Annotations.Forms.Field[];
                /**
                 * The field's child widgets
                */
                widgets?: Core.Annotations.WidgetAnnotation[];
                /**
                 * Gets the field's actions.
                */
                actions?: {
                    [key: string]: Core.Actions.Action[];
                };
                /**
                 * The field's default value
                */
                defaultValue?: number | string;
                /**
                 * The field's export value. Defaults to the field's value if not set.
                */
                exportValue?: number | string;
                /**
                 * The field's flags object
                */
                flags?: Core.Annotations.WidgetFlags;
                /**
                 * Returns the field's associated font object
                */
                font?: Core.Annotations.Font;
                /**
                 * Is field is modified?
                */
                IsModified?: boolean;
                /**
                 * The field's maximum length. -1 means infinite.
                */
                maxLen?: number;
                /**
                 * The full name of the field.
                */
                name: string;
                /**
                 * The field's options (or permanently null if the field type does not support options).
                */
                options?: object[];
                /**
                 * Returns the field's quadding. (One of 'Left-justified', 'Right-justified', 'Centered')
                */
                quadding?: string;
                /**
                 * The field's value.
                */
                value?: number | string;
                /**
                 * The text to be displayed when hovering over the field.
                */
                tooltipName: string;
            }
        }
        namespace Annotation {
            /**
             * an object that maps between a text style location(character index) to css styles.
             * @example
             * {
             *   0: {
             *     'font-weight': 'bold',
             *     'color': '#ff0000',
             *   },
             *   10: {
             *     'font-style': 'italic'
             *     'font-weight': 'bold',
             *     'color': '#0000ff',
             *   },
             *   12: {
             *     'text-decoration': 'underline',
             *   }
             * }
             *
             * this object means that the first 9 characters are bold and red, the following 2 characters are italic, bold, and blue, and the rest of characters have underline.
             */
            type RichTextStyle = {
                [key: string]: Core.Annotations.Annotation.RichTextCSSStyle;
            };
            /**
             */
            type RichTextCSSStyle = {
                'font-style'?: 'normal' | 'italic';
                'font-weight'?: 'normal' | 'bold';
                /**
                 * text-decoration: 'word' is equivalent to text-decoration: 'underline'. Values of text-decorations can also be joined by a space. For example, text-decoration: 'word line-through'
                 */
                'text-decoration'?: 'word' | 'line-through' | 'underline' | string;
                /**
                 * color in RGB hex format
                 */
                color?: string;
            };
            /**
             * An object containing the different display formats for measurement annotations.
             * @example
             * const fractionMeasurementDisplayFormat = Annotations.Annotation.MeasurementDisplayFormats.FRACTION
             */
            enum MeasurementDisplayFormats {
                DECIMAL,
                FRACTION,
                ROUND,
                TRUNCATE
            }
            /**
             * An object containing the different measurement systems for measurement annotations.
             * @example
             * const metricMeasurementSystem = Annotations.Annotation.MeasurementSystems.METRIC
             */
            enum MeasurementSystems {
                METRIC,
                IMPERIAL,
                TYPOGRAPHIC
            }
            /**
             * An object containing the different display measurement units for measurement annotations.
             * @example
             * const centimeterMeasurementUnit = Annotations.Annotation.MeasurementUnits.CM
             */
            enum MeasurementUnits {
                MM,
                CM,
                M,
                KM,
                IN,
                FT,
                YD,
                MI,
                PT,
                DOUBLE_PRIME_IN,
                PRIME_FT,
                FT_IN
            }
        }
        /**
         * The base class for all annotations
         * @param [initializer] - A map of values to auto-initialize certain properties of the annotation. You can only initialize properties defined on the annotation under the Members section (unless specified otherwise).
         */
        class Annotation {
            constructor(initializer?: any);
            /**
             * Gets or sets the name of the annotation element in XFDF.
             * <p style="font-weight: bold;">This property cannot be initialized through the initializer.</p>
             */
            elementName: string;
            /**
             * Gets or sets a selection model constructor for how an annotation gets selected.
             */
            selectionModel: Core.Annotations.SelectionModel;
            /**
             * Gets or sets whether the annotation is hidden.
             */
            Hidden: boolean;
            /**
             * Gets or sets whether the annotation is invisible, only if it is an unknown annotation type. Generally for hiding annotations you should use "Hidden".
             */
            Invisible: boolean;
            /**
             * Gets or sets whether the annotation is readonly or not. If it's readonly it can't be edited or deleted.
             */
            ReadOnly: boolean;
            /**
             * Gets or sets whether the annotation is locked or not. If it's locked it can't be edited or deleted, but the note can be edited.
             */
            Locked: boolean;
            /**
             * Gets or sets whether the annotation contents are locked or not. If the contents are locked then note can't be edited but the annotation can be edited or deleted.
             */
            LockedContents: boolean;
            /**
             * Gets or sets if this annotation can be rotated.
             */
            NoRotate: boolean;
            /**
             * Gets or sets if this annotation scales with the page.
             */
            NoZoom: boolean;
            /**
             * Gets or sets whether the annotation is visible on the screen. Differs from Hidden in that it can still be printed if the print flag is set.
             */
            NoView: boolean;
            /**
             * Gets or sets whether the ToggleNoView flag is set on the annotation.
             */
            ToggleNoView: boolean;
            /**
             * Represents the subject of the annotation. Default is the annotation's type.
             */
            Subject: string;
            /**
             * Gets or sets the annotation's clockwise rotation in degrees. Valid values are 0, 90, 180 and 270. Only applies to Stamp, FreeText and Caret annotations.
             */
            Rotation: number;
            /**
             * Enabled or disables the annotation's rotation control.
             */
            RotationControlEnabled: boolean;
            /**
             * The name of the tool that is used to create this annotation.
             */
            ToolName: string;
            /**
             * Draws the annotation on the provide canvas context, relative to the page.
             * The point (0,0) coresponds to the top left corner of the page.
             * @param ctx - The canvas context prepared to be drawn on.
             * @param pageMatrix - The page matrix for the page that the annotation is on.
             * You can get this object by calling getPageMatrix on the document object.
             */
            draw(ctx: CanvasRenderingContext2D, pageMatrix: any): void;
            /**
             * Whether the annotation is visible on the document or not **when viewing**.
             * If the Hidden or NoView flags are set, or if the annotation is a reply to another annotation then it won't be visible.
             * @returns Whether the annotation is visible on the document or not when viewing
             */
            isVisible(): boolean;
            /**
             * Gets whether the annotation is a reply to another annotation.
             * @returns Returns true if it does reply to another annotation, false otherwise.
             */
            isReply(): boolean;
            /**
             * Whether the annotation is visible on the document or not **when printed**.
             * If Hidden or if the annotation is a reply to another annotation then it won't be visible.
             * @returns Whether the annotation is visible on the document or not when printed
             */
            isPrintVisible(): boolean;
            /**
             * Sets the size and location of the annotation's bounding rectangle.
             * Use this method instead of resize when only the x, y, width and height needs to be modified.
             * Use setRectWithNormalization instead of setRect if you want to reverse
             * any wrong-way-round coordinates instead of ignoring them.
             * @param rect - the new bounding rectangle
             */
            setRectWithNormalization(rect: Core.Math.Rect): void;
            /**
             * Sets the size and location of the annotation's bounding rectangle.
             * Use this method instead of resize when only the x, y, width and height needs to be modified.
             * Beware: this method ignores coordinates if they are the wrong way around.
             * (It hasn't been fixed for reasons of maintaining backward compatibility.
             * use setRectWithNormalization instead if you want it to reverse the
             * wrong-way-round coordinates instead of ignoring them.)
             * @param rect - the new bounding rectangle
             */
            setRect(rect: Core.Math.Rect): void;
            /**
             * Get annotation bounding rectangle
             */
            getRect(): Core.Math.Rect;
            /**
             * Adjusts the annotation's bounding rectangle to take into account changes to the annotation
             * e.g. stroke thickness, start/end points, etc
             */
            adjustRect(): void;
            /**
             * Resize the annotation based on a new given {@link Core.Math.Rect}.
             * Use this method instead of setRect when internal properties (other than x, y, width and height) need to be modified on resize.
             * @param rect - the new bounding rectangle
             */
            resize(rect: Core.Math.Rect): void;
            /**
             * Move the annotation based on a new given {@link Core.Math.Rect}.
             * Use this method instead of setRect when internal properties (other than x, y, width and height) need to be modified on move.
             * @param rect - the new bounding rectangle
             */
            move(rect: Core.Math.Rect): void;
            /**
             * Gets the x position measured in page coordinates of an annotation.
             * @returns the x position
             */
            getX(): number;
            /**
             * Sets the x position measured in page coordinates of an annotation.
             * @param value - the x position
             */
            setX(value: number): void;
            /**
             * Gets the y position measured in page coordinates.
             */
            getY(): number;
            /**
             * Sets the y position measured in page coordinates.
             * @param value - the y position
             */
            setY(value: number): void;
            /**
             * Gets the width of the annotation.
             * @returns the width of the annotation.
             */
            getWidth(): number;
            /**
             * Sets the width of the annotation.
             * @param value - the width of the annotation.
             */
            setWidth(value: number): void;
            /**
             * Gets the height of the annotation.
             * @returns the height of the annotation.
             */
            getHeight(): number;
            /**
             * Sets the height of the annotation.
             * @param value - the height of the annotation.
             */
            setHeight(value: number): void;
            /**
             * Gets the padding that will be applied by default on the annotation's rectangle.
             * @returns The amount of padding
             */
            getRectPadding(): number;
            /**
             * Gets the page number of the annotation.
             * Note: page number starts from 1.
             * @returns The annotation's page number
             */
            getPageNumber(): number;
            /**
             * Sets the page number of the annotation.
             * Note: page numbers start from 1.
             * @param value - the page number to be set
             */
            setPageNumber(value: number): void;
            /**
             * Returns true if the rotation control is enabled for the annotation and false otherwise.
             */
            hasRotationControlEnabled(): boolean;
            /**
             * Enables or disables the rotation control for the annotation
             * @param rotationControlEnabled - true if the rotation control should be enabled
             */
            setRotationControlEnabled(rotationControlEnabled: boolean): void;
            /**
             * Enables the rotation control for the annotation
             */
            enableRotationControl(): void;
            /**
             * Disables the rotation control for the annotation
             */
            disableRotationControl(): void;
            /**
             * Flags the annotation as modified if it has been before the last call to exportAnnotationCommand
             * Removes the annotation's appearance if no parameter is passed
             * Should be called if changing a custom property on the annotation that is used for serialization
             * Otherwise the annotation will serialize the original deserialized value
             * @param [shouldKeepAppearance] - If true then the annotation's appearance will be maintained
             */
            setModified(shouldKeepAppearance?: boolean): void;
            /**
             * Sets the custom data associated with the specified key.
             * @param key - The key under which to store this custom data. Data will automatically be saved in the exported XFDF
             * and merged into the PDF when downloading.
             * @param value - The custom data to store
             */
            setCustomData(key: string, value: string): void;
            /**
             * Returns custom data associated with the given key.
             * @param key - The key for which to retrieve the associated data.
             * @returns value The custom data. If no data is available an empty string is returned.
             */
            getCustomData(key: string): string;
            /**
             * Deletes custom data associated with the given key.
             * @param key - The key for which to delete the associated data.
             */
            deleteCustomData(key: string): void;
            /**
             * Gets the rich text style of the annotation.
             * @returns the current rich text style
             */
            getRichTextStyle(): Core.Annotations.Annotation.RichTextStyle;
            /**
             * Sets the rich text style of the annotation. New style will replace the old one
             * @param richTextStyle - The new rich text style of the annotation
             */
            setRichTextStyle(richTextStyle: Core.Annotations.Annotation.RichTextStyle): void;
            /**
             * Update the rich text style of the annotation. Can provide a range to set the which characters the style should apply to
             * @param object - The new rich text style of the annotation
             * @param object.'underline' - boolean value for whether string should be underlined
             * @param object.'line-through' - boolean value for whether string should be strike through
             * @param object.'font-weight' - String for the font weight of the rich text  (can be 'bold')
             * @param object.'font-style' - String for font style of the rich text (can be 'italic')
             * @param object.'color' - string for what color to set text to
             * @param [startIndex] - Starting character to apply style, if null apply to every character
             * @param [endIndex] - Last character to apply style. If null, apply till end
             */
            updateRichTextStyle(object: {
                'underline': boolean;
                'line-through': boolean;
                'font-weight': string;
                'font-style': string;
                'color': string;
            }, startIndex?: number, endIndex?: number): void;
            /**
             * Gets the text content for the annotation.
             * Contents may be displayed in an annotation's popup or directly on the page (in the case of FreeTextAnnotation).
             * @returns the text content for the annotation.
             */
            getContents(): string;
            /**
             * Set the text content for the annotation.
             * Note that this will not refresh the text in the UI.
             * @param value - the text content to be set
             */
            setContents(value: string): void;
            /**
             * Gets the list of replies to this annotation.
             * @returns The list of replies
             */
            getReplies(): Core.Annotations.Annotation[];
            /**
             * Gets the list of group children to this annotation.
             * @returns The list of group children
             */
            getGroupedChildren(): Core.Annotations.Annotation[];
            /**
             * Gets the status of the annotation, and returns an empty string if no status set.
             * @returns The last status update.
             */
            getStatus(): string;
            /**
             * Gets whether the annotation is a child of a group
             * @returns Returns true if the annotation is a child of a group, false otherwise.
             */
            isGrouped(): boolean;
            /**
             * Returns whether the annotation is a form field place holder annotation,
             * which are annotations used as place holders for fields in the Form Field Creation mode
             */
            isFormFieldPlaceholder(): boolean;
            /**
             * Returns what type of form field place holder it is, if it is a form field place holder
             * @returns Form field place holder type as described by the Form Field Annotations enum
             */
            getFormFieldPlaceHolderType(): string;
            /**
             * Returns whether the annotation is a content editing placeholder,
             * which are annotations used as placeholders for content edit boxes when the content editing tool is active
             * @returns Whether the annotation is a content edit placeholder or not
             */
            isContentEditPlaceholder(): boolean;
            /**
             * Returns the content edit type, if there is one. Only applicable to content edit placeholder annotations.
             */
            getContentEditType(): string;
            /**
             * Resolves when all required resources have finished loading.
             * Currently only applicable to stamp annotations that use images.
             * @returns A promise that resolves when the resources have finished loading
             */
            resourcesLoaded(): Promise<void>;
            /**
             * Returns true if annotation is part of the original document, false otherwise.
             * @returns Whether the annotation is internal to the document or not
             */
            getInternal(): boolean;
            /**
             * Returns true if annotation is part of the original document, false otherwise.
             * @returns Whether the annotation is internal to the document or not
             */
            isInternal(): boolean;
            /**
             * Serialize the annotation to an xml element
             * @param element - an xml element representing the annotation
             * @param pageMatrix - the page matrix used to convert XOD coordinates to PDF coordinates.
             * @returns the resulting xml element representing the annotation
             */
            serialize(element: Element, pageMatrix: any): Element;
            /**
             * Adds a custom appearance to the annotation so that the annotation appears like the specified
             * PDF page or object in the PDF page. This appearance will be used instead of the default
             * WebViewer drawing of the annotation.
             * @param doc - the PDF document object.
             * @param [options] - An object that can contain the following optional parameters.
             * @param [options.pageNumber = 1] - Page number of source document to use for custom appearance.
             * @param [options.objnum] - The object number from the appearance document.
             * @param [options.gennum] - The generation number from the appearance document.
             * @param [options.transparentBackground] - Transparent background, default is true.
             */
            addCustomAppearance(doc: Core.Document, options?: {
                pageNumber?: string;
                objnum?: string;
                gennum?: string;
                transparentBackground?: string;
            }): void;
            /**
             * Removes the custom appearance of the annotation.
             */
            removeCustomAppearance(): void;
            /**
             * Deserializes the xml element into the annotation
             * @param element - an xml element representing the annotation
             * @param pageMatrix - the page matrix used to convert PDF coordinates to XOD coordinates.
             */
            deserialize(element: Element, pageMatrix: any): void;
            /**
             * Gets or sets the annotation's x-axis position.
             */
            X: number;
            /**
             * Gets or sets the annotation's y-axis position.
             */
            Y: number;
            /**
             * Gets or sets the width of the annotation.
             */
            Width: number;
            /**
             * Gets or sets the height of the annotation.
             */
            Height: number;
            /**
             * Gets or sets whether or not the annotation can be moved.
             */
            NoMove: boolean;
            /**
             * Gets or sets if this annotation can be resized by the user.
             */
            NoResize: boolean;
            /**
             * Gets or sets if this annotation can be deleted.
             */
            NoDelete: boolean;
            /**
             * Gets or sets the page number of a document that the annotation appears on.
             */
            PageNumber: number;
            /**
             * Gets or sets the date that the annotation was last modified.
             */
            DateModified: Date;
            /**
             * A unique identifier for the annotation. Corresponds to the name attribute in XFDF.
             */
            Id: string;
            /**
             * The author of the annotation.
             */
            Author: string;
            /**
             * Gets or sets whether the annotation has been added since the last time the AnnotCommand was retrieved.
             */
            IsAdded: boolean;
            /**
             * Gets or sets whether the annotation has been modified since the last time the AnnotCommand was retrieved.
             */
            IsModified: boolean;
            /**
             * Gets or sets whether the annotation has been deleted since the last time the AnnotCommand was retrieved.
             */
            IsDeleted: boolean;
            /**
             * Gets or sets whether the annotation should be listed in annotation lists. If set to true the annotation also will not be selectable.
             */
            Listable: boolean;
            /**
             * Gets or sets the annotation's stroke color.
             */
            Color: Core.Annotations.Color;
            /**
             * Gets or sets if the annotation maintains aspect ratio when being resized.
             */
            MaintainAspectRatio: boolean;
            /**
             * Gets or sets whether any parts of the annotation drawn outside of the rect are clickable.
             */
            IsClickableOutsideRect: boolean;
            /**
             * Gets or sets whether the annotation should be displayed when printing the page.
             */
            Printable: boolean;
            /**
             * The Id of the annotation that this annotation is replying to or the parent annotation it is grouped with.
             */
            InReplyTo: string;
            /**
             * The type of reply.
             */
            ReplyType: string;
        }
        /**
         * Creates a new instance of Border.
         * @property color - The color of the border
         * @property width - The width of the border
         * @property style - The style of the border (possible types include: solid, bevelled, inset)
         * @property cornerRadius - The corner radius size
         * @param options - The initialization options, an object with properties color, width, style, cornerRadius
         */
        class Border {
            constructor(options: any);
            /**
             * The color of the border
            */
            color: Core.Annotations.Color;
            /**
             * The width of the border
            */
            width: number;
            /**
             * The style of the border (possible types include: solid, bevelled, inset)
            */
            style: string;
            /**
             * The corner radius size
            */
            cornerRadius: number;
        }
        /**
         * Creates a new instance of Color.
         * @property R - the R (red) value (0-255)
         * @property G - the G (green) value (0-255)
         * @property B - the B (blue) value (0-255)
         * @property A - the A (alpha) value (0-1.0)
         * @param r - the R (red) value (0-255)
         * @param g - the G (green) value (0-255)
         * @param b - the B (blue) value (0-255)
         * @param [a] - the A (alpha) value (0-1.0)
         */
        class Color {
            constructor(r: number, g: number, b: number, a?: number);
            /**
             * Returns the color as a hex string e.g. #FFFFFF
             * @returns The hex color string.
             */
            toHexString(): string;
            /**
             * the R (red) value (0-255)
            */
            R: number;
            /**
             * the G (green) value (0-255)
            */
            G: number;
            /**
             * the B (blue) value (0-255)
            */
            B: number;
            /**
             * the A (alpha) value (0-1.0)
            */
            A: number;
        }
        /**
         * Creates a new box control handle
         * @param width - the width of the handle
         * @param height - the height of the handle
         * @param horizontalAlignment - the horizontal position of the handle
         * @param verticalAlignment - the vertical position of the handle
         */
        class BoxControlHandle extends Core.Annotations.ControlHandle {
            constructor(width: number, height: number, horizontalAlignment: number, verticalAlignment: number);
        }
        /**
         * Creates a callout control handle.
         * @param x - the x coordinate of the point
         * @param y - the y coordinate of the point
         * @param width - the width of the handle
         * @param height - the height of the handle
         * @param pathIndex - the index of the point in the path array
         */
        class CalloutControlHandle extends Core.Annotations.ControlHandle {
            constructor(x: number, y: number, width: number, height: number, pathIndex: number);
        }
        /**
         * Creates a new ControlHandle with the specified dimensions.
         * @param x - The x-coordinate of the upper-left point
         * @param y - The y-coordinate of the upper-left point
         * @param width - The width of the control handle
         * @param height - The width of the control handle
         */
        class ControlHandle {
            constructor(x: number, y: number, width: number, height: number);
            /**
             * Defines the width of all control handles. Default is 10.
             */
            static handleWidth: number;
            /**
             * Defines the height of all control handles. Default is 10.
             */
            static handleHeight: number;
            /**
             * Defines the width of all rotation control handles. Default is 28.
             */
            static rotationHandleWidth: number;
            /**
             * Defines the height of all rotation control handles. Default is 28.
             */
            static rotationHandleHeight: number;
            /**
             * Defines a padding for selection accuracy. Default is 1.
             * Increase this value to make selection more forgiving.
             */
            static selectionAccuracyPadding: number;
            /**
             * Defines the outline color for the annotation control point.
             */
            static outlineColor: Core.Annotations.Color;
            /**
             * Defines the color for the annotation control point.
             */
            static color: Core.Annotations.Color;
            /**
             * Defines the shadow color for the annotation control point.
             */
            static shadowColor: Core.Annotations.Color;
            /**
             * Defines the shadow blur for the annotation control point.
             */
            static shadowBlur: number;
            /**
             * Defines the offset Y position for the shadow blur for the annotation control point.
             */
            static shadowOffsetY: number;
            /**
             * Defines thickness of the annotation selection outline. Default is 3.
             */
            static selectionPointOutlineThickness: number;
            /**
             * Determines if the provided point is a hit on the control handle.
             * See {@link Core.Annotations.SelectionAlgorithm} for usuable selection algorithms.
             * @param annotation - the annotation
             * @param selectionBox - the selection rect
             * @param zoom - the current zoom level of the document
             * @param x - the x-coordinate of the point to test, in page coordinates
             * @param y - the y-coordinate of the point to test, in page coordinates
             * @returns true if the provided point is a hit
             */
            testSelection(annotation: Core.Annotations.Annotation, selectionBox: Core.Math.Rect, zoom: number, x: number, y: number): boolean;
            /**
             * Draws the control handle's appearance on the provided canvas context
             * @param ctx - the annotation canvas context
             * @param annotation - the annotation to modify
             * @param selectionBox - the selection rect
             * @param zoom - the current zoom level of the document
             */
            draw(ctx: CanvasRenderingContext2D, annotation: Core.Annotations.Annotation, selectionBox: Core.Math.Rect, zoom: number): void;
        }
        /**
         * Creates a line control handle.
         * @param x - the x coordinate of the point
         * @param y - the y coordinate of the point
         * @param width - the width of the handle
         * @param height - the height of the handle
         * @param isEnd - true if the handle is for the start point, false if the handle is for the end point
         */
        class LineControlHandle extends Core.Annotations.ControlHandle {
            constructor(x: number, y: number, width: number, height: number, isEnd: boolean);
        }
        /**
         * Creates a path control handle.
         * @param x - the x coordinate of the point
         * @param y - the y coordinate of the point
         * @param width - the width of the handle
         * @param height - the height of the handle
         * @param pathIndex - the index of the point in the path array
         */
        class PathControlHandle extends Core.Annotations.ControlHandle {
            constructor(x: number, y: number, width: number, height: number, pathIndex: number);
        }
        /**
         * Creates a polygon control handle.
         * @param x - the x coordinate of the point
         * @param y - the y coordinate of the point
         * @param width - the width of the handle
         * @param height - the height of the handle
         * @param pathIndex - the index of the point in the path array
         */
        class PolygonControlHandle extends Core.Annotations.PathControlHandle {
            constructor(x: number, y: number, width: number, height: number, pathIndex: number);
        }
        /**
         * Creates a new rotation control handle
         * @param width - The width of the handle
         * @param height - The height of the handle
         * @param offset - The minimum offset the control handle will be from the selection box
         * @param annotation - The annotation bound to this control handle
         */
        class RotationControlHandle extends Core.Annotations.ControlHandle {
            constructor(width: number, height: number, offset: number, annotation: Core.Annotations.Annotation);
        }
        /**
         * Contains the tools to create and manipulate form field data
         * @property getUsableInputWidth - A function to set the allowable width for fields with "scroll long text" disabled.
         * It takes the width of the field and it should return a number which is the new allowable width
         */
        class Forms {
            /**
             * A function to set the allowable width for fields with "scroll long text" disabled.
            It takes the width of the field and it should return a number which is the new allowable width
            */
            getUsableInputWidth: (...params: any[]) => any;
        }
        /**
         * A class representing a PDF font.
         * @property name - The font's name
         * @property [size = 0] - The font's size
         * @property [type = 'Type1'] - The font's type (One of CIDType0, CIDType2, MMType1, TrueType, Type0, Type1, Type3)
         * @property [strokeColor = new Core.Annotations.Color([0,0,0])] - The font's stroke color
         * @property [fillColor = new Core.Annotations.Color([0,0,0])] - The font's fill color
         * @property calculatedSize - The calculated size of the font if size is 0
         * @param [params] - An object containing parameters to be initialised on the font.
         */
        class Font {
            constructor(params?: any);
            /**
             * Set all properties on Font using a Font or a Font-like object.
             * @param options - The options to set on the Font
             */
            set(options: Core.Annotations.Font | any): void;
            /**
             * Is the font solid black?
             * @returns Whether the font is solid black
             */
            isBlack(): boolean;
            /**
             * Convert the font to a CSS object like one would pass to jQuery.css().
             * @returns An object appropriate to pass to jQuery.css()
             */
            toCSS(zoom: number): any;
            /**
             * The font's name
            */
            name: string;
            /**
             * The font's size
            */
            size?: number;
            /**
             * The font's type (One of CIDType0, CIDType2, MMType1, TrueType, Type0, Type1, Type3)
            */
            type?: string;
            /**
             * The font's stroke color
            */
            strokeColor?: Core.Annotations.Color | any[] | any;
            /**
             * The font's fill color
            */
            fillColor?: Core.Annotations.Color | any[] | any;
            /**
             * The calculated size of the font if size is 0
            */
            calculatedSize: number;
        }
        interface HTMLAnnotation extends Core.Actions.Dispatcher {
        }
        /**
         * An common base class annotation that displays its contents using HTML5 instead of via Canvas.
         * @property rect - The annotation's rectangle
         * @property element - Gets the annotation's outer display element, if it exists
         * @property innerElement - Gets the annotation's inner UI element, if it exists
         * @property [hidden = false] - Gets and sets whether the annotation is hidden
         * @property [color = new Core.Annotations.Color()] - Gets and sets the annotation's color (any type that can be used to construct Core.Annotations.Color)
         * @property [border = new Core.Annotations.Border()] - Gets and sets the annotation's border (is a border, or a map of border properties)
         * @property [backgroundColor = new Core.Annotations.Color()] - Gets and sets the annotation's background color
         * @property [actions = {}] - Gets the actions attached to this annotation as an object with triggers as keys and arrays of actions as values
         * @property [rotation = 0] - Gets and sets the annotation's rotation (must be one of 0, 90, 180, 270)
         */
        class HTMLAnnotation extends Core.Annotations.Annotation implements Core.Actions.Dispatcher {
            /**
             * Returns the HTML element of a widget annotation. Override this method to customize the HTML element.
             * @returns a HTML element
             */
            createInnerElement(): HTMLElement;
            /**
             * The annotation's rectangle
            */
            rect: any;
            /**
             * Gets the annotation's outer display element, if it exists
            */
            element: Element;
            /**
             * Gets the annotation's inner UI element, if it exists
            */
            innerElement: Element;
            /**
             * Gets and sets whether the annotation is hidden
            */
            hidden?: boolean;
            /**
             * Gets and sets the annotation's color (any type that can be used to construct Core.Annotations.Color)
            */
            color?: Core.Annotations.Color | any | any[];
            /**
             * Gets and sets the annotation's border (is a border, or a map of border properties)
            */
            border?: Core.Annotations.Border | any;
            /**
             * Gets and sets the annotation's background color
            */
            backgroundColor?: Core.Annotations.Color | any | any[];
            /**
             * Gets the actions attached to this annotation as an object with triggers as keys and arrays of actions as values
            */
            actions?: any;
            /**
             * Gets and sets the annotation's rotation (must be one of 0, 90, 180, 270)
            */
            rotation?: number;
        }
        /**
         * Represents a PDF Link annotation with associated actions.
         * @param options - A map of properties to set on the new Link
         */
        class Link extends Core.Annotations.HTMLAnnotation {
            constructor(options: any);
            /**
             * Returns whether the link is added by WebViewer automatically.
             * @returns Whether the link is added by WebViewer automatically.
             */
            isAutomaticLink(): boolean;
        }
        /**
         * Creates a box selection model.
         * @param annotation - The annotation
         * @param canModify - Indicates if the annotation can be modified
         * @param isSelected - boolean to denote if the annotation is selected
         */
        class BoxSelectionModel extends Core.Annotations.SelectionModel {
            constructor(annotation: Core.Annotations.Annotation, canModify: boolean, isSelected: boolean);
        }
        /**
         * Creates a callout selection model.
         * @param annotation - The annotation
         * @param canModify - Indicates if the annotation can be modified
         * @param isSelected - The annotation is already selected
         * @param docViewer - An instance of DocumentViewer.
         */
        class CalloutSelectionModel {
            constructor(annotation: Core.Annotations.FreeTextAnnotation, canModify: boolean, isSelected: boolean, docViewer: Core.DocumentViewer);
        }
        /**
         * Creates a free text selection model.
         * @param annotation - the annotation
         * @param canModify - indicates if the annotation can be modified
         */
        class FreeTextSelectionModel extends Core.Annotations.BoxSelectionModel {
            constructor(annotation: Core.Annotations.Annotation, canModify: boolean, isSelected: boolean);
        }
        /**
         * Creates a line selection model.
         * @param annotation - the annotation
         * @param canModify - indicates if the annotation can be modified
         */
        class LineSelectionModel extends Core.Annotations.SelectionModel {
            constructor(annotation: Core.Annotations.Annotation, canModify: boolean);
        }
        /**
         * Creates a path selection model.
         * @param annotation - the annotation
         * @param canModify - indicates if the annotation can be modified
         */
        class PathSelectionModel extends Core.Annotations.SelectionModel {
            constructor(annotation: Core.Annotations.Annotation, canModify: boolean);
        }
        /**
         * Creates a polygon selection model.
         * @param annotation - the annotation
         * @param canModify - indicates if the annotation can be modified
         */
        class PolygonSelectionModel extends Core.Annotations.PathSelectionModel {
            constructor(annotation: Core.Annotations.Annotation, canModify: boolean);
        }
        /**
         * Creates a text selection model.
         * @param annotation - the annotation
         * @param canModify - indicates if the annotation can be modified
         * @param isSelected - the annotation is already selected
         */
        class RedactionSelectionModel {
            constructor(annotation: Core.Annotations.Annotation, canModify: boolean, isSelected: boolean);
        }
        /**
         * Represents static utility functions to determine hit testing for annotations.
         * @property canvasVisibilityPadding - Defines a padding for the canvas visibility test algorithm. Increase this value to make selection more forgiving.
         */
        class SelectionAlgorithm {
            /**
             * Tests if the provided x and y coordinate is within the annotation's bounding rectangle (x, y, width, height).
             * @param x - the x-coordinate of the point to test, in page coordinates
             * @param y - the y-coordinate of the point to test, in page coordinates
             * @param zoom - the zoom level to use in the calculation if the annotation has a no zoom property
             * @returns true if the provided point is a hit on the annotation
             */
            static boundingRectTest(annotation: Core.Annotations.Annotation, x: number, y: number, zoom?: number): boolean;
            /**
             * Tests if the provided x and y coordinate is a visible point on the canvas.
             * @param x - the x-coordinate of the point to test, in page coordinates
             * @param y - the y-coordinate of the point to test, in page coordinates
             * @returns true if the provided point is a hit on the annotation
             */
            static canvasVisibilityTest(annotation: Core.Annotations.Annotation, x: number, y: number): boolean;
            /**
             * Tests if the provided x and y coordinate is within a text Quad of the provided text-based annotation.
             * @param annotation - the text markup annotation
             * @param x - the x-coordinate of the point to test, in page coordinates
             * @param y - the y-coordinate of the point to test, in page coordinates
             * @returns true if the provided point is a hit on the annotation
             */
            static textQuadTest(annotation: Core.Annotations.TextMarkupAnnotation, x: number, y: number): boolean;
            /**
             * Tests if the provided x and y coordinate is inside of the provided polygon annotation
             * @param annotation - The polygon annotation
             * @param x - The x-coordinate of the point to test, in page coordinates
             * @param y - The y-coordinate of the point to test, in page coordinates
             * @param pageMatrix - The page matrix for the page that the annotation is on.
             * @param zoom - The zoom level to use in the calculation if the annotation has a no zoom property
             */
            static insidePolygonTest(annotation: Core.Annotations.PolygonAnnotation, x: number, y: number, pageMatrix: any, zoom: number): void;
            /**
             * Defines a padding for the canvas visibility test algorithm. Increase this value to make selection more forgiving.
            */
            canvasVisibilityPadding: number;
        }
        /**
         * Create a new selection model.
         * @param annotation - The annotation selected
         * @param canModify - Modification of the annotation is allowed
         * @param isSelected - The annotation is already selected
         * @param docViewer - An instance of DocumentViewer.
         */
        class SelectionModel {
            constructor(annotation: Core.Annotations.Annotation, canModify: boolean, isSelected: boolean, docViewer: Core.DocumentViewer);
            /**
             * Defines thickness of the annotation selection outline. Default is 1.
             */
            static selectionOutlineThickness: number;
            /**
             * Defines padding for selection accuracy. Default is 2.
             * Increase this value to make selection more forgiving.
             */
            static selectionAccuracyPadding: number;
            /**
             * Defines the default color for the annotation selection outline.
             */
            static defaultSelectionOutlineColor: Core.Annotations.Color;
            /**
             * Defines the default color for the annotation selection outline when the user is not permitted to make modifications.
             */
            static defaultNoPermissionSelectionOutlineColor: Core.Annotations.Color;
            /**
             * Defines the default padding between selection control points. The padding only appears when the control points are too close.
             */
            static selectionOutlineExtraPadding: number;
            /**
             * Defines the dash size for the selection outline. Default is 4;
             */
            static selectionOutlineDashSize: number;
            /**
             * Defines if a dashed line style should be used for the selection outline. Default is false.
             */
            static useDashedLine: boolean;
            /**
             * Defines if extra padding should be shown when the selected annotation is too small. Default is true.
             */
            static showPaddingWhenAnnotationIsSmall: boolean;
            /**
             * Determines if the provided point is a hit on the selected annotationhandle.
             * * See {@link Core.Annotations.SelectionAlgorithm} for usuable selection algorithms.
             * @param annotation - the annotation
             * @param x - the x-coordinate of the point to test, in page coordinates
             * @param y - the y-coordinate of the point to test, in page coordinates
             * @param pageMatrix - the page matrix of the page the annotation is on
             * @param zoom - the zoom level of the page the annotation is on
             * @param rotation - the rotation of the page the annotation is on
             * @returns true if the provided point is a hit
             */
            testSelection(annotation: Core.Annotations.Annotation, x: number, y: number, pageMatrix: any, zoom: number, rotation: Core.PageRotation): boolean;
            /**
             * Hit detection for each control handle.
             * @returns The control handle that was hit
             */
            testControlHandles(annotation: Core.Annotations.Annotation, zoom: number, x: number, y: number): Core.Annotations.ControlHandle;
            /**
             * Returns the ControlHandle objects associated with this selection model.
             * @returns An array of ControlHandleObject
             */
            getControlHandles(): Core.Annotations.ControlHandle[];
            /**
             * Gets the dimensions {x, y, width, height} of the selection bounding box.
             * It may be different from the annotation's bounding box.
             * e.g. The selection bounding box may have a padding.
             */
            getDimensions(annotation: Core.Annotations.Annotation): Core.Math.Rect;
            /**
             * Indicates that the associated annotation is able to be modified
             */
            canModify(): boolean;
            /**
             * Draws the selection outline of the annotation.
             * By default, a rectangle is drawn based on the annotations x, y, width and height.
             */
            drawSelectionOutline(ctx: CanvasRenderingContext2D, annotation: Core.Annotations.Annotation, zoom: number): void;
            /**
             * Overwrites the functions in SelectionModel(ex: drawSelectionOutline, getDimensions, testSelection).
             * @example
             * const { Annotations } = instance.Core;
             * const { SelectionModel, BoxSelectionModel } = Annotations;
             * SelectionModel.setCustomHandlers(BoxSelectionModel, {
             *   // draws a diagonal dashed along across the middle of the selected annotation
             *    drawSelectionOutline(ctx, annotation, zoom, pageMatrix, { selectionModel, originalDrawSelectionOutline }) {
             *      if (!(annotation instanceof Annotations.RectangleAnnotation)) {
             *          originalDrawSelectionOutline(ctx, annotation, zoom, pageMatrix);
             *          return;
             *        }
             *       if (typeof zoom !== 'undefined') {
             *          ctx.lineWidth = SelectionModel.selectionOutlineThickness / zoom;
             *        } else {
             *          ctx.lineWidth = SelectionModel.selectionOutlineThickness;
             *        }
             *        if (selectionModel.canModify()) {
             *          ctx.strokeStyle = SelectionModel.defaultSelectionOutlineColor.toString();
             *        } else {
             *          ctx.strokeStyle = SelectionModel.defaultNoPermissionSelectionOutlineColor.toString();
             *        }
             *        ctx.beginPath();
             *        ctx.moveTo(annotation.X, annotation.Y);
             *        ctx.lineTo(annotation.X + annotation.Width, annotation.Y + annotation.Height);
             *        ctx.closePath();
             *        ctx.stroke();
             *        const dashUnit = SelectionModel.selectionOutlineDashSize / zoom;
             *        const sequence = [dashUnit, dashUnit];
             *        ctx.setLineDash(sequence);
             *        ctx.strokeStyle = 'rgb(255, 255, 255)';
             *        ctx.stroke();
             *      },
             *     // Get the dimension that is extended by 8 both horizontally and vertically
             *     getDimensions(annotation, { selectionModel, originalGetDimensions }) {
             *      if (!(annotation instanceof Annotations.RectangleAnnotation)) {
             *         return originalGetDimensions(annotation);
             *      }
             *      const x = annotation.X - 4;
             *      const y = annotation.Y - 4;
             *      const width = annotation.Width + 2 * 4;
             *      const height = annotation.Height + 2 * 4;
             *      return new Annotations.Rect(x, y, x + width, y + height);
             *     },
             *     testSelection(annotation, x, y, pageMatrix, zoom, rotation, { selectionModel, originalTestSelection }) {
             *       if (annotation instanceof Annotations.RectangleAnnotation) {
             *         return originalTestSelection(annotation, x, y, pageMatrix, zoom, rotation);;
             *       }
             *       return Annotations.SelectionAlgorithm.boundingRectTest(annotation, x, y, zoom);
             *     }
             * })
             * @param selectionModelClass - The class (constructor) of the selectionModel
             * @param selectionModelCustomHandlers - An object containing multiple handlers to overwrite functions on a SelectionModel.
             */
            static setCustomHandlers(selectionModelClass: Core.Annotations.SelectionModel, selectionModelCustomHandlers: Core.Annotations.SelectionModel.SelectionModelCustomHandlers): void;
        }
        /**
         * Creates a text selection model.
         * @param annotation - the annotation
         * @param canModify - indicates if the annotation can be modified
         */
        class TextSelectionModel extends Core.Annotations.SelectionModel {
            constructor(annotation: Core.Annotations.Annotation, canModify: boolean);
        }
        /**
         * Represents a Arc annotation.
         * @param [initializer] - A map of values to auto-initialize certain properties of the annotation. You can only initialize properties defined on the annotation under the Members section (unless specified otherwise).
         */
        class ArcAnnotation extends Core.Annotations.IPathAnnotation {
            constructor(initializer?: any);
            /**
             * Gets the current Radius.
             */
            Radius: string;
            /**
             * Gets the current length.
             */
            Length: string;
            /**
             * Gets the current Sweep Angle in degrees.
             */
            Angle: string;
            /**
             * Gets or Sets the 3 points defining the Arc.
             */
            Path: string;
            /**
             * Gets all the measurement properties of the Arc.
             */
            Properties: string;
            /**
             * Gets the annotations current type.
             */
            Type: string;
            /**
             * Gets or sets the border style of an annotation. e.g Solid, Cloudy
             */
            Style: string;
            /**
             * Gets or sets the border dash style of an annotation. e.g '3' or '3,3'
             */
            Dashes: string;
            /**
             * Gets or sets the annotation's precision from its measure dictionary.
             * @example
             * WebViewer(...)
             *   .then(function(instance) {
             *     const { annotationManager, Annotations } = instance.Core;
             *     const measurementAnnotation = annotationManager.getAnnotationsList()[0]
             *     const measurementDisplayFormats = Annotations.Annotation.MeasurementDisplayFormats
             *      measurementAnnotation.DisplayFormat = measurementDisplayFormats.FRACTION
             *   });
             */
            Precision: number;
            /**
             * Gets or sets the annotation's scale from its measure dictionary.
             */
            Scale: any[];
            /**
             * Gets or sets the annotation's system (Metric, Imperial, Typographic).
             * @example
             * WebViewer(...)
             *   .then(function(instance) {
             *     const { annotationManager, Annotations } = instance.Core;
             *     const measurementAnnotation = annotationManager.getAnnotationsList()[0]
             *     const measurementSystems = Annotations.Annotation.MeasurementSystems
             *      measurementAnnotation.System = measurementSystems.METRIC
             */
            System: string;
            /**
             * Gets or sets the annotation's measurement display format.
             * @example
             * WebViewer(...)
             *   .then(function(instance) {
             *     const { annotationManager, Annotations } = instance.Core;
             *     const measurementAnnotation = annotationManager.getAnnotationsList()[0]
             *     const measurementDisplayFormats = Annotations.Annotation.MeasurementDisplayFormats
             *      measurementAnnotation.DisplayFormat = measurementDisplayFormats.FRACTION
             *   });
             */
            DisplayFormat: string;
            /**
             * Gets or sets the annotation's measurement display units.
             * @example
             * WebViewer(...)
             *   .then(function(instance) {
             *     const { annotationManager, Annotations } = instance.Core;
             *     const measurementAnnotation = annotationManager.getAnnotationsList()[0]
             *     const measurementUnits = Annotations.Annotation.MeasurementUnits
             *      measurementAnnotation.DisplayUnits = [measurementUnits.FT, measurementUnits.IN]
             *   });
             */
            DisplayUnits: string[];
        }
        /**
         * Represents a caret annotation.
         * @param [initializer] - A map of values to auto-initialize certain properties of the annotation. You can only initialize properties defined on the annotation under the Members section (unless specified otherwise).
         */
        class CaretAnnotation extends Core.Annotations.MarkupAnnotation {
            constructor(initializer?: any);
        }
        /**
         * The base class for custom annotations. Extending from this class will allow your annotation to appear the same in other viewers.
         * This class will be serialized as a stamp and other viewers will view it as a stamp. However, this can be deserialized back into it's original type in WebViewer with the original behavior.
         * Please store your custom attributes/values into the custom data using {@link CustomAnnotation.SerializedData SerializedData} so that it will be preserved.
         * @property SerializationTypes - An enumeration of custom annotation serialization method types.
         * @property SerializationTypes.STAMP - Saves custom annotation as a stamp. Compatible with other viewers.
         * @property SerializationTypes.CUSTOM - Saves custom annotation using custom XFDF. Not compatible with other viewers.
         * @property QualityScale - Gets/sets the quality of the annotation when saved as a stamp. The higher the value, the higher the quality and memory usage. Default: 2.
         * @property SerializationType - Gets/sets the method this custom annotation class will be saved with. Default: STAMP.
         * @property OutputImagePadding - Gets/sets the additional padding around the custom annotation stamp appearance.
         * @param type - The initial element name for this custom annotation.
         * @param [initializer] - A map of values to auto-initialize certain properties of the annotation. You can only initialize properties defined on the annotation under the Members section (unless specified otherwise).
         */
        class CustomAnnotation extends Core.Annotations.MarkupAnnotation {
            constructor(type: any, initializer?: any);
            /**
             * Converts an existing annotation class into a custom annotation that can be customized and viewed in other viewers.
             * @param type - The initial element name for this custom annotation.
             * @param annotClass - The annotation class that will be made into a custom annotation instead.
             * @returns A custom annotation class that behaves the same as the input annotation class but is actually a custom annotation.
             */
            static createFromClass(type: string, annotClass: any): any;
            /**
             * The scaling factor that controls the output image quality. The higher the factor, the higher the quality, the higher the memory required. By default, this is set to two.
             */
            static QualityScale: number;
            /**
             * The type of XFDF that will be produced when exported. The only acceptable values are 'custom' or 'stamp'. By default, 'stamp' is used.
             */
            static SerializationType: string;
            /**
             * The amount of additional padding applied to the image for drawing outside the annotation's rectangular bounds.
             */
            static OutputImagePadding: number;
            /**
             * Gets an object that can be used to store primitive, custom data. Data set on this object will be saved to an annotations custom data automatically which gets preserved in the document.
             * <p style="font-weight: bold;">This property cannot be initialized through the initializer.</p>
             */
            SerializedData: any;
            /**
             * An enum with possible serialization types.
             * If custom is used, the custom annotation will be serialized as is. Otherwise, stamp will be automatically assumed and the custom annotation will be serialized as a stamp.
             */
            static SerializationTypes: any;
        }
        /**
         * Represents an ellipse annotation.
         * @param [initializer] - A map of values to auto-initialize certain properties of the annotation. You can only initialize properties defined on the annotation under the Members section (unless specified otherwise).
         */
        class EllipseAnnotation extends Core.Annotations.MarkupAnnotation {
            constructor(initializer?: any);
            /**
             * Gets or sets the border style of an annotation. e.g Solid, Cloudy
             */
            Style: string;
            /**
             * Gets or sets the border dash style of an annotation. e.g '3' or '3,3'
             */
            Dashes: string;
            /**
             * Gets or sets the annotation's precision from its measure dictionary.
             * @example
             * WebViewer(...)
             *   .then(function(instance) {
             *     const { annotationManager, Annotations } = instance.Core;
             *     const measurementAnnotation = annotationManager.getAnnotationsList()[0]
             *     const measurementDisplayFormats = Annotations.Annotation.MeasurementDisplayFormats
             *      measurementAnnotation.DisplayFormat = measurementDisplayFormats.FRACTION
             *   });
             */
            Precision: number;
            /**
             * Gets or sets the annotation's scale from its measure dictionary.
             */
            Scale: any[];
            /**
             * Gets or sets the annotation's system (Metric, Imperial, Typographic).
             * @example
             * WebViewer(...)
             *   .then(function(instance) {
             *     const { annotationManager, Annotations } = instance.Core;
             *     const measurementAnnotation = annotationManager.getAnnotationsList()[0]
             *     const measurementSystems = Annotations.Annotation.MeasurementSystems
             *      measurementAnnotation.System = measurementSystems.METRIC
             */
            System: string;
            /**
             * Gets or sets the annotation's measurement display format.
             * @example
             * WebViewer(...)
             *   .then(function(instance) {
             *     const { annotationManager, Annotations } = instance.Core;
             *     const measurementAnnotation = annotationManager.getAnnotationsList()[0]
             *     const measurementDisplayFormats = Annotations.Annotation.MeasurementDisplayFormats
             *      measurementAnnotation.DisplayFormat = measurementDisplayFormats.FRACTION
             *   });
             */
            DisplayFormat: string;
            /**
             * Gets or sets the annotation's measurement display units.
             * @example
             * WebViewer(...)
             *   .then(function(instance) {
             *     const { annotationManager, Annotations } = instance.Core;
             *     const measurementAnnotation = annotationManager.getAnnotationsList()[0]
             *     const measurementUnits = Annotations.Annotation.MeasurementUnits
             *      measurementAnnotation.DisplayUnits = [measurementUnits.FT, measurementUnits.IN]
             *   });
             */
            DisplayUnits: string[];
        }
        /**
         * Represents a file attachment annotation.
         * @param [initializer] - A map of values to auto-initialize certain properties of the annotation. You can only initialize properties defined on the annotation under the Members section (unless specified otherwise).
         */
        class FileAttachmentAnnotation extends Core.Annotations.MarkupAnnotation {
            constructor(initializer?: any);
            /**
             * @returns Object containing important attributes of the file
             */
            getFileMetadata(): Core.Annotations.FileAttachmentAnnotation.FileMetadata;
            /**
             * Gets the binary contents of the file attachment
             * @returns - A blob containing the binary contents of the file attachment
             */
            getFileData(): Promise<Blob>;
            /**
             * Sets the binary contents of the file attachment
             * @param data - An ArrayBuffer containing the binary contents of the fileattachment
             * @param mimeType - The mimeType of the data, for example application/pdf
             * @param filename - The filename for the attachment. This will be the name when the attachment is downloaded.
             * @returns A promise that resolves when the file data is set.
             */
            setFileData(data: ArrayBuffer, mimeType: string, filename: string): Promise<void>;
            /**
             * <p>Gets or sets the icon for this fileattachment.</p>
             * <p>Possible default icon types:</p>
             * <ul>
             *  <li>Graph</li>
             *  <li>PushPin</li>
             *  <li>Paperclip</li>
             *  <li>Tag</li>
             * </ul>
             */
            Icon: string;
        }
        namespace FileAttachmentAnnotation {
            /**
             */
            type FileMetadata = {
                /**
                 * The mimetype attribute of the file
                 */
                mimeType: string;
                /**
                 * The name of the file to be saved
                 */
                filename: string;
            };
        }
        /**
         * Represents a FreeHand annotation.
         * @param [initializer] - A map of values to auto-initialize certain properties of the annotation. You can only initialize properties defined on the annotation under the Members section (unless specified otherwise).
         */
        class FreeHandAnnotation extends Core.Annotations.IPathAnnotation {
            constructor(initializer?: any);
            /**
             * The leftmost point of the annotation.
             * <p style="font-weight: bold;">This property cannot be initialized through the initializer.</p>
             */
            LeftMost: number;
            /**
             * The rightmost point of the annotation.
             * <p style="font-weight: bold;">This property cannot be initialized through the initializer.</p>
             */
            RightMost: number;
            /**
             * The topmost point of the annotation.
             * <p style="font-weight: bold;">This property cannot be initialized through the initializer.</p>
             */
            TopMost: number;
            /**
             * The bottommost point of the annotation.
             * <p style="font-weight: bold;">This property cannot be initialized through the initializer.</p>
             */
            BottomMost: number;
            /**
             * Whether to simplify the path points or not.
             */
            shouldSimplifyPath: boolean;
            /**
             * Sets a path in the path array.
             * @param path - An array of Annotation.Point objects.
             * @param pathIndex - The index of the path, defaults to 0
             */
            setPath(path: Core.Math.Point[], pathIndex: number): void;
            /**
             * empty the paths in the path array.
             */
            emptyPaths(): void;
            /**
             * Gets the array of paths for this annotation.
             * @returns an array of paths, where a path is an array of Annotation.Points
             */
            getPaths(): any[];
            /**
             * Gets or sets the intent of the freehand.
             */
            Intent: string;
        }
        /**
         * Represents a free text annotation.
         * @property EXPORT_CALCULATED_FONT_SIZE - Whether to export calculated font size for auto-sized fonts. Default: true
         * @property Intent - An enumeration of possible intents for FreeText Annotations
         * @property Intent.FreeText - Should treat as regular freetext
         * @property Intent.FreeTextCallout - Should treat as callout
         * @param [intent] - The intended usage type of this freetext annotation. Could either be freetext or callout.
         * @param [initializer] - A map of values to auto-initialize certain properties of the annotation. You can only initialize properties defined on the annotation under the Members section (unless specified otherwise).
         */
        class FreeTextAnnotation extends Core.Annotations.IPathAnnotation {
            constructor(intent?: string, initializer?: any);
            /**
             * Object that contains all the flags to customize the auto-sizing behavior
             * @property shrinkWidth - Whether to shrink the width of the annotation if the size of its contents are smaller in width than the annotation
             * @property shrinkHeight - Whether to shrink the height of the annotation if the size of its contents are smaller in height than the annotation
             * @property expandWidth - Whether to expand the width of the annotation if the size of the contents are larger in width than the annotation
             * @property expandHeight - Whether to expand the height of the annotation if the size of the contents are larger in height than the annotation
             */
            autoSizeProperties: {
                /**
                 * Whether to shrink the width of the annotation if the size of its contents are smaller in width than the annotation
                 */
                shrinkWidth: boolean;
                /**
                 * Whether to shrink the height of the annotation if the size of its contents are smaller in height than the annotation
                 */
                shrinkHeight: boolean;
                /**
                 * Whether to expand the width of the annotation if the size of the contents are larger in width than the annotation
                 */
                expandWidth: boolean;
                /**
                 * Whether to expand the height of the annotation if the size of the contents are larger in height than the annotation
                 */
                expandHeight: boolean;
            };
            /**
             * An enum with possible auto-size types.
             * @property NONE - Freetext stays at fixed size
             * @property AUTO - Autosize to content
             * @property FIXED_WIDTH - Width cannot be changed
             * @property FIXED_HEIGHT - Height cannot be changed
             */
            static AutoSizeTypes: {
                /**
                 * Freetext stays at fixed size
                 */
                NONE: string;
                /**
                 * Autosize to content
                 */
                AUTO: string;
                /**
                 * Width cannot be changed
                 */
                FIXED_WIDTH: string;
                /**
                 * Height cannot be changed
                 */
                FIXED_HEIGHT: string;
            };
            /**
             * An enum with possible freetext intents.
             * @property FreeText - Treat as regular freetext
             * @property FreeTextCallout - Treat as callout
             */
            static Intent: {
                /**
                 * Treat as regular freetext
                 */
                FreeText: string;
                /**
                 * Treat as callout
                 */
                FreeTextCallout: string;
            };
            /**
             * Gets the intent of the FreeText annotation e.g. FreeTextCallout
             * @returns The intent of the annotation
             */
            getIntent(): string;
            /**
             * Sets the intent of the FreeText annotation
             * @param intent - The new intent for the annotation
             */
            setIntent(intent: string): void;
            /**
             * Sets the start style of the line. Only applicable for callout annotations.
             * @param startStyle - The starting style
             */
            setStartStyle(startStyle: string): void;
            /**
             * Gets the start style of the line. Only applicable for callout annotations
             * @returns The start style
             */
            getStartStyle(): string;
            /**
             * Resize the annotation's text box to fit its contents
             * @example
             * const freetextAnnot = annotManager.getAnnotationsList()[0];
             * const doc = docViewer.getDocument();
             * const pageNumber = 1;
             * const pageInfo = doc.getPageInfo(pageNumber);
             * const pageMatrix = doc.getPageMatrix(pageNumber);
             * const pageRotation = doc.getPageRotation(pageNumber);
             * freetextAnnot.fitText(pageInfo, pageMatrix, pageRotation);
             * annotManager.drawAnnotationsFromList([freetextAnnot]);
             * @param pageInfo - An object representing the page info. Contains the properties "width" and "height".
             * @param pageMatrix - The transformation matrix for the page that the annotation is on.
             * @param pageRotation - The internal degrees of rotation of the current page.
             */
            fitText(pageInfo: Core.Document.PageInfo, pageMatrix: any, pageRotation: number): void;
            /**
             * Sets the rectangle difference of the annotation bounding rect and the text rect
             * @param rect - The new rectangle difference
             */
            setPadding(rect: Core.Math.Rect): void;
            /**
             * Get the rectangle difference of the annotation bounding rect and the text rect
             * @returns the rectangle difference
             */
            getPadding(): Core.Math.Rect;
            /**
             * @returns Returns a boolean which indicates if the bounding box of the freetext will be resized automatically when its contents are being edited
             */
            isAutoSized(): boolean;
            /**
             * Sets how the freetext annotation auto-sizes to content.
             * @param type - Use one of the types provided by {@link Core.Annotations.FreeTextAnnotation.AutoSizeTypes AutoSizeTypes}
             */
            setAutoSizeType(type: string): void;
            /**
             * Set FreeText as a date type annotation with the specified format. A viewer can use this information to allow easier updating of the text to represent a date, for example by using a date picker.
             * @param format - Set Annotation Date format
             */
            setDateFormat(format: string): void;
            /**
             * Gets the date format of the FreeText (if any)
             * @returns Returns Date format
             */
            getDateFormat(): string;
            /**
             * Gets the auto-sizing method if any.
             * @returns The type of autosizing method
             */
            getAutoSizeType(): string;
            /**
             * @returns Returns the rich text editor instance associated with the annotation
             */
            getEditor(): Core.Annotations.FreeTextAnnotation.RichTextEditor;
            /**
             * Disables the Enter key for the instance of RichTextEditor
             */
            disableEnterKeypress(): void;
            /**
             * Enables the Enter key for the instance of RichTextEditor
             */
            enableEnterKeypress(): void;
            /**
             * The color of the text in the annotation.
             */
            TextColor: Core.Annotations.Color;
            /**
             * The font size to use for the annotation's text, specified like a CSS font size.
             */
            FontSize: string;
            /**
             * The font to use for the annotation's text.
             */
            Font: string;
            /**
             * The horizontal alignment of the annotation's text (left, right, center)
             */
            TextAlign: string;
            /**
             * The vertical alignment of the annotation's text (top, bottom, center) default: top
             */
            TextVerticalAlign: string;
            /**
             * Whether to export calculated font size for auto-sized fonts. Default: true
            */
            EXPORT_CALCULATED_FONT_SIZE: boolean;
        }
        /**
         * An abstract annotation class for aiding the creation of path-based annotations.
         * Classes extending IPathAnnotation or implements the interface can be used by the PathTools.
         * Note: this class makes no assumptions on serialization
         * @param [initializer] - A map of values to auto-initialize certain properties of the annotation. You can only initialize properties defined on the annotation under the Members section (unless specified otherwise).
         */
        class IPathAnnotation extends Core.Annotations.MarkupAnnotation {
            constructor(initializer?: any);
            /**
             * Adds a point to the path
             * @param x - The x coordinate of the point
             * @param y - The y coordinate of the point
             */
            addPathPoint(x: number, y: number): void;
            /**
             * Sets the path point at a specific index
             * @param index - The index in the path array to set
             * @param x - The x coordinate of the point
             * @param y - The y coordinate of the point
             */
            setPathPoint(index: number, x: number, y: number): void;
            /**
             * Gets the point in the path at the specified index
             * @param index - The index in the path array
             * @returns The path point as an object with x and y properties
             */
            getPathPoint(index: number): any;
            /**
             * Removes the last point from the path
             * @returns The path point as an object with x and y properties
             */
            popPath(): any;
            /**
             * Gets the path array
             * @returns The array of path points
             */
            getPath(): Core.Math.Point[];
            /**
             * Rotate the annotation by angle and origin point to rotate around.
             * @param angle - The angle in radians
             * @param rotationPoint - The rotation point to do the rotation around. The default is the center point of the annotation
             */
            rotate(angle: number, rotationPoint: Core.Math.Point): void;
        }
        /**
         * Represents a line annotation.
         * @param [initializer] - A map of values to auto-initialize certain properties of the annotation. You can only initialize properties defined on the annotation under the Members section (unless specified otherwise).
         */
        class LineAnnotation extends Core.Annotations.MarkupAnnotation {
            constructor(initializer?: any);
            /**
             * Sets the starting point of the line
             * @param x - The x coordinate of the point
             * @param y - The y coordinate of the point
             */
            setStartPoint(x: number, y: number): void;
            /**
             * Gets the starting point of the line
             * @returns The start point
             */
            getStartPoint(): Core.Math.Point;
            /**
             * Sets the ending point of the line
             * @param x - The x coordinate of the point
             * @param y - The y coordinate of the point
             */
            setEndPoint(x: number, y: number): void;
            /**
             * Gets the ending point of the line
             * @returns The end point
             */
            getEndPoint(): Core.Math.Point;
            /**
             * Sets the start style of the line
             * @param startStyle - The starting style
             */
            setStartStyle(startStyle: Core.Annotations.LineEndType): void;
            /**
             * Gets the start style of the line
             * @returns The start style
             */
            getStartStyle(): Core.Annotations.LineEndType;
            /**
             * Sets the ending style of the line
             * @param endingStyle - The ending style
             */
            setEndStyle(endingStyle: Core.Annotations.LineEndType): void;
            /**
             * Gets the end style of the line
             * @returns The end style
             */
            getEndStyle(): Core.Annotations.LineEndType;
            /**
             * Returns the leader points of this line
             * @returns An object containing the two leader points
             */
            getLeaderPoints(): Core.Annotations.LineAnnotation.LeaderPoints;
            /**
             * Returns the leader point located at the center (midpoint) of measurement line.
             * @returns Center (midpoint) of measurement line.
             */
            getCenterLeaderPoint(): Core.Math.Point;
            /**
             * Returns the leader point located at the given caption snap position, in viewer coordinates.
             * @param [captionSnapPosition] - Indicates which side of measurement line to calculate leader point.
             * Default value is whatever is returned from {@link Core.Annotations.LineAnnotation#getCaptionSnapPosition}.
             * @returns Position of leader control handle, in viewer coordinates.
             */
            getLeaderLineControlHandlePoint(captionSnapPosition?: Core.Annotations.LineAnnotation.CaptionSnapPositions): Core.Math.Point;
            /**
             * Returns the angle in radians from the X axis from start point to end point
             * @returns The angle in radians
             */
            getAngle(): number;
            /**
             * Returns the length of the line in points
             * @returns The length in points
             */
            getLineLength(): number;
            /**
             * Sets the length of a line
             * @param length - The length in points
             */
            setLineLength(length: number): void;
            /**
             * Snaps the caption of a measurement line to given position.
             * @param position - Use one of the positions provided by {@link Core.Annotations.LineAnnotation.CaptionSnapPositions CaptionSnapPositions}
             */
            setCaptionSnapPosition(position: Core.Annotations.LineAnnotation.CaptionSnapPositions): void;
            /**
             * Get the current caption snap position.
             * @returns Returns the current caption snap position.
             */
            getCaptionSnapPosition(): Core.Annotations.LineAnnotation.CaptionSnapPositions;
            /**
             * Gets or sets the start point of the line.
             */
            Start: Core.Math.Point;
            /**
             * Gets or sets the end point of the line.
             */
            End: Core.Math.Point;
            /**
             * Gets or sets the border style of an annotation. e.g Solid, Cloudy
             */
            Style: string;
            /**
             * Gets or sets the border dash style of an annotation. e.g '3' or '3,3'
             */
            Dashes: string;
            /**
             * Gets or sets the annotation's precision from its measure dictionary.
             * @example
             * WebViewer(...)
             *   .then(function(instance) {
             *     const { annotationManager, Annotations } = instance.Core;
             *     const measurementAnnotation = annotationManager.getAnnotationsList()[0]
             *     const measurementDisplayFormats = Annotations.Annotation.MeasurementDisplayFormats
             *      measurementAnnotation.DisplayFormat = measurementDisplayFormats.FRACTION
             *   });
             */
            Precision: number;
            /**
             * Gets or sets the annotation's scale from its measure dictionary.
             */
            Scale: any[];
            /**
             * Gets or sets the annotation's system (Metric, Imperial, Typographic).
             * @example
             * WebViewer(...)
             *   .then(function(instance) {
             *     const { annotationManager, Annotations } = instance.Core;
             *     const measurementAnnotation = annotationManager.getAnnotationsList()[0]
             *     const measurementSystems = Annotations.Annotation.MeasurementSystems
             *      measurementAnnotation.System = measurementSystems.METRIC
             */
            System: string;
            /**
             * Gets or sets the annotation's measurement display format.
             * @example
             * WebViewer(...)
             *   .then(function(instance) {
             *     const { annotationManager, Annotations } = instance.Core;
             *     const measurementAnnotation = annotationManager.getAnnotationsList()[0]
             *     const measurementDisplayFormats = Annotations.Annotation.MeasurementDisplayFormats
             *      measurementAnnotation.DisplayFormat = measurementDisplayFormats.FRACTION
             *   });
             */
            DisplayFormat: string;
            /**
             * Gets or sets the annotation's measurement display units.
             * @example
             * WebViewer(...)
             *   .then(function(instance) {
             *     const { annotationManager, Annotations } = instance.Core;
             *     const measurementAnnotation = annotationManager.getAnnotationsList()[0]
             *     const measurementUnits = Annotations.Annotation.MeasurementUnits
             *      measurementAnnotation.DisplayUnits = [measurementUnits.FT, measurementUnits.IN]
             *   });
             */
            DisplayUnits: string[];
        }
        namespace LineAnnotation {
            /**
             * the point in viewer coordinates
             */
            type LeaderPoints = {
                /**
                 * the start point
                 */
                Start: Core.Math.Point;
                /**
                 * the end point
                 */
                End: Core.Math.Point;
            };
            enum CaptionSnapPositions {
                START,
                CENTER,
                END
            }
        }
        /**
         * Creates a new instance of MarkupAnnotation.
         * @param [initializer] - A map of values to auto-initialize certain properties of the annotation. You can only initialize properties defined on the annotation under the Members section (unless specified otherwise).
         */
        class MarkupAnnotation extends Core.Annotations.Annotation {
            constructor(initializer?: any);
            /**
             * Gets or sets whether the annotation is hoverable or not. If it is hoverable then the IsHovering property will be true on the annotation when it is currently being hovered.
             */
            IsHoverable: boolean;
            /**
             * Sets the annotation's styles for stroke, fill and opacity on the canvas context
             * @param ctx - A canvas context
             * @param pageMatrix - The transformation matrix for the page that the annotation is on
             */
            setStyles(ctx: CanvasRenderingContext2D, pageMatrix: any): void;
            /**
             * Gets or sets the color of the annotation's interior.
             */
            FillColor: Core.Annotations.Color;
            /**
             * Gets or sets the color of the annotation's stroke.
             */
            StrokeColor: Core.Annotations.Color;
            /**
             * Gets or sets the width of the annotation's stroke outline.
             */
            StrokeThickness: number;
            /**
             * Gets or sets the opacity of the annotation.
             */
            Opacity: number;
            /**
             * Gets or sets the date the annotation was created.
             */
            DateCreated: Date;
            /**
             * Gets or sets the viewer state (zoom, rotation, etc) that is associated with the annotation. This state can then be restored in the viewer at a later time.
             */
            ViewState: string;
        }
        /**
         * Represents a 3D annotation.
         * @param options - A map of properties to set on the 3D annotation
         */
        class Model3D extends Core.Annotations.HTMLAnnotation {
            constructor(options: any);
            /**
             * Sets the 3D data for the annotation.
             * @param base64 - the 3d data in base64 format
             */
            set3DData(base64: string): void;
            /**
             * @returns The 3D model data as a base64 string
             */
            get3DData(): string;
            /**
             * @returns Whether the 3D object is interactive (can rotate and zoom)
             */
            getInteractive(): boolean;
            /**
             * Sets whether the 3D object is interactive
             * @param interactive - boolean to denote if the model is interactive
             */
            setInteractive(interactive: boolean): void;
            /**
             * Enable camera controls for the 3D model
             * Once enabled the 3D model is able to be rotated and zoomed but not able to be dragged around the page
             * Note that if the model is not interactive then camera controls cannot be enabled.
             */
            enableCameraControls(): void;
            /**
             * Disable camera controls for the 3D model
             * Once disabled the 3D model is moveable on the page but able to be rotated or zoomed
             */
            disableCameraControls(): void;
        }
        /**
         * Represents a Polyline annotation.
         * @param [initializer] - A map of values to auto-initialize certain properties of the annotation. You can only initialize properties defined on the annotation under the Members section (unless specified otherwise).
         */
        class PolylineAnnotation extends Core.Annotations.IPathAnnotation {
            constructor(initializer?: any);
            /**
             * Sets the start style of the polyline
             * @param startStyle - The starting style
             */
            setStartStyle(startStyle: Core.Annotations.LineEndType): void;
            /**
             * Gets the start style of the polyline
             * @returns The start style
             */
            getStartStyle(): Core.Annotations.LineEndType;
            /**
             * Sets the ending style of the polyline
             * @param endingStyle - The ending style
             */
            setEndStyle(endingStyle: Core.Annotations.LineEndType): void;
            /**
             * Gets the end style of the polyline
             * @returns The end style
             */
            getEndStyle(): Core.Annotations.LineEndType;
            /**
             * Gets or sets the border style of an annotation. e.g Solid, Cloudy
             */
            Style: string;
            /**
             * Gets or sets the border dash style of an annotation. e.g '3' or '3,3'
             */
            Dashes: string;
            /**
             * Gets or sets the annotation's precision from its measure dictionary.
             * @example
             * WebViewer(...)
             *   .then(function(instance) {
             *     const { annotationManager, Annotations } = instance.Core;
             *     const measurementAnnotation = annotationManager.getAnnotationsList()[0]
             *     const measurementDisplayFormats = Annotations.Annotation.MeasurementDisplayFormats
             *      measurementAnnotation.DisplayFormat = measurementDisplayFormats.FRACTION
             *   });
             */
            Precision: number;
            /**
             * Gets or sets the annotation's scale from its measure dictionary.
             */
            Scale: any[];
            /**
             * Gets or sets the annotation's system (Metric, Imperial, Typographic).
             * @example
             * WebViewer(...)
             *   .then(function(instance) {
             *     const { annotationManager, Annotations } = instance.Core;
             *     const measurementAnnotation = annotationManager.getAnnotationsList()[0]
             *     const measurementSystems = Annotations.Annotation.MeasurementSystems
             *      measurementAnnotation.System = measurementSystems.METRIC
             */
            System: string;
            /**
             * Gets or sets the annotation's measurement display format.
             * @example
             * WebViewer(...)
             *   .then(function(instance) {
             *     const { annotationManager, Annotations } = instance.Core;
             *     const measurementAnnotation = annotationManager.getAnnotationsList()[0]
             *     const measurementDisplayFormats = Annotations.Annotation.MeasurementDisplayFormats
             *      measurementAnnotation.DisplayFormat = measurementDisplayFormats.FRACTION
             *   });
             */
            DisplayFormat: string;
            /**
             * Gets or sets the annotation's measurement display units.
             * @example
             * WebViewer(...)
             *   .then(function(instance) {
             *     const { annotationManager, Annotations } = instance.Core;
             *     const measurementAnnotation = annotationManager.getAnnotationsList()[0]
             *     const measurementUnits = Annotations.Annotation.MeasurementUnits
             *      measurementAnnotation.DisplayUnits = [measurementUnits.FT, measurementUnits.IN]
             *   });
             */
            DisplayUnits: string[];
        }
        /**
         * Represents a Polygon annotation.
         * @param [initializer] - A map of values to auto-initialize certain properties of the annotation. You can only initialize properties defined on the annotation under the Members section (unless specified otherwise).
         */
        class PolygonAnnotation extends Core.Annotations.IPathAnnotation {
            constructor(initializer?: any);
            /**
             * Gets whether the polygon annotation is rectangular and behaves the same as a rectangle annotation.
             * @returns true if the polygon annotation is rectangular and behaves the same as a rectangle annotation.
             */
            isRectangularPolygon(): boolean;
            /**
             * Returns the Border style for the annotation, applicable values are solid (default) and cloudy.
             * @returns value the string value, either solid or cloudy
             */
            getBorderStyle(): string;
            /**
             * Set the Border style for the annotation, applicable values are solid (default) and cloudy.
             * @param value - the string value, either solid or cloudy
             */
            setBorderStyle(value: string): void;
            /**
             * Returns the intensity of the cloudy style border effect.
             * @returns value the intensity of the cloud style effect
             */
            getCloudIntensity(): number;
            /**
             * Sets the intensity of cloudy style effect. 0 for no effect.
             * @param value - the intensity value
             */
            setCloudIntensity(value: number): void;
            /**
             * Describes intensity of cloudy style effect. 0 for no effect.
             */
            Intensity: number;
            /**
             * Describes the intent of the annotation, e.g PolygonCloud, PolygonDimension
             */
            Intent: string;
            /**
             * Describes how the arcs of a PolygonCloud annotation will be drawn, can be one of either RANDOM_ARCS or EQUAL_ARCS
             */
            ArcDrawMode: string;
            /**
             * Gets or sets the border style of an annotation. e.g Solid, Cloudy
             */
            Style: string;
            /**
             * Gets or sets the border dash style of an annotation. e.g '3' or '3,3'
             */
            Dashes: string;
            /**
             * Gets or sets the annotation's precision from its measure dictionary.
             * @example
             * WebViewer(...)
             *   .then(function(instance) {
             *     const { annotationManager, Annotations } = instance.Core;
             *     const measurementAnnotation = annotationManager.getAnnotationsList()[0]
             *     const measurementDisplayFormats = Annotations.Annotation.MeasurementDisplayFormats
             *      measurementAnnotation.DisplayFormat = measurementDisplayFormats.FRACTION
             *   });
             */
            Precision: number;
            /**
             * Gets or sets the annotation's scale from its measure dictionary.
             */
            Scale: any[];
            /**
             * Gets or sets the annotation's system (Metric, Imperial, Typographic).
             * @example
             * WebViewer(...)
             *   .then(function(instance) {
             *     const { annotationManager, Annotations } = instance.Core;
             *     const measurementAnnotation = annotationManager.getAnnotationsList()[0]
             *     const measurementSystems = Annotations.Annotation.MeasurementSystems
             *      measurementAnnotation.System = measurementSystems.METRIC
             */
            System: string;
            /**
             * Gets or sets the annotation's measurement display format.
             * @example
             * WebViewer(...)
             *   .then(function(instance) {
             *     const { annotationManager, Annotations } = instance.Core;
             *     const measurementAnnotation = annotationManager.getAnnotationsList()[0]
             *     const measurementDisplayFormats = Annotations.Annotation.MeasurementDisplayFormats
             *      measurementAnnotation.DisplayFormat = measurementDisplayFormats.FRACTION
             *   });
             */
            DisplayFormat: string;
            /**
             * Gets or sets the annotation's measurement display units.
             * @example
             * WebViewer(...)
             *   .then(function(instance) {
             *     const { annotationManager, Annotations } = instance.Core;
             *     const measurementAnnotation = annotationManager.getAnnotationsList()[0]
             *     const measurementUnits = Annotations.Annotation.MeasurementUnits
             *      measurementAnnotation.DisplayUnits = [measurementUnits.FT, measurementUnits.IN]
             *   });
             */
            DisplayUnits: string[];
        }
        /**
         * Creates a new instance of PopupAnnotation.
         * @param [initializer] - A map of values to auto-initialize certain properties of the annotation. You can only initialize properties defined on the annotation under the Members section (unless specified otherwise).
         */
        class PopupAnnotation extends Core.Annotations.Annotation {
            constructor(initializer?: any);
            /**
             * open the popup annotation
             */
            open(): void;
            /**
             * close the popup annotation
             */
            close(): void;
        }
        /**
         * Represents a rectangle annotation.
         * @param [initializer] - A map of values to auto-initialize certain properties of the annotation. You can only initialize properties defined on the annotation under the Members section (unless specified otherwise).
         */
        class RectangleAnnotation extends Core.Annotations.MarkupAnnotation {
            constructor(initializer?: any);
            /**
             * Returns the Border style for the annotation, applicable values are solid (default) and cloudy.
             * @returns value the string value, either solid or cloudy
             */
            getBorderStyle(): string;
            /**
             * Set the Border style for the annotation, applicable values are solid (default) and cloudy.
             * @param value - the string value, either solid or cloudy
             */
            setBorderStyle(value: string): void;
            /**
             * Returns the intensity of the cloudy style border effect.
             * @returns value the intensity of the cloud style effect
             */
            getCloudIntensity(): number;
            /**
             * Sets the intensity of cloudy style effect. 0 for no effect.
             * @param value - the intensity value
             */
            setCloudIntensity(value: number): void;
            /**
             * Describes intensity of cloudy style effect. 0 for no effect.
             */
            Intensity: number;
        }
        /**
         * Represents a redaction annotation.
         * @param [options] - an initialization object that can contain the following optional parameters. You can only initialize properties defined on the annotation under the Members section (unless specified otherwise).
         * @param [options.StrokeColor] - The color of the redaction border before it been applied. This default to red
         * @param [options.FillColor] - The color of the redaction after it been applied. This default to black
         * @param [options.TextColor] - The color of the redaction overlay text. The default is red
         * @param options.PageNumber - The page number of the redaction
         * @param [options.Rect] - The bounding rectangle of the redaction
         * @param [options.Quads] - The individual rectangles of a redaction. For text redactions there might be muliple of these
         * @param [options.OverlayText] - Text to show after redaction has been applied
         * @param [options.TextAlign] - the justification of the redaction text (can be 'left', 'center', or 'right')
         */
        class RedactionAnnotation extends Core.Annotations.TextMarkupAnnotation {
            constructor(options?: {
                StrokeColor?: Core.Annotations.Color;
                FillColor?: Core.Annotations.Color;
                TextColor?: Core.Annotations.Color;
                PageNumber: number;
                Rect?: Core.Math.Rect;
                Quads?: Core.Math.Quad[];
                OverlayText?: string;
                TextAlign?: string;
            });
            /**
             * The font to use for the redaction text.
             */
            Font: string;
        }
        /**
         * Represents a sound annotation.
         * @param [initializer] - A map of values to auto-initialize certain properties of the annotation. You can only initialize properties defined on the annotation under the Members section (unless specified otherwise).
         */
        class SoundAnnotation extends Core.Annotations.MarkupAnnotation {
            constructor(initializer?: any);
            /**
             * Returns true if annotation has compressed and encoded audio data attached to it. False otherwise.
             * @returns Determines if annotation has compressed and encoded audio data attached to it.
             */
            hasAudioData(): boolean;
            /**
             * Decodes, decompresses, converts audio data into a blob, and stores on annotation.
             * @returns On success, audio blob is stored on annotation.
             */
            prepareAudioBlob(): Promise<void>;
            /**
             * <p>Gets or sets the icon for this sound annotation.</p>
             * <p>Possible default icon types:</p>
             * <ul>
             *  <li>SoundWave</li>
             * </ul>
             */
            Icon: string;
        }
        /**
         * Represents a stamp annotation.
         * @param [initializer] - A map of values to auto-initialize certain properties of the annotation. You can only initialize properties defined on the annotation under the Members section (unless specified otherwise).
         */
        class StampAnnotation extends Core.Annotations.MarkupAnnotation {
            constructor(initializer?: any);
            /**
             * Asynchronously returns the image data URL
             * @returns a promise that resolves to the image data URL
             */
            getImageData(): Promise<string>;
            /**
             * Asynchronously sets the image URL of the stamp annotation
             * @param imageDataUrl - the data URL of the image
             * @param [keepAsSVG = false] - If image is an SVG data URL then by default it will be converted to PNG to work with other PDF viewers. If this parameter is true then it will not be converted and remain as SVG but will not be visible in other PDF viewers after downloading.
             * @returns a promise that resolves when the image data URL has been set
             */
            setImageData(imageDataUrl: string, keepAsSVG?: boolean): Promise<void>;
            /**
             * Sets the stamp's text
             */
            setStampText(text: string): void;
            /**
             * Gets the stamp's text
             */
            getStampText(): string;
            /**
             * If this instance of a Stamp Annotation was originally created with a URL
             * in WebViewer, the corresponding URL will be returned
             * @returns The URL where this stamp originated from
             */
            getOriginalURL(): string;
            /**
             * Gets or sets the type of the stamp.
             */
            Icon: string;
            /**
             * Represents the different stamp icon names that you can use in the useStamp function of RubberStampCreateTool .
             * @property APPROVED - Stamp shows Approved
             * @property AS_IS - Stamp shows AsIs
             * @property COMPLETED - Stamp shows Compeleted
             * @property CONFIDENTIAL - Stamp shows Confidential
             * @property DEPARTMENTAL - Stamp shows Departmental
             * @property DRAFT - Stamp shows Draft
             * @property EXPERIMENTAL - Stamp shows Experimental
             * @property EXPIRED - Stamp shows Expired
             * @property FINAL - Stamp shows Final
             * @property FOR_COMMENT - Stamp shows For Comment
             * @property FOR_PUBLIC_RELEASE - Stamp shows For Public Release
             * @property INFORMATION_ONLY - Stamp shows Information Only
             * @property NOT_APPROVED - Stamp shows Not Approved
             * @property NOT_FOR_PUBLIC_RELEASE - Stamp shows Not For Public Release
             * @property PRELIMINARY_RESULTS - Stamp shows Preliminary Results
             * @property SB_REJECTED - Stamp shows Rejected
             * @property SH_ACCEPTED - Stamp shows Accepted
             * @property SH_INITIAL_HERE - Stamp shows Initial Here
             * @property SH_SIGN_HERE - Stamp shows Sign Here
             * @property SH_WITNESS - Stamp shows Witness
             * @property SOLD - Stamp shows Sold
             * @property TOP_SECRET - Stamp shows Top Secret
             * @property VOID - Stamp shows Void
             */
            static IconNames: {
                /**
                 * Stamp shows Approved
                 */
                APPROVED: string;
                /**
                 * Stamp shows AsIs
                 */
                AS_IS: string;
                /**
                 * Stamp shows Compeleted
                 */
                COMPLETED: string;
                /**
                 * Stamp shows Confidential
                 */
                CONFIDENTIAL: string;
                /**
                 * Stamp shows Departmental
                 */
                DEPARTMENTAL: string;
                /**
                 * Stamp shows Draft
                 */
                DRAFT: string;
                /**
                 * Stamp shows Experimental
                 */
                EXPERIMENTAL: string;
                /**
                 * Stamp shows Expired
                 */
                EXPIRED: string;
                /**
                 * Stamp shows Final
                 */
                FINAL: string;
                /**
                 * Stamp shows For Comment
                 */
                FOR_COMMENT: string;
                /**
                 * Stamp shows For Public Release
                 */
                FOR_PUBLIC_RELEASE: string;
                /**
                 * Stamp shows Information Only
                 */
                INFORMATION_ONLY: string;
                /**
                 * Stamp shows Not Approved
                 */
                NOT_APPROVED: string;
                /**
                 * Stamp shows Not For Public Release
                 */
                NOT_FOR_PUBLIC_RELEASE: string;
                /**
                 * Stamp shows Preliminary Results
                 */
                PRELIMINARY_RESULTS: string;
                /**
                 * Stamp shows Rejected
                 */
                SB_REJECTED: string;
                /**
                 * Stamp shows Accepted
                 */
                SH_ACCEPTED: string;
                /**
                 * Stamp shows Initial Here
                 */
                SH_INITIAL_HERE: string;
                /**
                 * Stamp shows Sign Here
                 */
                SH_SIGN_HERE: string;
                /**
                 * Stamp shows Witness
                 */
                SH_WITNESS: string;
                /**
                 * Stamp shows Sold
                 */
                SOLD: string;
                /**
                 * Stamp shows Top Secret
                 */
                TOP_SECRET: string;
                /**
                 * Stamp shows Void
                 */
                VOID: string;
            };
        }
        /**
         * Represents a sticky annotation.
         * @param [initializer] - A map of values to auto-initialize certain properties of the annotation. You can only initialize properties defined on the annotation under the Members section (unless specified otherwise).
         */
        class StickyAnnotation extends Core.Annotations.MarkupAnnotation {
            constructor(initializer?: any);
            /**
             * The name of the icon to use for this sticky annotation.
             * <p>Possible default icon types:</p>
             * <ul>
             *  <li>Comment</li>
             *  <li>Insert</li>
             *  <li>Circle</li>
             *  <li>NewParagraph</li>
             *  <li>Help</li>
             *  <li>Key</li>
             *  <li>Check</li>
             *  <li>Checkmark</li>
             *  <li>Cross</li>
             *  <li>CrossHairs</li>
             *  <li>Paragraph</li>
             *  <li>RightArrow</li>
             *  <li>RightPointer</li>
             *  <li>Star</li>
             *  <li>UpArrow</li>
             *  <li>UpLeftArrow</li>
             * </ul>
             */
            Icon: string;
            /**
             * An enum with possible icon names.
             */
            static IconNames: {
                INSERT: string;
                CIRCLE: string;
                NEW_PARAGRAPH: string;
                HELP: string;
                KEY: string;
                CHECK: string;
                CHECKMARK: string;
                CROSS: string;
                CROSS_HAIRS: string;
                PARAGRAPH: string;
                RIGHT_ARROW: string;
                RIGHT_POINTER: string;
                STAR: string;
                UP_ARROW: string;
                UP_LEFT_ARROW: string;
                COMMENT: string;
            };
            /**
             * The size of the width and height of all sticky annotations
             */
            static SIZE: number;
            /**
             * Gets the state of the annotation.
             * @returns the state of the annotation.
             */
            getState(): string;
            /**
             * Sets the state of the annotation.
             * @param state - the state of the annotation.
             */
            setState(state: string): void;
            /**
             * Gets the statemodel of the annotation.
             * @returns the statemodel of the annotation.
             */
            getStateModel(): string;
            /**
             * Sets the statemodel of the annotation.
             * @param stateModel - the statemodel of the annotation.
             */
            setStateModel(stateModel: string): void;
            /**
             * Gets or sets the state of the annotation. Annotations may have an author-specific state associated with them. State include: Accepted, Rejected, Cancelled, Completed, None.
             */
            State: string;
            /**
             * Gets or sets the statemodel of the annotation. Statemodel has two statemodels: Marked, Review. Under Marked, state expands to: Marked, Unmarked.
             */
            StateModel: string;
        }
        /**
         * Represents a text highlight annotation.
         * @property opacityCap - The maximum opacity of all highlight annotations.
         * @param [initializer] - A map of values to auto-initialize certain properties of the annotation. You can only initialize properties defined on the annotation under the Members section (unless specified otherwise).
         */
        class TextHighlightAnnotation extends Core.Annotations.TextMarkupAnnotation {
            constructor(initializer?: any);
            /**
             * The maximum opacity of all highlight annotations.
            */
            opacityCap: number;
        }
        /**
         * Creates a new instance of TextMarkupAnnotation.
         * @param [initializer] - A map of values to auto-initialize certain properties of the annotation. You can only initialize properties defined on the annotation under the Members section (unless specified otherwise).
         */
        class TextMarkupAnnotation extends Core.Annotations.MarkupAnnotation {
            constructor(initializer?: any);
            /**
             * Gets of sets the text quads of the annotation.
             */
            Quads: Core.Math.Quad[];
        }
        /**
         * Represents a redaction annotation.
         * @param [initializer] - A map of values to auto-initialize certain properties of the annotation. You can only initialize properties defined on the annotation under the Members section (unless specified otherwise).
         */
        class TextRedactAnnotation extends Core.Annotations.TextMarkupAnnotation {
            constructor(initializer?: any);
        }
        /**
         * Create a new TextSquigglyAnnotation.
         * @param [initializer] - A map of values to auto-initialize certain properties of the annotation. You can only initialize properties defined on the annotation under the Members section (unless specified otherwise).
         */
        class TextSquigglyAnnotation extends Core.Annotations.TextMarkupAnnotation {
            constructor(initializer?: any);
        }
        /**
         * Creates a new TextStrikeout annotation.
         * @param [initializer] - A map of values to auto-initialize certain properties of the annotation. You can only initialize properties defined on the annotation under the Members section (unless specified otherwise).
         */
        class TextStrikeoutAnnotation extends Core.Annotations.TextMarkupAnnotation {
            constructor(initializer?: any);
        }
        /**
         * Represents a text underline annotation.
         * @param [initializer] - A map of values to auto-initialize certain properties of the annotation. You can only initialize properties defined on the annotation under the Members section (unless specified otherwise).
         */
        class TextUnderlineAnnotation extends Core.Annotations.TextMarkupAnnotation {
            constructor(initializer?: any);
        }
        /**
         * Creates a new instance of ButtonWidgetAnnotation.
         * @param field - The field to associate with the widget
         * @param options - A map of properties to set on the widget
         */
        class ButtonWidgetAnnotation extends Core.Annotations.WidgetAnnotation {
            constructor(field: Core.Annotations.Forms.Field, options: any);
        }
        /**
         * A Checkbutton widget annotation.
         * @param field - The field to associate with the widget
         * @param options - A map of properties to set on the widget
         */
        class CheckButtonWidgetAnnotation extends Core.Annotations.ButtonWidgetAnnotation {
            constructor(field: Core.Annotations.Forms.Field, options: any);
        }
        /**
         * Creates a new instance of ChoiceWidgetAnnotation.
         * @property FORCE_SELECT - Whether to force all choice widgets to be html select elements
         * @param field - The field to associate with the widget
         * @param options - A map of properties to set on the widget
         */
        class ChoiceWidgetAnnotation extends Core.Annotations.WidgetAnnotation {
            constructor(field: Annotations.Forms.Field, options: any);
            /**
             * Whether to force all choice widgets to be html select elements
            */
            FORCE_SELECT: boolean;
        }
        /**
         * Represents a Date Picker Widget annotation. These include boxes and fields where date can be entered.
         * @param field - The field to associate with the widget
         * @param options - A map of properties to set on the widget
         */
        class DatePickerWidgetAnnotation extends Core.Annotations.TextWidgetAnnotation {
            constructor(field: Core.Annotations.Forms.Field, options: any);
            /**
             * Static property of DatePickerWidgetAnnotation for customizing DatePicker object
             * DatePickerWidgetAnnotation.datePickerOptions
             * Some of the options include:
             * @example
             * {
             *  "isRTL": true, // reverse the calendar for right-to-left languages
             *  "firstDay": 1, //first day of the week (0: Sunday, 1: Monday, etc)
             *  "i18n": {
             *    "previousMonth" : "Previous Month",
             *    "nextMonth"     : "Next Month",
             *    "months"        : ["January","February","March","April","May","June","July","August","September","October","November","December"],
             *    "monthsShort"   : ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],
             *    "weekdays"      : ["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],
             *    "weekdaysShort" : ["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],
             *    "invalidDateTime": "Custom error message",
             *  }, // language defaults for month and weekday names
             *  "yearRange": [1900, 2015], // number of years either side (e.g. 10) or array of upper/lower range
             * }
             */
            static datePickerOptions: any;
            /**
             * Returns DatePicker UI instance
             * @returns calendar UI instance
             */
            getDatePicker(): any;
            /**
             * Refreshes DatePicker UI and update config from DatePickerWidgetAnnotation.datePickerOptions
             */
            refreshDatePicker(): void;
        }
        /**
         * Creates a new instance of ListWidgetAnnotation.
         * @param field - The field to associate with the widget
         * @param options - A map of properties to set on the widget
         */
        class ListWidgetAnnotation extends Core.Annotations.WidgetAnnotation {
            constructor(field: Core.Annotations.Forms.Field, options: any);
        }
        /**
         * A Radio button widget.
         * @param field - The field to associate with the widget
         * @param options - A map of properties to set on the widget
         */
        class RadioButtonWidgetAnnotation extends Core.Annotations.ButtonWidgetAnnotation {
            constructor(field: Core.Annotations.Forms.Field, options: any);
        }
        /**
         * Creates a new instance of SignatureWidgetAnnotation.
         * @property createSignHereElement - A function that creates the sign here element in the annotation. This can be replaced with your own function.
         * @property annot - The annotation associated with the signature widget.
         * @param field - The field to associate with the widget
         * @param options - A map of properties to set on the widget
         */
        class SignatureWidgetAnnotation extends Core.Annotations.WidgetAnnotation {
            constructor(field: Core.Annotations.Forms.Field, options: any);
            /**
             * Returns a promise that will be resolved with a boolean value indicating whether the signature widget is signed digitally by default
             */
            isSignedDigitally(): Promise<any>;
            /**
             * Get the annotation associated with the signature widget.
             * @returns the annotation associated with the signature widget.
             */
            getAssociatedSignatureAnnotation(): Core.Annotations.FreeHandAnnotation | Core.Annotations.StampAnnotation;
            /**
             * Get the annotation associated with the signature widget.
             * @param associatedSignatureAnnotation - a freehand annotation or a stamp annotation
             */
            setAssociatedSignatureAnnotation(associatedSignatureAnnotation: Core.Annotations.FreeHandAnnotation | Core.Annotations.StampAnnotation): void;
            /**
             * Get or set the annotation associated with the signature widget.
             */
            annot: Core.Annotations.FreeHandAnnotation | Core.Annotations.StampAnnotation;
            /**
             * A function that creates the sign here element in the annotation. This can be replaced with your own function.
            */
            createSignHereElement: (...params: any[]) => any;
        }
        /**
         * Represents a Text Widget annotation. These include boxes and fields where text can be entered.
         * @param field - The field to associate with the widget
         * @param options - A map of properties to set on the widget
         */
        class TextWidgetAnnotation extends Core.Annotations.WidgetAnnotation {
            constructor(field: Core.Annotations.Forms.Field, options: any);
        }
        /**
         * Creates a new instance of WidgetAnnotation.
         * @property fieldName - Gets the name of field associated with the widget annotation.
         * @property value - Gets or sets the value of the widget annotation (defaults to the field value)
         * @property defaultValue - Gets or sets the default value of the field associated with the widget annotation.
         * @property fieldFlags - Gets the flags object of the field associated with this widget.
         * @property flags - Gets the flags object on this widget.
         * @property font - Gets or sets the font object associated with this widget (defaults to the field's font if not set).
         * @property appearances - Gets the appearances of this field (currently keys of an object).
         * @property appearance - Gets or sets the widgets current appearance name.
         * @property captions - Gets the map of this widget's captions. (Normal is used for the face of PushButtonAnnotations)
         * @property getCustomStyles - A function that receives the widget object and should return any CSS styles that you want to override
         * @property getContainerCustomStyles - A function that receives the widget object and should return any CSS styles that you want to override for its parent container
         */
        class WidgetAnnotation extends Core.Annotations.HTMLAnnotation {
            /**
             * Set all properties on this widget.
             * @param options - The set of parameters to set
             */
            set(options: Core.Annotations.WidgetAnnotation): void;
            /**
             * Get the widget's value.
             * @returns The widget's value (potentially formatted).
             */
            getValue(): string | number;
            /**
             * Set and format the widget's value.
             * @param value - The new value to set
             */
            setValue(value: string | number): void;
            /**
             * Gets the widget's associated field.
             * @returns The widget's field.
             */
            getField(): Core.Annotations.Forms.Field;
            /**
             * Sets the widget's associated field.
             * @param field - The new field to associate with the widget.
             */
            setField(field: Core.Annotations.Forms.Field): void;
            /**
             * Gets the name of field associated with the widget annotation.
            */
            fieldName: string;
            /**
             * Gets or sets the value of the widget annotation (defaults to the field value)
            */
            value: string | number;
            /**
             * Gets or sets the default value of the field associated with the widget annotation.
            */
            defaultValue: string | number;
            /**
             * Gets the flags object of the field associated with this widget.
            */
            fieldFlags: Core.Annotations.WidgetFlags;
            /**
             * Gets the flags object on this widget.
            */
            flags: Core.Annotations.WidgetFlags;
            /**
             * Gets or sets the font object associated with this widget (defaults to the field's font if not set).
            */
            font: Core.Annotations.Font;
            /**
             * Gets the appearances of this field (currently keys of an object).
            */
            appearances: any;
            /**
             * Gets or sets the widgets current appearance name.
            */
            appearance: string;
            /**
             * Gets the map of this widget's captions. (Normal is used for the face of PushButtonAnnotations)
            */
            captions: any;
            /**
             * A function that receives the widget object and should return any CSS styles that you want to override
            */
            getCustomStyles: (...params: any[]) => any;
            /**
             * A function that receives the widget object and should return any CSS styles that you want to override for its parent container
            */
            getContainerCustomStyles: (...params: any[]) => any;
        }
        /**
         * An object that describes flags on a Widget, or other PDF objects.
         * @param options - Define the set of supported flags.
         */
        class WidgetFlags {
            constructor(options: any);
            /**
             * If set, the user may not change the value of the field.
             */
            static READ_ONLY: string;
            /**
             * If set, the field shall have a value at the time it is exported by a submit-form action.
             */
            static REQUIRED: string;
            /**
             * If set, the field shall not be exported by a submit-form action.
             */
            static NO_EXPORT: string;
            /**
             * If set, the field may contain multiple lines of text.
             */
            static MULTILINE: string;
            /**
             * If set, the field is intended for entering a secure password that should not be echoed visibly to the screen.
             */
            static PASSWORD: string;
            /**
             * If set, the field shall be automatically divided into as many equally spaced positions as the value of the max length.
             */
            static COMB: string;
            /**
             * (Radio buttons only) If set, exactly one radio button shall be selected at all times.
             */
            static NO_TOGGLE_TO_OFF: string;
            /**
             * If set, the field is a set of radio buttons; if clear, the field is a checkbox.
             */
            static RADIO: string;
            /**
             * If set, the field is a pushbutton that does not retain a permanent value.
             */
            static PUSH_BUTTON: string;
            /**
             * If set, the field is a combo box; if clear, the field is a list box.
             */
            static COMBO: string;
            /**
             * If set, the combo box shall include an editable text box as well as a drop-down list; if clear, it shall include only a drop-down list.
             */
            static EDIT: string;
            /**
             * If set, the field shall not scroll (horizontally for single-line fields, vertically for multiple-line fields) to accommodate more text than fits within its annotation rectangle.
             */
            static DO_NOT_SCROLL: string;
            /**
             * If set, a group of radio buttons within a radio button field that use the same value for the on state will turn on and off in unison.
             */
            static RADIOS_IN_UNISON: string;
            /**
             * If set, the text entered in the field represents the pathname of a file whose contents shall be submitted as the value of the field.
             */
            static FILE_SELECT: string;
            /**
             * If set, text entered in the field shall not be spell-checked.
             */
            static DO_NOT_SPELL_CHECK: string;
            /**
             * If set, the value of this field shall be a rich text string.
             */
            static RICH_TEXT: string;
            /**
             * If set, the fields option items shall be sorted alphabetically.
             */
            static SORT: string;
            /**
             * If set, more than one of the fields option items may be selected simultaneously; if clear, at most one item shall be selected.
             */
            static MULTI_SELECT: string;
            /**
             * If set, the new value shall be committed as soon as a selection is made.
             */
            static COMMIT_ON_SEL_CHANGE: string;
            /**
             * Determine if the given flag is set.
             * @param flag - The name of the flag to check
             * @returns Whether the flag is set
             */
            get(flag: string): boolean;
            /**
             * Set flags to true or false.
             * If options is an array of strings, set the flags with those names to true.
             * If options is a number or array of numbers, set the flags from the corresponding numbers to true. (deprecated, relies on a limited interpretation of numbers as bitfields)
             * If options is a string, set that flag to shouldSet.
             * @param options - One of the possible input types to determine which flags to set
             * @param [shouldSet] - If options is a string, whether to set or unset the flag
             */
            set(options: string[] | number[] | string | number, shouldSet?: boolean): void;
        }
        /**
         * The namespace for utility functions for XFDF serialization and deserialization.
         */
        class XFDFUtils {
            /**
             * Convert a JavaScript date object into a string date that can be used in XFDF
             * @param date - Date object.
             * @returns Date in string format.
             */
            static toXMLDate(date: Date): string;
            /**
             * Serializes the point into a string suitable for an XFDF file.
             * @param point - Point with an x and y coordinate.
             * @param pageMatrix - Object representing the transformation matrix for the page.
             * @param coordinateSeparator - Separator used for coordinates. Defaults to ',' if not defined.
             * @returns Point in string format.
             */
            static serializePoint(point: Core.Math.Point, pageMatrix: Core.Math.Matrix, coordinateSeparator: string): string;
            /**
             * Deserializes a point string into a point object.
             * @param pointString - Point in string format.
             * @param pageMatrix - Object representing the transformation matrix for the page.
             * @param coordinateSeparator - Separator used for coordinates. Defaults to ',' if not defined.
             * @returns New Point with with an x and y coordinate.
             */
            static deserializePoint(pointString: string, pageMatrix: Core.Math.Matrix, coordinateSeparator: string): Core.Math.Point;
            /**
             * Seriarlize the array of points into a string suitable for an XFDF file.
             * @param pointArray - Array of points.
             * @param pageMatrix - Object representing the transformation matrix for the page.
             * @param coordinateSeparator - Separator used for coordinates. Defaults to ',' if not defined.
             * @param pointSeparator - Separator used for points. Defaults to ';' if not defined.
             * @returns Stringified array of points.
             */
            static serializePointArray(pointArray: Core.Math.Point[], pageMatrix: Core.Math.Matrix, coordinateSeparator: string, pointSeparator: string): string;
            /**
             * Deserializes a list of points in string format into a point array.
             * @param pointArrayText - Array of points in string (delimited by pointSeparator).
             * @param pageMatrix - Object representing the transformation matrix for the page.
             * @param coordinateSeparator - Separator used for coordinates. Defaults to ',' if not defined.
             * @param pointSeparator - Separator used for points. Defaults to ';' if not defined.
             * @returns Array of Points.
             */
            static deserializePointArray(pointArrayText: string, pageMatrix: Core.Math.Matrix, coordinateSeparator: string, pointSeparator: string): Core.Math.Point[];
            /**
             * Serializes a rect object into a string suitable for an XFDF file.
             * @param rect - Rect with the x and y coordinates.
             * @param pageMatrix - Object representing the transformation matrix for the page.
             * @param separator - Separator used for coordinates. Defaults to ',' if not defined.
             * @returns Rect in string format.
             */
            static serializeRect(rect: Core.Math.Rect, pageMatrix: Core.Math.Matrix, separator: string): string;
            /**
             * Deserializes a rect string into a rect object.
             * @param rectString - Rect in string format. Default value '0,0,0,0'.
             * @param pageMatrix - Object representing the transformation matrix for the page.
             * @param separator - Separator used for coordinates. Defaults to ',' if not defined.
             * @returns New Rect with the x and y coordinates.
             */
            static deserializeRect(rectString: string, pageMatrix: Core.Math.Matrix, separator: string): Core.Math.Rect;
            /**
             * Serializes a fringe rect object into a string suitable for an XFDF file.
             * @param rect - Rect with the x and y coordinates.
             * @param pageMatrix - Object representing the transformation matrix for the page.
             * @param separator - Separator used for coordinates. Defaults to ',' if not defined.
             * @returns Rect in string format.
             */
            static serializeFringeRect(rect: Core.Math.Rect, pageMatrix: Core.Math.Matrix, separator: string): string;
            /**
             * Deserializes a fringe rect string into a rect object.
             * @param rectString - Rect in string format.
             * @param pageMatrix - Object representing the transformation matrix for the page.
             * @param separator - Separator used for coordinates. Defaults to ',' if not defined.
             * @returns New Rect with the x and y coordinates.
             */
            static deserializeFringeRect(rectString: string, pageMatrix: Core.Math.Matrix, separator: string): Core.Math.Rect;
            /**
             * Parses a default appearance string from an XFDF file and returns an object representing the appearance.
             * @example
             * const data = "0 0 0 rg /Helvetica 40 Tf";
             * const response = Annotations.XFDFUtils.parseDefaultAppearance(data);
             *
             * Output:
             * {
             *    color: "#000000",
             *    font: {
             *       name: "Arial",
             *       rawName: "Helvetica",
             *       size: "40pt",
             *    },
             *    str: "0 0 0 rg /Helvetica 40 Tf",
             * }
             * @param da - Appearance information in string format.
             * @returns Appearance information in object format.
             */
            static parseDefaultAppearance(da: string): any;
            /**
             * Serializes the measure object into a measure XML element.
             * @param measureDictionary - Object with measure information.
             * @param measureDictionary.area - Area
             * @param measureDictionary.axis - Axis
             * @param measureDictionary.distance - Distance
             * @param measureDictionary.scale - Scale
             * @returns Return element.
             */
            static serializeMeasure(measureDictionary: {
                area: any[];
                axis: any[];
                distance: any[];
                scale: string;
            }): Element;
            /**
             * Deserializes the measure XML element into a measure object.
             * @param measureDictionary - Measure element.
             * @returns Object with measure information.
             */
            static deserializeMeasure(measureDictionary: Element): any;
        }
        /**
         * Callback that gets passed to serializeHandler in {@link Core.Annotations.setCustomSerializeHandler setCustomSerializeHandler}.
         * The signature is similar to {@link Core.Annotations.Annotation#serialize serialize} except with an additional options parameter.
         * @param element - An xml element representing the annotation
         * @param pageMatrix - The page matrix used to convert PDF coordinates to viewer coordinates
         * @param options - Additional options and parameters
         * @param options.annotation - The annotation being serialized
         * @param options.originalSerialize - The original serialize function of this annotation
         */
        type CustomAnnotationSerializeHandler = (element: Element, pageMatrix: any, options: {
            annotation: Core.Annotations.Annotation;
            originalSerialize: (...params: any[]) => any;
        }) => Element;
        /**
         * Callback that gets passed to deserializeHandler in {@link Core.Annotations.setCustomDeserializeHandler setCustomDeserializeHandler}.
         * The signature is similar to {@link Core.Annotations.Annotation#deserialize deserialize} except with an additional options parameter.
         * @param element - An xml element representing the annotation
         * @param pageMatrix - The page matrix used to convert PDF coordinates to viewer coordinates
         * @param options - Additional options and parameters
         * @param options.annotation - The annotation being deserialized
         * @param options.originalDeserialize - The original deserialize function of this annotation
         */
        type CustomAnnotationDeserializeHandler = (element: Element, pageMatrix: any, options: {
            annotation: Core.Annotations.Annotation;
            originalDeserialize: (...params: any[]) => any;
        }) => void;
        /**
         * Changes how an annotation type is serialized within WebViewer. Note that custom attributes will not be persisted in the downloaded PDF and are only useful if you're saving the XFDF separately from the PDF.
         * If you are looking to save your custom property/attribute, please consider using {@link Core.Annotations.Annotation#setCustomData setCustomData} which will be persisted.
         * @example
         * Annotations.setCustomSerializeHandler(Annotations.RectangleAnnotation, function(element, pageMatrix, options) {
         *   const annot = options.annotation;
         *   options.originalSerialize(element, pageMatrix)
         *   if (annot.Width > 100) {
         *     element.setAttribute('myAttr', 1);
         *   }
         *   return element;
         * });
         * @param annotationClass - The class (constructor) of the annotation
         * @param serializeHandler - A handler function that will serialize the annotation
         */
        function setCustomSerializeHandler(annotationClass: Core.Annotations.Annotation, serializeHandler: Core.Annotations.CustomAnnotationSerializeHandler): void;
        /**
         * Callback that gets passed to createInnerElementHandler in {@link Core.Annotations.setCustomCreateInnerElementHandler setCustomCreateInnerElementHandler}.
         * The signature is similar to {@link Core.Annotations.HTMLAnnotation#createInnerElement createInnerElement} except with an additional options parameter.
         * @param options - Additional options and parameters
         * @param options.annotation - The annotation being selected to change innerElement
         * @param options.originalCreateInnerElement - The original createInnerElement function of this annotation
         */
        type CustomCreateInnerElementHandler = (annotationManager: Core.AnnotationManager, options: {
            annotation: Core.Annotations.WidgetAnnotation;
            originalCreateInnerElement: (...params: any[]) => any;
        }) => HTMLElement;
        /**
         * Change createInnerElement to customize the HTML element.
         * @example
         * Annotations.setCustomCreateInnerElementHandler(Annotations.CheckButtonWidgetAnnotation, function(annotationManager, {annotation, originalCreateInnerElement}){
         *  const button = this;
         *   const el = originalCreateInnerElement();
         *   el.addEventListener('click', () => {
         *     console.log('check button clicked', annotation.fieldName);
         *   });
         *   return el;
         * })
         * @param annotationClass - The annotation being selected to change innerElement
         */
        function setCustomCreateInnerElementHandler(annotationClass: Core.Annotations.WidgetAnnotation, createInnerElementHandler: Core.Annotations.CustomCreateInnerElementHandler): void;
        /**
         * Changes how an annotation type is deserialized within WebViewer.
         * If your custom property/attribute is stored in the CustomData, please consider using {@link Core.Annotations.Annotation#getCustomData getCustomData} instead.
         * @example
         * Annotations.setCustomDeserializeHandler(Annotations.RectangleAnnotation, function(element, pageMatrix, options) {
         *   const annot = options.annotation;
         *   options.originalDeserialize(element, pageMatrix)
         *   if (annot.Width > 100) {
         *     annot.myProperty = element.getAttribute('myAttr');
         *   }
         * });
         * @param annotationClass - The class (constructor) of the annotation
         * @param deserializeHandler - A handler function that will deserialize the annotation
         */
        function setCustomDeserializeHandler(annotationClass: Core.Annotations.Annotation, deserializeHandler: Core.Annotations.CustomAnnotationDeserializeHandler): void;
        /**
         * Callback that gets passed to createSignHereElementHandler in {@link Core.Annotations.setCustomCreateSignHereElementHandler setCustomCreateSignHereElementHandler}.
         * The signature is similar to {@link Core.Annotations.SignatureWidgetAnnotation#createSignHereElement createSignHereElement} except with an additional options parameter.
         * @param signatureTool - The tool that create signature annotation widget
         * @param options - Additional options and parameters
         * @param options.annotation - The annotation being selected to create sign here element
         * @param options.originalCreateSignHereElement - The original createSignHereElement function of this annotation
         */
        type CustomCreateSignHereElementHandler = (signatureTool: Core.Tools.SignatureCreateTool, options: {
            annotation: Core.Annotations.SignatureWidgetAnnotation;
            originalCreateSignHereElement: (...params: any[]) => any;
        }) => HTMLElement;
        /**
         * Change createSignHereElement to customize the HTML element.
         * @example
         * Annotations.setCustomCreateSignHereElementHandler(function(tool, {annotation, originalCreateSignHereElement}) {
         *   const signHereElement = originalCreateSignHereElement(tool);
         *   signHereElement.style.background = "red";
         *   return signHereElement;
         * })
         */
        function setCustomCreateSignHereElementHandler(createSignHereElementHandler: Core.Annotations.CustomCreateSignHereElementHandler): void;
        /**
         * Restores the serialize function back to the default.
         * @param annotationClass - The class (constructor) of the annotation
         */
        function restoreSerialize(annotationClass: Core.Annotations.Annotation): void;
        /**
         * Restores the deserialize function back to the default.
         * @param annotationClass - The class (constructor) of the annotation
         */
        function restoreDeserialize(annotationClass: Core.Annotations.Annotation): void;
        /**
         * Callback that gets passed to controlHandleDrawHandler in {@link Core.Annotations.setCustomControlHandleDrawHandler setCustomControlHandleDrawHandler}.
         * The signature is similar to {@link Core.Annotations.ControlHandle#draw draw} except with an additional options parameter.
         * @param ctx - The annotation canvas context
         * @param annotation - The annotation to modify
         * @param selectionBox - The selection rect
         * @param zoom - The current zoom level of the document
         * @param options - Additional options and parameters
         * @param options.controlHandle - The selected controlHandle instance
         * @param options.originalDraw - The original draw function of the controlHandle
         */
        type CustomControlHandleDrawHandler = (ctx: CanvasRenderingContext2D, annotation: Core.Annotations.Annotation, selectionBox: Core.Math.Rect, zoom: number, options: {
            controlHandle: Core.Annotations.ControlHandle;
            originalDraw: (...params: any[]) => any;
        }) => void;
        /**
         * Change ControlHandle's draw to customize appearance on the provided canvas context.
         * @example
         * Annotations.setCustomControlHandleDrawHandler(Core.Annotations.ControlHandle, function(ctx, annotation, selectionBox, zoom, {controlHandle, originalDraw}) {
         *   if(controlHandle instanceof Core.Annotations.BoxControlHandle) {
         *     const dim = this.getDimensions(annotation, selectionBox, zoom);
         *     ctx.fillStyle = '#FFFFFF';
         *     ctx.beginPath();
         *     ctx.moveTo(dim.x1 + (dim.getWidth() / 2), dim.y1);
         *     ctx.lineTo(dim.x1 + dim.getWidth(), dim.y1 + dim.getHeight());
         *     ctx.lineTo(dim.x1, dim.y1 + dim.getHeight());
         *     ctx.closePath();
         *     ctx.stroke();
         *     ctx.fill();
         *   } else {
         *      originalDraw(ctx, annotation, selectionBox, zoom);
         *   }
         * })
         * @param controlHandle - The class (constructor) of the controlHandle
         * @param controlHandleDrawHandler - The handler will customize the appearance of the controlHandle
         */
        function setCustomControlHandleDrawHandler(controlHandle: Core.Annotations.ControlHandle, controlHandleDrawHandler: CustomControlHandleDrawHandler): void;
        /**
         * Annotation draw function signature.
         * @param ctx - A canvas context
         * @param pageMatrix - The transformation matrix for the page that the annotation is on
         * @param [rotation] - Certain annotations, such as sticky notes, get rotation as a third parameter. Default: undefined
         */
        type AnnotationDrawFunction = (ctx: CanvasRenderingContext2D, pageMatrix: any, rotation?: number) => void;
        /**
         * Callback that gets passed to drawHandler in {@link Core.Annotations.setCustomDrawHandler setCustomDrawHandler}.
         * The signature is similar to {@link Core.Annotations.Annotation#draw draw} except with an additional options parameter.
         * @param ctx - A canvas context
         * @param pageMatrix - The transformation matrix for the page that the annotation is on
         * @param rotation - Certain annotations, such as sticky notes, get rotation as a third parameter. Default: undefined
         * @param options - Additional options and parameters
         * @param options.annotation - The annotation being drawn
         * @param options.originalDraw - The original draw function of this annotation
         */
        type CustomAnnotationDrawHandler = (ctx: CanvasRenderingContext2D, pageMatrix: any, rotation: number, options: {
            annotation: Core.Annotations.Annotation;
            originalDraw: Core.Annotations.AnnotationDrawFunction;
        }) => void;
        namespace SelectionModel {
            /**
             * Callback that gets passed to drawSelectionOutlineHandler in {@link Core.Annotations.SelectionModel.setCustomHandlers setCustomHandlers}.
             * @param ctx - A canvas context
             * @param annotation - The annotation being selected
             * @param zoom - the current zoom level of the document
             * @param pageMatrix - The transformation matrix for the page that the annotation is on
             * @param options - Additional options and parameters
             * @param options.selectionModel - The selection model of the annotation which is currently selected.
             * @param options.originalDrawSelectionOutline - The original draw function of this selection model
             */
            type CustomDrawSelectionOutlineHandler = (ctx: CanvasRenderingContext2D, annotation: Core.Annotations.Annotation, zoom: number, pageMatrix: any, options: {
                selectionModel: Core.Annotations.SelectionModel;
                originalDrawSelectionOutline: (...params: any[]) => any;
            }) => void;
            /**
             * Callback that gets passed to getDimensionsHandler in {@link Core.Annotations.SelectionModel.setCustomHandlers setCustomHandlers}.
             * @param annotation - The annotation being selected
             * @param zoom - the current zoom level of the document
             * @param options - Optional options
             * @param options.selectionModel - The selection model of the annotation which is currently selected.
             * @param options.originalGetDimensions - The original getDimensions function of this selection model
             */
            type CustomGetDimensionsHandler = (annotation: Core.Annotations.Annotation, selectionBox: Core.Math.Rect, zoom: number, options: {
                selectionModel: Core.Annotations.SelectionModel;
                originalGetDimensions: (...params: any[]) => any;
            }) => Core.Math.Rect;
            /**
             * Callback that gets passed to testSelectionHandler in {@link Core.Annotations.SelectionModel.setCustomHandlers setCustomHandlers}.
             * @param x - The x-coordinate of the point to test, in page coordinates
             * @param y - The y-coordinate of the point to test, in page coordinates
             * @param pageMatrix - the page matrix of the page the annotation is on
             * @param zoom - The zoom level of the page the annotation is on
             * @param rotation - The rotation of the page the annotation is on
             * @param options - Optional options
             * @param options.selectionModel - The selection model of the annotation which is currently selected.
             * @param options.originalTestSelection - The original draw function of this selection model
             */
            type CustomTestSelectionHandler = (x: number, y: number, pageMatrix: any, zoom: number, rotation: Core.PageRotation, options: {
                selectionModel: Core.Annotations.SelectionModel;
                originalTestSelection: (...params: any[]) => any;
            }) => boolean;
            /**
             * A collection of functions that overwrite the original functions in SelectionModel
             */
            type SelectionModelCustomHandlers = {
                /**
                 * Changes how a selection model is drawn within WebViewer.
                 */
                drawSelectionOutline?: Core.Annotations.SelectionModel.CustomDrawSelectionOutlineHandler;
                /**
                 * Gets the rect of the selection bounding box.
                 */
                getDimensions?: Core.Annotations.SelectionModel.CustomGetDimensionsHandler;
                /**
                 * Determines if the provided point is a hit on the selected annotation handle.
                 */
                testSelection?: Core.Annotations.SelectionModel.CustomTestSelectionHandler;
            };
        }
        /**
         * Changes how an annotation type is drawn within WebViewer.
         * By default, this will also generate an appearance for the annotation when the document is downloaded, so it will appear the same in other viewers. Please note that changes to the annotation may cause the appearance to be discarded, reverting it back to normal.
         * <br/>
         * Please note that NoZoom annotations do render slightly differently from standard annotations. Nonetheless, please draw at the annotation coordinates.
         * The appearance set by {@link Core.Annotations.Annotation#addCustomAppearance addCustomAppearance} will take priority.
         * @example
         * Annotations.setCustomDrawHandler(Annotations.RectangleAnnotation, function(ctx, pageMatrix, rotation, options) {
         *   options.originalDraw(ctx, pageMatrix); // Draw original annotation
         *   const annot = options.annotation;
         *
         *   // Draw annotation ID overtop the rectangle
         *   ctx.fillStyle = '#FF0000';
         *   ctx.strokeStyle = '#000000';
         *   const fontSize = 12;
         *   ctx.fillText(annot.Id, annot.X, annot.Y + fontSize);   // Draw at annotation location
         *   ctx.strokeText(annot.Id, annot.X, annot.Y + fontSize);
         * });
         * @param annotationClass - The class (constructor) of the annotation
         * @param drawHandler - A handler function that will draw the annotation
         * @param [options] - Optional options
         * @param [options.generateAppearance] - Whether to generate a custom appearance. Defaults to true
         * @param [options.canvasMultiplier] - The quality value of the generated custom appearance. The higher the value, the more memory is required. By default, this will use the canvas multiplier value set in WebViewer
         */
        function setCustomDrawHandler(annotationClass: Core.Annotations.Annotation, drawHandler: Core.Annotations.CustomAnnotationDrawHandler, options?: {
            generateAppearance?: boolean;
            canvasMultiplier?: number;
        }): void;
        /**
         * Restores the draw function back to the default.
         * @param annotationClass - The class (constructor) of the annotation
         */
        function restoreDraw(annotationClass: Core.Annotations.Annotation): void;
        /**
         * A wrapper helper for drawing to HTML canvases.
         * @param canvas - The canvas or canvas context to draw to
         */
        class CanvasHelper {
            constructor(canvas: HTMLCanvasElement | CanvasRenderingContext2D);
            /**
             * Clears the canvas.
             * @returns The current instance
             */
            clear(): CanvasHelper;
            /**
             * Draws the text to a location on the canvas.
             * @param text - The text to be drawn
             * @param x - The x-coordinate
             * @param y - The y-coordinate
             * @param [drawingParameters] - Additional drawing parameters. Values are acceptable HTML canvas values
             * @param [drawingParameters.fillColor] - Fill color
             * @param [drawingParameters.borderColor] - Border or stroke color
             * @param [drawingParameters.borderStyle] - Either 'solid' or 'dash'. Default: solid
             * @param [drawingParameters.borderWidth] - The border width
             * @param [drawingParameters.dashes] - Array of dash size and spacing ex. [4, 3]. Default: [3]
             * @param [drawingParameters.fontSize] - Size of font. Default: 10
             * @param [drawingParameters.fontSizeUnits] - Font units. Default: pt
             * @param [drawingParameters.fontWeight] - Font boldness. Default: normal
             * @param [drawingParameters.fontStyle] - Font style. Default: normal
             * @param [drawingParameters.fontFamily] - List of font-families. Default: sans-serif
             * @param [drawingParameters.opacity] - Opacity value. Default: 1
             * @param [drawingParameters.transform] - Drawing transformation
             * @param [drawingParameters.isStateful] - Whether to undo canvas context changes after rendering. Default: true
             * @param [drawingParameters.forceFill] - Whether to fill the shape regardless of whether a fill color is passed. This would use the currently set fillStyle on the canvas context. Default: false
             * @param [drawingParameters.forceStroke] - Whether to stroke the shape regardless of whether a stroke color is passed. This would use the currently set strokeStyle on the canvas context. Default: false
             * @returns The current instance
             */
            drawText(text: string, x: number, y: number, drawingParameters?: {
                fillColor?: Core.Annotations.Color;
                borderColor?: Core.Annotations.Color;
                borderStyle?: string;
                borderWidth?: number;
                dashes?: number[];
                fontSize?: number;
                fontSizeUnits?: string;
                fontWeight?: string;
                fontStyle?: string;
                fontFamily?: string;
                opacity?: number;
                transform?: Core.Math.Matrix;
                isStateful?: boolean;
                forceFill?: boolean;
                forceStroke?: boolean;
            }): CanvasHelper;
            /**
             * Draws a line using two points on the canvas.
             * @param start - The start point
             * @param end - The end point
             * @param [drawingParameters] - Additional drawing parameters. Values are acceptable HTML canvas values
             * @param [drawingParameters.color] - The line color
             * @param [drawingParameters.borderStyle] - Either 'solid' or 'dash'. Default: solid
             * @param [drawingParameters.borderWidth] - The border width
             * @param [drawingParameters.dashes] - Array of dash size and spacing ex. [4, 3]. Default: [3]
             * @param [drawingParameters.transform] - Drawing transformation
             * @param [drawingParameters.isStateful] - Whether to undo canvas context changes after rendering. Default: true
             * @param [drawingParameters.forceFill] - Whether to fill the shape regardless of whether a fill color is passed. This would use the currently set fillStyle on the canvas context. Default: false
             * @param [drawingParameters.forceStroke] - Whether to stroke the shape regardless of whether a stroke color is passed. This would use the currently set strokeStyle on the canvas context. Default: false
             * @returns The current instance
             */
            drawLine(start: Core.Math.Point, end: Core.Math.Point, drawingParameters?: {
                color?: Core.Annotations.Color;
                borderStyle?: string;
                borderWidth?: number;
                dashes?: number[];
                transform?: Core.Math.Matrix;
                isStateful?: boolean;
                forceFill?: boolean;
                forceStroke?: boolean;
            }): CanvasHelper;
            /**
             * Draws a line using two points on the canvas.
             * @param sx - The start x-coordinate
             * @param sy - The start y-coordinate
             * @param dx - The end x-coordinate
             * @param dy - The end y-coordinate
             * @param [drawingParameters] - Additional drawing parameters. Values are acceptable HTML canvas values
             * @param [drawingParameters.color] - The line color
             * @param [drawingParameters.borderStyle] - Either 'solid' or 'dash'. Default: solid
             * @param [drawingParameters.borderWidth] - The border width
             * @param [drawingParameters.dashes] - Array of dash size and spacing ex. [4, 3]. Default: [3]
             * @param [drawingParameters.transform] - Drawing transformation
             * @param [drawingParameters.isStateful] - Whether to undo canvas context changes after rendering. Default: true
             * @param [drawingParameters.forceFill] - Whether to fill the shape regardless of whether a fill color is passed. This would use the currently set fillStyle on the canvas context. Default: false
             * @param [drawingParameters.forceStroke] - Whether to stroke the shape regardless of whether a stroke color is passed. This would use the currently set strokeStyle on the canvas context. Default: false
             * @returns The current instance
             */
            drawLineXY(sx: number, sy: number, dx: number, dy: number, drawingParameters?: {
                color?: Core.Annotations.Color;
                borderStyle?: string;
                borderWidth?: number;
                dashes?: number[];
                transform?: Core.Math.Matrix;
                isStateful?: boolean;
                forceFill?: boolean;
                forceStroke?: boolean;
            }): CanvasHelper;
            /**
             * Draws the rectangle to a location on the canvas.
             * @param rect - The rect to be drawn
             * @param [drawingParameters] - Additional drawing parameters. Values are acceptable HTML canvas values
             * @param [drawingParameters.fillColor] - Fill color
             * @param [drawingParameters.borderColor] - Border or stroke color
             * @param [drawingParameters.borderStyle] - Either 'solid' or 'dash'. Default: solid
             * @param [drawingParameters.borderWidth] - The border width
             * @param [drawingParameters.dashes] - Array of dash size and spacing ex. [4, 3]. Default: [3]
             * @param [drawingParameters.opacity] - Opacity value. Default: 1
             * @param [drawingParameters.clipPath] - Whether to clip the path. Default: false
             * @param [drawingParameters.transform] - Drawing transformation
             * @param [drawingParameters.isStateful] - Whether to undo canvas context changes after rendering. Default: true
             * @param [drawingParameters.forceFill] - Whether to fill the shape regardless of whether a fill color is passed. This would use the currently set fillStyle on the canvas context. Default: false
             * @param [drawingParameters.forceStroke] - Whether to stroke the shape regardless of whether a stroke color is passed. This would use the currently set strokeStyle on the canvas context. Default: false
             * @returns The current instance
             */
            drawRectangle(rect: Core.Math.Rect, drawingParameters?: {
                fillColor?: Core.Annotations.Color;
                borderColor?: Core.Annotations.Color;
                borderStyle?: string;
                borderWidth?: number;
                dashes?: number[];
                opacity?: number;
                clipPath?: boolean;
                transform?: Core.Math.Matrix;
                isStateful?: boolean;
                forceFill?: boolean;
                forceStroke?: boolean;
            }): CanvasHelper;
            /**
             * Draws a circle in the provided rectangle on the canvas.
             * @param rect - The rect where the circle will be drawn
             * @param [drawingParameters] - Additional drawing parameters. Values are acceptable HTML canvas values
             * @param [drawingParameters.fillColor] - Fill color
             * @param [drawingParameters.borderColor] - Border or stroke color
             * @param [drawingParameters.borderStyle] - Either 'solid' or 'dash'. Default: solid
             * @param [drawingParameters.borderWidth] - The border width
             * @param [drawingParameters.dashes] - Array of dash size and spacing ex. [4, 3]. Default: [3]
             * @param [drawingParameters.opacity] - Opacity value. Default: 1
             * @param [drawingParameters.clipPath] - Whether to clip the path. Default: false
             * @param [drawingParameters.transform] - Drawing transformation
             * @param [drawingParameters.isStateful] - Whether to undo canvas context changes after rendering. Default: true
             * @param [drawingParameters.forceFill] - Whether to fill the shape regardless of whether a fill color is passed. This would use the currently set fillStyle on the canvas context. Default: false
             * @param [drawingParameters.forceStroke] - Whether to stroke the shape regardless of whether a stroke color is passed. This would use the currently set strokeStyle on the canvas context. Default: false
             * @returns The current instance
             */
            drawCircle(rect: Core.Math.Rect, drawingParameters?: {
                fillColor?: Core.Annotations.Color;
                borderColor?: Core.Annotations.Color;
                borderStyle?: string;
                borderWidth?: number;
                dashes?: number[];
                opacity?: number;
                clipPath?: boolean;
                transform?: Core.Math.Matrix;
                isStateful?: boolean;
                forceFill?: boolean;
                forceStroke?: boolean;
            }): CanvasHelper;
            /**
             * Draws a circle in the provided rectangle on the canvas.
             * @param cx - The x-coordinate of the circles center
             * @param cy - The rect where the circle will be drawn
             * @param radius - The radius of the circle
             * @param [drawingParameters] - Additional drawing parameters. Values are acceptable HTML canvas values
             * @param [drawingParameters.fillColor] - Fill color
             * @param [drawingParameters.borderColor] - Border or stroke color
             * @param [drawingParameters.borderStyle] - Either 'solid' or 'dash'. Default: solid
             * @param [drawingParameters.borderWidth] - The border width
             * @param [drawingParameters.dashes] - Array of dash size and spacing ex. [4, 3]. Default: [3]
             * @param [drawingParameters.opacity] - Opacity value. Default: 1
             * @param [drawingParameters.clipPath] - Whether to clip the path. Default: false
             * @param [drawingParameters.transform] - Drawing transformation
             * @param [drawingParameters.isStateful] - Whether to undo canvas context changes after rendering. Default: true
             * @param [drawingParameters.forceFill] - Whether to fill the shape regardless of whether a fill color is passed. This would use the currently set fillStyle on the canvas context. Default: false
             * @param [drawingParameters.forceStroke] - Whether to stroke the shape regardless of whether a stroke color is passed. This would use the currently set strokeStyle on the canvas context. Default: false
             * @returns The current instance
             */
            drawCircleXY(cx: number, cy: number, radius: number, drawingParameters?: {
                fillColor?: Core.Annotations.Color;
                borderColor?: Core.Annotations.Color;
                borderStyle?: string;
                borderWidth?: number;
                dashes?: number[];
                opacity?: number;
                clipPath?: boolean;
                transform?: Core.Math.Matrix;
                isStateful?: boolean;
                forceFill?: boolean;
                forceStroke?: boolean;
            }): CanvasHelper;
            /**
             * Draws a shape provided by the points on the canvas.
             * @param points - An array of points that represents a shape
             * @param [drawingParameters] - Additional drawing parameters. Values are acceptable HTML canvas values
             * @param [drawingParameters.fillColor] - Fill color
             * @param [drawingParameters.borderColor] - Border or stroke color
             * @param [drawingParameters.borderStyle] - Either 'solid' or 'dash'. Default: solid
             * @param [drawingParameters.borderWidth] - The border width
             * @param [drawingParameters.dashes] - Array of dash size and spacing ex. [4, 3]. Default: [3]
             * @param [drawingParameters.opacity] - Opacity value. Default: 1
             * @param [drawingParameters.closePath] - Whether automatically close the path between the first and last points. Default: true
             * @param [drawingParameters.clipPath] - Whether to clip the path. Default: false
             * @param [drawingParameters.transform] - Drawing transformation
             * @param [drawingParameters.isStateful] - Whether to undo canvas context changes after rendering. Default: true
             * @param [drawingParameters.forceFill] - Whether to fill the shape regardless of whether a fill color is passed. This would use the currently set fillStyle on the canvas context. Default: false
             * @param [drawingParameters.forceStroke] - Whether to stroke the shape regardless of whether a stroke color is passed. This would use the currently set strokeStyle on the canvas context. Default: false
             * @returns The current instance
             */
            drawPolygon(points: Core.Math.Point[], drawingParameters?: {
                fillColor?: Core.Annotations.Color;
                borderColor?: Core.Annotations.Color;
                borderStyle?: string;
                borderWidth?: number;
                dashes?: number[];
                opacity?: number;
                closePath?: boolean;
                clipPath?: boolean;
                transform?: Core.Math.Matrix;
                isStateful?: boolean;
                forceFill?: boolean;
                forceStroke?: boolean;
            }): CanvasHelper;
            /**
             * Draws a cloud shape provided by the points on the canvas.
             * @param annot - The annotation being drawn
             * @param points - An array of points that represents a shape
             * @param [drawingParameters] - Additional drawing parameters. Values are acceptable HTML canvas values
             * @param [drawingParameters.fillColor] - Fill color
             * @param [drawingParameters.borderColor] - Border or stroke color
             * @param [drawingParameters.borderStyle] - Either 'solid' or 'dash'. Default: solid
             * @param [drawingParameters.borderWidth] - The border width
             * @param [drawingParameters.dashes] - Array of dash size and spacing ex. [4, 3]. Default: [3]
             * @param [drawingParameters.opacity] - Opacity value. Default: 1
             * @param [drawingParameters.closePath] - Whether automatically close the path between the first and last points. Default: true
             * @param [drawingParameters.clipPath] - Whether to clip the path. Default: false
             * @param [drawingParameters.transform] - Drawing transformation
             * @param [drawingParameters.isStateful] - Whether to undo canvas context changes after rendering. Default: true
             * @param [drawingParameters.forceFill] - Whether to fill the shape regardless of whether a fill color is passed. This would use the currently set fillStyle on the canvas context. Default: false
             * @param [drawingParameters.forceStroke] - Whether to stroke the shape regardless of whether a stroke color is passed. This would use the currently set strokeStyle on the canvas context. Default: false
             * @returns The current instance
             */
            drawClouds(annot: Core.Annotations.Annotation, points: Core.Math.Point[], drawingParameters?: {
                fillColor?: Core.Annotations.Color;
                borderColor?: Core.Annotations.Color;
                borderStyle?: string;
                borderWidth?: number;
                dashes?: number[];
                opacity?: number;
                closePath?: boolean;
                clipPath?: boolean;
                transform?: Core.Math.Matrix;
                isStateful?: boolean;
                forceFill?: boolean;
                forceStroke?: boolean;
            }): CanvasHelper;
            /**
             * Measures the width of the text given the string and additional information.
             * @param text - The text to be drawn
             * @param [options] - Additional drawing parameters. Values are acceptable HTML canvas values
             * @param [options.fontSize] - Size of font. Default: 10
             * @param [options.fontSizeUnits] - Font units. Default: pt
             * @param [options.fontWeight] - Font boldness. Default: normal
             * @param [options.fontStyle] - Font style. Default: normal
             * @param [options.fontFamily] - List of font-families. Default: sans-serif
             * @returns The measured text info
             */
            measureText(text: string, options?: {
                fontSize?: number;
                fontSizeUnits?: string;
                fontWeight?: string;
                fontStyle?: string;
                fontFamily?: string;
            }): TextMetrics;
        }
        /**
         * The namespace for utility functions for annotation rotation.
         */
        class RotationUtils {
            /**
             * @param pointsArray - An array containing the points to be rotated.
             * @param angle - The angle to rotate the points.
             * @param rotationPoint - The pivot point around which the points in the array will be rotated.
             * @returns An array containing the rotated points.
             */
            getRotatedPointsArray(pointsArray: Core.Math.Point[], angle: number, rotationPoint: Core.Math.Point): Core.Math.Point[];
            /**
             * @param rect - The rect representing the rotated annotation's bounding box.
             * @param angle - The angle that the annotation in rotated.
             * @returns An object with the annotation's unrotated dimensions (X, Y, Width and Height).
             */
            getUnrotatedDimensionsFromRectangularAnnotations(rect: Core.Math.Rect, angle: number): any;
            /**
             * @param unrotatedDimensions - An object with the annotation's unrotated dimensions (X, Y, Width and Height).
             * @param angle - The angle that the annotation in rotated.
             * @param rotationPoint - To pivot point for which the annotation is rotated on.
             * @returns The rect representing the rotated annotation's bounding box.
             */
            getRotatedBoundingBoxRectFromRectangularAnnotations(unrotatedDimensions: any, angle: number, rotationPoint: Core.Math.Point): Core.Math.Rect;
            /**
             * @param angleInDegrees - The angle in degrees.
             * @returns The angle in radians.
             */
            getRotationAngleInRadiansByDegrees(angleInDegrees: number): number;
            /**
             * @param angleInRadians - The angle in radians.
             * @returns The angle in degrees.
             */
            getRotationAngleInDegreesByRadians(angleInRadians: number): number;
            /**
             * @param angleInRadians - The angle in radians.
             * @returns The normalized angle (between 0 and 2*PI) in radians.
             */
            normalizeAngle(angleInRadians: number): number;
            /**
             * Adds the following methods to a class:
             * <ul>
             * <li><b>rotate</b>: Changes the Rotation property of the annotation, Updates the annotation path and updates the bounding box.</li>
             * <li><b>adjustRect</b>: Adjusts the annotation's bounding box.</li>
             * <li><b>serialize / deserialize</b>: Make sure the annotation gets correctly saved into the PDF when downloading the document and that it will load fine.</li>
             * </ul>
             * For this mixin to work properly, the annotation class must implement two methods:
             * <ul>
             * <li><b>setPath</b>: Updates the annotation's path (Array of points)</li>
             * <li><b>getPath</b>: returns the annotation's path (Array of points)</li>
             * <ul>
             */
            PathCustomAnnotationRotationMixin(): void;
            /**
             * Adds the following methods to a class:
             * <ul>
             * <li><b>rotate</b>: Changes the Rotation property of the annotation and updates the bounding box.</li>
             * <li><b>getUnrotatedDimensions</b>: Calculates the correct dimension for drawing.</li>
             * <li><b>getRotatedAnnotationBoundingBoxRect</b>: Calculates the bounding box dimensions.</li>
             * <li><b>serialize / deserialize</b>: Make sure the annotation gets correctly saved into the PDF when downloading the document and that it will load fine.</li>
             * </ul>
             */
            RectangularCustomAnnotationRotationMixin(): void;
        }
        namespace ButtonWidgetAnnotation {
            /**
             * An enum for each checkbox/radioButton caption values
             * When assgin the enum to checkbox/radioButton caption, the UI of the checkbox/radioButton will be changed to the corresponded shape
             */
            enum WidgetButtonCaptions {
                CROSS,
                TICK,
                CIRCLE,
                DIAMAND,
                SQUARE,
                STAR
            }
        }
        namespace FreeTextAnnotation {
            namespace RichTextEditor {
                /**
                 * The available formats of an editor instance
                 */
                type Format = 'color' | 'bold' | 'italic' | 'underline' | 'strike';
                /**
                 * The value of a format.
                 * The value should be a hex color string(e.g. #FF00FF) for the `color` format, and boolean for the rest of formats.
                 */
                type FormatValue = string | boolean;
                /**
                 */
                type QuillEditorOptions = {
                    /**
                     * DOM Element or a CSS selector for a DOM Element, within which the editors UI elements (i.e. tooltips, etc.) should be confined. Currently, it only considers left and right boundaries.
                     */
                    bounds: Element;
                    /**
                     * Shortcut for {@link https://quilljs.com/docs/api/#debug debug}. Note debug is a static method and will affect other instances of Quill editors on the page. Only warning and error messages are enabled by default.
                     */
                    debug: string;
                    /**
                     * [WARNING: this is not fully supported by WebViewer and may result in unexpected behavior] Whitelist of formats to allow in the editor. See {@link https://quilljs.com/docs/formats/ Formats} for a complete list.
                     */
                    formats: any;
                    /**
                     * Collection of modules to include and respective options. See {@link https://quilljs.com/docs/modules/ Modules} for more information.
                     */
                    modules: any;
                    /**
                     * Placeholder text to show when editor is empty.
                     */
                    placeholder: string;
                    /**
                     * Whether to instantiate the editor in read-only mode.
                     */
                    readOnly: boolean;
                    /**
                     * DOM Element or a CSS selector for a DOM Element, specifying which container has the scrollbars (i.e. overflow-y: auto), if is has been changed from the default ql-editor with custom CSS. Necessary to fix scroll jumping bugs when Quill is set to auto grow its height, and another ancestor container is responsible from the scrolling.
                     */
                    scrollingContainer: Element;
                    /**
                     * [WARNING: this is not fully supported by WebViewer and may result in unexpected behavior] {@link https://quilljs.com/docs/themes/ Themes} to use for the editor.
                     */
                    theme: string;
                };
            }
            /**
             * A class that represents controls used for editing contents of a freetext annotation
             */
            class RichTextEditor {
                /**
                 * Sets the Quill editor options.
                 * @param options - Quill options to be set.
                 */
                static setEditorOptions(options: Core.Annotations.FreeTextAnnotation.RichTextEditor.QuillEditorOptions): void;
                /**
                 * Gets the Quill editor options.
                 * @returns Quill options that are currently set.
                 */
                static getEditorOptions(): Core.Annotations.FreeTextAnnotation.RichTextEditor.QuillEditorOptions;
                /**
                 * Gets the current contents in the editor
                 * @returns Returns the current contents in the editor
                 */
                getContents(): string;
                /**
                 * Format text at the current selection. If the current selection has length of 0, then the format will be set active.
                 */
                format(format: Core.Annotations.FreeTextAnnotation.RichTextEditor.Format, value: Core.Annotations.FreeTextAnnotation.RichTextEditor.FormatValue): void;
                /**
                 * Gets the format of the text in the given range.
                 * @param index - the start index of the range
                 * @param length - the length of the range
                 * @returns Returns the format of the given range
                 */
                getFormat(index: number, length: number): any;
                /**
                 * Sets the content in the editor.
                 * @param contents - the contents that need to be updated in the editor
                 */
                setText(contents: string): void;
                /**
                 * Insert the content in the editor.
                 * @param index - the start index of the range
                 * @param contents - the contents that need to be updated in the editor
                 */
                insertText(index: number, contents: string): void;
                /**
                 * Delete some content from the editor.
                 * @param index - the start index of the range
                 * @param length - the length of the range
                 */
                deleteText(index: number, length: number): void;
                /**
                 * Sets the current selection in the editor.
                 * @param index - the start index of the range
                 * @param length - the length of the selection range
                 */
                setSelection(index: number, length: number): void;
                /**
                 * Gets the current selection range in the editor.
                 * @returns Returns the current selection range
                 */
                getSelection(): Core.EditBoxManager.Range;
                /**
                 * Checks if the editor is being focused.
                 * @returns Whether the editor is focused
                 */
                hasFocus(): boolean;
            }
        }
        /**
         * An enum representing different line end types that are available for line annotations
         */
        enum LineEndType {
            NONE,
            OPEN_ARROW,
            R_OPEN_ARROW,
            CLOSED_ARROW,
            R_CLOSED_ARROW,
            BUTT,
            SQUARE,
            DIAMOND,
            CIRCLE,
            SLASH
        }
    }
    /**
     * The manager of the Annotation history state for undoing and redoing annotation changes
     */
    class AnnotationHistoryManager extends Core.EventHandler {
        /**
         * Undoes the most recent annotation change
         * @returns Returns a promise that resolves when the operation is complete
         */
        undo(): Promise<void>;
        /**
         * Reapplies the most recent annotation change that was undone
         * @returns Returns a promise that resolves when the operation is complete
         */
        redo(): Promise<void>;
        /**
         * Clears the undo/redo history so that no older changes can be undone.
         */
        clear(): void;
        /**
         * Returns whether there is a change available to undo
         * @returns Whether there is a change that can be undone or not
         */
        canUndo(): boolean;
        /**
         * Returns whether there is a change available to redo
         * @returns Whether there is a change that can be redone or not
         */
        canRedo(): boolean;
        /**
         * Triggered when the annotation history stack changes.
         * This could be used to check the canUndo or canRedo functions if their value has changed.
         */
        on(event: 'historyChanged', callback: () => void): void;
        /**
         * Triggered when the annotation history stack changes.
         * This could be used to check the canUndo or canRedo functions if their value has changed.
         */
        one(event: 'historyChanged', callback: () => void): void;
        off(event?: 'historyChanged', callback?: () => void): void;
    }
    /**
     * Creates a new instance of AnnotationManager.
     * @property controlPointSize - The size of annotation control points.
     * @property controlPointHitBoxScale - The scale of the hit box of the annotation control points. Increase to increase the selectable area.
     */
    class AnnotationManager extends Core.EventHandler {
        constructor(docViewer: Core.DocumentViewer);
        /**
         * Groups an array of annotations
         * @param primaryAnnotation - The primary annotation for this group.
         * @param annotations - The array of annotations to group.
         */
        groupAnnotations(primaryAnnotation: Core.Annotations.Annotation, annotations: Core.Annotations.Annotation[]): void;
        /**
         * Ungroups an array of annotations
         * @param annotations - The array of annotations to ungroup.
         */
        ungroupAnnotations(annotations: Core.Annotations.Annotation[]): void;
        /**
         * Gets the number of annotations in the current selection
         * @returns The number of groups in the current selection. A loose annotation is a group of 1.
         */
        getNumberOfGroups(): number;
        /**
         * Gets all the annotations that are grouped with the passed in annotation, including said annotation.
         * @param annotation - An annotation in the group
         * @returns Gets all the annotations that are grouped with the passed in annotation, including said annotation.
         */
        getGroupAnnotations(annotation: Core.Annotations.Annotation): Core.Annotations.Annotation[];
        /**
         * Returns the user name of the current user.
         * @returns The user name of the current user.
         */
        getCurrentUser(): string;
        /**
         * Sets the current user of the viewer.
         * @param user - the user name of the current user.
         */
        setCurrentUser(user: string): void;
        /**
         * Returns whether the current user has admin privileges.
         * @returns true if the current user is an admin, false otherwise.
         */
        getIsAdminUser(): boolean;
        /**
         * Returns whether the current user has admin privileges.
         * @returns true if the current user is an admin, false otherwise.
         */
        isUserAdmin(): boolean;
        /**
         * Sets whether the current user is an admin user.
         * @param isAdminUser - true if the current user is an admin, false otherwise.
         */
        setIsAdminUser(isAdminUser: boolean): void;
        /**
         * Promote the current user to be an admin user. Admin users can edit any annotations.
         */
        promoteUserToAdmin(): void;
        /**
         * Demote the current user so they are no longer an admin user.
         */
        demoteUserFromAdmin(): void;
        /**
         * Returns whether the viewer is currently in read-only mode.
         * @returns true if the current viewer is in read-only mode, false otherwise.
         */
        getReadOnly(): boolean;
        /**
         * Returns whether the viewer is currently in read-only mode.
         * @returns true if the current viewer is in read-only mode, false otherwise.
         */
        isReadOnlyModeEnabled(): boolean;
        /**
         * Sets whether the viewer is currently in read-only mode.
         * @param readOnly - true if the viewer is in read-only mode, false otherwise.
         */
        setReadOnly(readOnly: boolean): void;
        /**
         * Enables read-only mode in the viewer. In this mode no annotations can be added or commented on.
         */
        enableReadOnlyMode(): void;
        /**
         * Disables read-only mode in the viewer.
         */
        disableReadOnlyMode(): void;
        /**
         * Returns whether freeform rotation is enabled for annotations.
         * @returns true if freeform rotation is enabled, false otherwise.
         */
        isFreeformRotationEnabled(): boolean;
        /**
         * Sets whether the annotations will have freeform rotation enabled.
         * @param freeformRotationEnabled - true if freeform rotation should be enabled, false otherwise.
         */
        setFreeformRotationEnabled(freeformRotationEnabled: boolean): void;
        /**
         * Enables freeform rotation for annotations
         */
        enableFreeformRotation(): void;
        /**
         * Disables freeform rotation for annotations.
         */
        disableFreeformRotation(): void;
        /**
         * Sets the rotation options for annotation manager.
         * @example
         * // Enables snap rotations at 60 degree steps, without having to hold shift key.
         * // Hotkey will not toggle rotation type (ie, freeform rotations are disabled).
         * const { Core } = instance;
         * const annotManager = Core.documentViewer.getAnnotationManager();
         * annotManager.setRotationOptions({
         *   isEnabled: true,
         *   defaultRotationType: Core.AnnotationManager.RotationTypes.SNAP_ROTATION,
         *   hotkeyTogglesRotationType: false,
         *   snapAngleStepSizeInDegrees: 60
         * });
         * @param options - An object that can contain the following parameters
         * @param [options.isEnabled] - Whether rotations are enabled or not.
         * @param [options.hotkeyTogglesRotationType] - Determines if rotation type performed is toggled when holding down shift key.
         * @param [options.defaultRotationType] - Determines which rotation type will be performed without holding shift key.
         * @param [options.snapAngleStepSizeInDegrees] - The angle (in degrees) applied to each snap rotation. Valid range is between 0 and 180.
         */
        setRotationOptions(options: {
            isEnabled?: boolean;
            hotkeyTogglesRotationType?: boolean;
            defaultRotationType?: string;
            snapAngleStepSizeInDegrees?: number;
        }): void;
        /**
         * Gets the rotation options for annotation manager.
         * @example
         * const { Core } = instance;
         * const annotManager = Core.documentViewer.getAnnotationManager();
         * const rotationOptions = annotManager.getRotationOptions();
         * @returns An object containing rotation options for annotation manager.
         */
        getRotationOptions(): any;
        /**
         * Returns whether free text editing is enabled directly on the annotation.
         * @returns true if free text editing is enabled, false otherwise.
         */
        useFreeTextEditing(): boolean;
        /**
         * Returns whether free text editing is enabled directly on the annotation.
         * @returns true if free text editing is enabled, false otherwise.
         */
        isFreeTextEditingEnabled(): boolean;
        /**
         * Disables the editing of free text annotations directly on the annotation.
         */
        disableFreeTextEditing(): void;
        /**
         * Disables the use of vector appearances for stamp annotations and always uses a fixed size bitmap.
         * This may be much faster in certain situations but will appear blurry at higher zoom levels.
         */
        disableStampVectorAppearance(): void;
        /**
         * Sets the function that should be used to determine if the annotation can be modified or not.
         * @param callback - The function that should be called. Should return true or false.
         */
        setPermissionCheckCallback(callback: (...params: any[]) => any): void;
        /**
         * Whether or not the current user can modify the annotation.
         * @param annotation - The annotation to check permissions on.
         * @returns Whether the annotation can be modified or not.
         */
        canModify(annotation: Core.Annotations.Annotation): boolean;
        /**
         * Whether or not the current user can modify the annotation's contents.
         * @param annotation - The annotation to check permissions on.
         * @returns Whether the annotation's contents can be modified or not.
         */
        canModifyContents(annotation: Core.Annotations.Annotation): boolean;
        /**
         * Sets the function to be called when a submit form action is triggered.
         * @param callback - The function that should be called. Will be passed the form data.
         */
        setSubmitFormActionCallback(callback: (...params: any[]) => any): void;
        /**
         * Sets the function to be called before a submit form action is triggered.
         * IMPORTANT: If either no value or a falsy value is returned from the callback,
         * then the submitForm API will be cancelled. Please ensure your callback
         * function returns the boolean true in order for the submit form action to
         * complete
         * @param callback - The function that will be called prior to
         * invocation of the SubmitForm API.
         */
        setBeforeSubmitFormActionCallback(callback: Core.AnnotationManager.setBeforeSubmitFormActionCallbackFunction): void;
        /**
         * Gets the associated field manager.
         */
        getFieldManager(): Core.Annotations.Forms.FieldManager;
        /**
         * Draws all annotations associated with the given page number.
         * Note that the entire annotation canvas for the page will be redrawn.
         * @param options - An object that can contain the following parameters
         * @param options.pageNumber - The page number of the page to draw
         * @param [options.overrideCanvas] - Optionally draw directly to this canvas
         * @param [options.majorRedraw] - Signify that this is a major redraw, so widget-like annotations must be re-rendered as well
         * @param [options.overrideContainer] - Optionally the container HTML element that the widget annotations should be appended to
         * @returns Returns a promise that resolves when all the annotations on the page have been drawn
         */
        drawAnnotations(options: {
            pageNumber: number;
            overrideCanvas?: any;
            majorRedraw?: boolean;
            overrideContainer?: any;
        }): Promise<any>;
        /**
         * Set the page transform of an annotation canvas
         * @param annotCanvasContext - Annotation canvas context to draw on
         * @param zoom - The zoom or the scaling of the page canvas
         * @param rotation - The rotation of the page canvas
         */
        setAnnotationCanvasTransform(annotCanvasContext: CanvasRenderingContext2D, zoom: number, rotation: Core.PageRotation): void;
        /**
         * Redraws the specified annotation.
         * Note that the entire annotation canvas for the page will be redrawn.
         * @param annotation - The annotation to be redrawn.
         */
        redrawAnnotation(annotation: Core.Annotations.Annotation): void;
        /**
         * Sets the rate at which the redrawing of annotations is throttled. This can improve
         * annotation rendering on lower quality devices and browsers.
         * @param value - The throttled rate at which annotations will be redrawn, in milliseconds
         */
        setRedrawThrottle(value: number): void;
        /**
         * Sets the rate at which the redrawing of annotations is throttled. This can improve
         * annotation rendering on lower quality devices and browsers.
         * @param value - The throttled rate at which annotations will be redrawn, in milliseconds
         */
        setRedrawThrottleRate(value: number): void;
        /**
         * Jumps to the page of the annotation and if it isn't visible then centers it in the window.
         * @param annotation - The annotation to be jumped to.
         * @param [options] - Optional settings for jump behaiour. Default will guarantee the annotation will be on the screen at the current zoom level.
         * @param [options.horizontalOffset = auto] - Percentage of the screen the annotation will jump to, '0%' being the left of the page. Anything over '100%' and under '0%' will be off the page.
         * @param [options.verticalOffset = auto] - Percentage of the screen the annotation will jump to, '0%' being the top of the page. Anything over '100%' and under '0%' will be off the page.
         * @param [options.zoom = 1] - The level of zoom, 1 being 100% zoom.
         * @param [options.fitToView = false] - If set to true the zoom will fit the entire annotation within the viewport.
         * @param [options.isSmoothScroll = false] - If set to true, the viewer will scroll to the annotation in a smooth way.
         */
        jumpToAnnotation(annotation: Core.Annotations.Annotation, options?: {
            horizontalOffset?: string;
            verticalOffset?: string;
            zoom?: string;
            fitToView?: boolean;
            isSmoothScroll?: boolean;
        }): void;
        /**
         * Hides the specified annotation.
         * @param annot - The annotation to hide
         */
        hideAnnotation(annot: Core.Annotations.Annotation): void;
        /**
         * Hides all of the annotations in the list
         * @param annots - Array of annotations to hide
         */
        hideAnnotations(annots: Core.Annotations.Annotation[]): void;
        /**
         * Shows the annotation
         * @param annot - The annotation to show
         */
        showAnnotation(annot: Core.Annotations.Annotation): void;
        /**
         * Shows all of the annotations in the list
         * @param annots - Array of annotations to show
         */
        showAnnotations(annots: Core.Annotations.Annotation[]): void;
        /**
         * Determines if the specified annotation exists in the managed list of annotations.
         * @param annotation - An instance of Annotation.
         */
        hasAnnotation(annotation: Core.Annotations.Annotation): void;
        /**
         * Sets the value of the note for the specified annotation.
         * @param annotation - The annotation that will have its note updated.
         * @param text - The value to update the note text to.
         */
        setNoteContents(annotation: Core.Annotations.Annotation, text: string): void;
        /**
         * Sets the rich text style for the specified annotation
         * @param annotation - The annotation that will have its rich text style updated.
         * @param style - The object to update the rich text style to.
         */
        setAnnotationRichTextStyle(annotation: Core.Annotations.Annotation, style: Core.Annotations.Annotation.RichTextStyle): void;
        /**
         * Update the rich text style for the specified annotation
         * @param annotation - The annotation that will have its rich text style updated.
         * @param style - The object to update the rich text style to.
         * @param style.'underline' - boolean value for whether string should be underlined
         * @param style.'line-through' - boolean value for whether string should be strike through
         * @param style.'font-weight' - String for the font weight of the rich text  (can be 'bold')
         * @param style.'font-style' - String for font style of the rich text (can be 'italic')
         * @param style.'color' - string for what color to set text to
         * @param [start] - Optional starting index to apply the style, if not set, will start at 0
         * @param [end] - Optional ending index for the style, if not set, will apply style to end of text
         */
        updateAnnotationRichTextStyle(annotation: Core.Annotations.Annotation, style: {
            'underline': boolean;
            'line-through': boolean;
            'font-weight': string;
            'font-style': string;
            'color': string;
        }, start?: number, end?: number): void;
        /**
         * Move the annotation to the end of the managed list of annotations, so that it will be shown on top of all annotations.
         * @param annotation - The annotation that will be shown in the front.
         */
        bringToFront(annotation: Core.Annotations.Annotation): void;
        /**
         * Move the annotation to the beginning of the managed list of annotations, so that it will be shown behind all annotations.
         * @param annotation - The annotation that will be shown in the back.
         */
        bringToBack(annotation: Core.Annotations.Annotation): void;
        /**
         * Adds the specified annotation to the managed list of annotations.
         * @param annotation - An instance of Annotation.
         * @param [options] - An object that can contain the following optional parameters.
         * @param [options.imported = false] - Whether the annotation was imported from another source or not
         * @param [options.isUndoRedo = false] - Whether the annotation change was caused by undo/redo or not
         * @param [options.autoFocus = false] - Whether the annotation's text input should be automatically focused if applicable. Relevant to FreeText and Callout annotations.
         */
        addAnnotation(annotation: Core.Annotations.Annotation | Core.Annotations.Annotation[], options?: {
            imported?: boolean;
            isUndoRedo?: boolean;
            autoFocus?: boolean;
        }): void;
        /**
         * Adds the specified annotations to the managed list of annotations.
         * @param annotations - An array of annotations.
         * @param [options] - An object that can contain the following optional parameters.
         * @param [options.imported = false] - Whether the annotations were imported from another source or not
         * @param [options.isUndoRedo = false] - Whether the annotation change was caused by undo/redo or not
         * @param [options.autoFocus = false] - Whether the annotation's text input should be automatically focused if applicable. Relevant to FreeText and Callout annotations.
         */
        addAnnotations(annotations: Core.Annotations.Annotation[], options?: {
            imported?: boolean;
            isUndoRedo?: boolean;
            autoFocus?: boolean;
        }): void;
        /**
         * Gets the root annotation that this annotation is replying to.
         * If this annotation is not replying to anything then the root is itself.
         * @param annotation - The annotation from which to find the root annotation in the reply chain
         * @returns The root annotation
         */
        getRootAnnotation(annotation: Core.Annotations.Annotation): Core.Annotations.Annotation;
        /**
         * Creates an annotation that replies to the passed in annotation. Annotation replies are sticky note annotations.
         * @param annotation - The annotation to add a reply to
         * @param initialText - The initialText for the annotation, defaults to the empty string
         * @returns The created annotation reply
         */
        createAnnotationReply(annotation: Core.Annotations.Annotation, initialText: string): Core.Annotations.StickyAnnotation;
        /**
         * Updates the annotation state. This is done by creating an annotation that replies to the passed in annotation.
         * @param annotation - The annotation to add a reply to
         * @param state - Annotations may have an author-specific state associated with them.
         * Valid states are for Review stateModel: Accepted, Rejected, Cancelled, Completed, None. Default is None.
         * Valid states are for Marked stateModel: Marked and Unmarked. Default is Unmarked.
         * @param stateModel - Gets or sets the stateModel of the annotation. stateModel has two statemodels: Marked, Review. Default is Review.
         * @param message - Message to be set when the state is updated.
         * @returns The created annotation reply
         */
        updateAnnotationState(annotation: Core.Annotations.Annotation, state: string, stateModel: string, message: string): Core.Annotations.StickyAnnotation;
        /**
         * Redraws the annotations on the same page as the specified annotation if the annotation has been added.
         * @param annotation - An instance of Annotation.
         */
        updateAnnotation(annotation: Core.Annotations.Annotation): void;
        /**
         * Apply redaction annotations
         * @param [annotations] - An array of redaction annotations or a single redaction annotation.
         * If nothing passed, apply all redactions. If the redaction annotations overlap with other annotations, it calls deleteAnnotations on the other annotations.
         * @returns Returns a promise that resolves with an array of redaction info when the redactions have been applied.
         * If using WebViewer server, the promise will resolve with a URL to the redacted document.
         */
        applyRedactions(annotations?: Core.Annotations.Annotation | Core.Annotations.Annotation[]): Promise<Core.AnnotationManager.RedactionInfo[] | string>;
        /**
         * Check if applying redaction is enabled
         * @returns True if applying redactions is enabled, false otherwise
         */
        isApplyRedactionEnabled(): boolean;
        /**
         * Check if creating redaction is enabled
         * @returns True if creating redactions is enabled, false otherwise
         */
        isCreateRedactionEnabled(): boolean;
        /**
         * Enable redaction tools
         * Please use enableRedaction or disableRedaction without passing parameters
         * Using a parameter is deprecated in version 8.0
         */
        enableRedaction(): void;
        /**
         * Disable redaction tools
         */
        disableRedaction(): void;
        /**
         * Check if an annotation is redactable (is a redaction annotation the user can apply).
         * When using Webviewer Server, single redaction aren't allowed, only redact all is allowed
         * @param annotation - An annotation to check if it redactable
         * @returns True if annotation can be redacted (WebViewer is set up correctly for applying), false otherwise
         */
        isAnnotationRedactable(annotation: Core.Annotations.Annotation): boolean;
        /**
         * Deletes the specified annotation in the managed list of annotations.
         * If an annotation is successfully deleted, the annotationChanged event will be fired with a "delete" action.
         * @param annotation - An instance of Annotation.
         * @param [options] - An object that can contain the following optional parameters.
         * @param [options.imported] - Whether the annotation was imported from another source or not OR a option parameters contains
         * @param [options.force] - If true then the annotation will be deleted regardless of the user's current permissions
         * @param [options.isUndoRedo] - Whether the annotation change was caused by undo/redo or not
         * @param [options.source] - What type of action cause this event (i.e. "redactionApplied")
         */
        deleteAnnotation(annotation: Core.Annotations.Annotation | Core.Annotations.Annotation[], options?: {
            imported?: boolean;
            force?: boolean;
            isUndoRedo?: boolean;
            source?: string;
        }): void;
        /**
         * Deletes the specified annotations in the managed list of annotations.
         * If an annotation is successfully deleted, the annotationChanged event will be fired with a "delete" action.
         * @param annotation - An array of annotations
         * @param [options] - An object that can contain the following optional parameters.
         * @param [options.imported] - Whether the annotations were imported from another source or not
         * @param [options.force] - If true then the annotations will be deleted regardless of the user's current permissions
         * @param [options.isUndoRedo] - Whether the annotation change was caused by undo/redo or not
         * @param [options.source] - What type of action cause this event (i.e. "redactionApplied")
         */
        deleteAnnotations(annotation: Core.Annotations.Annotation[], options?: {
            imported?: boolean;
            force?: boolean;
            isUndoRedo?: boolean;
            source?: string;
        }): void;
        /**
         * Copies the currently selected annotations.
         */
        updateCopiedAnnotations(): void;
        /**
         * Get copied annotations.
         * @returns returns array of copied annotations
         */
        getCopiedAnnotations(): Core.Annotations.Annotation[];
        /**
         * Pastes the currently copied annotations.
         * @param [useMouseLocation = false] - Whether or not to paste the
         * annotations based on the position of the mouse cursor in the window,
         * accounting for the scroll position
         */
        pasteCopiedAnnotations(useMouseLocation?: boolean): void;
        /**
         * Returns a deep copy of the annotation
         * @param annotation - An instance of Annotation to be copied.
         * @param options - Options for this function
         * @param options.copyAssociatedLink - Whether to make a deep copy of an associated link
         * @returns a copy of the annotation, null if annotation cannot be copied
         */
        getAnnotationCopy(annotation: Core.Annotations.Annotation, options: {
            copyAssociatedLink: boolean;
        }): Core.Annotations.Annotation;
        /**
         * Gets the annotation associated with the popup object.
         * @param popup - The popup object associated with an annotation
         * @returns The annotation that the popup belongs to
         */
        getAnnotationFromPopup(popup: any): Core.Annotations.Annotation;
        /**
         * Returns whether an annotation is currently selected
         * @param annotation - An instance of Annotation.
         * @returns true if annotation is selected, false otherwise
         */
        isAnnotationSelected(annotation: Core.Annotations.Annotation): boolean;
        /**
         * Selects the specified annotation.
         * If an annotation is successfully selected then the annotationSelected event will be fired with a "selected" action.
         * Note: the annotationSelected event has two parameters: an array of annotations and a string value of either "selected" or "deselected"
         * @param annotation - An instance of Annotation.
         */
        selectAnnotation(annotation: Core.Annotations.Annotation): void;
        /**
         * Selects the specified annotations.
         * If an annotation is successfully selected then the annotationSelected event will be fired with a "selected" action.
         * Note: the annotationSelected event has two parameters: an array of annotations and a string value of either "selected" or "deselected"
         * @param annotations - An array of Annotations.
         */
        selectAnnotations(annotations: Core.Annotations.Annotation[]): void;
        /**
         * Deselects all annotations.
         * If an annotation is successfully deselected then the annotationSelected event will be triggered with two parameters: an array of annotations that were deselected and a "deselected" action.
         * Note: the annotationSelected event has two parameters: an array of annotations and a string value of either "selected" or "deselected"
         * The annotationDeselected event will also be triggered with one parameter: an array of annotations that were deselected.
         */
        deselectAllAnnotations(): void;
        /**
         * Deselects the specified annotation.
         * If an annotation is successfully deselected then the annotationSelected event will be fired with a "deselected" action.
         * Note: the annotationSelected event has two parameters: an array of annotations and a string value of either "selected" or "deselected"
         * @param annotation - An instance of Annotation.
         */
        deselectAnnotation(annotation: Core.Annotations.Annotation): void;
        /**
         * Deselects the specified annotations.
         * If annotations are successfully deselected then the annotationSelected event will be fired with a "deselected" action.
         * Note: the annotationSelected event has two parameters: an array of annotations and a string value of either "selected" or "deselected"
         * @param annotations - An array of annotation instances
         */
        deselectAnnotations(annotations: Core.Annotations.Annotation[]): void;
        /**
         * Returns the list of selected annotations.
         * @returns An array of selected annotations.
         */
        getSelectedAnnotations(): Core.Annotations.Annotation[];
        /**
         * Gets the list of all annotations managed by the AnnotationManager.
         * @returns An array of Annotations.
         */
        getAnnotationsList(): Core.Annotations.Annotation[];
        /**
         * Gets an annotation object by the annotation's ID.
         * @param id - The ID of the annotation.
         * @param [annotationList] - Optionally pass your own array of annotations to search in
         * @returns An annotation object.
         */
        getAnnotationById(id: string, annotationList?: any[]): Core.Annotations.Annotation;
        /**
         * Gets the top-most annotation using a DOM mouse event. This method can be used to test if a mouse point will hit any annotations on pages.
         * @param event - A DOM mouse event.
         * @returns An annotation object.
         */
        getAnnotationByMouseEvent(event: MouseEvent): Core.Annotations.Annotation;
        /**
         * Gets the annotations underneath the cursor using a DOM mouse event. This method can be used to test if a mouse point will hit annotations on pages.
         * @param event - A DOM mouse event.
         * @returns An array of annotation objects.
         */
        getAnnotationsByMouseEvent(event: MouseEvent): Core.Annotations.Annotation[];
        /**
         * Exports all annotations as an XFDF (XML) string
         * @param [options] - Options for the export. Set options.widgets or options.links or options.fields to false to disable exporting of them.
         * @param [options.annotList] - An array of annotations to only export the XFDF for those particular annotations.
         * @param [options.widgets] - Whether to export widget information
         * @param [options.links] - Whether to export links information
         * @param [options.fields] - Whether to export fields information
         * @param [options.useDisplayAuthor] - Whether to export annotations with the Display Author name from annotationManager.getDisplayAuthor()
         * @param [options.generateInlineAppearances] - Whether to generate custom appearance strings for annotations that have an appearance generated on export (e.g. freetext). Default: true
         * @returns Returns a promise that resolves with the XFDF (XML) annotations as a string
         */
        exportAnnotations(options?: {
            annotList?: Core.Annotations.Annotation[];
            widgets?: boolean;
            links?: boolean;
            fields?: boolean;
            useDisplayAuthor?: boolean;
            generateInlineAppearances?: boolean;
        }): Promise<string>;
        /**
         * Gets an XML string from the last time this function was called.
         * XML string specifies the added, modified and deleted annotations.
         * Added and modified annotations will have their XFDF representation included
         * while deleted annotations will only include their id.
         * @returns Returns a promise that resolves to an XFDF command string
         */
        exportAnnotCommand(): Promise<string>;
        /**
         * Gets an XML string from the last time this function was called.
         * XML string specifies the added, modified and deleted annotations.
         * Added and modified annotations will have their XFDF representation included
         * while deleted annotations will only include their id.
         * @returns Returns a promise that resolves to an XFDF command string
         */
        exportAnnotationCommand(): Promise<string>;
        /**
         * Loads XFDF annotations into the viewer
         * @param xfdfString - The XFDF annotations as a string
         * @param [options] - The options for importing
         * @param [options.batchSize] - The number of annotations to import in each batch (default 100)
         * @param [options.batchDelay] - The amount of time in milliseconds to delay between importing each batch (default 0)
         * @param [options.replace] - The type of existing annotations that will be removed before import starts (default [])
         * @returns Returns a promise that resolves with the annotations have been imported
         */
        importAnnotations(xfdfString: string, options?: {
            batchSize?: number;
            batchDelay?: number;
            replace?: Core.Annotations.Annotation | Core.Annotations.Annotation[];
        }): Promise<any>;
        /**
         * Updates the viewer with the xfdf changes (add/modify/delete) in the xml string
         * @param xfdfString - The XML annotation updates as a string
         * @returns A promise that resolves to the list of annotations that were updated
         */
        importAnnotCommand(xfdfString: string): Promise<Core.Annotations.Annotation[]>;
        /**
         * Updates the viewer with the xfdf changes (add/modify/delete) in the xml string
         * @param xfdfString - The XML annotation updates as a string
         * @returns A promise that resolves to the list of annotations that were updated
         */
        importAnnotationCommand(xfdfString: string): Promise<Core.Annotations.Annotation[]>;
        /**
         * Used to load appearance documents for annotations with custom appearances.
         * The function will be called when an annotation is imported that contains a custom appearance that references a filename.
         * @param func - Function which must return Document object created with {@link Core.createDocument}
         */
        setCustomAppearanceHandler(func: (...params: any[]) => any): void;
        /**
         * Draws all the pages associated with the annotations in the list as long the page is visible.
         * A single annotation can also be passed in.
         * @param annotationList - List of annotations or a single annotation object
         * @returns Returns a promise that resolves when all the annotations in the annotationList have been drawn
         */
        drawAnnotationsFromList(annotationList: Core.Annotations.Annotation[] | Core.Annotations.Annotation): Promise<any>;
        /**
         * Registers an annotation class. Annotations that are registered will be serialized and deserialized by the AnnotationManager.
         * @param elementName - the string representing the xml element name of the annotation
         * @param annotationClass - the class (constructor) of the annotation
         * @returns true if registration was successful
         */
        registerAnnotationType(elementName: string, annotationClass: typeof Core.Annotations.Annotation): boolean;
        /**
         * Deregisters an annotation class.
         * @param elementName - the string representing the xml element name of the annotation
         * @param annotationClass - the class (constructor) of the annotation
         * @returns true if deregistration was successful
         */
        deregisterAnnotationType(elementName: string, annotationClass: typeof Core.Annotations.Annotation): boolean;
        /**
         * Gets a map of registered annotations. This can be modified directly, instead of using AnnotationManager#registerAnnotationType and AnnotationManager#deregisterAnnotationType.
         * @returns a JavaScript object containing a key-value map, where the key is the annotation element name and the value is an array of Annotation classes.
         */
        getRegisteredAnnotationTypes(): any;
        /**
         * @returns Returns an instance of EditorBoxManager
         */
        getEditBoxManager(): Core.EditBoxManager;
        /**
         * Gets the associated form field creation manager
         * @returns Returns an instance of FormFieldCreationManager
         */
        getFormFieldCreationManager(): Core.FormFieldCreationManager;
        /**
         * Set the styles for the annotation
         * @param annotation - an annotation of which the styles will be changed.
         * @param newStyles - if an object is used, it should contain properties of the new styles.
         * If a function is used, the current styles will be passed as its argument and the function should return an object which contains properties of the new styles.
         * Example of valid properties: StrokeColor, TextColor, FillColor, FontSize, Opacity, StrokeThickness, Precision, Scale, OverlayText, Style and Dashes.
         */
        setAnnotationStyles(annotation: Core.Annotations.Annotation, newStyles: any | ((...params: any[]) => any)): void;
        /**
         * Sets the mapping function used to get the display name for annotation authors
         * and is used when calling getDisplayAuthor.
         * @example
         * annotManager.setAnnotationDisplayAuthorMap((annotationUserId) => {
         *   if (annotationUserId === '1') {
         *     return 'John';
         *   } else {
         *     return 'Guest';
         *   }
         * });
         * @param mapFunction - The mapping function to use. The function is passed a userID/GUID and should return the display name for the UI.
         */
        setAnnotationDisplayAuthorMap(mapFunction: (...params: any[]) => any): void;
        /**
         * Annotations may set the author to a unique id which isn't suitable for display in the UI.
         * this function gets the author name of the annotation that should be displayed.
         * @param annotationUserId - Annotation userId
         * @returns The display author name
         */
        getDisplayAuthor(annotationUserId: string): string;
        /**
         * Changes the sticky note rendering to the old implementation when the sticky note
         * has been created before the specified date.
         * @param date - The date timestamp to use
         */
        setOldStickyNoteRenderingDate(date: number): void;
        /**
         * Enable dragging annotations across pages.
         */
        enableDraggingAcrossPages(): void;
        /**
         * Disable dragging annotations across pages.
         */
        disableDraggingAcrossPages(): void;
        /**
         * Check if dragging annotations across pages is enabled.
         * @returns True if dragging annotations across pages is enabled, false otherwise.
         */
        isDraggingAcrossPagesEnabled(): boolean;
        /**
         * Set the snap options for annotation tool snapping
         * @param options - The snap mode options.
         */
        setSnapDefaultOptions(options: Core.AnnotationManager.snapDefaultOptions): void;
        /**
         * Get the current snap options for annotation tool snapping
         * @returns The snap mode options.
         */
        getSnapDefaultOptions(): Core.AnnotationManager.snapDefaultOptions;
        /**
         * Triggered when an annotation or annotations have been changed (added, deleted, modified).
         * Attach like annotManager.addEventListener('annotationChanged', callback)
         * @param annotations - The annotations that were changed
         * @param action - The action that occurred (add, delete, modify)
         * @param info - An object containing extra information about the annotationChanged event
         */
        on(event: 'annotationChanged', callback: (annotations: Core.Annotations.Annotation[], action: string, info: Core.AnnotationManager.AnnotationChangedInfoObject) => void): void;
        /**
         * Triggered when an annotation or annotations have been changed (added, deleted, modified).
         * Attach like annotManager.addEventListener('annotationChanged', callback)
         * @param annotations - The annotations that were changed
         * @param action - The action that occurred (add, delete, modify)
         * @param info - An object containing extra information about the annotationChanged event
         */
        one(event: 'annotationChanged', callback: (annotations: Core.Annotations.Annotation[], action: string, info: Core.AnnotationManager.AnnotationChangedInfoObject) => void): void;
        off(event?: 'annotationChanged', callback?: (annotations: Core.Annotations.Annotation[], action: string, info: Core.AnnotationManager.AnnotationChangedInfoObject) => void): void;
        /**
         * Triggered after an annotation has been double clicked
         * @param annotation - The annotation that has been double clicked
         */
        on(event: 'annotationDoubleClicked', callback: (annotation: Core.Annotations.Annotation) => void): void;
        /**
         * Triggered after an annotation has been double clicked
         * @param annotation - The annotation that has been double clicked
         */
        one(event: 'annotationDoubleClicked', callback: (annotation: Core.Annotations.Annotation) => void): void;
        off(event?: 'annotationDoubleClicked', callback?: (annotation: Core.Annotations.Annotation) => void): void;
        /**
         * Triggered when a field's value has been changed.
         * Attach like annotManager.addEventListener('fieldChanged', callback)
         * @param field - The field that was changed
         * @param value - The field's new value
         */
        on(event: 'fieldChanged', callback: (field: any, value: string) => void): void;
        /**
         * Triggered when a field's value has been changed.
         * Attach like annotManager.addEventListener('fieldChanged', callback)
         * @param field - The field that was changed
         * @param value - The field's new value
         */
        one(event: 'fieldChanged', callback: (field: any, value: string) => void): void;
        off(event?: 'fieldChanged', callback?: (field: any, value: string) => void): void;
        /**
         * Triggered after annotations have been hidden/shown.
         * @param annotationList - List of annotations that were hidden or shown
         * @param hidden - Whether the annotations have been hidden or shown
         */
        on(event: 'annotationHidden', callback: (annotationList: Core.Annotations.Annotation[], hidden: boolean) => void): void;
        /**
         * Triggered after annotations have been hidden/shown.
         * @param annotationList - List of annotations that were hidden or shown
         * @param hidden - Whether the annotations have been hidden or shown
         */
        one(event: 'annotationHidden', callback: (annotationList: Core.Annotations.Annotation[], hidden: boolean) => void): void;
        off(event?: 'annotationHidden', callback?: (annotationList: Core.Annotations.Annotation[], hidden: boolean) => void): void;
        /**
         * Triggered after annotation selection has been changed.
         * @param annotationList - List of annotations that have selected or deselected.
         * @param action - Either 'selected' or 'deselected'
         */
        on(event: 'annotationSelected', callback: (annotationList: Core.Annotations.Annotation[], action: string) => void): void;
        /**
         * Triggered after annotation selection has been changed.
         * @param annotationList - List of annotations that have selected or deselected.
         * @param action - Either 'selected' or 'deselected'
         */
        one(event: 'annotationSelected', callback: (annotationList: Core.Annotations.Annotation[], action: string) => void): void;
        off(event?: 'annotationSelected', callback?: (annotationList: Core.Annotations.Annotation[], action: string) => void): void;
        /**
         * Triggered after annotations have been deselected.
         * @param annotationList - List of annotations that have been deselected.
         */
        on(event: 'annotationDeselected', callback: (annotationList: Core.Annotations.Annotation[]) => void): void;
        /**
         * Triggered after annotations have been deselected.
         * @param annotationList - List of annotations that have been deselected.
         */
        one(event: 'annotationDeselected', callback: (annotationList: Core.Annotations.Annotation[]) => void): void;
        off(event?: 'annotationDeselected', callback?: (annotationList: Core.Annotations.Annotation[]) => void): void;
        /**
         * Triggered when a reply has been added to an annotation
         * @param annotation - The annotation that was added
         * @param parent - The annotation that is the direct parent of the first annotation
         * @param root - The annotation that is the root parent of the first annotation (may be the same as parent)
         */
        on(event: 'addReply', callback: (annotation: Core.Annotations.Annotation, parent: Core.Annotations.Annotation, root: Core.Annotations.Annotation) => void): void;
        /**
         * Triggered when a reply has been added to an annotation
         * @param annotation - The annotation that was added
         * @param parent - The annotation that is the direct parent of the first annotation
         * @param root - The annotation that is the root parent of the first annotation (may be the same as parent)
         */
        one(event: 'addReply', callback: (annotation: Core.Annotations.Annotation, parent: Core.Annotations.Annotation, root: Core.Annotations.Annotation) => void): void;
        off(event?: 'addReply', callback?: (annotation: Core.Annotations.Annotation, parent: Core.Annotations.Annotation, root: Core.Annotations.Annotation) => void): void;
        /**
         * Triggered when a reply has been deleted from an annotation
         * @param annotation - The annotation that was deleted
         * @param root - The annotation that is the root parent of the first annotation
         */
        on(event: 'deleteReply', callback: (annotation: Core.Annotations.Annotation, root: Core.Annotations.Annotation) => void): void;
        /**
         * Triggered when a reply has been deleted from an annotation
         * @param annotation - The annotation that was deleted
         * @param root - The annotation that is the root parent of the first annotation
         */
        one(event: 'deleteReply', callback: (annotation: Core.Annotations.Annotation, root: Core.Annotations.Annotation) => void): void;
        off(event?: 'deleteReply', callback?: (annotation: Core.Annotations.Annotation, root: Core.Annotations.Annotation) => void): void;
        /**
         * Triggered when the text should be set on a note
         * @param annotation - The annotation that needs to have its note text updated
         * @param root - The annotation that is the root parent of the first annotation
         */
        on(event: 'setNoteText', callback: (annotation: Core.Annotations.Annotation, root: Core.Annotations.Annotation) => void): void;
        /**
         * Triggered when the text should be set on a note
         * @param annotation - The annotation that needs to have its note text updated
         * @param root - The annotation that is the root parent of the first annotation
         */
        one(event: 'setNoteText', callback: (annotation: Core.Annotations.Annotation, root: Core.Annotations.Annotation) => void): void;
        off(event?: 'setNoteText', callback?: (annotation: Core.Annotations.Annotation, root: Core.Annotations.Annotation) => void): void;
        /**
         * Triggered when permissions for annotations should be updated. This might be when the user changes or readonly is switched to.
         * If no annotation is specified then every annotation should be updated.
         * @param [annotation] - The annotation that needs to have its permissions updated
         */
        on(event: 'updateAnnotationPermission', callback: (annotation?: Core.Annotations.Annotation) => void): void;
        /**
         * Triggered when permissions for annotations should be updated. This might be when the user changes or readonly is switched to.
         * If no annotation is specified then every annotation should be updated.
         * @param [annotation] - The annotation that needs to have its permissions updated
         */
        one(event: 'updateAnnotationPermission', callback: (annotation?: Core.Annotations.Annotation) => void): void;
        off(event?: 'updateAnnotationPermission', callback?: (annotation?: Core.Annotations.Annotation) => void): void;
        /**
         * Triggered after annotations have been drawn for a page
         * @param pageNumber - The page number of all the annotations that were just drawn
         */
        on(event: 'annotationsDrawn', callback: (pageNumber: any) => void): void;
        /**
         * Triggered after annotations have been drawn for a page
         * @param pageNumber - The page number of all the annotations that were just drawn
         */
        one(event: 'annotationsDrawn', callback: (pageNumber: any) => void): void;
        off(event?: 'annotationsDrawn', callback?: (pageNumber: any) => void): void;
        /**
         * Triggered after the file attachment data is available after double clicking on the annotation
         * @param fileInfo - Information of the file attachment
         * @param fileInfo.fileData - The blob data of the file attachment
         * @param fileInfo.filename - The name of the file attachment
         * @param fileInfo.mimeType - The mimetype attribute of the file attachment
         */
        on(event: 'fileAttachmentDataAvailable', callback: (fileInfo: {
            fileData: Blob;
            filename: string;
            mimeType: string;
        }) => void): void;
        /**
         * Triggered after the file attachment data is available after double clicking on the annotation
         * @param fileInfo - Information of the file attachment
         * @param fileInfo.fileData - The blob data of the file attachment
         * @param fileInfo.filename - The name of the file attachment
         * @param fileInfo.mimeType - The mimetype attribute of the file attachment
         */
        one(event: 'fileAttachmentDataAvailable', callback: (fileInfo: {
            fileData: Blob;
            filename: string;
            mimeType: string;
        }) => void): void;
        off(event?: 'fileAttachmentDataAvailable', callback?: (fileInfo: {
            fileData: Blob;
            filename: string;
            mimeType: string;
        }) => void): void;
        /**
         * @property ANNOTATION_SELECTED - {@link Core.AnnotationManager#event:annotationSelected Core.AnnotationManager.annotationSelected }
         * @property ANNOTATION_DESELECTED - {@link Core.AnnotationManager#event:annotationDeselected Core.AnnotationManager.annotationDeselected }
         * @property ANNOTATION_DOUBLE_CLICKED - {@link Core.AnnotationManager#event:annotationDoubleClicked Core.AnnotationManager.annotationDoubleClicked }
         * @property ANNOTATION_CHANGED - {@link Core.AnnotationManager#event:annotationChanged Core.AnnotationManager.annotationChanged }
         * @property UPDATE_ANNOTATION_PERMISSION - {@link Core.AnnotationManager#event:updateAnnotationPermission Core.AnnotationManager.updateAnnotationPermission }
         * @property ANNOTATIONS_DRAWN - {@link Core.AnnotationManager#event:annotationsDrawn Core.AnnotationManager.annotationsDrawn }
         * @property ANNOTATION_HIDDEN - {@link Core.AnnotationManager#event:annotationHidden Core.AnnotationManager.annotationHidden }
         * @property SET_NOTE_TEXT - {@link Core.AnnotationManager#event:setNoteText Core.AnnotationManager.setNoteText }
         * @property ADD_REPLY - {@link Core.AnnotationManager#event:addReply Core.AnnotationManager.addReply }
         * @property DELETE_REPLY - {@link Core.AnnotationManager#event:deleteReply Core.AnnotationManager.deleteReply }
         * @property FIELD_CHANGED - {@link Core.AnnotationManager#event:fieldChanged Core.AnnotationManager.fieldChanged }
         * @property FILE_ATTACHMENT_DATA_AVAILABLE - {@link Core.AnnotationManager#event:fileAttachmentDataAvailable Core.AnnotationManager.fileAttachmentDataAvailable }
         */
        static Events: {
            /**
             * {@link Core.AnnotationManager#event:annotationSelected Core.AnnotationManager.annotationSelected }
             */
            ANNOTATION_SELECTED: string;
            /**
             * {@link Core.AnnotationManager#event:annotationDeselected Core.AnnotationManager.annotationDeselected }
             */
            ANNOTATION_DESELECTED: string;
            /**
             * {@link Core.AnnotationManager#event:annotationDoubleClicked Core.AnnotationManager.annotationDoubleClicked }
             */
            ANNOTATION_DOUBLE_CLICKED: string;
            /**
             * {@link Core.AnnotationManager#event:annotationChanged Core.AnnotationManager.annotationChanged }
             */
            ANNOTATION_CHANGED: string;
            /**
             * {@link Core.AnnotationManager#event:updateAnnotationPermission Core.AnnotationManager.updateAnnotationPermission }
             */
            UPDATE_ANNOTATION_PERMISSION: string;
            /**
             * {@link Core.AnnotationManager#event:annotationsDrawn Core.AnnotationManager.annotationsDrawn }
             */
            ANNOTATIONS_DRAWN: string;
            /**
             * {@link Core.AnnotationManager#event:annotationHidden Core.AnnotationManager.annotationHidden }
             */
            ANNOTATION_HIDDEN: string;
            /**
             * {@link Core.AnnotationManager#event:setNoteText Core.AnnotationManager.setNoteText }
             */
            SET_NOTE_TEXT: string;
            /**
             * {@link Core.AnnotationManager#event:addReply Core.AnnotationManager.addReply }
             */
            ADD_REPLY: string;
            /**
             * {@link Core.AnnotationManager#event:deleteReply Core.AnnotationManager.deleteReply }
             */
            DELETE_REPLY: string;
            /**
             * {@link Core.AnnotationManager#event:fieldChanged Core.AnnotationManager.fieldChanged }
             */
            FIELD_CHANGED: string;
            /**
             * {@link Core.AnnotationManager#event:fileAttachmentDataAvailable Core.AnnotationManager.fileAttachmentDataAvailable }
             */
            FILE_ATTACHMENT_DATA_AVAILABLE: string;
        };
        /**
         * The size of annotation control points.
        */
        controlPointSize: number;
        /**
         * The scale of the hit box of the annotation control points. Increase to increase the selectable area.
        */
        controlPointHitBoxScale: number;
    }
    namespace AnnotationManager {
        /**
         * @param submitFormParams - An object corresponding to the
         * parameters passed when the submitForm API was invoked
         */
        type setBeforeSubmitFormActionCallbackFunction = (submitFormParams: Core.AnnotationManager.SubmitFormParams) => void;
        /**
         */
        type SubmitFormParams = {
            /**
             * An array of field names to submit
             */
            fields: any[];
            /**
             * If true, submit all fields, including those that
            have no value. If false, exclude fields that currently have no value
             */
            empty: boolean;
            /**
             * If true, form data is submitted as FDF. If false,
            it is submitted as XFDF
             */
            fdf: boolean;
            /**
             * The URL to submit the form data to
             */
            url: string;
        };
        /**
         */
        type RedactionInfo = {
            /**
             * The page number of the redaction
             */
            pageNumber: number;
            /**
             * A rect containing the bounding box of the redaction
             */
            rect: Core.Math.Rect;
        };
        /**
         */
        type snapDefaultOptions = {
            /**
             * The distance threshold in pixel for snap feature to be effective.
             */
            radiusThreshold: number;
            /**
             * The side length in pixels of the snap indicator's bounding square.
             */
            indicatorSize: number;
            /**
             * The color of the snap indicator. Accepts CSS HEX or CSS RGBA value.
             */
            indicatorColor: string;
        };
        /**
         */
        type AnnotationChangedInfoObject = {
            /**
             * A boolean that will be true if the annotation change is the result of importing annotations using importAnnotations, importAnnotationCommand or if the imported parameter is set to true when calling addAnnotations or deleteAnnotations
             */
            imported: boolean;
            /**
             * A boolean that will be true if the annotation change is the result of an undo or redo action
             */
            isUndoRedo: boolean;
            /**
             * An optional string that indicates what type of action caused this event (i.e. "redactionApplied")
             */
            source: string;
        };
        /**
         * Represents the types of rotations available to perform on an annotation.
         */
        enum RotationTypes {
            SNAP_ROTATION,
            FREEFORM_ROTATION
        }
    }
    /**
     * Forces a higher level of accuracy in image downsampling at the expense of rendering performance.
     * This function should be called before loading a document to ensure this setting is used.
     * @param advanced - if true advanced image scaling will be used. Can alternatively pass a number for
     * the number of downsampling steps to take. Passing true is equivalent to passing 1.4.
     */
    function setAdvancedImageScaling(advanced: boolean): void;
    /**
     * Syncs the namespaces under the Core namespace attached to the <b>window only</b>.
     * <br/><br/>
     * This is required for interoperability between multiple instances of WebViewer since each loaded instance ends up with different class references despite sharing the same name.
     * @param namespaces - The object containing the namespaces that will be used.
     * @param [namespaces.PDFNet] - The PDFNet namespace. This is probably the most common that needs to be synced.
     * @param [namespaces.Actions] - The Actions namespace.
     * @param [namespaces.Annotations] - The Annotations namespace.
     * @param [namespaces.Math] - The Math namespace.
     * @param [namespaces.Tools] - The Tools namespace.
     */
    function syncNamespaces(namespaces: {
        PDFNet?: any;
        Actions?: any;
        Annotations?: any;
        Math?: any;
        Tools?: any;
    }): void;
    /**
     * Setting the base path that relatively loading documents will be relative to.
     */
    var setBasePath: any;
    /**
     * Create document options.
     */
    type CreateDocumentOptions = {
        /**
         * Same as licenseKey.
         */
        l?: string;
        /**
         * The license key for viewing PDF or Office files (PDF/Office only). You only need to use one of 'l' or 'licenseKey'.
         */
        licenseKey?: string;
        /**
         * An unique identifier for the document, used for offline mode.
         */
        docId?: string;
        /**
         * A callback function for loading progress, function signature function(percent) {}.
         */
        onLoadingProgress?: (...params: any[]) => any;
        /**
         * A callback function that will be called when error occurs in the process of creating a document. function signature function(e) {}
         */
        onError?: (...params: any[]) => any;
        /**
         * The workerTransportPromise that should be used to load the document.
         */
        workerTransportPromise?: Promise<any>;
        /**
         * A password string or a function of the form function(callback) where callback is of the form function(password). This 'password' function will be called when a password is required to load a PDF document and should call the callback with the retrieved password.
         */
        password?: string | ((...params: any[]) => any);
        /**
         * A filename that is used for the downloaded file, and for determining the extension when options.extension isn't used.
         */
        filename?: string;
        /**
         * Used for specifying the extension of the document to be loaded. This is necessary if the URL/path does not contain the file extension or if you're loading a Blob/File.
         */
        extension?: string;
        /**
         * An object containing custom HTTP headers to use when retrieving the document from the specified url. For example: {'Authorization' : 'Basic dXNlcm5hbWU6cGFzc3dvcmQ='}.
         */
        customHeaders?: any;
        /**
         * A boolean indicating whether Downloader should be used on urls (PDF only). https://www.pdftron.com/documentation/web/guides/usedownloader-option/.
         */
        useDownloader?: boolean;
        /**
         * Whether to set the withCredentials property on the XMLHttpRequest.
         */
        withCredentials?: boolean;
        /**
         * An array of objects in the shape of { width: number, height: number }. Used to determine the page sizes when loading an image file.
         */
        pageSizes?: object[];
        /**
         * A string representing the "backend type" for rendering PDF documents. Pass "asm" to force the use of the ASM.js worker, "ems" to force the use of the WebAssembly worker (or ASM.js on non-wasm browsers) or "wasm-threads" to use threaded WebAssembly.
         */
        backendType?: string;
        /**
         * An object that contains the options for a XOD document.
         */
        xodOptions?: {
            decrypt?: boolean;
            decryptOptions?: boolean;
            streaming?: boolean;
            azureWorkaround?: boolean;
            startOffline?: boolean;
        };
        /**
         * A URL to the WebViewer server drop-in backend https://www.pdftron.com/documentation/web/guides/wv-server-deployment.
         */
        webviewerServerURL?: string;
        /**
         * A boolean indicating whether to fall back to client side rendering when WebViewer server fails
         */
        fallbackToClientSide?: boolean;
        /**
         * A key that will be used for caching the document on WebViewer Server.
         */
        cacheKey?: string;
        /**
         * If set to true then when loading a document using WebViewer Server the document will always switch to client only rendering allowing page manipulation and the full API to be used.
         */
        forceClientSideInit?: boolean;
        /**
         * If set to true then this will convert any office file passed in into a PDF document
         */
        loadAsPDF?: boolean;
        /**
         * A field used to specify PDFTron custom security handler. Its value needs to be an integer in [0, 0xFFFFFFFF].
         */
        customHandlerId?: number;
        /**
         * A custom document type. If set then the document type is not determined from the file extension.
         */
        type?: string;
        /**
         * An object used to pass properties down to a custom document type.
         */
        customDocParams?: any;
        /**
         * If true, source will be considered as relative path/url.
         */
        isRelativePath?: boolean;
        /**
         * An object that contains the options for an Office document.
         */
        officeOptions?: {
            templateValues?: Core.TemplateData;
            doTemplatePrep?: boolean;
            disableBrowserFontSubstitution?: boolean;
            formatOptions?: {
                applyPageBreaksToSheet?: boolean;
                displayChangeTracking?: boolean;
                excelDefaultCellBorderWidth?: number;
                excelMaxAllowedCellCount?: number;
                locale?: string;
            };
        };
    };
    /**
     * Creates an initialized Core.Document instance.
     * @param src - Source parameter, path/url to document or File.
     * @param [options] - Create document options.
     * @returns Promise that resolves when doc.loadAsync has been successfully called and returns Core.Document instance.
     */
    function createDocument(src: string | File | ArrayBuffer | Blob | Core.PDFNet.PDFDoc, options?: Core.CreateDocumentOptions): Promise<Core.Document>;
    /**
     * Create DatePicker UI
     * @param options - An object to set the configuration of the date picker
     * @param options.field - The HTML form field the date picker should be bound to
     * @param options.container - DOM node to render calendar into
     * @param options.onDateSelected - Function that is called when the date is selected from the date picker UI
     * @param options.format - the date format showed after select date
     */
    function createDatePicker(options: {
        field: HTMLElement;
        container: HTMLElement;
        onDateSelected: Core.onDateSelected;
        format: string;
    }): void;
    /**
     * Callback function for when a date is selected
     * @param date - selected Date
     */
    type onDateSelected = (date: string) => void;
    /**
     * Display modes that control how the document's page are displayed
     * @property Single - Displays one page at a time.
     * @property Continuous - Displays all the pages in a scrolling view in one column.
     * @property Facing - Displays up to two pages at a time, side by side.
     * @property FacingContinuous - Displays all pages in a scrolling view in two columns.
     * @property Cover - Displays all pages in a scrolling view in two columns.  The first row has a single page in the second column.
     * @property CoverFacing - Same as the Cover display mode except that it is not a scrolling view.
     * @property Custom - Any custom display mode.
     */
    var DisplayModes: {
        /**
         * Displays one page at a time.
         */
        Single: string;
        /**
         * Displays all the pages in a scrolling view in one column.
         */
        Continuous: string;
        /**
         * Displays up to two pages at a time, side by side.
         */
        Facing: string;
        /**
         * Displays all pages in a scrolling view in two columns.
         */
        FacingContinuous: string;
        /**
         * Displays all pages in a scrolling view in two columns.  The first row has a single page in the second column.
         */
        Cover: string;
        /**
         * Same as the Cover display mode except that it is not a scrolling view.
         */
        CoverFacing: string;
        /**
         * Any custom display mode.
         */
        Custom: string;
    };
    /**
     * Constructs a new Display Mode that specifies how the pages are displayed on the screen
     * @param docViewer - The DocumentViewer instance
     * @param mode - The display mode type
     * @param [scrollable] - (Optional) Whether the display mode is scrollable or not
     */
    class DisplayMode {
        constructor(docViewer: any, mode: string, scrollable?: boolean);
        /**
         * Sets parameters of the display mode
         * @param nCols - The number of columns
         * @param nRows - The number of rows
         * @param currentRow - The current row to be displayed
         * @param startRow - The starting row to have in the DOM
         * @param endRow - The ending row to have in the DOM
         */
        setParameters(nCols: number, nRows: number, currentRow: number, startRow: number, endRow: number): void;
        /**
         * Sets callbacks to provide custom functionality when in custom display mode
         * @param fns.pageToWindow - transform coordinates relative to a document page to coordinates relative to the viewer div
         * @param fns.windowToPage - transform coordinates relative to the viewer div relative to a document page
         * @param fns.getSelectedPages - returns an array of currently selected page indices
         * @param fns.getVisiblePages - returns an array of currently visible pages
         * @param fns.getPageTransform - returns the offsets of a page container
         * @param fns.createPageSections - lays out pageSection and pageContainer divs to DocumentViewer can put content in them
         */
        setCustomFunctions(): void;
        /**
         * Returns whether or not the display is continuous
         * @returns true if the display mode is continuous i.e. shows more than one row at a time
         */
        isContinuous(): boolean;
        /**
         * Converts page coordinates to window coordinates.
         * @param pagePt - A object with x and y properties in page coordinates
         * @param pageNumber - The page number
         * @returns An object with the page index as well as x and y values in window coordinates
         */
        pageToWindow(pagePt: any, pageNumber: number): any;
        /**
         * Converts window coordinates to page coordinates.
         * @param windowPt - A object with x and y properties in window coordinates
         * @param pageNumber - The page number
         * @returns An object with the page number as well as x and y values in page coordinates
         */
        windowToPage(windowPt: any, pageNumber: number): any;
        /**
         * Gets the indexes of the first and last pages selected.
         * @param mousePt1 - The starting mouse point, an object with x and y properties
         * @param mousePt2 - The ending mouse point, an object with x and y properties
         * @returns An object with a 'first' property being the first page selected and a 'last'
         *      property being the last page selected.  last must be >= first.
         */
        getSelectedPages(mousePt1: any, mousePt2: any): any;
        /**
         * Returns an array of page indexes that are visible on screen.
         * @param [amountAhead] - The amount of space ahead of the viewport to count as visible as a multiple of the screen height (default is 0.5)
         * @param [amountSide] - The amount of space to the side of the viewport to count as visible as a multiple of the screen height (default is 0.5)
         * @returns an array page numbers.
         */
        getVisiblePages(amountAhead?: number, amountSide?: number): number[];
        /**
         * Returns the amount the page is shifted relative to the viewport
         * @param pageNumber - The number of the page
         * @returns An object with x and y properties of the amount the page is shifted relative to the viewport
         *      and width and height properties of the page.
         */
        getPageTransform(pageNumber: number): any;
        /**
         * Returns the amount the page is offset from its container
         * @param pageNumber - The number of the page
         * @returns An object with x and y properties of the amount the page is offset from its container
         */
        getPageOffset(pageNumber: number): any;
        /**
         * Returns the current display mode.
         * @returns The current display mode
         */
        getMode(): string;
    }
    /**
     * Creates a new instance of DisplayModeManager
     * @param docViewer - The DocumentViewer instance
     */
    class DisplayModeManager {
        constructor(docViewer: any);
        /**
         * Returns the current display mode.
         * @returns The current display mode.
         */
        getDisplayMode(): any;
        /**
         * Disable virtual display mode and switch to non-virtual display mode.
         */
        disableVirtualDisplayMode(): void;
        /**
         * Check if virtual display mode for pages is enabled
         */
        isVirtualDisplayEnabled(): void;
        /**
         * Sets the display mode. Also removes selection caused by text selection or search.
         * Only renders if a document has been loaded.
         * @param displayMode - The display mode object to set as the current display mode
         */
        setDisplayMode(displayMode: any): void;
    }
    /**
     * BaseDocument is used to alert if a Document implementation is not following the Document interface.
     */
    function BaseDocument(): void;
    /**
     * Bookmarks typically represent an outline of the document, and as each bookmark is usually associated with a specific page in a document, they are typically used to facilitate navigation.
     * @param children - A list of child bookmarks
     * @param name - The name of the bookmark
     * @param pageNumber - The page number of the bookmark
     * @param parent - The parent bookmark of this bookmark
     * @param verticalOffset - The vertical position that the linked page will be scrolled to
     * @param horizontalOffset - The horizontal position that the linked page will be scrolled to
     * @param [url] - An optional parameter that allows the bookmark to link to a URL instead of a page number (this overrides the page number)
     * @param [index] - An optional parameter that indicates the position of the bookmark among its siblings
     * @param [objNum] - The PDF object number of the bookmark
     */
    class Bookmark {
        constructor(children: Core.Bookmark[], name: string, pageNumber: number, parent: Core.Bookmark, verticalOffset: number, horizontalOffset: number, url?: string, index?: number, objNum?: number);
        /**
         * Gets the children of the bookmark.
         * @returns The children of the bookmark
         */
        getChildren(): Core.Bookmark[];
        /**
         * Gets the name of the bookmark.
         * @returns The name of the bookmark
         */
        getName(): string;
        /**
         * Gets the page number of the bookmark.
         * @returns The page number of the bookmark
         */
        getPageNumber(): number;
        /**
         * Gets the url of the bookmark if it has one.
         * @returns The url of the bookmark
         */
        getURL(): string;
        /**
         * Gets the parent of this bookmark if it has one.
         * @returns The parent of the bookmark
         */
        getParent(): Core.Bookmark;
        /**
         * Gets the vertical position of the bookmark.
         * @returns The vertical position of the bookmark
         */
        getVPos(): number;
        /**
         * Gets the vertical position of the bookmark.
         * @returns The vertical position of the bookmark
         */
        getVerticalPosition(): number;
        /**
         * Gets the horizontal position of the bookmark.
         * @returns The horizontal position of the bookmark
         */
        getHPos(): number;
        /**
         * Gets the horizontal position of the bookmark.
         * @returns The horizontal position of the bookmark
         */
        getHorizontalPosition(): number;
        /**
         * Gets the index of the bookmark among its siblings
         * @returns The index of the bookmark
         */
        getIndex(): number;
        /**
         * Determines whether the bookmark goes to a valid destination.
         * @returns Whether the bookmark points to a valid destination
         */
        isValid(): boolean;
        /**
         * Gets the PDF object number of the bookmark.
         * @returns The PDF object number of the bookmark
         */
        getObjNum(): number;
    }
    /**
     * Control the time between progressive events when rendering a more complex page.
     * @param milliseconds - the number of milliseconds between progressive events. By default this is disabled for XOD and 3 seconds (3000) otherwise.
     */
    function setProgressiveTime(milliseconds: number): void;
    /**
     * Set the allowed file extensions.
     * @param fileExtensionArray - An array of file extensions, not case sensitive. An empty array will allow any supported file extension to be loaded.
     */
    function setAllowedFileExtensions(fileExtensionArray: string[]): void;
    /**
     * Get the array of allowed file extensions. An empty array indicates all supported file extensions are allowed.
     */
    function getAllowedFileExtensions(): void;
    /**
     * Set the caching level between 0 and 10, where 0 is no caching and 10 uses a very large cache. The default is 6.
     * @param level - The level to set
     */
    function SetCachingLevel(level: number): void;
    /**
     * Set the pre-render level between 0 and 10, where 0 has pre-rendering and 10 has a lot of pre-rendering.
     * @param level - The level to set
     */
    function SetPreRenderLevel(level: number): void;
    /**
     * Constructs a new empty Document, representing a document with individual pages (canvases) that can be displayed on screen and printed.
     * @param id - Unique string identifier for the document
     * @param type - The type of document that should be instantiated.
     * Values are 'xod' for XOD documents, 'pdf' for PDF, JPG or PNG documents, 'office' for MS Office documents and 'webviewerServer' for WebViewer Server documents
     */
    class Document extends Core.EventHandler {
        constructor(id: string, type: string);
        /**
         * Register new document type with Document class
         * @param type - Name of the new document type
         * @param source - Class of the new document
         * @param exposedFuncs - An array containing strings of the function names to expose on the document object
         */
        static registerDocumentType(type: string, source: any, exposedFuncs: string[]): boolean;
        /**
         * Unregister existing document type form Document class
         * @param type - Name of registered document type
         */
        static unregisterDocumentType(type: string): boolean;
        /**
         * Gets the type of the document.
         * @returns The type of the document (xod, pdf, office, webviewerServer)
         */
        getType(): string;
        /**
         * Gets whether the document will be interacted with as a WebViewer Server document
         * This will return false if the document was loaded from WebViewer Server but forceClientSideInit is set to true
         * @returns Returns whether the document will be interacted with as a WebViewer Server document.
         */
        isWebViewerServerDocument(): boolean;
        /**
         * Cancels the request made for thumbnail with the specified request Id
         * @param requestId - The id returned from loadThumbnailAsync
         */
        cancelLoadThumbnail(requestId: number): void;
        /**
         * Cancels the loadCanvasAsync call corresponding to the passed in id
         * @param id - The id returned from the loadCanvasAsync call that will be cancelled.
         */
        cancelLoadCanvas(id: number): void;
        /**
         * Unloads resources for the page associated with the loadCanvasAsync call corresponding to the passed in id.
         * So if the loadCanvasAsync call had requested page 2 then page 2's resources will be cleaned up
         * (as long as nothing else requires those resources). Note that the canvas element itself is not touched.
         * @param id - The id returned from the loadCanvasAsync call that will have it's page resources unloaded
         */
        unloadCanvasResources(id: number): void;
        /**
         * Cancels a download for offline mode in progress.  If there is no current download then this does nothing.
         */
        cancelOfflineModeDownload(): void;
        /**
         * Returns an array containing the bookmarks in the document.
         * @returns A promise resolving to an array containing the bookmarks in the current document.
         */
        getBookmarks(): Promise<Core.Bookmark[]>;
        /**
         * Returns an array containing the links on the specified page of the document.
         * @param pageNumber - The page number, one-indexed, that the links are on.
         * @returns An array containing the links on the specified page of the document.
         */
        getLinks(pageNumber: number): string[];
        /**
         * Returns whether offline mode is currently enabled or not.
         */
        getOfflineModeEnabled(): void;
        /**
         * Returns the number of pages in a document.
         * @returns The number of the pages in the current document.
         */
        getPageCount(): number;
        /**
         * Returns an object containing the width and height of a page.
         * @param pageNumber - The page number of the requested page.
         * @returns An object representing the page info. Contains the properties "width" and "height".
         */
        getPageInfo(pageNumber: number): Core.Document.PageInfo;
        /**
         * Returns an object with the original x and y coordinates converted to PDF coordinates for the page.
         * @param pageNumber - The page number that the coordinates are on
         * @param x - The x coordinate
         * @param y - The y coordinate
         * @returns An object with the x and y PDF coordinates
         */
        getPDFCoordinates(pageNumber: number, x: number, y: number): any;
        /**
         * Gets quads for each of the characters from start to end index.
         * @param pageNumber - The page number that the text is on.
         * @param textStartIndex - The position where to start getting character quads from.
         * @param textEndIndex - The position (up to, but not including) where to finish getting characters.
         * @returns Resolves with quads, which is an array of objects with (x1,y1,x2,y2,x3,y3,x4,y4)
         */
        getTextPosition(pageNumber: number, textStartIndex: number, textEndIndex: number): Promise<object[]>;
        /**
         * Returns an object with the original x and y PDF coordinates converted to XOD coordinates for the page.
         * @param pageNumber - The page number that the coordinates are on
         * @param x - The x coordinate
         * @param y - The y coordinate
         * @returns An object with the x and y XOD coordinates
         */
        getXODCoordinates(pageNumber: number, x: number, y: number): any;
        /**
         * Returns an object with the original x and y PDF coordinates converted to Viewer coordinates for the page.
         * @param pageNumber - The page number that the coordinates are on
         * @param x - The x coordinate
         * @param y - The y coordinate
         * @returns An object with the x and y Viewer coordinates
         */
        getViewerCoordinates(pageNumber: number, x: number, y: number): any;
        /**
         * Returns an object with metadata associated with the document.
         * @returns A promise that resolves to an object with document metadata
         */
        getMetadata(): Promise<object>;
        /**
         * Used to know if a document contains thumbnails.
         * @returns True if the document contains thumbnails.
         */
        includesThumbnails(): boolean;
        /**
         * [XOD Document only] Initializes the offline database for use.  Must be called before any other offline mode functions are used.
         * @returns Resolves when offline database is ready for use.
         */
        initOfflineDB(): Promise<void>;
        /**
         * [XOD Document only] Whether the document has already been downloaded for offline mode or not.
         */
        isDownloaded(): void;
        /**
         * Initialize a Document so that it can be used to load page canvases.
         * @param partRetriever - An instance of PartRetriever.
         * @param options - an object that can contain the following optional parameters
         * @param [options.workerTransportPromise] - Required to load a PDF or Office file. A promise that will be resolved when a worker transport has been initialized. This can be created by calling Core.initPDFWorkerTransports or Core.initOfficeWorkerTransports as appropriate.
         * @param [options.getPassword] - A method of the form function(callback) where callback is of the form function(password). getPassword will be called when a password is required to load a PDF document and should call the callback with the retrieved password.
         * @param [options.extension] - A field used to specify the type of file being read. This is only relevant for PDF viewing and at the moment only works for certain image formats and .pdf
         * @param [options.customHandlerId] - A field used to specify PDFTron custom security handler. Its value needs to be an integer in [0, 0xFFFFFFFF].
         * @returns Resolves when document is initialized, or rejects with error.
         */
        loadAsync(partRetriever: Core.PartRetrievers.PartRetriever, callback: Core.Document.LoadAsyncCallback, options: {
            workerTransportPromise?: Promise<any>;
            getPassword?: (...params: any[]) => any;
            extension?: string;
            customHandlerId?: number;
        }): Promise<void>;
        /**
         * Update rasterizer options of the document
         * @param options - Options for this function
         * @param [options.pageTransparent = false] - Page background transparency.
         * @param [options.overprintMode = Core.OverprintPreviewMode.PDFX_ON] - Enable or disable support for overprint and overprint simulation.
         * @param [options.antiAliasing = true] - Enable or disable anti-aliasing.
         * @param [options.pathHinting = true] - Enable or disable path hinting.
         * @param [options.thinLinePixelGridFit = false] - If true (horizontal/vertical) thin lines will be snapped to integer pixel positions.
         * @param [options.thinLineStrokeAdjust = true] - Enable or disable auto stroke adjustment.
         * @param [options.imageSmoothing = true] - Enable or disable image smoothing.
         * @param [options.hqImageResampling = false] - Whether use a higher quality (but slower) smoothing algorithm.
         * @param [options.caching = true] - Enables or disables caching. Caching can improve the rendering performance in cases where the same page will be drawn multiple times.
         * @param [options.expGamma = -1.0] - The gamma factor used for anti-aliased rendering. It is the exponent value of gamma function. Typical values are in the range from 0.1 to 3.
         * @param [options.colorPostProcessMode = Core.ColorPostProcessMode.NONE] - Set the color post processing transformation. This transform is applied to the rasterized bitmap as the final step in the rasterization process, and is applied directly to the resulting bitmap (disregarding any color space information). Note that this option has no effect when using Core.OverprintPreviewMode.SEPARATION_RENDER.
         * @param [options.renderAnnots = false] - Enable or disable annotation and forms rendering (In the viewer, annotation rendering is done separately).
         * @param [options.highlightFields = false] - Enable or disable highlighting form fields. This option only has an effect when renderAnnots is true.
         * @param [options.isPrinting = false] - Tells the rasterizer to render the page 'print' mode. Certain page elements (such as annotations or OCG-s) are meant to be visible either on the screen or on the printed paper but not both. A common example, is the "Submit" button on electronic forms.
         * @returns returns true if document can update rasterizer options
         */
        updateRasterizerOptions(options: {
            pageTransparent?: boolean;
            overprintMode?: number;
            antiAliasing?: boolean;
            pathHinting?: boolean;
            thinLinePixelGridFit?: boolean;
            thinLineStrokeAdjust?: boolean;
            imageSmoothing?: boolean;
            hqImageResampling?: boolean;
            caching?: boolean;
            expGamma?: number;
            colorPostProcessMode?: number;
            renderAnnots?: boolean;
            highlightFields?: boolean;
            isPrinting?: boolean;
        }): boolean;
        /**
         * Loads a canvas for a particular page number.
         * @param options - An object specifying the options for loading the canvas. The following parameters should be properties on this object. The only non-optional parameter is pageNumber.
         * @param options.pageNumber - The page number of the requested canvas.
         * @param [options.zoom] - The zoom value to render the page at.
         * @param [options.getZoom] - A function that returns the zoom value to render the page at. Use this instead of "zoom" if the value might change in the process of setting up the canvas.
         * @param [options.pageRotation] - The rotation of the page. Valid values are Core.PageRotation.E_0, Core.PageRotation.E_90, Core.PageRotation.E_180, Core.PageRotation.E_270.
         * @param [options.getPageRotation] - A function that returns the rotation of the page. Use this instead of "pageRotation" if the value might change in the process of setting up the canvas.
         * @param [options.finishedLoading] - A callback called after the list of page resources is retrieved. Return true if rendering should continue, false otherwise.
         * @param [options.acquireResources] - A function that returns whether resources need to be acquired or not, defaults to true.
         * @param [options.resourcesLoaded] - A callback called after the page's resources have been loaded. Return true if rendering should continue, false otherwise.
         * @param [options.getPageTransform] - A function that returns the x and y values of the page's translation.
         * @param [options.drawComplete] - The callback to call when the canvas has been completely rendered. The first parameter is a canvas object, and the second parameter is the page number.
         * @param [options.drawProgressive] - The callback to call when the canvas has been partially rendered.
         * @param [options.renderRect] - An object with x1, y1, x2, y2 properties which is the partial rectangle to render of the entire page. The top left of the page is (0, 0).
         * @param [options.useProgress] - Whether progressive rendering should be used or not.
         * @param [options.height] - Used to calculate the zoom level if zoom level is not provided. If it's passed the zoom level will be set so the document fits this height. If both width and height are passed the zoom level will be set so the document fits the box delimited by them.
         * @param [options.width] - Used to calculate the zoom level if zoom level is not provided. If it's passed the zoom level will be set so the document fits this width. If both width and height are passed the zoom level will be set so the document fits the box delimited by them.
         * @param [options.multiplier] - The quality of the loaded canvas. Must be a positive number. Higher values are higher quality but take longer to complete and use more memory.
         * @param [options.source] - Indicate the origin of the call. This may be used by the Document's implementation of loadCanvasAsync.
         * @returns An id that can be passed to the corresponding Pause, Resume or Cancel functions
         */
        loadCanvasAsync(options: {
            pageNumber: number;
            zoom?: number;
            getZoom?: (...params: any[]) => any;
            pageRotation?: Core.PageRotation;
            getPageRotation?: (...params: any[]) => any;
            finishedLoading?: (...params: any[]) => any;
            acquireResources?: (...params: any[]) => any;
            resourcesLoaded?: (...params: any[]) => any;
            getPageTransform?: (...params: any[]) => any;
            drawComplete?: (...params: any[]) => any;
            drawProgressive?: (...params: any[]) => any;
            renderRect?: any;
            useProgress?: boolean;
            height?: number;
            width?: number;
            multiplier?: number;
            source?: string;
        }): string;
        /**
         * Loads a canvas for a particular page number.
         * @param options - An object specifying the options for loading the canvas. The following parameters should be properties on this object. The only non-optional parameter is pageNumber.
         * @param options.pageNumber - The page number of the requested canvas.
         * @param [options.zoom] - The zoom value to render the page at.
         * @param [options.getZoom] - A function that returns the zoom value to render the page at. Use this instead of "zoom" if the value might change in the process of setting up the canvas.
         * @param [options.pageRotation] - The rotation of the page. Valid values are Core.PageRotation.E_0, Core.PageRotation.E_90, Core.PageRotation.E_180, Core.PageRotation.E_270.
         * @param [options.getPageRotation] - A function that returns the rotation of the page. Use this instead of "pageRotation" if the value might change in the process of setting up the canvas.
         * @param [options.finishedLoading] - A callback called after the list of page resources is retrieved. Return true if rendering should continue, false otherwise.
         * @param [options.acquireResources] - A function that returns whether resources need to be acquired or not, defaults to true.
         * @param [options.resourcesLoaded] - A callback called after the page's resources have been loaded. Return true if rendering should continue, false otherwise.
         * @param [options.getPageTransform] - A function that returns the x and y values of the page's translation.
         * @param [options.drawComplete] - The callback to call when the canvas has been completely rendered. The first parameter is a canvas object, and the second parameter is the page number.
         * @param [options.drawProgressive] - The callback to call when the canvas has been partially rendered.
         * @param [options.renderRect] - An object with x1, y1, x2, y2 properties which is the partial rectangle to render of the entire page. The top left of the page is (0, 0).
         * @param [options.useProgress] - Whether progressive rendering should be used or not.
         * @param [options.height] - Used to calculate the zoom level if zoom level is not provided. If it's passed the zoom level will be set so the document fits this height. If both width and height are passed the zoom level will be set so the document fits the box delimited by them.
         * @param [options.width] - Used to calculate the zoom level if zoom level is not provided. If it's passed the zoom level will be set so the document fits this width. If both width and height are passed the zoom level will be set so the document fits the box delimited by them.
         * @param [options.multiplier] - The quality of the loaded canvas. Must be a positive number. Higher values are higher quality but take longer to complete and use more memory.
         * @param [options.source] - Indicate the origin of the call. This may be used by the Document's implementation of loadCanvasAsync.
         * @returns An id that can be passed to the corresponding Pause, Resume or Cancel functions
         */
        loadCanvas(options: {
            pageNumber: number;
            zoom?: number;
            getZoom?: (...params: any[]) => any;
            pageRotation?: Core.PageRotation;
            getPageRotation?: (...params: any[]) => any;
            finishedLoading?: (...params: any[]) => any;
            acquireResources?: (...params: any[]) => any;
            resourcesLoaded?: (...params: any[]) => any;
            getPageTransform?: (...params: any[]) => any;
            drawComplete?: (...params: any[]) => any;
            drawProgressive?: (...params: any[]) => any;
            renderRect?: any;
            useProgress?: boolean;
            height?: number;
            width?: number;
            multiplier?: number;
            source?: string;
        }): string;
        /**
         * Gets all the text on the requested page.
         * @param pageNumber - The page number that the text is on.
         * @returns A promise that resolves with the page's text.
         */
        loadPageText(pageNumber: number): Promise<string>;
        /**
         * Gets the XFDF data for the document's internal annotations.
         * @param [pages] - An array of page numbers to get the XFDF data for the document. Note: Only one page
         * is supported by XOD documents. For PDF documents if no parameter is passed then the XFDF data for the entire document is returned.
         * @returns A promise that resolves to an object with an xfdfString property and a pages property where pages is the array of page numbers that annotations were extracted from
         */
        extractXFDF(pages?: number[]): Promise<Core.Document.XFDFInfo>;
        /**
         * Loads a thumbnail image for a particular page.
         * @param pageNumber - The page number of the requested thumbnail (1-indexed).
         * @param onLoadThumbnail - The callback to call when the thumbnail has been retrieved. Accepts an HTMLImageElement or HTMLCanvasElement as a parameter.
         * @returns The id of the request that can later be used for cancelling the request
         * It is passed an image element if the .xod file contains thumbnails and a canvas element otherwise.
         */
        loadThumbnailAsync(pageNumber: number, onLoadThumbnail: (...params: any[]) => any): string;
        /**
         * Loads a thumbnail image for a particular page.
         * @param pageNumber - The page number of the requested thumbnail (1-indexed).
         * @param onLoadThumbnail - The callback to call when the thumbnail has been retrieved. Accepts an HTMLImageElement or HTMLCanvasElement as a parameter.
         * @returns The id of the request that can later be used for cancelling the request
         * It is passed an image element if the .xod file contains thumbnails and a canvas element otherwise.
         */
        loadThumbnail(pageNumber: number, onLoadThumbnail: (...params: any[]) => any): string;
        /**
         * Pauses the loadCanvasAsync call corresponding to the passed in id
         * @param id - The id returned from the loadCanvasAsync call that will be paused.
         */
        pauseLoadCanvas(id: number): void;
        /**
         * Resumes the loadCanvasAsync call corresponding to the passed in id
         * @param id - The id returned from the loadCanvasAsync call that will be resumed.
         */
        resumeLoadCanvas(id: number): void;
        /**
         * Returns the PDFNet.PDFDoc object associated with the document. Note that the full API is required to be enabled
         * and WebViewer Server cannot be enabled.
         * @returns A promise that resolves to the PDFDoc object.
         */
        getPDFDoc(): Promise<Core.PDFNet.PDFDoc>;
        /**
         * [XOD Document only] Sets whether offline mode is enabled or not.
         * @param enabled - The new value for whether offline mode is enabled or not.
         */
        setOfflineModeEnabled(enabled: boolean): void;
        /**
         * [XOD Document only] Enable offline mode.
         */
        enableOfflineMode(): void;
        /**
         * [XOD Document only] Disable offline mode.
         */
        disableOfflineMode(): void;
        /**
         * [XOD Document only] Downloads the document for offline viewing.
         * @param onComplete - The function that's called when the document has finished being downloaded or the download has been cancelled
         * @param onProgress - The function that's called on each update in progress of the download.
         * The fraction downloaded is passed as a parameter. (eg 50% downloaded passes 0.5)
         */
        storeOffline(onComplete: (...params: any[]) => any, onProgress: (...params: any[]) => any): void;
        /**
         * Cleans up the resources associated with the document.
         */
        unloadResources(): void;
        /**
         * Refresh the text data stored by the viewer.
         * Useful if the text content of the document has changed, e.g. after a redaction.
         */
        refreshTextData(): void;
        /**
         * Sets the flags with which to extract the text from a PDF document.
         * @param flags - The flags with which to extract the text from a PDF document. See {@link Core.TextExtractorProcessingFlags}
         */
        setTextExtractorProcessingFlags(flags: number[]): void;
        /**
         * [PDF/Office Document only] Asynchronously saves the document and provides the result as an ArrayBuffer.
         * To include annotations in the saved document, please provide an object with the xfdfString property.
         * @param [options] - An optional object containing save options and parameters.
         * @param [options.xfdfString] - An xfdf string containing annotation data to be used when saving. This will usually be retrieved by calling exportAnnotations on a Core.AnnotationManager object.
         * @param [options.flatten] - A flag that is only useful when the xfdfString option is used. If true all the annotations in the saved document will be flattened.
         * @param [options.finishedWithDocument] - A flag specifying that the document data may be discarded by the worker after use.
         * Only use this when completely finished with document processing. When handling larger documents this can be useful to avoid memory exhaustion as only one copy of the document needs to be kept.
         * @param [options.printDocument] - If true the saved document data will have an open action specifying that it should be printed. This is mostly only used to trigger print actions in the browser's PDF Viewer.
         * @param [options.downloadType] - The file type to download as, where the default is the source type. PDF and image files can only be downloaded as PDFs, but office files can be downloaded as "pdf" or as "office" if you want to get the original file without annotations.
         * @param [options.flags] - The flags with which to save the document.
         * Possible values include Core.SaveOptions.REMOVE_UNUSED (remove unused objects during save) and Core.SaveOptions.LINEARIZED (optimize the document for fast web view and remove unused objects). The default value is Core.SaveOptions.REMOVE_UNUSED.
         * @param [options.includeAnnotations] - If false, all annotations will be removed from PDF document.
         * @returns a promise that resolves to an array buffer containing PDF document bytes.
         */
        getFileData(options?: {
            xfdfString?: string;
            flatten?: boolean;
            finishedWithDocument?: boolean;
            printDocument?: boolean;
            downloadType?: string;
            flags?: number;
            includeAnnotations?: boolean;
        }): Promise<ArrayBuffer>;
        /**
         * [PDFTron Server only] Provides a URL to a the PDF with annotations and watermarks merged, and an open action specifying that it should be printed.
         * @returns Will be null if not supported. Otherwise a promise that resolves to an object with a `url` property pointing to the printable PDF.
         */
        getPrintablePDF(): Promise<object> | null;
        /**
         * Get the document filename used for downloading.
         * @returns filename of the document.
         */
        getFilename(): string;
        /**
         * [PDFTron Server only] Provides a URL to a the PDF with annotations and watermarks merged.
         * @param [options] - An optional object containing download options and parameters.
         * @param [options.filename] - The preferred name for the downloaded file on the client side. This has no effect on the backend target of the returned link, only the filename used by the browser when the link is accessed.
         * @returns Will be null if not supported. Otherwise a promise that resolves to an object with a `url` property pointing to the printable PDF.
         */
        getDownloadLink(options?: {
            filename?: string;
        }): Promise<object> | null;
        /**
         * [Office Document only] Provides information about the template keys present in the document.
         * Must have loaded the document with officeOptions.doTemplatePrep, officeOptions.templateValues, or called {@link setTemplatevalues} before calling this function.
         * @param [format] - Specifies what type of information to return.  Defaults to 'flat'.
         * 'flat' returns a list of all top-level keys used in the document.  Keys used in loop bodies are not included in this list, however, this may change in the future.
         * 'schema' returns a detailed {@link Core.TemplateSchema schema} of the keys used in the document, containing information such as the inferred type of key data.
         * 'locations' returns a collection of the {@link Core.TemplateBoundingBoxes bounding boxes} of template content in the document
         *     If the template document has been prepped but not filled (officeOptions.doTemplatePrep option has been set), it will return bounding boxes for the template tag text.
         *     If the template document has been filled ({@link applyTemplateValues} has been called), it will return bounding boxes for the inserted content.
         * @returns A promise that resolves to the requested data.
         */
        getTemplateKeys(format?: 'flat' | 'schema' | 'locations'): Promise<string[] | Core.TemplateSchema | Core.TemplateBoundingBoxes>;
        /**
         * [PDF Document only] Inserts a set of pages from the provided Document before a given page number. Note that this method will need to wait for the entire file to be downloaded before the change is applied.
         * @param sourceDocument - other document from which to take pages (cannot be the same document)
         * @param [pageArray] - An optional array of page numbers to extract from the given document. If not passed in, will insert all pages.
         * @param [insertBeforeThisPage] - An optional page number before which to insert the pages. If not passed in, will append to the end.
         * @returns a promise that resolves to an object describing the updated state of the pages in the document
         */
        insertPages(sourceDocument: Core.Document, pageArray?: number[], insertBeforeThisPage?: number): Promise<object>;
        /**
         * [PDF Document only] Moves the pages given in an array so they appear in sequence before a given page number. Note that this method will need to wait for the entire file to be downloaded before the change is applied.
         * @param pageArray - the page numbers to move
         * @param insertBeforeThisPage - page number before which to insert the other pages
         * @returns a promise that resolves to an object describing the updated state of the pages in the document
         */
        movePages(pageArray: number[], insertBeforeThisPage: number): Promise<object>;
        /**
         * [PDF Document only] Removes the given page numbers. Note that this method will need to wait for the entire file to be downloaded before the change is applied.
         * @param pageArray - the page numbers to remove
         * @returns a promise that resolves to an object describing the updated state of the pages in the document
         */
        removePages(pageArray: number[]): Promise<object>;
        /**
         * [PDF Document only][PDFNetJS full only] Get the updated context of a document as a PDFNet object.
         * @param layers - layers
         * @returns a promise that resolves to a PDFNet Context object representing the current layers/OCG state.
         */
        extractPDFNetLayersContext(layers: any): Promise<object>;
        /**
         * [PDF Document only] Adds the given rotation to the given pages. Note that this method will need to wait for the entire file to be downloaded before the change is applied.
         * @param pageArray - an array of the numbers of pages to rotate
         * @param rotation - the page rotation to add
         * @returns a promise that resolves to an object describing the updated state of the pages in the document
         */
        rotatePages(pageArray: number[], rotation: Core.PageRotation): Promise<object>;
        /**
         * [PDF Document only] Extract the given pages from the document. Note that this method will need to wait for the entire file to be downloaded before the change is applied.
         * @param pageArray - an array of the page numbers to extract
         * @param [xfdfString] - Optional XFDF string to merge into the document before extracting
         * @returns a promise that resolves on completion
         */
        extractPages(pageArray: number[], xfdfString?: string): Promise<any>;
        /**
         * [PDF Document only] Merge a file into the currently opened document
         * @param source - Source parameter, path/url to document or File.
         * @param [position] - Optional position for where to merge the document, default to end of file if nothing entered
         * @returns a promise that resolves on completion
         */
        mergeDocument(source: string | File | ArrayBuffer | Blob, position?: number): Promise<any>;
        /**
         * [PDF Document only] Crop the given pages by the given margins. Note that this method will need to wait for the entire file to be downloaded before the change is applied.
         * @param pageArray - an array of page numbers to crop
         * @param topMargin - how much to crop from the top
         * @param botMargin - how much to crop from the bottom
         * @param leftMargin - how much to crop from the left
         * @param rightMargin - how much to crop from the right
         * @returns a promise that resolves to an object describing the updated state of the pages in the document
         */
        cropPages(pageArray: number[], topMargin: number, botMargin: number, leftMargin: number, rightMargin: number): Promise<object>;
        /**
         * [PDF Document only] Get an array describing the layers/OCG structure in the document.
         * @returns A promise that resolves to an array representing the layers in the PDF document
         */
        getLayersArray(): Promise<Core.Document.LayerContext[]>;
        /**
         * [PDF Document only] Update the array describing the layers/OCG structure in order
         * to adjust which layers should be enabled or disabled.
         * The layers updated event is triggered as a side effect
         * @param layersContext - the OCG layers to set
         */
        setLayersArray(layersContext: Core.Document.LayerContext[]): void;
        /**
         * [PDF Document only] Set the overprint preview mode to be used when rendering
         * this document.
         * @param mode - The mode to use. Possible values are Core.OverprintPreviewMode.OFF,
         * Core.OverprintPreviewMode.ON and Core.OverprintPreviewMode.PDFX_ON
         */
        setOverprintPreviewMode(mode: any): void;
        /**
         * [PDF Document only] Ensures that a particular page of the pdf document is finished loading before reading, writing or rendering it.
         * @param pageNumber - The page number to ensure completion of loading
         * @returns a promise that resolves when the page has been loaded
         */
        requirePage(pageNumber: number): Promise<void>;
        /**
         * Returns an object representing the transformation matrix for the page.
         * @param pageNumber - The page number of the requested page.
         * @returns An object representing the page matrix.
         */
        getPageMatrix(pageNumber: number): any;
        /**
         * Returns the internal degrees of rotation of a page.
         * @param pageNumber - The page number of the requested page.
         * @returns The internal degrees of rotation of a page. (0, 90, 180 or 270)
         */
        getPageRotation(pageNumber: number): number;
        /**
         * @returns returns user defined document id passed in WebViewer constructor constorctor or loadDocument API, e.g.
         * WebViewer({ documentId: 'foo-11', initialDoc: 'url'  }) or instance.loadDocument(url, { documentId: 'foo-11' })
         */
        getDocumentId(): string;
        /**
         * @returns A promise that resolves when all of the page information is available for the document
         */
        documentCompletePromise(): Promise<any>;
        /**
         * @returns A promise that resolves when all of the page information is available for the document
         */
        getDocumentCompletePromise(): Promise<any>;
        /**
         * [PDF Document only] Inserts blank pages before the given list of pages. Both width and height are in units of PDF points.
         * @param insertBeforeThesePages - array of page numbers before which to insert blanks
         * @param width - width of the blank pages to insert. By default the width is 612 PDF points.
         * @param height - height of the blank pages to insert. By default the height is 792 PDF points.
         * @returns a promise that resolves to an object with info for any pages inserted
         */
        insertBlankPages(insertBeforeThesePages: number[], width: number, height: number): Promise<object>;
        /**
         * [PDF Document only] Returns whether the document is linearized or not.
         * Note that this only works for documents that are loaded by URL and if useDownloader is not set to false.
         * @returns Whether the document is linearized or not
         */
        isLinearized(): boolean;
        /**
         * Sets watermark to be added to the document
         * @example
         * doc.setWatermark({
         *   diagonal: {
         *     fontSize: (number),
         *     fontFamily: (string),
         *     color: (string),
         *     opacity: (number (between 0 and 100)),
         *     text: (string)
         *   },
         *   header: {
         *     fontSize: (number),
         *     fontFamily: (string),
         *     color: (string),
         *     opacity: (number (between 0 and 100)),
         *     left: (string),
         *     center: (string),
         *     right: (string)
         *   },
         *   footer: {
         *     fontSize: (number),
         *     fontFamily: (string),
         *     color: (string),
         *     opacity: (number (between 0 and 100)),
         *     left: (string),
         *     center: (string),
         *     right: (string)
         *   }
         *   custom: (function(ctx, pageIndex, pageWidth, pageHeight))
         * });
         *
         * To allow more customization of the header/footer, the following can be done:
         *
         * doc.setWatermark({
         * diagonal: {
         *   fontSize: (number),
         *   fontFamily: (string),
         *   color: (string),
         *   opacity: (number (between 0 and 100)),
         *   text: (string)
         * },
         * headerLeft: {
         *   fontSize: (number),
         *   fontFamily: (string),
         *   color: (string),
         *   opacity: (number (between 0 and 100)),
         *   text: (string)
         * },
         * headerCenter: {
         *   fontSize: (number),
         *   fontFamily: (string),
         *   color: (string),
         *   opacity: (number (between 0 and 100)),
         *   text: (string)
         * },
         * headerRight: {
         *   fontSize: (number),
         *   fontFamily: (string),
         *   color: (string),
         *   opacity: (number (between 0 and 100)),
         *   text: (string)
         * },
         * footerLeft: {
         *   fontSize: (number),
         *   fontFamily: (string),
         *   color: (string),
         *   opacity: (number (between 0 and 100)),
         *   text: (string)
         * },
         * footerCenter: {
         *   fontSize: (number),
         *   fontFamily: (string),
         *   color: (string),
         *   opacity: (number (between 0 and 100)),
         *   text: (string)
         * },
         * footerRight: {
         *   fontSize: (number),
         *   fontFamily: (string),
         *   color: (string),
         *   opacity: (number (between 0 and 100)),
         *   text: (string)
         * },
         * custom: (function(ctx, pageIndex, pageWidth, pageHeight))
         * });
         * @param options - Object that contains style/content of the watermark
         */
        setWatermark(options: any): void;
        /**
         * [PDF Document only] Enables the color separations feature for rendering.
         * the boolean parameter is deprecated since version 8.0
         * @param options - The options parameter for color separation
         * @param options.checkIfBaseColorsUsed - Check if the base colors
         * Cyan, Magenta, Yellow and Black are actually used in the document, and if
         * not, prevents the Document.colorSeparationAdded event from firing for one
         * or more of those colors
         */
        enableColorSeparations(options: {
            checkIfBaseColorsUsed: boolean;
        }): void;
        /**
         * [PDF Document only] Disable the color separations feature for rendering.
         */
        disableColorSeparations(): void;
        /**
         * [Server Document only] Get client Id for current server document.
         * @returns the client Id as a string.
         */
        getClientId(): string;
        /**
         * [Server Document only] Get auth Id for current server document.
         * @returns the auth Id as a string.
         */
        getAuthId(): string;
        /**
         * [PDF Document only] Gets the color separations available on this document.
         * @returns The color separations of the document
         */
        getColorSeparations(): any[];
        /**
         * [PDF Document only] Enables or disables the rendering of a particular color separation.
         * @param name - The name of the separation
         * @param enabled - Whether to enable or disable the separation
         */
        enableSeparation(name: string, enabled: boolean): void;
        /**
         * Get the size of the document in bytes. Throws if the size cannot be found.
         * @param [aggressionLevel = 2] - Set the number of failed attempts to allow before throwing.
         * Each attempt calls a method that may take slighly longer than the previous.
         * The order of attempts are as follows:
         * 1) Return the size immediately if we already have the data
         * 2) Make a HEAD request to the server and attempt to read the 'content-length' header
         * 3) Download the full document and return the size
         *
         * For example, setting aggressionLevel to 1 only tries the first method, setting it to 3 tries all the methods.
         * The default is 2
         * @returns The number of bytes
         */
        getFileSize(aggressionLevel?: number): Promise<number>;
        /**
         * It returns the text that is within the Rect on the given page
         * @param pageNumber - The page number that the rect is on
         * @param rect - A Rect with x1,y1 representing the top-left and x2,y2 representing the bottom-right
         * @returns A promise that resolves to the extracted text
         */
        getTextByPageAndRect(pageNumber: number, rect: Core.Math.Rect): Promise<string>;
        /**
         * [Office Document only] Update a Document via binding template keys to content.
         * @param templateValues - The template replacement values.
         * @returns Resolves when template data has been applied to the document, or rejects with an error.
         */
        applyTemplateValues(templateValues: Core.TemplateData): Promise<void>;
        /**
         * [PDF Document only] Check if the PDF Document has been altered with page modifications (Additions, deletions, rotations, crops).
         * @returns A boolean value indicating whether the PDF Document has been altered.
         */
        arePagesAltered(): boolean;
        /**
         * Triggered when a color separation is loaded and available on the document.
         * @param colorData - An object with properties of the color separation
         * @param colorData.name - The name of the color separation
         * @param colorData.rgb - An array containing the R, G and B values for the separation
         */
        on(event: 'colorSeparationAdded', callback: (colorData: {
            name: string;
            rgb: any[];
        }) => void): void;
        /**
         * Triggered when a color separation is loaded and available on the document.
         * @param colorData - An object with properties of the color separation
         * @param colorData.name - The name of the color separation
         * @param colorData.rgb - An array containing the R, G and B values for the separation
         */
        one(event: 'colorSeparationAdded', callback: (colorData: {
            name: string;
            rgb: any[];
        }) => void): void;
        off(event?: 'colorSeparationAdded', callback?: (colorData: {
            name: string;
            rgb: any[];
        }) => void): void;
        /**
         * Triggered when a document's layers/OCG structures change visibility.
         * @param layerContext - array of page layers
         */
        on(event: 'layersUpdated', callback: (layerContext: Core.Document.LayerContext[]) => void): void;
        /**
         * Triggered when a document's layers/OCG structures change visibility.
         * @param layerContext - array of page layers
         */
        one(event: 'layersUpdated', callback: (layerContext: Core.Document.LayerContext[]) => void): void;
        off(event?: 'layersUpdated', callback?: (layerContext: Core.Document.LayerContext[]) => void): void;
    }
    namespace Document {
        /**
         */
        type PageInfo = {
            /**
             * The width of the page
             */
            width: number;
            /**
             * The height of the page
             */
            height: number;
        };
        /**
         * The callback to call when the Document has been initialized. If there is an error then an error object will be passed to the callback function.
         * @param [error] - The error that occurs when initializing the document
         */
        type LoadAsyncCallback = (error?: any) => void;
        /**
         */
        type XFDFInfo = {
            /**
             * The XFDF string
             */
            xfdfString: string;
            /**
             * Array of page numbers that annotations were extracted from
             */
            pages: number[];
        };
        /**
         */
        type LayerContext = {
            /**
             * the unique identifier of the layer. This is not defined if the layer is a label
             */
            obj: string;
            /**
             * the name of the layer. It does not have not be unique
             */
            name: string;
            /**
             * boolean to denote if the layer is locked for viewing. This state cannot be toggled by the user through the user interface
             */
            locked: boolean;
            /**
             * boolean to denote if the layer is visible
             */
            visible: boolean;
            /**
             * the layer's children (if any). This is not defined if the layer is a label.
             */
            children: Core.Document.LayerContext[];
        };
    }
    /**
     * Office template data (input supplied to {@link applyTemplateValues}).
     */
    type TemplateData = Core.TemplateDataKeyValues;
    /**
     * A dictionary of template keys and their replacement values.
     */
    type TemplateDataKeyValues = {
        [key: string]: Core.TemplateDataValue;
    };
    /**
     * A replacement value for a tag.
     */
    type TemplateDataValue = Core.TemplateDataContent | Core.TemplateDataLoop | Core.TemplateDataKeyValues | boolean;
    /**
     * A replacement value for a simple data tag, @example '{{tag}}'
     */
    type TemplateDataContent = Core.TemplateDataText | Core.TemplateDataImage;
    /**
     * A text replacement value.
     */
    type TemplateDataText = string | Core.TemplateDataTextExplicit | Core.TemplateDataTextLines;
    /**
     * Simple text, equivalent to just passing a string.
     */
    type TemplateDataTextExplicit = {
        text: string;
    };
    /**
     * An array of text which will separated by line breaks.
     */
    type TemplateDataTextLines = {
        text_lines: string[];
    };
    /**
     * A bitmap image.  All parameters are required.
     * The image will be resized to the requested width and height on the page, which may change it's aspect ratio.
     */
    type TemplateDataImage = {
        /**
         * URL to download image from.
         */
        image_url: string;
        /**
         * The image width, measure in points.
         */
        width: number;
        /**
         * The image height, measured in points.
         */
        height: number;
    };
    /**
     * The argument to a template loop: an array which will be looped over.
     */
    type TemplateDataLoop = Core.TemplateDataKeyValues[];
    /**
     * Office template schema (output returned from {@link getTemplateKeys} with format: schema).
     */
    type TemplateSchema = {
        /**
         * The top-level template keys in the document.
         */
        keys: Core.TemplateSchemaKeyValues;
    };
    /**
     * A dictionary of template keys and their expected data types.
     */
    type TemplateSchemaKeyValues = {
        [key: string]: Core.TemplateSchemaValue;
    };
    /**
     * The expected type of input data for a template tag.
     * The type can be read from the typeId property.
     */
    type TemplateSchemaValue = Core.TemplateSchemaContent | Core.TemplateSchemaBool | Core.TemplateSchemaLoop | Core.TemplateSchemaObject;
    /**
     * This indicates there is a template tag for this key that will be replaced with content, such as text or an image.
     */
    type TemplateSchemaContent = {
        typeId: 'TemplateSchemaContent';
        /**
         * An index representing this template key's first occurrence in the natural flow order of the document's keys (left-to-right, top-to-bottom).
         */
        docOrder: number;
    };
    /**
     * This indicates all usages of the key are used in a conditional.
     * The key is not restricted to a boolean and can take data in the form of content such as a string,
     * but that string would not be rendered anywhere in the document.
     */
    type TemplateSchemaBool = {
        typeId: 'TemplateSchemaBool';
        /**
         * An index representing this template key's first occurrence in the natural flow order of the document's keys (left-to-right, top-to-bottom).
         */
        docOrder: number;
    };
    /**
     * This indicates the key is a loop.  Since a key may be reused in multiple loops, the loopType property is an array.
     */
    type TemplateSchemaLoop = {
        typeId: 'TemplateSchemaLoop';
        /**
         * An index representing this template key's first occurrence in the natural flow order of the document's keys (left-to-right, top-to-bottom).
         */
        docOrder: number;
        /**
         * The sub-schema for this loop.  Template keys that are used within the loop will appear here.
        Note that if multiple loops with the same key have different inner keys, the item schema will contain the union of all inner key usages.
         */
        itemSchema: Core.TemplateSchemaKeyValues;
        /**
         * Array of the loop types, ordered by their document ordering.
         */
        loopType: ('tableRow' | 'orderedList' | 'unorderedList' | 'other')[];
    };
    /**
     * This indicates the key is used as an object in a tag dot expression.
     * @example
     * 'obj' in the tag '{{obj.prop}}'
     */
    type TemplateSchemaObject = {
        typeId: 'TemplateSchemaObject';
        /**
         * An index representing this template key's first occurrence in the natural flow order of the document's keys (left-to-right, top-to-bottom).
         */
        docOrder: number;
        /**
         * The sub-schema for all properties of this object.  The properties are gathered
        from the right-hand-side of all usages of this object in dot expressions.
         */
        properties: Core.TemplateSchemaKeyValues;
    };
    /**
     * A bounding box of template tag text or template inserted content.
     */
    type TemplateBoundingBox = {
        /**
         * The page index (1-based indexing) this bounding box appears on.
         */
        pageNum: number;
        /**
         * The bounding box, units are points.
         */
        box: Core.Math.Rect;
    };
    /**
     * A dictionary mapping template keys to bounding boxes of either template tags or template inserted content.
     * The template engine tries to infer the scope of the template that are used in loops.  Loop keys will be scoped in this dictionary with the '::' separator, like this:
     * @example
     * 'loop_var_1::loop_var_2 ... ::item_var'
     */
    type TemplateBoundingBoxes = {
        [key: string]: Core.TemplateBoundingBox[];
    };
    /**
     * Represents the different color post processing options that can used in the {@link Core.Document#updateRasterizerOptions updateRasterizerOptions} function.
     * @property NONE - No post processing. This is the default setting
     * @property INVERT - Inverted color mode
     * @property GRADIENT_MAP - Gradient color mode
     * @property NIGHT_MODE - Night mode
     */
    var ColorPostProcessMode: {
        /**
         * No post processing. This is the default setting
         */
        NONE: number;
        /**
         * Inverted color mode
         */
        INVERT: number;
        /**
         * Gradient color mode
         */
        GRADIENT_MAP: number;
        /**
         * Night mode
         */
        NIGHT_MODE: number;
    };
    /**
     * Represents the different save option values that you can use in the getFileData function.
     * @property INCREMENTAL - Saves new data to the end of the file
     * @property REMOVE_UNUSED - Removes unused data when saving
     * @property HEX_STRINGS - Save strings in hexadecimal format
     * @property OMIT_XREF - Do not save cross reference table
     * @property LINEARIZED - Optimize data for speed and remove unused data
     * @property COMPATIBILITY - Maximize compatibility with older PDF consumers (e.g. the file will not use object and compressed XREF streams)
     */
    var SaveOptions: {
        /**
         * Saves new data to the end of the file
         */
        INCREMENTAL: number;
        /**
         * Removes unused data when saving
         */
        REMOVE_UNUSED: number;
        /**
         * Save strings in hexadecimal format
         */
        HEX_STRINGS: number;
        /**
         * Do not save cross reference table
         */
        OMIT_XREF: number;
        /**
         * Optimize data for speed and remove unused data
         */
        LINEARIZED: number;
        /**
         * Maximize compatibility with older PDF consumers (e.g. the file will not use object and compressed XREF streams)
         */
        COMPATIBILITY: number;
    };
    /**
     * Represents the different processing option values to direct the flow of content recognition algorithms that you can use in the setTextExtractorProcessingFlags function.
     * @property NO_LIGATURE_EXP - Disables expanding of ligatures using a predefined mapping. Default ligatures are: fi, ff, fl, ffi, ffl, ch, cl, ct, ll, ss, fs, st, oe, OE
     * @property NO_DUP_REMOVE - Disables removing duplicated text that is frequently used to achieve visual effects of drop shadow and fake bold
     * @property PUNCT_BREAK - Treat punctuation (e.g. full stop, comma, semicolon, etc.) as word break characters
     * @property REMOVE_HIDDEN_TEXT - Enables removal of text that is obscured by images or rectangles
     * @property NO_INVISIBLE_TEXT - Enables removing text that uses rendering mode 3 (i.e. invisible text), which is usually used in 'PDF Searchable Images' (i.e. scanned pages with a corresponding OCR text)
     * @property NO_WATERMARKS - Enables removal of text that is marked as part of a Watermark layer
     * @property EXTRACT_USING_ZORDER - Use Z-order as reading order for text
     */
    var TextExtractorProcessingFlags: {
        /**
         * Disables expanding of ligatures using a predefined mapping. Default ligatures are: fi, ff, fl, ffi, ffl, ch, cl, ct, ll, ss, fs, st, oe, OE
         */
        NO_LIGATURE_EXP: number;
        /**
         * Disables removing duplicated text that is frequently used to achieve visual effects of drop shadow and fake bold
         */
        NO_DUP_REMOVE: number;
        /**
         * Treat punctuation (e.g. full stop, comma, semicolon, etc.) as word break characters
         */
        PUNCT_BREAK: number;
        /**
         * Enables removal of text that is obscured by images or rectangles
         */
        REMOVE_HIDDEN_TEXT: number;
        /**
         * Enables removing text that uses rendering mode 3 (i.e. invisible text), which is usually used in 'PDF Searchable Images' (i.e. scanned pages with a corresponding OCR text)
         */
        NO_INVISIBLE_TEXT: number;
        /**
         * Enables removal of text that is marked as part of a Watermark layer
         */
        NO_WATERMARKS: number;
        /**
         * Use Z-order as reading order for text
         */
        EXTRACT_USING_ZORDER: number;
    };
    /**
     * Creates a new empty DocumentViewer.
     * @property defaults - Default values for document viewer. Set FitMode, DisplayMode or Zoom.
     */
    class DocumentViewer extends Core.EventHandler {
        /**
         * This function must be called after modifying the scroll view element's dimensions or properties.
         * The scroll view is the element returned from docViewer.getScrollViewElement()
         */
        scrollViewUpdated(): void;
        /**
         * Reinitializes data and clears the viewer area content.
         */
        closeDocument(): void;
        /**
         * Request a recalculation of page layout and rerender all pages. For use when
         * modifying the underlying Document without using the provided page
         * modification functions (cropPages, rotatePages...)
         * @param pagesToRecalculate - An array of page numbers (1-indexed) that should be recalculated
         */
        recalculateLayout(pagesToRecalculate: number[]): void;
        /**
         * Returns whether add automatic link is enabled.
         * @returns Whether add automatic link is enabled.
         */
        isAutomaticLinkingEnabled(): boolean;
        /**
         * Sets whether automatic linking should be enabled.
         * If enabled then any URLs detected in the document text will automatically be linked.
         * @param enable - Whether to enable automatic linking.
         */
        setEnableAutomaticLinking(enable: boolean): void;
        /**
         * Enable automatic linking.
         * If enabled then any URLs detected in the document text will automatically be linked.
         */
        enableAutomaticLinking(): void;
        /**
         * Disable automatic linking.
         * If disabled then any URLs detected in the document text will not automatically be linked.
         */
        disableAutomaticLinking(): void;
        /**
         * Initialize the viewer and load a .xod document into the viewer.
         * @param partRetriever - An instance of PartRetriever.
         * @param options - An object that can contain the following optional parameters
         * @param [options.type] - The type of document being loaded. Values are xod, pdf, office, webviewerServer. Default is xod.
         * @param [options.docId] - An optional unique identifier for the document, used for offline mode
         * @param [options.onError] - A callback of the form function(err) which will be called when a loading error occurs.
         * @param [options.workerTransportPromise] - Required for PDF viewing. A promise that will be resolved when a worker transport has been initialized. This can be created by calling Core.initializeWorkerTransport
         * @param [options.getPassword] - An method of the form function(callback) where callback is of the form function(password). getPassword will be called when a password is required to load a PDF document and should call the callback with the retrieved password.
         * @param [options.extension] - An field used to specify the type of file being read. This is only relevant for PDF viewing and at the moment only works for certain image formats and .pdf
         * @param [options.licenseKey] - The license key to use. Only necessary for client side and WebViewer Server rendering.
         */
        loadAsync(partRetriever: Core.PartRetrievers.PartRetriever, options: {
            type?: string;
            docId?: string;
            onError?: (...params: any[]) => any;
            workerTransportPromise?: Promise<void>;
            getPassword?: (...params: any[]) => any;
            extension?: string;
            licenseKey?: string;
        }): void;
        /**
         * Initialize the viewer and load the given file into the viewer.
         * @param src - Source parameter, path/url to document or File.
         * @param [options] - Load document options.
         * @returns A promise that resolves when the document is finished loading
         */
        loadDocument(src: string | File | ArrayBuffer | Blob | Core.Document | Core.PDFNet.PDFDoc, options?: Core.CreateDocumentOptions): Promise<void>;
        /**
         * Gets a promise that resolves when the annotations in the current document have all been loaded
         * @returns Promise that resolves when the annotations in the current document have loaded.
         */
        getAnnotationsLoadedPromise(): Promise<any>;
        /**
         * Gets the scrollview element that is being used by DocumentViewer
         * @returns The scrollview DOM element that DocumentViewer appends pages
         */
        getScrollViewElement(): Element;
        /**
         * Sets the scrollview element that DocumentViewer will append rendered pages to.
         * @param scrollViewElement - The scrollview DOM element to be used
         */
        setScrollViewElement(scrollViewElement: Element): void;
        /**
         * Gets the viewer element that is being used by DocumentViewer
         * @returns The viewer DOM element that DocumentViewer appends pages
         */
        getViewerElement(): Element;
        /**
         * Sets the viewer element that DocumentViewer will append rendered pages to.
         * @param viewerElement - The viewer DOM element to be used
         */
        setViewerElement(viewerElement: Element): void;
        /**
         * Disposes the current document's data
         */
        dispose(): void;
        /**
         * Get the current height of the specified page, taking into account rotation.
         * @param pageNumber - The page number
         * @returns The height of the page
         */
        getPageHeight(pageNumber: number): number;
        /**
         * Get the current width of the specified page, taking into account rotation.
         * @param pageNumber - The page number
         * @returns The width of the page
         */
        getPageWidth(pageNumber: number): number;
        /**
         * Returns the AnnotationManager used by this DocumentViewer
         * @returns an instance of AnnotationManager
         */
        getAnnotationManager(): AnnotationManager;
        /**
         * Returns the MeasurementManager used by this DocumentViewer
         * @returns an instance of MeasurementManager
         */
        getMeasurementManager(): MeasurementManager;
        /**
         * Returns the AnnotationHistoryManager used by this DocumentViewer
         * @returns an instance of AnnotationHistoryManager
         */
        getAnnotationHistoryManager(): AnnotationHistoryManager;
        /**
         * Set the options that are used when importing annotations from a document asynchronously.
         * These are the options that will be passed to AnnotationManager.importAnnotations.
         * @param options - The options for importing
         * @param options.batchSize - The number of annotations to import in each batch
         * @param options.batchDelay - The amount of time in milliseconds to delay between importing each batch
         */
        setAnnotationImportOptions(options: {
            batchSize: number;
            batchDelay: number;
        }): void;
        /**
         * Sets whether annotations should only be loaded from the visible pages and removed when a page is no longer visible.
         * Note that when enabling this option only annotations on the visible pages will be exported or included in the downloaded document
         * @param val - Whether the option should be enabled or not
         */
        setLoadAnnotationsFromVisiblePages(val: boolean): void;
        /**
         * Enable annotations to only be loaded from the visible pages and removed when a page is no longer visible.
         * Note that when enabling this option only annotations on the visible pages will be exported or included in the downloaded document
         */
        enableLoadingAnnotationsFromVisiblePages(): void;
        /**
         * If loading annotations from visible pages was previously enabled then calling this function will switch back to the default behavior.
         */
        disableLoadingAnnotationsFromVisiblePages(): void;
        /**
         * Allows you to transform (or replace) the internal annotations of the document. Note that to handle annotations using PDFNetJS without useDownloader: false you will also want to call setPagesUpdatedInternalAnnotationsTransform
         * @param handler - A handler function that takes annotation data as the first parameter and a callback that is called when the transformed data is ready as the second parameter
         */
        setInternalAnnotationsTransform(handler: (...params: any[]) => any): void;
        /**
         * Allows you to transform (or replace) the internal annotations of the document when pages receive an update event. This includes when using PDFNetJS with downloader enabled (default) on a linearized document. For completeness you will also want to call setInternalAnnotationsTransform.
         * @param handler - A handler function that takes annotation data as the first parameter, an array of updated page numbers as a second parameter and a callback that is called when the transformed data is ready as a third parameter
         */
        setPagesUpdatedInternalAnnotationsTransform(handler: (...params: any[]) => any): void;
        /**
         * Sets the XFDF retriever that will be called when a document is being loaded. The XFDF returned from the retriever will be merged into the document.
         * It is recommended to use this function instead of annotManager.importAnnotations if you are loading XFDF from your server so that you don't need to wait for the annotationsLoaded event to be triggered. setDocumentXFDFRetriever will ensure that the annotation data is merged at the right time and as early as possible.
         * @example
         * instance.docViewer.setDocumentXFDFRetriever(async (documentId) => {
         *   const documentXFDFString = await fetchDocumentXFDFFromServer(documentId);
         *   return documentXFDFString;
         * })
         * @param retriever - A retriever function that returns a Promise which should resolve to the XFDF string that is going to merged into the document
         * @returns A promise that resolves when the retriever has been set
         */
        setDocumentXFDFRetriever(retriever: Core.DocumentViewer.DocumentXFDFRetriever | null): Promise<void>;
        /**
         * Sets the callback function that will be called when a page is newly visible in the viewer.
         * @param callback - A function that takes in a page number indicating the page that is now visible
         */
        setPageVisibilityCallback(callback: (...params: any[]) => any): void;
        /**
         * Returns the DisplayModeManager used by this DocumentViewer
         * @returns an instance of DisplayModeManager
         */
        getDisplayModeManager(): DisplayModeManager;
        /**
         * Returns the path coordinate within the page that is closest to the queried point.
         * @param pageNumber - The page number the point is on
         * @param x - The x position to calculate the snap point from
         * @param y - The y position to calculate the snap point from
         * @param [mode] - Enum for an optional snapping mode for the snapping
         * @returns A promise that resolves to the SnapData object.
         */
        snapToNearest(pageNumber: number, x: number, y: number, mode?: number): Promise<Core.DocumentViewer.SnapData>;
        /**
         * Sets specific DocumentViewer options.
         * @param options - An options object, currently valid options are enableAnnotations and annotMode
         */
        setOptions(options: any): void;
        /**
         * Enable annotations. Any annotations in the document will be visible.
         */
        enableAnnotations(): void;
        /**
         * Disable annotations. Annotations in the document will not be visible.
         */
        disableAnnotations(): void;
        /**
         * Returns the current zoom level
         * @returns The current zoom level.
         */
        getZoom(): number;
        /**
         * Returns the current zoom level.
         * @returns The current zoom level.
         */
        getZoomLevel(): number;
        /**
         * Returns a pixel value, representing the left, right, top and bottom margins.
         * @returns The margin value.
         */
        getMargin(): number;
        /**
         * Set the pixel value to use for the left, right, top and bottom margins.
         * @param margin - The margin value to set.
         */
        setMargin(margin: number): void;
        /**
         * Returns the text selected by text selection tool or search.
         * @param [pageNumber] - Optionally pass the 1-indexed page number
         * @returns Selected text.
         */
        getSelectedText(pageNumber?: number): string;
        /**
         * Returns the quads of the text selected by text selection tool or search.
         * @param [pageNumber] - Optionally pass the 1-indexed page number
         * @returns Selected text quads.
         */
        getSelectedTextQuads(pageNumber?: number): any;
        /**
         * Sets the color to use when highlighting text from text selection.
         * @param color - The color to set.  eg 'rgba(0, 0, 200, 0.3)'
         */
        setTextHighlightColor(color: string): void;
        /**
         * Sets the color to use when highlighting text from searching.
         * @example
         * docViewer.setSearchHighlightColors({
         *   searchResult: 'rgba(255, 0, 0, 0.5)',
         *   activeSearchResult: 'rgba(0, 255, 0, 0.5)'
         * });
         * @param colorOptions - An object with searchResult or activeSearchResult properties
         * set as a color eg 'rgba(0, 0, 200, 0.5)'
         */
        setSearchHighlightColors(colorOptions: any): void;
        /**
         * Returns the current tool.
         * @returns The current tool.
         */
        getToolMode(): Core.Tools.Tool;
        /**
         * Returns the tool mode map object.
         * @returns The tool mode map object.
         */
        getToolModeMap(): any;
        /**
         * Returns a specific tool from the tool mode map.
         * @param Name - of the tool. eg 'AnnotationEdit'
         * @returns The tool mode map object.
         */
        getTool(Name: string | Core.Tools.ToolNames): Core.Tools.Tool;
        /**
         * Returns whether stylus annotating mode is enabled.
         * @returns Returns whether stylus annotating mode is enabled
         */
        setEnableStylusMode(): boolean;
        /**
         * Puts all annotation tools in the stylus annotating mode.
         * When in this mode, finger movements will scroll the document and using a stylus device will annotate the document.
         */
        enableStylusMode(): void;
        /**
         * Disables the stylus annotating mode for all annotation tools.
         */
        disableStylusMode(): void;
        /**
         * Enables read-only mode in the viewer. In this mode no page manipulation features can be done from thumbnail panel of UI.
         */
        enableReadOnlyMode(): void;
        /**
         * Disables read-only mode in the viewer.
         */
        disableReadOnlyMode(): void;
        /**
         * Returns the current viewing rotation.
         * @example
         * PageRotation['E_0'] = 0 (0 degress) <br/>
         * PageRotation['E_90'] = 1 (90 degress) <br/>
         * PageRotation['E_180'] = 2 (180 degress) <br/>
         * PageRotation['E_270'] = 3 (270 degress) <br/>
         * @param [pageNumber] - Optionally pass the page number to get the specific page's rotation
         * @returns The current viewing rotation.
         */
        getRotation(pageNumber?: number): Core.PageRotation;
        /**
         * Returns the complete rotation of the page including the document's rotation.
         * @param pageNumber - The page number to get that page's rotation
         * @returns The current complete rotation.
         */
        getCompleteRotation(pageNumber: number): Core.PageRotation;
        /**
         * Sets the current viewing rotation.
         * @param pageRotation - desired viewing rotation.
         * @param [pageNumber] - Optionally pass the page number to set the specific page's rotation
         */
        setRotation(pageRotation: Core.PageRotation, pageNumber?: number): void;
        /**
         * Sets the individual page rotations of multiple pages at once. Pages that aren't specified will
         * use the default document rotation.
         * @param rotations - An object with keys that are page indexes (1-indexed) and values that are rotation values.
         * Rotations should be specified as {Core.PageRotation}s
         */
        setPageRotations(rotations: any): void;
        /**
         * Gets the individual page rotations of the document. Only returns pages that have been rotated individually.
         * @returns An object with keys that are page indexes (1-indexed) and values that are rotation values.
         */
        getPageRotations(): any;
        /**
         * Returns the Document that is currently being displayed by the viewer.
         * @returns returns the current document.
         */
        getDocument(): Core.Document;
        /**
         * Returns the current viewport rendering region if viewport rendering is enabled.
         * @param pageNumber - The page number
         * @returns returns the current viewport rendering region
         */
        getViewportRegionRect(pageNumber: number): any;
        /**
         * Returns the exact viewport rendering region if viewport rendering is enabled.
         * @param pageNumber - The page number
         * @returns returns the current viewport rendering region
         */
        getExactViewportRegionRect(pageNumber: number): any;
        /**
         * Returns the current fit mode.
         * @returns The current fit mode.
         */
        getFitMode(): Core.DocumentViewer.FitMode;
        /**
         * Returns whether right to left page rendering is enabled.
         * @returns The current page rendering order.
         */
        getRightToLeftPages(): boolean;
        /**
         * Returns whether right to left page rendering is enabled.
         * @returns True if right to left page rendering is enabled, false otherwise.
         */
        isRightToLeftPageRenderingEnabled(): boolean;
        /**
         * Sets the page rendering order.
         * @param rightToLeftPages - Whether the new page rendering order should be right to left or not.
         */
        setRightToLeftPages(rightToLeftPages: boolean): void;
        /**
         * Enable the right to left page rendering order.
         */
        enableRightToLeftPageRendering(): void;
        /**
         * Disable right to left page rendering order.
         */
        disableRightToLeftPageRendering(): void;
        /**
         * Enable using the left/right arrow keys to switch pages.
         */
        enableArrowKeyNavigation(): void;
        /**
         * Disable using the left/right arrow keys to switch pages.
         */
        disableArrowKeyNavigation(): void;
        /**
         * If the boomark is an internal link then it scrolls the viewer so that the position of the bookmark is in the upper-left corner of the viewer.
         * If it's an external URL then it opens the URL.
         * @param bookmark - A bookmark that specifies the location to go to. Returned by {@link Core.Document#getBookmarks}.
         */
        displayBookmark(bookmark: Bookmark): void;
        /**
         * Shifts the current viewport of the viewer such that it can display the specified viewer coordinate position
         * Please refer to https://www.pdftron.com/documentation/web/guides/coordinates/#viewer-page-coordinates for more details
         * @param pageNumber - The page number the location is on
         * @param horizontalPosition - The horizontal position from the x-axis origin of the page (in viewer page coordinates)
         * @param verticalPostion - The vertical position from the y-axis of the page (in viewer page coordinates)
         * @param [doNotJumpIfInView] - If true then if the page location is currently in view don't cause the viewer to shift
         */
        displayPageLocation(pageNumber: number, horizontalPosition: number, verticalPostion: number, doNotJumpIfInView?: boolean): void;
        /**
         * Searches for a particular text string on the currently displayed Document, starting on the current page unless otherwise specified.
         * @param pattern - The text to search for.
         * @param mode - The options for search, controlling options such as case sensitivity and search direction.
         * @param [searchOptions] - An object that can contain the following optional parameters
         * @param [searchOptions.fullSearch] - If true, a search of the entire document will be performed. Otherwise, a single search will be performed.
         * @param [searchOptions.onResult] - (result) The callback function that is called when the search returns a result.
         * @param [searchOptions.onPageEnd] - (result) The callback function that is called when reaching the end of the page (if using page_stop mode).
         * @param [searchOptions.onDocumentEnd] - () The callback function that is called when reaching the end of the document.
         * @param [searchOptions.onError] - (result) The callback function that is called when search failed or regex has syntax error.
         * @param [searchOptions.startPage] - Page to start the search on (1-indexed).
         * @param [searchOptions.endPage] - Page to end the search on inclusively (1-indexed).
         * The search may complete when the search term is found, when the entire document has been searched, and, depending on the search options, at the end of every page. Parameter result: {@link DocumentViewer.SearchResults}.
         */
        textSearchInit(pattern: string, mode: number, searchOptions?: {
            fullSearch?: boolean;
            onResult?: (...params: any[]) => any;
            onPageEnd?: (...params: any[]) => any;
            onDocumentEnd?: (...params: any[]) => any;
            onError?: (...params: any[]) => any;
            startPage?: number;
            endPage?: number;
        }): void;
        /**
         * [PDF Document only] Set the number of pages to search at a time. Searching more pages at a time will speed up searching but decrease page rendering responsiveness while a search is ongoing. Default is 50.
         * @param searchBatchSize - The number of pages to search at a time
         */
        setSearchPageBatchSize(searchBatchSize: number): void;
        /**
         * The code indicating the reason that the search process concluded.
         * @property ambientStr - The text surrounding the result string.
         * @property resultStr - The found text.
         * @property resultStrStart - The index in ambient string where the result string starts.
         * @property resultStrEnd - The index in ambient string where the result string end.
         * @property pageNum - The page number which the search was conducted on.
         * @property resultCode - The reason the search completed.
         * @property quads - A list of Quads, representing the bounding box(es) of the found text. Useful for highlighting the text.
         */
        static SearchResults: {
            /**
             * The text surrounding the result string.
             */
            ambientStr: string;
            /**
             * The found text.
             */
            resultStr: string;
            /**
             * The index in ambient string where the result string starts.
             */
            resultStrStart: number;
            /**
             * The index in ambient string where the result string end.
             */
            resultStrEnd: number;
            /**
             * The page number which the search was conducted on.
             */
            pageNum: number;
            /**
             * The reason the search completed.
             */
            resultCode: number;
            /**
             * A list of Quads, representing the bounding box(es) of the found text. Useful for highlighting the text.
             */
            quads: any;
        };
        /**
         * Scrolls the viewer so that the position of the search result is in the middle of the viewer.
         * @param result - The result of a search, {@link Core.DocumentViewer.SearchResult}. Returned by onResult in {@link Core.DocumentViewer#textSearchInit}.
         * @param [jump] - The callback for navigating to the found result. This is optional and will jump to the correct location in the DocumentViewer if no parameter is passed.
         */
        displaySearchResult(result: any, jump?: (...params: any[]) => any): void;
        /**
         * Displays the new search result without clearing previous results
         * @param result - The result of a search, {@link Core.DocumentViewer.SearchResult} Returned by onResult in {@link Core.DocumentViewer#textSearchInit}.
         */
        displayAdditionalSearchResult(result: any): void;
        /**
         * Displays the new search results without clearing previous results
         * If you need to display many results at the same time this can be much
         * more efficient than calling displayAdditionalSearchResult for each result
         * @param results - An array of search results {@link Core.DocumentViewer.SearchResult}. Returned by onResult in {@link Core.DocumentViewer#textSearchInit}.
         */
        displayAdditionalSearchResults(results: object[]): void;
        /**
         * Sets the active search result, causing it to be displayed as a different color and visible on the screen.
         * @param result - The result of a search, {@link Core.DocumentViewer.SearchResult}. Returned by onResult in {@link Core.DocumentViewer#textSearchInit}.
         */
        setActiveSearchResult(result: any): void;
        /**
         * Gets the currently active search result
         * @returns SearchResult {@link Core.DocumentViewer.SearchResult}
         */
        getActiveSearchResult(): any;
        /**
         * Clears all search results from the viewer
         */
        clearSearchResults(): void;
        /**
         * Get results of the current search
         * @param [pageNumber] - page number indicating to return the search hits from a specific page. If it's not given, the function will return search hits from all document pages.
         * @returns SearchResult array {@link Core.DocumentViewer.SearchResult}
         */
        getPageSearchResults(pageNumber?: number): any;
        /**
         * Draws the text selection for the specified page. Should be called after calling
         * AnnotationManager's drawAnnotations function if the selection should still be shown.
         * @param pageNumber - The page number to draw the selection on
         */
        drawSelection(pageNumber: number): void;
        /**
         * Selects the text content of the document given two page coordinates.
         * @param pt1 - Starting page coordinate. Requires properties x, y and pageNumber.
         * @param pt2 - Ending page coordinate. Requires properties x, y and pageNumber.
         */
        select(pt1: any, pt2: any): void;
        /**
         * Clears any selected text on the all pages.
         */
        clearSelection(): void;
        /**
         * Gets the color separation values for the specified point. The x and y values should be in page coordinates.
         * @param pageNumber - The page number of the point
         * @param x - The x value of the point
         * @param y - The y value of the point
         * @returns A list of objects which each have the name of the separation and the saturation percentage of the color at the point [{ name, value }, ...]
         */
        getColorSeparationsAtPoint(pageNumber: number, x: number, y: number): any[];
        /**
         * Sets the tool mode. Also removes selection caused by text selection or search.
         * @param tool - An instance of the toolmode
         */
        setToolMode(tool: Core.Tools.Tool): void;
        /**
         * Sets how the document will scale to fit the size of the scrollviewer's viewport.
         * Also re-renders content to the appropriate zoom level.
         * Only renders if a document has been loaded.
         */
        setFitMode(fitMode: DocumentViewer.FitMode): void;
        /**
         * Rotates all pages in the currently displayed document clockwise by 90 degrees.
         * @param [pageNumber] - Optionally pass the page number to rotate only a specific page
         */
        rotateClockwise(pageNumber?: number): void;
        /**
         * Rotates all pages in the currently displayed document counter-clockwise by 90 degrees.
         * @param [pageNumber] - Optionally pass the page number to rotate only a specific page
         */
        rotateCounterClockwise(pageNumber?: number): void;
        /**
         * Adjusts the viewer's zoom factor, and positions the point (x,y) at the upper left corner of the viewer.
         * Only renders if a document has been loaded.
         * @param zoom - Zoom value.
         * @param [x] - Horizontal position to scroll to.
         * @param [y] - Vertical position to scroll to.
         */
        zoomTo(zoom: number, x?: number, y?: number): void;
        /**
         * Adjusts the viewer's zoom factor and positions the point on the document under the mouse at the same position
         * after zooming in.
         * @param zoom - Zoom value
         * @param offsetX - The x offset from the mouse position to the viewer's position (e.g. taking into account toolbars)
         * @param offsetY - The y offset from the mouse position to the viewer's position (e.g. taking into side panels)
         */
        zoomToMouse(zoom: number, offsetX: number, offsetY: number): void;
        /**
         * Get the PDF coordinates of the current mouse event
         * @param event - A DOM mouse event.
         * @returns Returns an object with the x and y PDF coordinates of the mouse event
         */
        getPDFCoordinatesFromMouseEvent(event: MouseEvent): any;
        /**
         * Get the viewer page coordinates of the current mouse event
         * @param event - A DOM mouse event.
         * @returns Returns an object with the x and y viewer coordinates of the mouse event
         */
        getViewerCoordinatesFromMouseEvent(event: MouseEvent): any;
        /**
         * Get the zoom value for a particular page.
         * @param pageNumber - The page number.
         * @returns Returns page's zoom value
         */
        getPageZoom(pageNumber: number): number;
        /**
         * Sets the zoom for a particular page. Should be followed by a call to updateView to actually render the page.
         * @param pageNumber - The page number.
         * @param zoom - Zoom value for page.
         */
        setPageZoom(pageNumber: number, zoom: number): void;
        /**
         * Removes all the page content from the DOM.
         * Also clear the cache if the zoom or rotation has changed.
         * @param removeData - Whether or not to remove all event handlers and data on the elements
         */
        removeContent(removeData: boolean, rotationChanged: boolean, isZoomChanged: boolean): void;
        /**
         * Sets the current page. Updates the current page and jumps to it.
         * @param pageNumber - The page number to jump to.
         * @param isSmoothScroll - If set to true, the viewer will scroll in a smooth way.
         */
        setCurrentPage(pageNumber: number, isSmoothScroll: boolean): void;
        /**
         * Returns the current page number.
         * @returns The current 1-indexed page number.
         */
        getCurrentPage(): number;
        /**
         * Returns the number of pages in a document.
         * @returns The number of the pages in the current document.
         */
        getPageCount(): number;
        /**
         * Scrolls the viewer so that the upper-left corner of the Document's last page is in the upper-left corner of the viewer.
         */
        displayLastPage(): void;
        /**
         * Scrolls the viewer so that the upper-left corner of the Document's first page is in the upper-left corner of the viewer.
         */
        displayFirstPage(): void;
        /**
         * Invalidates the rendering cache for all pages and removes embedded
         * thumbnails for viewer optimized PDF
         */
        refreshAll(): void;
        /**
         * Invalidates the rendering cache for the specified page
         * @param pageNumber - The page number of the page (1-indexed)
         */
        refreshPage(pageNumber: number): void;
        /**
         * Updates old xod (version <= 1.2) link annotations in the annotation manager
         * @param pageNumber - The 1-indexed page number to update
         */
        updateLinks(pageNumber: number): void;
        /**
         * Removes previously drawn pages that are no longer visible and
         * draws pages that are visible and have not been drawn.
         * If visiblePages are provided then those pages are rendered otherwise visiblePages are calculated
         * depending on where the DIV elements for the pages are located.
         * @param [visiblePages] - An array of integers representing the pages to render.
         * @param [currentPageNumber] - The number of the page that is currently visible in the viewer.
         */
        updateView(visiblePages?: number[], currentPageNumber?: number): void;
        /**
         * Notifies the document viewer that the visible pages have changed
         * but does not draw any pages.
         * @param [visiblePages] - An array of integers representing the pages to render.
         */
        updateVisiblePages(visiblePages?: number[]): void;
        /**
         * Stops the rendering of the specified page.
         * @param pageNumber - The number of the page who's rendering should be stopped.
         */
        stopPageRender(pageNumber: number): void;
        /**
         * Sets whether viewport rendering mode should be used
         * @param val - Whether viewport rendering mode should be used or not
         */
        setViewportRenderMode(val: boolean): void;
        /**
         * Enables viewport rendering mode. This only renders the part of the page that is visible within the viewport.
         */
        enableViewportRenderMode(): void;
        /**
         * Disables viewport rendering mode
         */
        disableViewportRenderMode(): void;
        /**
         * Returns a boolean to denote if viewer is in viewport rendering mode
         * @returns the boolean to denote if in viewport render mode
         */
        isInViewportRenderMode(): boolean;
        /**
         * Sets default background color for pages, default is white.
         * @param color - Background color value
         */
        setDefaultPageColor(color: string): void;
        /**
         * Enable viewing document in Grayscale
         */
        enableGrayscaleMode(): void;
        /**
         * Disable viewing document in Grayscale
         */
        disableGrayscaleMode(): void;
        /**
         * Returns whether grayscale mode is enabled for viewing the document
         * @returns Whether grayscale mode is enabled or not
         */
        isGrayscaleModeEnabled(): boolean;
        /**
         * Enable viewing annotations in grayscale
         */
        enableGrayscaleAnnotationsMode(): void;
        /**
         * Disable viewing annotations in grayscale
         */
        disableGrayscaleAnnotationsMode(): void;
        /**
         * Enable viewing annotations in grayscale
         */
        enableGrayscaleAnnotations(): void;
        /**
         * Disable viewing annotations in grayscale
         */
        disableGrayscaleAnnotations(): void;
        /**
         * Returns whether grayscale annotations mode is enabled for viewing the document
         * @returns Whether grayscale annotation mode is enabled or not
         */
        isGrayscaleAnnotationsModeEnabled(): boolean;
        /**
         * Sets watermark to be added to documents. Instead of an options object you can also pass a Promise
         * that resolves with the watermark options object. If the document hasn't been loaded yet then
         * DocumentViewer will wait to finish loading it until the watermark options are ready.
         * @example
         * docViewer.setWatermark({
         *   diagonal: {
         *     text: (string),
         *     fontSize: (number || 20),
         *     fontFamily: (string || 'sans-serif'),
         *     color: (string || 'black'),
         *     opacity: (number || 100)
         *   },
         *   header: {
         *     left: (string),
         *     center: (string),
         *     right: (string),
         *     fontSize: (number || 20),
         *     fontFamily: (string || 'sans-serif'),
         *     color: (string || 'black'),
         *     opacity: (number || 100)
         *   },
         *   footer: {
         *     left: (string)
         *     center: (string),
         *     right: (string),
         *     fontSize: (number || 20),
         *     fontFamily: (string || 'sans-serif'),
         *     color: (string || 'black'),
         *     opacity: (number || 100),
         *   },
         *   custom: (function(ctx, pageIndex, pageWidth, pageHeight)),
         *   shouldDrawOverAnnotations: (boolean || false)
         * });
         * @param options - Object that contains style/content of the watermark
         * @param [options.diagonal] - Settings for a diagonal watermark
         * @param [options.diagonal.text] - The text content to be rendered as a diagonal watermark
         * @param [options.diagonal.fontSize = 20] - The font size of the text, measured in pixels (px)
         * @param [options.diagonal.fontFamily = 'sans-serif'] - The font type
         * @param [options.diagonal.color = 'black'] - The color of the text
         * @param [options.diagonal.opacity = 100] - The percentage of opacity for the watermark
         * @param [options.header] - Settings for a header watermark
         * @param [options.header.left] - The text content to be rendered at the left side of the header
         * @param [options.header.center] - The text content to be rendered at the center of the header
         * @param [options.header.right] - The text content to be rendered at the right side of the header
         * @param [options.header.fontSize = 20] - The font size of the text, measured in pixels (px)
         * @param [options.header.fontFamily = 'sans-serif'] - The font type
         * @param [options.header.color = 'black'] - The color of the text
         * @param [options.header.opacity = 100] - The percentage of opacity for the watermark
         * @param [options.footer] - Settings for a footer watermark
         * @param [options.footer.left] - The text content to be rendered at the left side of the footer
         * @param [options.footer.center] - The text content to be rendered at the center of the footer
         * @param [options.footer.right] - The text content to be rendered at the right side of the footer
         * @param [options.footer.fontSize = 20] - The font size of the text, measured in pixels (px)
         * @param [options.footer.fontFamily = 'sans-serif'] - The font type
         * @param [options.footer.color = 'black'] - The color of the text
         * @param [options.footer.opacity = 100] - The percentage of opacity for the watermark
         * @param [options.custom] - Function that is invoked for each page, to fully customize which page(s) have a watermark render, and how they should be rendered.
         * @param [options.shouldDrawOverAnnotations = false] - Toggles if the watermark should be drawn over annotations
         */
        setWatermark(options: {
            diagonal?: {
                text?: string;
                fontSize?: number;
                fontFamily?: string;
                color?: string;
                opacity?: number;
            };
            header?: {
                left?: string;
                center?: string;
                right?: string;
                fontSize?: number;
                fontFamily?: string;
                color?: string;
                opacity?: number;
            };
            footer?: {
                left?: string;
                center?: string;
                right?: string;
                fontSize?: number;
                fontFamily?: string;
                color?: string;
                opacity?: number;
            };
            custom?: Core.DocumentViewer.CustomWatermarkCallback;
            shouldDrawOverAnnotations?: boolean;
        }): void;
        /**
         * Gets the watermark options that had been previously set.
         * @returns Returns a promise containing the watermark options.
         */
        getWatermark(): Promise<object>;
        /**
         * Triggered for the mouseLeftButtonDown event in the DocumentViewer's viewing area
         * Attach like docViewer.addEventListener('mouseLeftDown', callback)
         * @param nativeEvt - Event object of the native JavaScript event
         */
        on(event: 'mouseLeftDown', callback: (nativeEvt: any) => void): void;
        /**
         * Triggered for the mouseLeftButtonDown event in the DocumentViewer's viewing area
         * Attach like docViewer.addEventListener('mouseLeftDown', callback)
         * @param nativeEvt - Event object of the native JavaScript event
         */
        one(event: 'mouseLeftDown', callback: (nativeEvt: any) => void): void;
        off(event?: 'mouseLeftDown', callback?: (nativeEvt: any) => void): void;
        /**
         * Triggered for the mouseLeftButtonUp event in the DocumentViewer's viewing area
         * @param nativeEvt - Event object of the native JavaScript event
         */
        on(event: 'mouseLeftUp', callback: (nativeEvt: any) => void): void;
        /**
         * Triggered for the mouseLeftButtonUp event in the DocumentViewer's viewing area
         * @param nativeEvt - Event object of the native JavaScript event
         */
        one(event: 'mouseLeftUp', callback: (nativeEvt: any) => void): void;
        off(event?: 'mouseLeftUp', callback?: (nativeEvt: any) => void): void;
        /**
         * Triggered for the mouseRightButtonDown event in the DocumentViewer's viewing area
         * @param nativeEvt - Event object of the native JavaScript event
         */
        on(event: 'mouseRightDown', callback: (nativeEvt: any) => void): void;
        /**
         * Triggered for the mouseRightButtonDown event in the DocumentViewer's viewing area
         * @param nativeEvt - Event object of the native JavaScript event
         */
        one(event: 'mouseRightDown', callback: (nativeEvt: any) => void): void;
        off(event?: 'mouseRightDown', callback?: (nativeEvt: any) => void): void;
        /**
         * Triggered for the mouseRightButtonUp event in the DocumentViewer's viewing area
         * @param nativeEvt - Event object of the native JavaScript event
         */
        on(event: 'mouseRightUp', callback: (nativeEvt: any) => void): void;
        /**
         * Triggered for the mouseRightButtonUp event in the DocumentViewer's viewing area
         * @param nativeEvt - Event object of the native JavaScript event
         */
        one(event: 'mouseRightUp', callback: (nativeEvt: any) => void): void;
        off(event?: 'mouseRightUp', callback?: (nativeEvt: any) => void): void;
        /**
         * Triggered for the mouseMove event in the DocumentViewer's viewing area
         * @param nativeEvt - Event object of the native JavaScript event
         */
        on(event: 'mouseMove', callback: (nativeEvt: any) => void): void;
        /**
         * Triggered for the mouseMove event in the DocumentViewer's viewing area
         * @param nativeEvt - Event object of the native JavaScript event
         */
        one(event: 'mouseMove', callback: (nativeEvt: any) => void): void;
        off(event?: 'mouseMove', callback?: (nativeEvt: any) => void): void;
        /**
         * Triggered for the mouseEnter event in the DocumentViewer's viewing area
         * @param nativeEvt - Event object of the native JavaScript event
         */
        on(event: 'mouseEnter', callback: (nativeEvt: any) => void): void;
        /**
         * Triggered for the mouseEnter event in the DocumentViewer's viewing area
         * @param nativeEvt - Event object of the native JavaScript event
         */
        one(event: 'mouseEnter', callback: (nativeEvt: any) => void): void;
        off(event?: 'mouseEnter', callback?: (nativeEvt: any) => void): void;
        /**
         * Triggered for the mouseLeave event in the DocumentViewer's viewing area
         * @param nativeEvt - Event object of the native JavaScript event
         */
        on(event: 'mouseLeave', callback: (nativeEvt: any) => void): void;
        /**
         * Triggered for the mouseLeave event in the DocumentViewer's viewing area
         * @param nativeEvt - Event object of the native JavaScript event
         */
        one(event: 'mouseLeave', callback: (nativeEvt: any) => void): void;
        off(event?: 'mouseLeave', callback?: (nativeEvt: any) => void): void;
        /**
         * Triggered when there is a tap in the DocumentViewer's viewing area. Taps are defined as a mouse down and up within a short time period and within a short distance.a
         * @param nativeEvt - Event object of the native JavaScript event
         */
        on(event: 'tap', callback: (nativeEvt: any) => void): void;
        /**
         * Triggered when there is a tap in the DocumentViewer's viewing area. Taps are defined as a mouse down and up within a short time period and within a short distance.a
         * @param nativeEvt - Event object of the native JavaScript event
         */
        one(event: 'tap', callback: (nativeEvt: any) => void): void;
        off(event?: 'tap', callback?: (nativeEvt: any) => void): void;
        /**
         * Triggered for the click event in the DocumentViewer's viewing area
         * @param nativeEvt - Event object of the native JavaScript event
         */
        on(event: 'click', callback: (nativeEvt: any) => void): void;
        /**
         * Triggered for the click event in the DocumentViewer's viewing area
         * @param nativeEvt - Event object of the native JavaScript event
         */
        one(event: 'click', callback: (nativeEvt: any) => void): void;
        off(event?: 'click', callback?: (nativeEvt: any) => void): void;
        /**
         * Triggered for the dblClick event in the DocumentViewer's viewing area
         * @param nativeEvt - Event object of the native JavaScript event
         */
        on(event: 'dblClick', callback: (nativeEvt: any) => void): void;
        /**
         * Triggered for the dblClick event in the DocumentViewer's viewing area
         * @param nativeEvt - Event object of the native JavaScript event
         */
        one(event: 'dblClick', callback: (nativeEvt: any) => void): void;
        off(event?: 'dblClick', callback?: (nativeEvt: any) => void): void;
        /**
         * Triggered for the keyDown event in the DocumentViewer's viewing area
         * @param nativeEvt - Event object of the native JavaScript event
         */
        on(event: 'keyDown', callback: (nativeEvt: any) => void): void;
        /**
         * Triggered for the keyDown event in the DocumentViewer's viewing area
         * @param nativeEvt - Event object of the native JavaScript event
         */
        one(event: 'keyDown', callback: (nativeEvt: any) => void): void;
        off(event?: 'keyDown', callback?: (nativeEvt: any) => void): void;
        /**
         * Triggered for the keyUp event in the DocumentViewer's viewing area
         * @param nativeEvt - Event object of the native JavaScript event
         */
        on(event: 'keyUp', callback: (nativeEvt: any) => void): void;
        /**
         * Triggered for the keyUp event in the DocumentViewer's viewing area
         * @param nativeEvt - Event object of the native JavaScript event
         */
        one(event: 'keyUp', callback: (nativeEvt: any) => void): void;
        off(event?: 'keyUp', callback?: (nativeEvt: any) => void): void;
        /**
         * Triggered when the zoom level has been updated
         * @param zoom - The new zoom level of the viewer
         */
        on(event: 'zoomUpdated', callback: (zoom: number) => void): void;
        /**
         * Triggered when the zoom level has been updated
         * @param zoom - The new zoom level of the viewer
         */
        one(event: 'zoomUpdated', callback: (zoom: number) => void): void;
        off(event?: 'zoomUpdated', callback?: (zoom: number) => void): void;
        /**
         * Triggered when the page number is updated
         * @param pageNumber - The new page number (1-indexed)
         */
        on(event: 'pageNumberUpdated', callback: (pageNumber: number) => void): void;
        /**
         * Triggered when the page number is updated
         * @param pageNumber - The new page number (1-indexed)
         */
        one(event: 'pageNumberUpdated', callback: (pageNumber: number) => void): void;
        off(event?: 'pageNumberUpdated', callback?: (pageNumber: number) => void): void;
        /**
         * Triggered when the display mode is updated
         */
        on(event: 'displayModeUpdated', callback: () => void): void;
        /**
         * Triggered when the display mode is updated
         */
        one(event: 'displayModeUpdated', callback: () => void): void;
        off(event?: 'displayModeUpdated', callback?: () => void): void;
        /**
         * Triggered when DocumentViewer starts rendering pages
         */
        on(event: 'beginRendering', callback: () => void): void;
        /**
         * Triggered when DocumentViewer starts rendering pages
         */
        one(event: 'beginRendering', callback: () => void): void;
        off(event?: 'beginRendering', callback?: () => void): void;
        /**
         * Triggered when DocumentViewer finishes rendering pages
         */
        on(event: 'finishedRendering', callback: () => void): void;
        /**
         * Triggered when DocumentViewer finishes rendering pages
         */
        one(event: 'finishedRendering', callback: () => void): void;
        off(event?: 'finishedRendering', callback?: () => void): void;
        /**
         * Triggered when the fit mode has changed
         * @param fitMode - The fit mode that has been changed to e.g. docViewer.FitMode.FitWidth
         */
        on(event: 'fitModeUpdated', callback: (fitMode: any) => void): void;
        /**
         * Triggered when the fit mode has changed
         * @param fitMode - The fit mode that has been changed to e.g. docViewer.FitMode.FitWidth
         */
        one(event: 'fitModeUpdated', callback: (fitMode: any) => void): void;
        off(event?: 'fitModeUpdated', callback?: (fitMode: any) => void): void;
        /**
         * Triggered when the selected text has changed
         * @param quads - An array of bounding box quads of the selected text
         * @param text - The selected text
         * @param pageNumber - The page number that the text was selected on
         */
        on(event: 'textSelected', callback: (quads: Core.Math.Quad[], text: string, pageNumber: number) => void): void;
        /**
         * Triggered when the selected text has changed
         * @param quads - An array of bounding box quads of the selected text
         * @param text - The selected text
         * @param pageNumber - The page number that the text was selected on
         */
        one(event: 'textSelected', callback: (quads: Core.Math.Quad[], text: string, pageNumber: number) => void): void;
        off(event?: 'textSelected', callback?: (quads: Core.Math.Quad[], text: string, pageNumber: number) => void): void;
        /**
         * Triggered when the tool styles or tool name have changed
         * @param toolModeClass - The tool object that has been changed.
         */
        on(event: 'toolUpdated', callback: (toolModeClass: any) => void): void;
        /**
         * Triggered when the tool styles or tool name have changed
         * @param toolModeClass - The tool object that has been changed.
         */
        one(event: 'toolUpdated', callback: (toolModeClass: any) => void): void;
        off(event?: 'toolUpdated', callback?: (toolModeClass: any) => void): void;
        /**
         * Triggered when the tool mode has changed
         * @param newToolObject - The tool object that has been changed to.
         * @param oldToolObject - The tool object that has been changed from.
         */
        on(event: 'toolModeUpdated', callback: (newToolObject: any, oldToolObject: any) => void): void;
        /**
         * Triggered when the tool mode has changed
         * @param newToolObject - The tool object that has been changed to.
         * @param oldToolObject - The tool object that has been changed from.
         */
        one(event: 'toolModeUpdated', callback: (newToolObject: any, oldToolObject: any) => void): void;
        off(event?: 'toolModeUpdated', callback?: (newToolObject: any, oldToolObject: any) => void): void;
        /**
         * Triggered when the page rotation has changed
         * @param rotation - The new viewing rotation.
         * @param [pageNumber] - Optionally the specific page number that had its rotation changed
         */
        on(event: 'rotationUpdated', callback: (rotation: Core.PageRotation, pageNumber?: number) => void): void;
        /**
         * Triggered when the page rotation has changed
         * @param rotation - The new viewing rotation.
         * @param [pageNumber] - Optionally the specific page number that had its rotation changed
         */
        one(event: 'rotationUpdated', callback: (rotation: Core.PageRotation, pageNumber?: number) => void): void;
        off(event?: 'rotationUpdated', callback?: (rotation: Core.PageRotation, pageNumber?: number) => void): void;
        /**
         * Triggered just before the document has been loaded into the viewer
         */
        on(event: 'beforeDocumentLoaded', callback: () => void): void;
        /**
         * Triggered just before the document has been loaded into the viewer
         */
        one(event: 'beforeDocumentLoaded', callback: () => void): void;
        off(event?: 'beforeDocumentLoaded', callback?: () => void): void;
        /**
         * Triggered when a new document has been loaded
         */
        on(event: 'documentLoaded', callback: () => void): void;
        /**
         * Triggered when a new document has been loaded
         */
        one(event: 'documentLoaded', callback: () => void): void;
        off(event?: 'documentLoaded', callback?: () => void): void;
        /**
         * Triggered when the current document has been closed and unloaded
         */
        on(event: 'documentUnloaded', callback: () => void): void;
        /**
         * Triggered when the current document has been closed and unloaded
         */
        one(event: 'documentUnloaded', callback: () => void): void;
        off(event?: 'documentUnloaded', callback?: () => void): void;
        /**
         * Triggered when all the annotations embedded in the document have been loaded
         */
        on(event: 'annotationsLoaded', callback: () => void): void;
        /**
         * Triggered when all the annotations embedded in the document have been loaded
         */
        one(event: 'annotationsLoaded', callback: () => void): void;
        off(event?: 'annotationsLoaded', callback?: () => void): void;
        /**
         * Triggered when a search starts or ends.
         * When {@link Core.DocumentViewer#clearSearchResults} is executed searchInProgress event is triggered with both inProgress and isFullSearch
         * arguments to be undefined. This can be used to differentiate the search that hasnt been started versus the search that was done.
         * @param inProgress - Whether a search is in progress or not
         * @param isFullSearch - Whether this is a full text search or not
         */
        on(event: 'searchInProgress', callback: (inProgress: boolean, isFullSearch: boolean) => void): void;
        /**
         * Triggered when a search starts or ends.
         * When {@link Core.DocumentViewer#clearSearchResults} is executed searchInProgress event is triggered with both inProgress and isFullSearch
         * arguments to be undefined. This can be used to differentiate the search that hasnt been started versus the search that was done.
         * @param inProgress - Whether a search is in progress or not
         * @param isFullSearch - Whether this is a full text search or not
         */
        one(event: 'searchInProgress', callback: (inProgress: boolean, isFullSearch: boolean) => void): void;
        off(event?: 'searchInProgress', callback?: (inProgress: boolean, isFullSearch: boolean) => void): void;
        /**
         * Triggered when a page location should be displayed
         * @param pageNum - The 1-indexed page number
         * @param verticalOffset - The offset from the top of the page
         * @param horizontalOffset - The offset from the left of the page
         */
        on(event: 'displayPageLocation', callback: (pageNum: number, verticalOffset: number, horizontalOffset: number) => void): void;
        /**
         * Triggered when a page location should be displayed
         * @param pageNum - The 1-indexed page number
         * @param verticalOffset - The offset from the top of the page
         * @param horizontalOffset - The offset from the left of the page
         */
        one(event: 'displayPageLocation', callback: (pageNum: number, verticalOffset: number, horizontalOffset: number) => void): void;
        off(event?: 'displayPageLocation', callback?: (pageNum: number, verticalOffset: number, horizontalOffset: number) => void): void;
        /**
         * Triggered when there is a notification relating to searching or annotation permissions.
         * @param type - The type of notification that has occurred
         */
        on(event: 'notify', callback: (type: string) => void): void;
        /**
         * Triggered when there is a notification relating to searching or annotation permissions.
         * @param type - The type of notification that has occurred
         */
        one(event: 'notify', callback: (type: string) => void): void;
        off(event?: 'notify', callback?: (type: string) => void): void;
        /**
         * Triggered when a page has been completely rendered.
         * @param pageNum - The 1-indexed page number
         * @param canvas - The canvas for the page
         */
        on(event: 'pageComplete', callback: (pageNum: number, canvas: HTMLCanvasElement) => void): void;
        /**
         * Triggered when a page has been completely rendered.
         * @param pageNum - The 1-indexed page number
         * @param canvas - The canvas for the page
         */
        one(event: 'pageComplete', callback: (pageNum: number, canvas: HTMLCanvasElement) => void): void;
        off(event?: 'pageComplete', callback?: (pageNum: number, canvas: HTMLCanvasElement) => void): void;
        /**
         * Triggered when an embedded thumbnail of a viewer-optimized pdf is completely loaded.
         * @param pageNum - The 1-indexed page number
         */
        on(event: 'embeddedThumbnailComplete', callback: (pageNum: number) => void): void;
        /**
         * Triggered when an embedded thumbnail of a viewer-optimized pdf is completely loaded.
         * @param pageNum - The 1-indexed page number
         */
        one(event: 'embeddedThumbnailComplete', callback: (pageNum: number) => void): void;
        off(event?: 'embeddedThumbnailComplete', callback?: (pageNum: number) => void): void;
        /**
         * Triggered when the layout has changed because pages have permanently been added, removed, moved or changed in some other way.
         * @param changes - An object with keys added, removed, moved and contentChanged, indicating which pages have changed
         */
        on(event: 'pagesUpdated', callback: (changes: any) => void): void;
        /**
         * Triggered when the layout has changed because pages have permanently been added, removed, moved or changed in some other way.
         * @param changes - An object with keys added, removed, moved and contentChanged, indicating which pages have changed
         */
        one(event: 'pagesUpdated', callback: (changes: any) => void): void;
        off(event?: 'pagesUpdated', callback?: (changes: any) => void): void;
        /**
         * Triggered when the search results list has changed
         * @param results - The new search results, {@link Core.DocumentViewer.SearchResult}.
         */
        on(event: 'searchResultsChanged', callback: (results: object[]) => void): void;
        /**
         * Triggered when the search results list has changed
         * @param results - The new search results, {@link Core.DocumentViewer.SearchResult}.
         */
        one(event: 'searchResultsChanged', callback: (results: object[]) => void): void;
        off(event?: 'searchResultsChanged', callback?: (results: object[]) => void): void;
        /**
         * Triggered when the active search result has changed
         * @param result - The new active search result, {@link Core.DocumentViewer.SearchResult}.
         */
        on(event: 'activeSearchResultChanged', callback: (result: any) => void): void;
        /**
         * Triggered when the active search result has changed
         * @param result - The new active search result, {@link Core.DocumentViewer.SearchResult}.
         */
        one(event: 'activeSearchResultChanged', callback: (result: any) => void): void;
        off(event?: 'activeSearchResultChanged', callback?: (result: any) => void): void;
        /**
         * @property ACTIVE_SEARCH_RESULT_CHANGED - {@link Core.DocumentViewer#event:activeSearchResultChanged Core.DocumentViewer.activeSearchResultChanged }
         * @property MOUSE_LEFT_UP - {@link Core.DocumentViewer#event:mouseLeftUp Core.DocumentViewer.mouseLeftUp }
         * @property MOUSE_LEFT_DOWN - {@link Core.DocumentViewer#event:mouseLeftDown Core.DocumentViewer.mouseLeftDown }
         * @property CLICK - {@link Core.DocumentViewer#event:click Core.DocumentViewer.click }
         * @property TAP - {@link Core.DocumentViewer#event:tap Core.DocumentViewer.tap }
         * @property DBL_CLICK - {@link Core.DocumentViewer#event:dblClick Core.DocumentViewer.dblClick }
         * @property KEY_DOWN - {@link Core.DocumentViewer#event:keyDown Core.DocumentViewer.keyDown }
         * @property KEY_UP - {@link Core.DocumentViewer#event:keyUp Core.DocumentViewer.keyUp }
         * @property MOUSE_ENTER - {@link Core.DocumentViewer#event:mouseEnter Core.DocumentViewer.mouseEnter }
         * @property MOUSE_MOVE - {@link Core.DocumentViewer#event:mouseMove Core.DocumentViewer.mouseMove }
         * @property MOUSE_LEAVE - {@link Core.DocumentViewer#event:mouseLeave Core.DocumentViewer.mouseLeave }
         * @property MOUSE_RIGHT_DOWN - {@link Core.DocumentViewer#event:mouseRightDown Core.DocumentViewer.mouseRightDown }
         * @property MOUSE_RIGHT_UP - {@link Core.DocumentViewer#event:mouseRightUp Core.DocumentViewer.mouseRightUp }
         * @property DOCUMENT_UNLOADED - {@link Core.DocumentViewer#event:documentUnloaded Core.DocumentViewer.documentUnloaded }
         * @property ANNOTATIONS_LOADED - {@link Core.DocumentViewer#event:annotationsLoaded Core.DocumentViewer.annotationsLoaded }
         * @property BEFORE_DOCUMENT_LOADED - {@link Core.DocumentViewer#event:beforeDocumentLoaded Core.DocumentViewer.beforeDocumentLoaded }
         * @property DOCUMENT_LOADED - {@link Core.DocumentViewer#event:documentLoaded Core.DocumentViewer.documentLoaded }
         * @property DISPLAY_PAGE_LOCATION - {@link Core.DocumentViewer#event:displayPageLocation Core.DocumentViewer.displayPageLocation }
         * @property NOTIFY - {@link Core.DocumentViewer#event:notify Core.DocumentViewer#event:notify }
         * @property SEARCH_IN_PROGRESS - {@link Core.DocumentViewer#event:searchInProgress Core.DocumentViewer.searchInProgress }
         * @property TEXT_SELECTED - {@link Core.DocumentViewer#event:textSelected Core.DocumentViewer.textSelected }
         * @property TOOL_MODE_UPDATED - {@link Core.DocumentViewer#event:toolModeUpdated Core.DocumentViewer.toolModeUpdated }
         * @property FIT_MODE_UPDATED - {@link Core.DocumentViewer#event:fitModeUpdated Core.DocumentViewer.fitModeUpdated }
         * @property ROTATION_UPDATED - {@link Core.DocumentViewer#event:rotationUpdated Core.DocumentViewer.rotationUpdated }
         * @property ZOOM_UPDATED - {@link Core.DocumentViewer#event:zoomUpdated Core.DocumentViewer.zoomUpdated }
         * @property PAGE_NUMBER_UPDATED - {@link Core.DocumentViewer#event:pageNumberUpdated Core.DocumentViewer.pageNumberUpdated }
         * @property PAGES_UPDATED - {@link Core.DocumentViewer#event:pagesUpdated Core.DocumentViewer.pagesUpdated }
         * @property PAGE_COMPLETE - {@link Core.DocumentViewer#event:pageComplete Core.DocumentViewer.pageComplete }
         * @property DISPLAY_MODE_UPDATED - {@link Core.DocumentViewer#event:displayModeUpdated Core.DocumentViewer.displayModeUpdated }
         * @property BEGIN_RENDERING - {@link Core.DocumentViewer#event:beginRendering Core.DocumentViewer.beginRendering }
         * @property FINISHED_RENDERING - {@link Core.DocumentViewer#event:finishedRendering Core.DocumentViewer.finishedRendering }
         * @property TOOL_UPDATED - {@link Core.DocumentViewer#event:toolUpdated Core.DocumentViewer.toolUpdated }
         */
        static Events: {
            /**
             * {@link Core.DocumentViewer#event:activeSearchResultChanged Core.DocumentViewer.activeSearchResultChanged }
             */
            ACTIVE_SEARCH_RESULT_CHANGED: string;
            /**
             * {@link Core.DocumentViewer#event:mouseLeftUp Core.DocumentViewer.mouseLeftUp }
             */
            MOUSE_LEFT_UP: string;
            /**
             * {@link Core.DocumentViewer#event:mouseLeftDown Core.DocumentViewer.mouseLeftDown }
             */
            MOUSE_LEFT_DOWN: string;
            /**
             * {@link Core.DocumentViewer#event:click Core.DocumentViewer.click }
             */
            CLICK: string;
            /**
             * {@link Core.DocumentViewer#event:tap Core.DocumentViewer.tap }
             */
            TAP: string;
            /**
             * {@link Core.DocumentViewer#event:dblClick Core.DocumentViewer.dblClick }
             */
            DBL_CLICK: string;
            /**
             * {@link Core.DocumentViewer#event:keyDown Core.DocumentViewer.keyDown }
             */
            KEY_DOWN: string;
            /**
             * {@link Core.DocumentViewer#event:keyUp Core.DocumentViewer.keyUp }
             */
            KEY_UP: string;
            /**
             * {@link Core.DocumentViewer#event:mouseEnter Core.DocumentViewer.mouseEnter }
             */
            MOUSE_ENTER: string;
            /**
             * {@link Core.DocumentViewer#event:mouseMove Core.DocumentViewer.mouseMove }
             */
            MOUSE_MOVE: string;
            /**
             * {@link Core.DocumentViewer#event:mouseLeave Core.DocumentViewer.mouseLeave }
             */
            MOUSE_LEAVE: string;
            /**
             * {@link Core.DocumentViewer#event:mouseRightDown Core.DocumentViewer.mouseRightDown }
             */
            MOUSE_RIGHT_DOWN: string;
            /**
             * {@link Core.DocumentViewer#event:mouseRightUp Core.DocumentViewer.mouseRightUp }
             */
            MOUSE_RIGHT_UP: string;
            /**
             * {@link Core.DocumentViewer#event:documentUnloaded Core.DocumentViewer.documentUnloaded }
             */
            DOCUMENT_UNLOADED: string;
            /**
             * {@link Core.DocumentViewer#event:annotationsLoaded Core.DocumentViewer.annotationsLoaded }
             */
            ANNOTATIONS_LOADED: string;
            /**
             * {@link Core.DocumentViewer#event:beforeDocumentLoaded Core.DocumentViewer.beforeDocumentLoaded }
             */
            BEFORE_DOCUMENT_LOADED: string;
            /**
             * {@link Core.DocumentViewer#event:documentLoaded Core.DocumentViewer.documentLoaded }
             */
            DOCUMENT_LOADED: string;
            /**
             * {@link Core.DocumentViewer#event:displayPageLocation Core.DocumentViewer.displayPageLocation }
             */
            DISPLAY_PAGE_LOCATION: string;
            /**
             * {@link Core.DocumentViewer#event:notify Core.DocumentViewer#event:notify }
             */
            NOTIFY: string;
            /**
             * {@link Core.DocumentViewer#event:searchInProgress Core.DocumentViewer.searchInProgress }
             */
            SEARCH_IN_PROGRESS: string;
            /**
             * {@link Core.DocumentViewer#event:textSelected Core.DocumentViewer.textSelected }
             */
            TEXT_SELECTED: string;
            /**
             * {@link Core.DocumentViewer#event:toolModeUpdated Core.DocumentViewer.toolModeUpdated }
             */
            TOOL_MODE_UPDATED: string;
            /**
             * {@link Core.DocumentViewer#event:fitModeUpdated Core.DocumentViewer.fitModeUpdated }
             */
            FIT_MODE_UPDATED: string;
            /**
             * {@link Core.DocumentViewer#event:rotationUpdated Core.DocumentViewer.rotationUpdated }
             */
            ROTATION_UPDATED: string;
            /**
             * {@link Core.DocumentViewer#event:zoomUpdated Core.DocumentViewer.zoomUpdated }
             */
            ZOOM_UPDATED: string;
            /**
             * {@link Core.DocumentViewer#event:pageNumberUpdated Core.DocumentViewer.pageNumberUpdated }
             */
            PAGE_NUMBER_UPDATED: string;
            /**
             * {@link Core.DocumentViewer#event:pagesUpdated Core.DocumentViewer.pagesUpdated }
             */
            PAGES_UPDATED: string;
            /**
             * {@link Core.DocumentViewer#event:pageComplete Core.DocumentViewer.pageComplete }
             */
            PAGE_COMPLETE: string;
            /**
             * {@link Core.DocumentViewer#event:displayModeUpdated Core.DocumentViewer.displayModeUpdated }
             */
            DISPLAY_MODE_UPDATED: string;
            /**
             * {@link Core.DocumentViewer#event:beginRendering Core.DocumentViewer.beginRendering }
             */
            BEGIN_RENDERING: string;
            /**
             * {@link Core.DocumentViewer#event:finishedRendering Core.DocumentViewer.finishedRendering }
             */
            FINISHED_RENDERING: string;
            /**
             * {@link Core.DocumentViewer#event:toolUpdated Core.DocumentViewer.toolUpdated }
             */
            TOOL_UPDATED: string;
        };
        /**
         * Default values for document viewer. Set FitMode, DisplayMode or Zoom.
        */
        defaults: any;
    }
    namespace DocumentViewer {
        /**
         * @param docId - the id of the document that is being loaded
         */
        type DocumentXFDFRetriever = (docId: string) => Promise<string | string[]>;
        /**
         */
        type SnapData = {
            /**
             * The x position of the nearestPoint
             */
            x: number;
            /**
             * The y position of the nearestPoint
             */
            y: number;
            /**
             * The effective mode that was used to find this snap point.
             */
            mode: number;
            /**
             * The name of the effective mode that was used to find this snap point.
             */
            modeName: string;
        };
        /**
         * @param ctx - The {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D|Canvas Context} that determines how the watermark will be rendered.
         * Edit the {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D#Text_styles|text styles attributes} to change the rendering styling.
         * @param pageIndex - The index of the current page
         * @param pageWidth - The width of the current page
         * @param pageHeight - The height of the current page
         */
        type CustomWatermarkCallback = (ctx: CanvasRenderingContext2D, pageIndex: number, pageWidth: number, pageHeight: number) => void;
        /**
         * Contains a list of available fit modes for the DocumentViewer.
         */
        enum FitMode {
            FitWidth,
            FitPage,
            Zoom
        }
    }
    /**
     * A manager class that controls freetext annotation contents editing.
     */
    class EditBoxManager extends EventHandler {
        /**
         * Triggered after an editor is focused
         * @param editor - an instance of Editor
         * @param annotation - a freetext annotation
         */
        on(event: 'editorFocus', callback: (editor: Core.Annotations.FreeTextAnnotation.RichTextEditor, annotation: Core.Annotations.FreeTextAnnotation) => void): void;
        /**
         * Triggered after an editor is focused
         * @param editor - an instance of Editor
         * @param annotation - a freetext annotation
         */
        one(event: 'editorFocus', callback: (editor: Core.Annotations.FreeTextAnnotation.RichTextEditor, annotation: Core.Annotations.FreeTextAnnotation) => void): void;
        off(event?: 'editorFocus', callback?: (editor: Core.Annotations.FreeTextAnnotation.RichTextEditor, annotation: Core.Annotations.FreeTextAnnotation) => void): void;
        /**
         * Triggered after an editor blurred
         * @param editor - an instance of Editor
         * @param annotation - a freetext annotation
         */
        on(event: 'editorBlur', callback: (editor: Core.Annotations.FreeTextAnnotation.RichTextEditor, annotation: Core.Annotations.FreeTextAnnotation) => void): void;
        /**
         * Triggered after an editor blurred
         * @param editor - an instance of Editor
         * @param annotation - a freetext annotation
         */
        one(event: 'editorBlur', callback: (editor: Core.Annotations.FreeTextAnnotation.RichTextEditor, annotation: Core.Annotations.FreeTextAnnotation) => void): void;
        off(event?: 'editorBlur', callback?: (editor: Core.Annotations.FreeTextAnnotation.RichTextEditor, annotation: Core.Annotations.FreeTextAnnotation) => void): void;
        /**
         * Triggered after some text in the editor changed
         */
        on(event: 'editorTextChanged', callback: () => void): void;
        /**
         * Triggered after some text in the editor changed
         */
        one(event: 'editorTextChanged', callback: () => void): void;
        off(event?: 'editorTextChanged', callback?: () => void): void;
        /**
         * Triggered after selection in the editor changed
         * @param range - current selected range
         * @param oldRange - previous selected range
         */
        on(event: 'editorSelectionChanged', callback: (range: Core.EditBoxManager.Range, oldRange: Core.EditBoxManager.Range) => void): void;
        /**
         * Triggered after selection in the editor changed
         * @param range - current selected range
         * @param oldRange - previous selected range
         */
        one(event: 'editorSelectionChanged', callback: (range: Core.EditBoxManager.Range, oldRange: Core.EditBoxManager.Range) => void): void;
        off(event?: 'editorSelectionChanged', callback?: (range: Core.EditBoxManager.Range, oldRange: Core.EditBoxManager.Range) => void): void;
    }
    namespace EditBoxManager {
        /**
         */
        type Range = {
            /**
             * the index of cursor
             */
            index: number;
            /**
             * the number of characters that are selected
             */
            length: number;
        };
    }
    /**
     * A manager class that controls form field creation and editing
     */
    class FormFieldCreationManager extends EventHandler {
        /**
         * Starts the Form Field Creation mode, a mode in which all annotations are hidden
        and only form field place holder annotations can be added
         */
        startFormFieldCreationMode(): void;
        /**
         * Ends the Form Field Creation mode, converting all the form field place holder annotations
        into Widget annotations with their respective fields.
         */
        endFormFieldCreationMode(): void;
        /**
         * Gets if the Form Field Creation manager is currently in creation mode
         */
        isInFormFieldCreationMode(): void;
        /**
         * Set the form field placeholder name
         * @param formfieldPlaceHolder - The form field place holder
         * @param fieldName - The field name
         */
        setFieldName(formfieldPlaceHolder: any, fieldName: any): void;
        /**
         * Set the field default value
         * @param formfieldPlaceHolder - The form field place holder
         * @param fieldValue - The field value
         */
        setFieldValue(formfieldPlaceHolder: any, fieldValue: any): void;
        /**
         * Set a field flag as true or false
        Available field flags are those listed in custom data labels
         * @param formfieldPlaceHolder - The form field place holder
         * @param fieldFlag - The field flag name
         * @param boolean - Value for the flag
         */
        setFieldFlag(formfieldPlaceHolder: any, fieldFlag: any, boolean: any): void;
        /**
         * Returns true or false depending on whether a flag is set on the form field place holder
         * @param formfieldPlaceHolder - The form field place holder
         * @param fieldFlag - A string representing the field flag
         * @returns boolean representing whether flag is set
         */
        getFieldFlag(formfieldPlaceHolder: any, fieldFlag: any): any;
        /**
         * Sets the options list on the form field place holder
         * @param formfieldPlaceHolder - The form field place holder
         * @param options - The options, an array of objects with a value and displayValue property
         */
        setFieldOptions(formfieldPlaceHolder: any, options: any): void;
        /**
         * Gets the field name from the form form field place holder
         * @param formfieldPlaceHolder - The form field place holder
         * @returns string Field name
         */
        getFieldName(formfieldPlaceHolder: any): any;
        /**
         * Gets the field value from the form form field place holder
         * @param formfieldPlaceHolder - The form field place holder
         * @returns string Field value
         */
        getFieldValue(formfieldPlaceHolder: any): any;
        /**
         * Gets the existing radio button groups
         * @returns string[] Array with Radio Button group names
         */
        getRadioButtonGroups(): any;
        /**
         * Returns the labels being used to store the field custom data
         */
        getFieldLabels(): void;
        /**
         * Gets the field options associated with the form field place holder
         * @param formfieldPlaceHolder - The form field place holder
         */
        getFieldOptions(formfieldPlaceHolder: any): void;
        /**
         * Applies all form field annotations as PDF Fields with associated Widgets
         */
        applyFormFields(): void;
        /**
         * Returns a Widget Flags object based on the flags set in the form field place holder
         * @param formfieldPlaceHolder - The form field place holder
         * @returns WidgetFlags
         */
        getAnnotationFlags(formfieldPlaceHolder: any): any;
    }
    /**
     * Contains helpful classes to work with position, dimensions, and transformations.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     var Math = instance.Core.Math;
     *     // Math.Point
     *   });
     */
    namespace Math {
        /**
         * Creates a new Matrix.
         * @property Rows - the number of rows
         * @property Columns - the number of columns
         * @param Rows - the number of rows
         * @param Columns - the number of columns
         */
        class Matrix {
            constructor(Rows: number, Columns: number);
            /**
             * Returns a 3x3 identity matrix.
             */
            static Identity: any;
            /**
             * Multiplies two matrices together
             * @param left - The left matrix
             * @param right - The right Matrix
             * @returns The result matrix
             */
            static multiply(left: Core.Math.Matrix, right: Core.Math.Matrix): Core.Math.Matrix;
            /**
             * Multiples a series of transformations to create a final transformation matrix. Optionally, provide a point to transform with respect to.
             * Note that the order of transformations in the array matters and should be the logical order you expect them to execute in.
             * @param transforms - An array of ordered transformations
             * @param [origin] - A point to transform with respect to. Default: (0, 0)
             * @returns The result matrix
             */
            static createTransformWithRespectTo(transforms: Core.Math.Matrix[], origin?: Core.Math.Point): Core.Math.Matrix;
            /**
             * Creates a matrix from {@link Core.PDFNet.Matrix2D Matrix2D}.
             * @param mat2d - The PDFNet matrix
             * @returns The matrix that represents the original
             */
            static fromMatrix2D(mat2d: Core.PDFNet.Matrix2D): Core.Math.Matrix;
            /**
             * Gets a value in a particular cell in the matrix.
             * @param row - The row number
             * @param column - The column number
             */
            get(row: number, column: number): number;
            /**
             * Sets the value in a particular cell in the matrix.
             * @param row - The row number
             * @param column - The column number
             * @param val - The number to set
             */
            set(row: number, column: number, val: number): void;
            /**
             * Sets the scale transformation values.
             * @param sx - The amount to scale horizontally
             * @param sy - The amount to scale vertically
             */
            setScale(sx: number, sy: number): void;
            /**
             * Set the X scale transformation value.
             * @param sx - The amount to scale horizontally
             */
            setScaleX(sx: any): void;
            /**
             * Set the Y scale transformation value.
             * @param sy - The amount to scale vertically
             */
            setScaleY(sy: any): void;
            /**
             * Sets the translate transformation values.
             * @param tx - The amount to translate horizontally
             * @param ty - The amount to translate vertically
             */
            setTranslate(tx: any, ty: any): void;
            /**
             * Sets the X translate transformation value.
             * @param tx - The amount to translate horizontally
             */
            setTranslateX(tx: any): void;
            /**
             * Set the Y translate transformation value.
             * @param ty - The amount to translate vertically
             */
            setTranslateY(ty: any): void;
            /**
             * Sets the skew transformation values.
             * @param sx - The amount to skew horizontally
             * @param sy - The amount to skew vertically
             */
            setSkew(sx: any, sy: any): void;
            /**
             * Sets the X skew transformation value.
             * @param sx - The amount to skew horizontally.
             */
            setSkewX(sx: any): void;
            /**
             * Sets the Y skew transformation value.
             * @param sy - The amount to skew vertically.
             */
            setSkewY(sy: any): void;
            /**
             * Sets the rotational values of the matrix.
             * @param angle - The amount to rotate by.
             * @param [inRadians = false] - Whether the amount is in radians. Default: false
             */
            setRotation(angle: number, inRadians?: boolean): void;
            /**
             * Multiples this matrix (left) against another matrix (right).
             * @param rightMatrix - The other matrix
             * @returns The result matrix
             */
            multiply(rightMatrix: Core.Math.Matrix): Core.Math.Matrix;
            /**
             * Flips the values of the matrix using the diagonal row.
             */
            transpose(): void;
            /**
             * Gets an array of values to use in an HTML Canvas context transform.
             * @returns Array of values
             */
            toTransform(): number[];
            /**
             * Clones this matrix.
             * @returns A clone of this matrix
             */
            clone(): any;
            /**
             * Calculates the determinant of the matrix. Only works for 3x3!
             * @returns The determinant
             */
            determinent(): number;
            /**
             * Get an inverse matrix. This is helpful for reversing transformations.
             * This function will return null if no inverse was found.
             * @returns The inverse matrix of this matrix
             */
            inverse(): Core.Math.Matrix;
            /**
             * the number of rows
            */
            Rows: number;
            /**
             * the number of columns
            */
            Columns: number;
        }
        /**
         * Creates a new Point with an x and y coordinate.
         * @property x - The x-coordinate
         * @property y - The y-coordinate
         * @param x - The x-coordinate
         * @param y - The y-coordinate
         */
        class Point {
            constructor(x: number, y: number);
            /**
             * Gets a point at (0, 0).
             */
            static Origin: any;
            /**
             * Returns the X value of this point.
             * @returns The X value
             */
            getX(): number;
            /**
             * Returns the Y value of this point.
             * @returns The Y value
             */
            getY(): number;
            /**
             * Adds two vectors together.
             * @param vec - A delta vector
             * @returns The combined vector representing a new direction
             */
            add(vec: Core.Math.Point): Core.Math.Point;
            /**
             * Subtracts two vectors from each other.
             * @param vec - A delta vector
             * @returns The resulting vector representing a new direction
             */
            subtract(vec: Core.Math.Point): Core.Math.Point;
            /**
             * Gets the dot product of this vector and another. This operation is commutative.
             * @param vec - The other vector
             * @returns The dot product
             */
            dot(vec: Core.Math.Point): number;
            /**
             * Gets the cross product of this vector and another. This operation is non-commutative.
             * @param vec - The other vector
             * @returns A cross product object with X, Y, Z properties
             */
            cross(vec: Core.Math.Point): any;
            /**
             * Gets the distance between this point and another.
             * @param vec - The other point
             * @returns The distance between these two points
             */
            distance(vec: Core.Math.Point): number;
            /**
             * Gets the angle between this point and another relative to the origin.
             * @param vec - The other point
             * @param [inRadians = false] - Whether the result should be in radians. Default: false
             * @returns The angle between these two points. Returns radians if inRadians is true
             */
            angle(vec: Core.Math.Point, inRadians?: boolean): number;
            /**
             * Normalizes the vector to get a unit vector of length 1.
             * @returns The unit vector
             */
            normalize(): Core.Math.Point;
            /**
             * .
             * Reverses the direction of this vector
             * @returns The reverse vector
             */
            reverse(): Core.Math.Point;
            /**
             * Gets a perpendicular vector from this one.
             * @returns The perpendicular vector
             */
            perpendicular(): Core.Math.Point;
            /**
             * Translates this point by the specified delta values.
             * @param x - the unit in the x-axis to translate by
             * @param y - the unit in the y-axis to translate by
             */
            translate(x: number, y: number): void;
            /**
             * Scales the point by a scaling factor.
             * @param s - The amount to scale by
             */
            rotate(s: any): void;
            /**
             * Gets a matrix that represents this point. You can include additional rows to add to the final matrix.
             * @param [vecs] - Additional rows to add.
             * @returns The matrix that represents this point.
             */
            toMatrix(vecs?: Core.Math.Point[]): Core.Math.Matrix;
            /**
             * Applies a transformation matrix to this point.
             * @param transform - The transformation matrix.
             */
            transform(transform: Core.Math.Matrix): void;
            /**
             * Compares this point to another. Points are considered the same if they are within 0.00001 units of each other.
             * @param vec - The other point
             * @returns Returns true if points are 0.00001 units of each other. Otherwise false.
             */
            equals(vec: Core.Math.Point): any;
            /**
             * Checks whether this vector is parallel to another vector.
             * @param vec - The other vector
             * @returns Returns true if both vectors are parallel (same slope). Otherwise false.
             */
            isParallelTo(vec: Core.Math.Point): any;
            /**
             * Clones this point.
             * @returns Returns a new instance of the same point.
             */
            clone(): any;
            /**
             * Compares this point to another. Evaluates the same way as {@link Core.Math.Point#equals equals}.
             * @param vec - The other point
             * @returns Returns true if points are 0.00001 units of each other. Otherwise false.
             */
            equalTo(vec: any): any;
            /**
             * Serialize a Point object to a JSON object, which can be saved for further use.
             * Calling 'JSON.stringify()' on a Point object will call this function automatically.
             * @returns The converted Point JSON object.
             */
            toJSON(): any;
            /**
             * The x-coordinate
            */
            x: number;
            /**
             * The y-coordinate
            */
            y: number;
        }
        /**
         * Create a new Quad with the x and y coordinates of the the four points of a quadrilateral.
         * @example
         * (x4,y4)---(x3,y3)
         *     |        |
         *  (x1,y1)---(x2,y2)
         * @property x1 - the x coordinate of the lower-left point
         * @property y1 - the y coordinate of the lower-left point
         * @property x2 - the x coordinate of the lower-right point
         * @property y2 - the y coordinate of the lower-right point
         * @property x3 - the x coordinate of the upper-right point
         * @property y3 - the y coordinate of the upper-right point
         * @property x4 - the x coordinate of the upper-left point
         * @property y4 - the y coordinate of the upper-left point
         * @param x1 - the x coordinate of the lower-left point
         * @param y1 - the y coordinate of the lower-left point
         * @param x2 - the x coordinate of the lower-right point
         * @param y2 - the y coordinate of the lower-right point
         * @param x3 - the x coordinate of the upper-right point
         * @param y3 - the y coordinate of the upper-right point
         * @param x4 - the x coordinate of the upper-left point
         * @param y4 - the y coordinate of the upper-left point
         */
        class Quad {
            constructor(x1: number, y1: number, x2: number, y2: number, x3: number, y3: number, x4: number, y4: number);
            /**
             * Returns a {@link Core.Math.Rect Rect} that represents this quad.
             * @returns A rect that represents this quad
             */
            toRect(): Core.Math.Rect;
            /**
             * the x coordinate of the lower-left point
            */
            x1: number;
            /**
             * the y coordinate of the lower-left point
            */
            y1: number;
            /**
             * the x coordinate of the lower-right point
            */
            x2: number;
            /**
             * the y coordinate of the lower-right point
            */
            y2: number;
            /**
             * the x coordinate of the upper-right point
            */
            x3: number;
            /**
             * the y coordinate of the upper-right point
            */
            y3: number;
            /**
             * the x coordinate of the upper-left point
            */
            x4: number;
            /**
             * the y coordinate of the upper-left point
            */
            y4: number;
        }
        /**
         * Create a new Rect with the x and y coordinates of the upper-left and lower right points.
         * @example
         * (x1,y1)------|
         *     |         |
         *     |-------(x2,y2)
         * @property x1 - the x coordinate of the upper-left point
         * @property y1 - the y coordinate of the upper-left point
         * @property x2 - the x coordinate of the lower-right point
         * @property y2 - the y coordinate of the lower-right point
         * @param x1 - the x coordinate of the upper-left point
         * @param y1 - the y coordinate of the upper-left point
         * @param x2 - the x coordinate of the lower-right point
         * @param y2 - the y coordinate of the lower-right point
         */
        class Rect {
            constructor(x1: number, y1: number, x2: number, y2: number);
            /**
             * A static method that determines whether the two rects provided intersect each other.
             * @param rect1 - The first rect
             * @param rect2 - The second rect
             * @returns True if the rects intersect. Otherwise, false.
             */
            static intersects(rect1: Core.Math.Rect, rect2: Core.Math.Rect): boolean;
            /**
             * A static method that determines whether the first rect is contains the second rect.
             * @param rect - The first rect (container)
             * @param container - The second rect
             * @returns True if the first rect contains the second rect. Otherwise false
             */
            static contains(rect: Core.Math.Rect, container: Core.Math.Rect): boolean;
            /**
             * Creates a Rect using position and dimensions.
             * @param x - The X coordinate
             * @param y - The Y coordinate
             * @param width - The width of the rect
             * @param height - The height of the rect
             * @returns A rect at the designated position of the defined size
             */
            static createFromDimensions(x: number, y: number, width: number, height: number): Core.Math.Rect;
            /**
             * Returns the most left X value.
             */
            getLeft(): number;
            /**
             * Returns the most right X value.
             */
            getRight(): number;
            /**
             * Returns the most top Y value.
             */
            getTop(): number;
            /**
             * Returns the most bottom Y value.
             */
            getBottom(): number;
            /**
             * Gets the width of the rect
             * @returns The width of the rect
             */
            getWidth(): number;
            /**
             * Gets the height of the rect
             * @returns The height of the rect
             */
            getHeight(): number;
            /**
             * Gets a {@link Core.Math.Point Point} that is at the center of the rect.
             * @returns A point at the center of the rect
             */
            getCenter(): Core.Math.Point;
            /**
             * Gets a {@link Core.Math.Point Point} that is at the top-left of the rect.
             * @returns A point at the top-left of the rect
             */
            getTopLeft(): Core.Math.Point;
            /**
             * Gets a {@link Core.Math.Point Point} that is at the top-right of the rect.
             * @returns A point at the top-right of the rect
             */
            getTopRight(): Core.Math.Point;
            /**
             * Gets a {@link Core.Math.Point Point} that is at the bottom-left of the rect.
             * @returns A point at the bottom-left of the rect
             */
            getBottomLeft(): Core.Math.Point;
            /**
             * Gets a {@link Core.Math.Point Point} that is at the top-right of the rect.
             * @returns A point at the top-right of the rect
             */
            getBottomRight(): Core.Math.Point;
            /**
             * Translates the rect
             * @param x - The amount to translate in the x direction
             * @param y - The amount to translate in the y direction
             */
            translate(x: number, y: number): void;
            /**
             * Best fit this rect into another larger rect
             */
            fitTo(rect: Core.Math.Rect): void;
            /**
             * Normalizes the rect to ensure point (x1, y1) is the upper left point and width and height are non-negative.
             */
            normalize(): void;
            /**
             * Normalizes the rect to ensure point (x1, y1) is the bottom left point as expected by xfdf output
             */
            exportNormalize(): void;
            /**
             * A method to determine whether this rect overlaps with another. If this rect contains another, this is still considered true.
             * @param otherRect - The other rect
             * @returns True if the rects intersect. Otherwise, false.
             */
            intersects(otherRect: Rect): boolean;
            /**
             * A method to determine whether this rect contains another rect. It is not considered as containment if another rect intersects this one.
             * @param otherRect - The other rect
             * @returns True if this rect contains 'otherRect'. Otherwise, false.
             */
            contains(otherRect: Rect): boolean;
            /**
             * Applies a transformation matrix to the rect which will adjust the points.
             * @param transform - The transformation matrix to apply
             */
            transform(transform: Core.Math.Matrix): void;
            /**
             * Returns a {@link Core.Math.Quad Quad} that represents this rect.
             * @returns A quad that represents this rect
             */
            toQuad(): Core.Math.Quad;
            /**
             * the x coordinate of the upper-left point
            */
            x1: number;
            /**
             * the y coordinate of the upper-left point
            */
            y1: number;
            /**
             * the x coordinate of the lower-right point
            */
            x2: number;
            /**
             * the y coordinate of the lower-right point
            */
            y2: number;
        }
        /**
         * A builder class to help facilitate creating transformation matrices.
         * @param [initial] - transformation matrix list.
         */
        class TransformationBuilder {
            constructor(initial?: Core.Math.Matrix[]);
            /**
             * Gets the transformation at a particular index.
             * @param index - A valid index
             * @returns A transformation matrix
             */
            getAt(index: number): Core.Math.Matrix;
            /**
             * Sets the transformation matrix at a particular index.
             * @param index - A valid index
             * @param transform - A transformation matrix
             * @returns This instance
             */
            setAt(index: number, transform: Core.Math.Matrix): Core.Math.TransformationBuilder;
            /**
             * Inserts a transformation matrix at a particular index.
             * @param index - A valid index
             * @param transform - A transformation matrix
             * @returns This instance
             */
            insertAt(index: number, transform: Core.Math.Matrix): Core.Math.TransformationBuilder;
            /**
             * Removes the transformation matrix at a particular index.
             * @param index - A valid index
             * @returns This instance
             */
            removeAt(index: number): Core.Math.TransformationBuilder;
            /**
             * Pushes a transformation matrix into the list.
             * @param transform - The transformation matrix
             * @returns This instance
             */
            push(transform: Core.Math.Matrix): Core.Math.TransformationBuilder;
            /**
             * Pop and returns the last transformation matrix.
             * @returns This instance
             */
            pop(): Core.Math.TransformationBuilder;
            /**
             * Creates a translation transform and adds it to the list.
             * @param x - The amount to translate by horizontally
             * @param y - The amount to translate by vertically
             * @returns This instance
             */
            translate(x: number, y: number): Core.Math.TransformationBuilder;
            /**
             * Creates a translation transform from a source to a destination and adds it to the list.
             * @param sx - The source X value
             * @param sy - The source Y value
             * @param dx - The destination X value
             * @param dy - The destination Y value
             * @returns This instance
             */
            translateTo(sx: number, sy: number, dx: number, dy: number): Core.Math.TransformationBuilder;
            /**
             * Creates a scale transform and adds it to the list.
             * @param x - The amount to scale by horizontally
             * @param y - The amount to scale by vertically
             * @returns This instance
             */
            scale(x: number, y: number): Core.Math.TransformationBuilder;
            /**
             * Creates a scale transform and adds it to the list.
             * @param x - The amount to scale by horizontally
             * @param y - The amount to scale by vertically
             * @returns This instance
             */
            skew(x: number, y: number): Core.Math.TransformationBuilder;
            /**
             * Creates a rotation transform and adds it to the list.
             * @param angle - The amount to rotate by
             * @param [inRadians = false] - Whether the amount is in radians. Default: false
             * @returns This instance
             */
            rotate(angle: number, inRadians?: boolean): Core.Math.TransformationBuilder;
            /**
             * Gets the final transformation by multiplying the matrices in the list.
             * @returns The tranformation matrix
             */
            getFinalTransform(): Core.Math.Matrix;
            /**
             * Clears the list of all transformations.
             * @returns The tranformation matrix
             */
            clear(): Core.Math.Matrix;
        }
    }
    /**
     * A manager class that controls measurement of annotations and distance create tools.
     */
    class MeasurementManager extends Core.EventHandler {
        /**
         * Triggered when the scale has been updated.
         * @param result - All the scales with related annotations
         */
        on(event: 'scaleUpdated', callback: (result: any) => void): void;
        /**
         * Triggered when the scale has been updated.
         * @param result - All the scales with related annotations
         */
        one(event: 'scaleUpdated', callback: (result: any) => void): void;
        off(event?: 'scaleUpdated', callback?: (result: any) => void): void;
        /**
         * @returns Returns an object with the keys as scale strings and the values as an array of annotations and tools that use the scale
         */
        getScales(): {
            [key: string]: (Core.Annotations.Annotation | Core.Tools.Tool)[];
        };
        /**
         * @param options - The options for the scale to be created
         * @param options.scale - The scale object which contains the page scale, world scale and precision
         * @param options.applyTo - The measurement annotations and tools that the scale should be applied to
         */
        createAndApplyScale(options: {
            scale: Core.Scale;
            applyTo: (Core.Annotations.Annotation | Core.Tools.Tool)[];
        }): void;
        /**
         * @param scale - The scale object that should be deleted
         */
        deleteScale(scale: Core.Scale): void;
        /**
         * For all annotations and tools that currently use the old scale, this scale will be replaced with the new scale.
         * @param oldScale - The old scale which is selected
         * @param newScale - The new scale used to replace the old scale.
         * @returns Returns a list of annotations or measurement tools related to the newly created scale
         */
        replaceScale(oldScale: Core.Scale, newScale: Core.Scale): (Core.Annotations.Annotation | Core.Tools.Tool)[];
        /**
         * For all annotations and tools that currently use the old scales, these scales will be replaced with the new scale.
         * @param oldScales - The array of old scales which are selected
         * @param newScale - The new scale used to replace the old scales.
         * @returns Returns a list of annotations or measurement tools related to the newly created scale
         */
        replaceScales(oldScales: Core.Scale[], newScale: Core.Scale): (Core.Annotations.Annotation | Core.Tools.Tool)[];
        /**
         * Enable annotation's styles to be updated when the corresponding measurement tool's styles are updated.
         * @example
         * WebViewer(...)
         *  .then(function(instance) {
         *   let measurementManager = instance.Core.documentViewer.getMeasurementManager();
         *   measurementManager.enableAnnotationAndToolStyleSyncing()
         * });
         */
        enableAnnotationAndToolStyleSyncing(): void;
        /**
         * Disable the automatic updating of annotation styles even if the corresponding measurement tool's styles are updated.
         * @example
         * WebViewer(...)
         *  .then(function(instance) {
         *   let measurementManager = instance.Core.documentViewer.getMeasurementManager();
         *   measurementManager.disableAnnotationAndToolStyleSyncing()
         * });
         */
        disableAnnotationAndToolStyleSyncing(): void;
        /**
         * Return true if automatic updating of annotation styles when corresponding measurement tool's styles are updated, otherwise return false.
         * @example
         * WebViewer(...)
         *  .then(function(instance) {
         *   let measurementManager = instance.Core.documentViewer.getMeasurementManager();
         *   measurementManager.isAnnotationAndToolStyleSyncingEnabled()
         * });
         */
        isAnnotationAndToolStyleSyncingEnabled(): boolean;
        /**
         * @property SCALE_UPDATED - {@link Core.MeasurementManager#event:scaleUpdated Core.MeasurementManager.scaleUpdated }
         */
        static Events: {
            /**
             * {@link Core.MeasurementManager#event:scaleUpdated Core.MeasurementManager.scaleUpdated }
             */
            SCALE_UPDATED: string;
        };
    }
    /**
     * A class that encapsulates measurement scale information for converting from and to different units.
     * @example
     * const scale1 = new Core.Scale({pageScale: {value: 1, unit: 'in'}, worldScale: {value: 1, unit: 'ft'}}, 0.01);
     * const scale2 = new Core.Scale([[1, 'in'], [1, 'ft']], 0.01);
     * const scale2 = new Core.Scale('1 in = 1 ft', 0.01);
     * const scale2 = new Core.Scale({pageScale: {value: 1, unit: 'in'}, worldScale: {value: 1, unit: 'ft'}});
     * @param scaleRatio - Either an object, string or array containing the scale information. See examples for more detail.
     * @param [scaleObject.pageScale] - The page scale of the document
     * @param scaleObject.pageScale.value - The number value of the page scale
     * @param scaleObject.pageScale.unit - The unit of the page scale, e.g. cm
     * @param [scaleObject.worldScale] - The world scale
     * @param scaleObject.worldScale.value - The number value of the world scale
     * @param scaleObject.worldScale.unit - The unit of the world scale, e.g. cm
     * @param [precision] - The precision of the scale
     */
    class Scale {
        constructor(scaleRatio: any | string | (number | string)[][], precision?: number);
        /**
         * @returns Returns the values and units of the page scale and world scale in an array. For example: [[1, 'in'],[1, 'in']].
         */
        getScaleRatioAsArray(): (number | string)[][];
        /**
         * @returns Returns string format of scale
         */
        toString(): string;
    }
    /**
     * Contains tools for pan scrolling, text selection, annotation editing and annotation creation. You can access it as follows:
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     const Tools = instance.Core.Tools;
     *     // Tools.SomeClass
     *   });
     */
    namespace Tools {
        /**
         * Creates a new instance of AnnotationEditTool.
         * @param docViewer - An instance of DocumentViewer.
         */
        class AnnotationEditTool extends Core.Tools.AnnotationSelectTool {
            constructor(docViewer: Core.DocumentViewer);
        }
        /**
         * Represents a tool that can select annotations
         * @property overrideSelection - Whether to override the default annotation selection behavior of the tool. If true then annotations will not be selected by the tool.
         * @param docViewer - An instance of DocumentViewer.
         */
        class AnnotationSelectTool extends Core.Tools.Tool {
            constructor(docViewer: Core.DocumentViewer);
            /**
             * padding at the page edges that defines how close annotations can be created and dragged to the edge
             */
            static PAGE_PADDING: Core.Math.Rect;
            /**
             * Sets the minimum size of annotations when resizing.
             * @example
             * instance.Core.Tools.AnnotationSelectTool.setMinimumAnnotationSizeWhenResizing((annotation) => {
             *   if (annotation instanceof instance.Annotations.RectangleAnnotation) {
             *     // minimum size for rectangles
             *     return { width: 100, height: 30 };
             *   }
             *   // no minimum size for other types
             *   return null;
             * });
             * @param minimumAnnotationSizeGetterFunction - A function that receives the annotation being resized
             * and returns an object with width and height values that represent the minimum width and height the annotation
             * should be allowed to resize to.
             */
            setMinimumAnnotationSizeWhenResizing(minimumAnnotationSizeGetterFunction: (...params: any[]) => any): void;
            /**
             * Sets the maximum size of annotations when resizing.
             * @example
             * instance.Core.Tools.AnnotationSelectTool.setMaximumAnnotationSizeWhenResizing((annotation) => {
             *   if (annotation instanceof instance.Annotations.RectangleAnnotation) {
             *     // maximum size for rectangles
             *     return { width: 100, height: 30 };
             *   }
             *   // no maximum size for other types
             *   return null;
             * });
             * @param maximumAnnotationSizeGetterFunction - A function that receives the annotation being resized
             * and returns an object with width and height values that represent the maximum width and height the annotation
             * should be allowed to resize to.
             */
            setMaximumAnnotationSizeWhenResizing(maximumAnnotationSizeGetterFunction: (...params: any[]) => any): void;
            /**
             * Set if the tool should trigger action immediately after clicking an annotation.
             * For example, if this is enabled then you can immediately click and drag an annotation without making a separate click to select the annotation.
             * @example
             * To enable this for one tool (The Pan tool, for example), this can be done:
             *
             * const tool = docViewer.getTool(window.Core.Tools.ToolNames.PAN);
             * tool.setEnableImmediateActionOnAnnotationSelection(true);
             *
             * To enable this for all selection tools, this can be done:
             *
             * const allTools = Object.values(docViewer.getToolModeMap());
             * for (const tool of allTools) {
             *   if (tool instanceof Tools.AnnotationSelectTool) {
             *     tool.setEnableImmediateActionOnAnnotationSelection(true);
             *   }
             * }
             * @param enable - A boolean indicating whether actions are triggered immediately on clicking on an annotation
             */
            setEnableImmediateActionOnAnnotationSelection(enable: boolean): void;
            /**
             * Sets if the tool should trigger actions immediately after clicking an annotation.
             * For example, if this is enabled then you can immediately click and drag an annotation without making a separate click to select the annotation.
             * @example
             * To enable this for one tool (The Pan tool, for example), this can be done:
             *
             * const tool = docViewer.getTool(window.Core.Tools.ToolNames.PAN);
             * tool.enableImmediateActionOnAnnotationSelection();
             *
             * To enable this for all selection tools, this can be done:
             *
             * const allTools = Object.values(docViewer.getToolModeMap());
             * for (const tool of allTools) {
             *   if (tool instanceof Tools.AnnotationSelectTool) {
             *     tool.enableImmediateActionOnAnnotationSelection();
             *   }
             * }
             */
            enableImmediateActionOnAnnotationSelection(): void;
            /**
             * Disable whether the tool should trigger an action immediately after clicking an annotation. When this is disabled you need to first click on annotation to select it before you can drag it.
             * This behavior is disabled by default.
             */
            disableImmediateActionOnAnnotationSelection(): void;
            /**
             * Whether to override the default annotation selection behavior of the tool. If true then annotations will not be selected by the tool.
            */
            overrideSelection: boolean;
        }
        /**
         * Represents the tool for creating {@link Core.Annotations.ArcAnnotation}.
         * @param docViewer - An instance of DocumentViewer.
         */
        class ArcCreateTool extends Core.Tools.PolylineCreateTool {
            constructor(docViewer: Core.DocumentViewer);
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
        }
        /**
         * Represents the tool for creating arc annotations with a measure dictionary.
         * @param docViewer - An instance of DocumentViewer.
         */
        class ArcMeasurementCreateTool extends Core.Tools.ArcCreateTool {
            constructor(docViewer: Core.DocumentViewer);
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
        }
        /**
         * Represents the tool for creating polygon annotations with a measure dictionary.
         * @param docViewer - An instance of DocumentViewer.
         */
        class AreaMeasurementCreateTool extends Core.Tools.PerimeterMeasurementCreateTool {
            constructor(docViewer: Core.DocumentViewer);
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
        }
        /**
         * Represents the tool for creating line annotations with an arrow head.
         * @param docViewer - An instance of DocumentViewer.
         */
        class ArrowCreateTool extends Core.Tools.LineCreateTool {
            constructor(docViewer: Core.DocumentViewer);
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
        }
        /**
         * Represents the tool for creating {@link Core.Annotations.FreeTextAnnotation}.
         * @property lineCount - The number of segments for the line of the created callout
         * @property defaults - The default styles of the tool
         * @property defaults.StrokeColor - The stroke color of the tool
         * @property defaults.FillColor - The fill color of the tool
         * @property defaults.TextColor - The text color of the tool
         * @property defaults.Opacity - The opacity of the tool
         * @property defaults.StrokeThickness - The stroke thickness of the tool
         * @property defaults.FontSize - The font size of the tool
         * @property defaults.Width - The width of the text box
         * @property defaults.Height - The height of the text box
         * @property defaults.Font - The font family of the tool. The value should be web safe fonts
         * @property defaults.TextAlign - The text alignment of the tool
         * @param docViewer - An instance of DocumentViewer.
         */
        class CalloutCreateTool extends Core.Tools.PolylineCreateTool {
            constructor(docViewer: Core.DocumentViewer);
            /**
             * @param handler - A function that should return a string that will be used as the initial text for a freetext annotation
             */
            static setTextHandler(handler: (...params: any[]) => any): void;
            /**
             * Set if the text box of the annotation should auto resize with a fixed width on text change
             * The width can be adjusted by changing calloutTool.defaults.Width to a different value
             * @param enable - A boolean indicating whether only the box height will resize on text change
             */
            setEnableAutoSized(enable: boolean): void;
            /**
             * Enables the text box of the annotation to auto resize with a fixed width when the text changes
             * The width can be adjusted by changing calloutTool.defaults.Width to a different value
             */
            enableAutoSizedTextBox(): void;
            /**
             * Disables auto resizing of the annotation text box
             */
            disableAutoSizedTextBox(): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * The number of segments for the line of the created callout
            */
            lineCount: number;
            /**
             * The default styles of the tool
            */
            defaults: {
                StrokeColor: Core.Annotations.Color;
                FillColor: Core.Annotations.Color;
                TextColor: Core.Annotations.Color;
                Opacity: number;
                StrokeThickness: number;
                FontSize: number;
                Width: number;
                Height: number;
                Font: string;
                TextAlign: 'left' | 'center' | 'right';
            };
        }
        /**
         * Represents the tool for creating change view annotations
         * @param docViewer - An instance of DocumentViewer.
         */
        class ChangeViewCreateTool extends Core.Tools.Tool {
            constructor(docViewer: Core.DocumentViewer);
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Allow the tool to create new annotations when hovering over an existing annotation
             */
            enableCreationOverAnnotation(): void;
            /**
             * Prevent the tool from creating new annotations when hovering over an existing annotation. The annotation will be selected instead.
             */
            disableCreationOverAnnotation(): void;
        }
        /**
         * Represents the tool for creating CheckBox Form Field Placeholders.
         * @param docViewer - An instance of DocumentViewer.
         */
        class CheckBoxFormFieldCreateTool extends Core.Tools.RectangleCreateTool {
            constructor(docViewer: Core.DocumentViewer);
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
        }
        /**
         * Represents the tool for creating rectangular polygon annotations with a measure dictionary.
         * @param docViewer - An instance of DocumentViewer.
         */
        class CloudyRectangularAreaMeasurementTool extends Core.Tools.RectangularAreaMeasurementTool {
            constructor(docViewer: Core.DocumentViewer);
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
        }
        /**
         * Represents the tool for creating ComboBox Form Field Placeholders
         * @param docViewer - An instance of DocumentViewer.
         */
        class ComboBoxFormFieldCreateTool extends Core.Tools.RectangleCreateTool {
            constructor(docViewer: Core.DocumentViewer);
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
        }
        /**
         * Represents a tool for document content editing.
         * When this tool is active then editable content boxes will automatically show up on the pages.
         * @param docViewer - An instance of DocumentViewer.
         * @param name - Name of the tool.
         */
        class ContentEditTool extends Core.Tools.AnnotationSelectTool {
            constructor(docViewer: Core.DocumentViewer, name: string);
        }
        /**
         * Creates a new instance of the CountMeasurementCreateTool
         * @param docViewer - An instance of DocumentViewer
         */
        class CountMeasurementCreateTool extends Core.Tools.StickyCreateTool {
            constructor(docViewer: Core.DocumentViewer);
        }
        /**
         * Represents the tool for creating {@link Core.Annotations.FreeTextAnnotation} with an associated date format.
         * @param docViewer - An instance of DocumentViewer.
         */
        class DateFreeTextCreateTool extends Core.Tools.FreeTextCreateTool {
            constructor(docViewer: Core.DocumentViewer);
            /**
             * Set the date format for the date picker
             * @param dateFormat - The date format that will be used by FreeText annotations created with this tool, eg: 'YYYY-MM-DD'
             */
            setDateFormat(dateFormat: string): void;
            /**
             * Get the date format for the date picker
             * @returns The date format used by this tool
             */
            getDateFormat(): string;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
        }
        namespace DistanceMeasurementCreateTool {
            /**
             */
            type LeaderLineOptions = {
                /**
                 * Indicates if leader lines can be drawn after an annotation is created.
                 */
                enabled: boolean;
                /**
                 * Indicates if leader lines will be drawn automatically after an annotation is created.
                 */
                autoCreate: boolean;
                /**
                 * Indicates length of leader lines in pixels.
                 */
                length: number;
            };
        }
        /**
         * Represents the tool for creating line annotations with a measure dictionary.
         * @param docViewer - An instance of DocumentViewer.
         */
        class DistanceMeasurementCreateTool extends Core.Tools.LineCreateTool {
            constructor(docViewer: Core.DocumentViewer);
            /**
             * Set if the tool should draw leader lines after the first mouse up instead of finishing it
             * @param enable - A boolean indicating whether leader lines should be drawn
             */
            setEnableLeaderLines(enable: boolean): void;
            /**
             * Enables the drawing of leader lines after the first mouse up instead of finishing the creation of the annotation
             */
            enableLeaderLines(): void;
            /**
             * Disables drawing of leader lines after the first mouse up. The annotation will be immediately created.
             */
            disableLeaderLines(): void;
            /**
             * Enables the creation of new distance annotations where the units are shown as imperial marks: ' and "
             * @example
             * WebViewer(...).then(instance => {
             *  const { Core } = instance;
             *  const tool = Core.documentViewer.getTool(Core.Tools.ToolNames.DISTANCE_MEASUREMENT);
             *  tool.enableImperialMarks();
             * })
             */
            enableImperialMarks(): void;
            /**
             * Check if imperial marks is enabled or disabled
             * @example
             * WebViewer(...).then(instance => {
             *  const tool = instance.Core.documentViewer.getTool('AnnotationCreateDistanceMeasurement');
             *  tool.isImperialMarksEnabled();
             * })
             * @returns Returns true if tool is imperial marks enabled
             */
            disableImperialMarks(): boolean;
            /**
             * Gets the default options set for leader line functionality.
             * @example
             * WebViewer(...).then(instance => {
             *  const { Core } = instance;
             *  const tool = Core.documentViewer.getTool(Core.Tools.ToolNames.DISTANCE_MEASUREMENT);
             *  const defaultLeaderLineOptions = tool.getLeaderLineDefaultOptions();
             *  console.log(defaultLeaderLineOptions);
             * });
             */
            getLeaderLineDefaultOptions(): Core.Tools.DistanceMeasurementCreateTool.LeaderLineOptions;
            /**
             * Sets the default options set for leader lines.
             * @example
             * WebViewer(...).then(instance => {
             *  const { Core } = instance;
             *  const tool = Core.documentViewer.getTool(Core.Tools.ToolNames.DISTANCE_MEASUREMENT);
             *  const defaultLeaderLineOptions = tool.setLeaderLineDefaultOptions({
             *    enabled: true,
             *    autoCreate: true,
             *    length: 20
             *  });
             * });
             */
            setLeaderLineDefaultOptions(options: Core.Tools.DistanceMeasurementCreateTool.LeaderLineOptions): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
        }
        /**
         * Represents the tool for creating {@link Core.Annotations.EllipseAnnotation}.
         * @param docViewer - An instance of DocumentViewer.
         */
        class EllipseCreateTool extends Core.Tools.GenericAnnotationCreateTool {
            constructor(docViewer: Core.DocumentViewer);
            /**
             * Sets the draw mode for the tool.
             * @param drawMode - One of the available draw modes.
             */
            setDrawMode(drawMode: Core.Tools.EllipseCreateTool.DrawModes): void;
            /**
             * Gets the draw mode for the tool.
             * @returns The current draw mode of the tool.
             */
            getDrawMode(): Core.Tools.EllipseCreateTool.DrawModes;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
        }
        /**
         * Represents the tool from creating an Ellipse Annotation to measure area and diameter
         * @param docViewer - An instance of DocumentViewer
         */
        class EllipseMeasurementCreateTool extends Core.Tools.EllipseCreateTool {
            constructor(docViewer: Core.DocumentViewer);
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
        }
        /**
         * Represents the tool for creating {@link Core.Annotations.EraserTool}.
         * @param docViewer - an instance of DocumentViewer.
         */
        class EraserTool extends Core.Tools.GenericAnnotationCreateTool {
            constructor(docViewer: Core.DocumentViewer);
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation is about to be deleted from the document by the tool
             * @example
             * const eraserTool = docViewer.getTool('AnnotationEraserTool');
             *
             *     eraserTool.addEventListener('erasingAnnotation', function(args) {
             *       // Make eraser tool skip deleting rectangle annotations
             *       if (args.annotation instanceof Annotations.RectangleAnnotation) {
             *         args.skipAnnotation();
             *       }
             *     });
             * @param args - Event arguments with event related properties
             * @param args.annotation - The annotation that will be deleted
             * @param args.skipAnnotation - A function you can call to skip deleting the annotation or points from a
             */
            on(event: 'erasingAnnotation', callback: (args: {
                annotation: any;
                skipAnnotation: Core.Annotations.FreeHandAnnotation;
            }) => void): void;
            /**
             * Triggered when an annotation is about to be deleted from the document by the tool
             * @example
             * const eraserTool = docViewer.getTool('AnnotationEraserTool');
             *
             *     eraserTool.addEventListener('erasingAnnotation', function(args) {
             *       // Make eraser tool skip deleting rectangle annotations
             *       if (args.annotation instanceof Annotations.RectangleAnnotation) {
             *         args.skipAnnotation();
             *       }
             *     });
             * @param args - Event arguments with event related properties
             * @param args.annotation - The annotation that will be deleted
             * @param args.skipAnnotation - A function you can call to skip deleting the annotation or points from a
             */
            one(event: 'erasingAnnotation', callback: (args: {
                annotation: any;
                skipAnnotation: Core.Annotations.FreeHandAnnotation;
            }) => void): void;
            off(event?: 'erasingAnnotation', callback?: (args: {
                annotation: any;
                skipAnnotation: Core.Annotations.FreeHandAnnotation;
            }) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
        }
        /**
         * Represents the tool for creating {@link Core.Annotations.FileAttachmentAnnotation}.
         * @property ACCEPTED_FILE_TYPES - A string specifying the accepted file types to be opened by the file picker. By default any file type is accepted.
         * @property ACCEPTED_FILE_SIZE - A number specifying the accepted file size in bytes (exclusive). A null, undefined, or value zero and below means no limit.
         * @param docViewer - An instance of DocumentViewer.
         */
        class FileAttachmentCreateTool extends Core.Tools.Tool {
            constructor(docViewer: Core.DocumentViewer);
            /**
             * A string specifying the accepted file types to be opened by the file picker. By default any file type is accepted.
            */
            ACCEPTED_FILE_TYPES: string;
            /**
             * A number specifying the accepted file size in bytes (exclusive). A null, undefined, or value zero and below means no limit.
            */
            ACCEPTED_FILE_SIZE: number;
        }
        /**
         * Represents the tool for creating {@link Core.Annotations.FreeHandAnnotation}.
         * @property createDelay - The delay to allow for multiple paths to be added as part of the same annotation
         * @property simplifyPen - Whether to simplify the annotation path when a pen input is used, defaults to false
         * @param docViewer - An instance of DocumentViewer.
         */
        class FreeHandCreateTool extends Core.Tools.GenericAnnotationCreateTool {
            constructor(docViewer: Core.DocumentViewer);
            /**
             * When called, the current freehand annotation being created is added to the AnnotationManager, ignoring the createDelay.
             * It is only necessary to call this function if you want the annotation to be added before the createDelay elapses.
             * @returns A promise that resolves when the current freehand annotation has been added to the AnnotationManager
             */
            complete(): Promise<any>;
            /**
             * Set the createDelay property of the tool. This will change the delay for the tool to register new strokes as a new annotation. This will change the createDelay property on the instance of the tool, not the prototype.
             * @param createDelay - The delay to allow for multiple paths to be added as part on the same annotation
             */
            setCreateDelay(createDelay: number): void;
            /**
             * Get the createDelay property of the tool.
             * @returns The delay to allow for multiple paths to be added as part of the same annotation
             */
            getCreateDelay(): number;
            /**
             * Set the simplifyPen property of the tool. This will change the simplifyPen property on the instance of the tool, not the prototype.
             * @param simplifyPen - Whether to simplify the annotation path when a pen input is used, defaults to false
             */
            setSimplifyPen(simplifyPen: boolean): void;
            /**
             * Get the simplifyPen property of the tool.
             * @returns Whether to simplify the annotation path when a pen input is used, defaults to false
             */
            getSimplifyPen(): boolean;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * The delay to allow for multiple paths to be added as part of the same annotation
            */
            createDelay: number;
            /**
             * Whether to simplify the annotation path when a pen input is used, defaults to false
            */
            simplifyPen: boolean;
        }
        /**
         * Represents the tool for creating {@link Core.Annotations.FreeHandAnnotation}.
         * @property createDelay - The delay to allow for multiple paths to be added as part of the same annotation
         * @property simplifyPen - Whether to simplify the annotation path when a pen input is used, defaults to false
         * @property autoSmoothingRange - The range for error in auto-smoothing, a larger number meaning more room for error. Highlights that are drawn wider than this range will not be autosmoothed
         * @param docViewer - An instance of DocumentViewer.
         */
        class FreeHandHighlightCreateTool extends Core.Tools.FreeHandCreateTool {
            constructor(docViewer: Core.DocumentViewer);
            /**
             * Sets how wide the range would be for auto smoothing vertical and horizontal strokes.
             * @example
             * const tool = docViewer.getTool(instance.Core.Tools.ToolNames.FREEHAND_HIGHLIGHT);
             * tool.setAutoSmoothingRange(1);
             * @param range - a number indicating how wide is the range to auto smooth vertical and horizontal strokes
             */
            setAutoSmoothingRange(range: number): void;
            /**
             * Gets how wide the range would be for auto smoothing vertical and horizontal strokes.
             * @example
             * const tool = docViewer.getTool(instance.Core.Tools.ToolNames.FREEHAND_HIGHLIGHT);
             * tool.getAutoSmoothingRange();
             * @returns Returns a number indicating how the range would be for auto smoothing vertical and horizontal strokes.
             */
            getAutoSmoothingRange(): number;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * The delay to allow for multiple paths to be added as part of the same annotation
            */
            createDelay: number;
            /**
             * Whether to simplify the annotation path when a pen input is used, defaults to false
            */
            simplifyPen: boolean;
            /**
             * The range for error in auto-smoothing, a larger number meaning more room for error. Highlights that are drawn wider than this range will not be autosmoothed
            */
            autoSmoothingRange: number;
        }
        /**
         * Represents the tool for creating {@link Core.Annotations.FreeTextAnnotation}.
         * @property defaults - The default styles of the tool
         * @property defaults.StrokeColor - The stroke color of the tool
         * @property defaults.FillColor - The fill color of the tool
         * @property defaults.TextColor - The text color of the tool
         * @property defaults.Opacity - The opacity of the tool
         * @property defaults.StrokeThickness - The stroke thickness of the tool
         * @property defaults.FontSize - The font size of the tool
         * @property defaults.Font - The font family of the tool. The value should be web safe fonts
         * @property defaults.TextAlign - The horizontal text alignment of the tool
         * @property defaults.TextVerticalAlign - The vertical text alignment of the tool
         * @property defaults.RichTextStyle - The RichTextCSSStyle for text created by the tool
         * @param docViewer - An instance of DocumentViewer.
         */
        class FreeTextCreateTool extends Core.Tools.GenericAnnotationCreateTool {
            constructor(docViewer: Core.DocumentViewer);
            /**
             * @param handler - A function that should return a string that will be used as the initial text for a freetext annotation
             */
            static setTextHandler(handler: (...params: any[]) => any): void;
            /**
             * Enables autofocus of free text annotations on creation.
             * @example
             * const { Core } = instance;
             * Core.documentViewer.getTool(Core.Tools.ToolNames.FREETEXT).enableAutoFocusOnCreate();
             */
            enableAutoFocusOnCreate(): void;
            /**
             * Disables autofocus of free text annotations on creation.
             * @example
             * const { Core } = instance;
             * Core.documentViewer.getTool(Core.Tools.ToolNames.FREETEXT).disableAutoFocusOnCreate();
             */
            disableAutoFocusOnCreate(): void;
            /**
             * Returns whether free text annotations autofocus on creation.
             * @returns Returns true if free texts are autofocused on creation, false otherwise.
             */
            isAutoFocusingOnCreate(): boolean;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * The default styles of the tool
            */
            defaults: {
                StrokeColor: Core.Annotations.Color;
                FillColor: Core.Annotations.Color;
                TextColor: Core.Annotations.Color;
                Opacity: number;
                StrokeThickness: number;
                FontSize: number;
                Font: string;
                TextAlign: 'left' | 'center' | 'right';
                TextVerticalAlign: 'top' | 'center' | 'bottom';
                RichTextStyle: Core.Annotations.Annotation.RichTextCSSStyle;
            };
        }
        /**
         * Represents a generic tool use to create markup annotations based on two mouse points (mouse left down and mouse left up).
         * @property annotation - The instance of the annotation object created
         * @property annotationPrototype - The prototype of the annotation object created
         * @property defaults - The default styles of the tool
         * @property defaults.StrokeColor - The stroke color of the tool
         * @property defaults.FillColor - The fill color of the tool
         * @property defaults.Opacity - The opacity of the tool
         * @property defaults.StrokeThickness - The stroke thickness of the tool
         * @param docViewer - The instance of the corresponding DocumentViewer
         * @param annotationPrototype - The prototype of the Annotation to create.
         * @param [constructorArg] - optional argument to pass to the annotation's constructor
         */
        class GenericAnnotationCreateTool extends Core.Tools.AnnotationSelectTool {
            constructor(docViewer: Core.DocumentViewer, annotationPrototype: Core.Annotations.Annotation, constructorArg?: any);
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * The instance of the annotation object created
            */
            annotation: Core.Annotations.Annotation;
            /**
             * The prototype of the annotation object created
            */
            annotationPrototype: Core.Annotations.Annotation;
            /**
             * The default styles of the tool
            */
            defaults: {
                StrokeColor: Core.Annotations.Color;
                FillColor: Core.Annotations.Color;
                Opacity: number;
                StrokeThickness: number;
            };
        }
        /**
         * Represents the tool for creating {@link Core.Annotations.LineAnnotations}.
         * @param docViewer - An instance of DocumentViewer.
         */
        class LineCreateTool extends Core.Tools.GenericAnnotationCreateTool {
            constructor(docViewer: Core.DocumentViewer);
            /**
             * Sets the draw mode for the tool.
             * @param drawMode - One of the available draw modes.
             */
            setDrawMode(drawMode: Tools.LineCreateTool.DrawModes): void;
            /**
             * Gets the draw mode for the tool.
             * @returns The current draw mode of the tool.
             */
            getDrawMode(): Core.Tools.LineCreateTool.DrawModes;
            /**
             * Set the snap mode that will be used to calculate the end point position
             * @param mode - Enum for a snapping mode for the snapping.
             */
            setSnapMode(mode: number): void;
            /**
             * Get the current snap mode that will be used to calculate the end point position
             * @returns Enum for a snapping mode for the snapping.
             */
            getSnapMode(): number;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
        }
        /**
         * Represents the tool for creating ListBox Form Field Placeholders
         * @param docViewer - An instance of DocumentViewer.
         */
        class ListBoxFormFieldCreateTool extends Core.Tools.RectangleCreateTool {
            constructor(docViewer: Core.DocumentViewer);
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
        }
        /**
         * Creates a new instance of MarqueeZoomTool.
         * @property setZoomHandler - Sets the function that takes the current zoom level and returns the next zoom level if a mouse click without drag is performed
         * @param docViewer - An instance of DocumentViewer.
         */
        class MarqueeZoomTool extends Core.Tools.Tool {
            constructor(docViewer: Core.DocumentViewer);
            /**
             * Sets the function that takes the current zoom level and returns the next zoom level if a mouse click without drag is performed
            */
            setZoomHandler: (...params: any[]) => any;
        }
        /**
         * Represents a point on a page
         * @property pageIndex - the 0-based page value
         * @property x - the x offset of this point relative to the top left corner of the page
         * @property y - the y offset of this point relative to the top left corner of the page
         */
        class PageCoordinate {
            /**
             * the 0-based page value
            */
            pageIndex: number;
            /**
             * the x offset of this point relative to the top left corner of the page
            */
            x: number;
            /**
             * the y offset of this point relative to the top left corner of the page
            */
            y: number;
        }
        /**
         * Represents a tool for DocumentViewer's built-in mouse pan scrolling.
         * @property [previousStylusTool] - Deprecated Please use previouslyUsedTool instead. The previous tool instance before panning the document in the stylus mode, or pressing mouse wheel button.
         * @property [previouslyUsedTool] - The previous tool instance before panning the document in the stylus mode, or pressing mouse wheel button.
         * @param docViewer - An instance of DocumentViewer.
         */
        class PanTool extends Core.Tools.AnnotationSelectTool {
            constructor(docViewer: Core.DocumentViewer);
            /**
             * Checks whether the user is currently panning or not
             */
            isPanning(): boolean;
            /**
             * Checks whether the user is currently pinching or not
             */
            isPinching(): boolean;
            /**
             * Deprecated Please use previouslyUsedTool instead. The previous tool instance before panning the document in the stylus mode, or pressing mouse wheel button.
            */
            previousStylusTool?: Core.Tools.Tool;
            /**
             * The previous tool instance before panning the document in the stylus mode, or pressing mouse wheel button.
            */
            previouslyUsedTool?: Core.Tools.Tool;
        }
        /**
         * Represents the tool for creating polyline annotations with a measure dictionary.
         * @param docViewer - An instance of DocumentViewer.
         */
        class PerimeterMeasurementCreateTool extends Core.Tools.PolylineCreateTool {
            constructor(docViewer: Core.DocumentViewer);
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
        }
        namespace PolygonCloudCreateTool {
            enum ArcDrawModes {
                EQUAL_ARCS,
                RANDOM_ARCS
            }
        }
        /**
         * Represents the tool for creating {@link Core.Annotations.PolygonAnnotation}.
         * @param docViewer - An instance of DocumentViewer.
         */
        class PolygonCloudCreateTool extends Core.Tools.PolygonCreateTool {
            constructor(docViewer: Core.DocumentViewer);
            /**
             * Sets the arc drawing mode for annotations created by the tool
             * @example
             * const cloudTool = docViewer.getTool('AnnotationCreatePolygonCloud');
             * cloudTool.setArcDrawMode(instance.Core.Tools.PolygonCloudCreateTool.ArcDrawModes.RANDOM_ARCS);
             * @param arcDrawMode - Is either RANDOM_ARCS or EQUAL_ARCs
             * use existing ENUM to pass this value
             */
            setArcDrawMode(arcDrawMode: string): void;
            /**
             * Returns the current ArcDrawMode for the tool
             * @returns the ArcDrawMode
             */
            getArcDrawMode(): string;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
        }
        /**
         * Represents the tool for creating {@link Core.Annotations.PolygonAnnotation}.
         * @param docViewer - An instance of DocumentViewer.
         */
        class PolygonCreateTool extends Core.Tools.PolylineCreateTool {
            constructor(docViewer: Core.DocumentViewer);
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
        }
        /**
         * Represents the tool for creating {@link Core.Annotations.PolylineAnnotation}.
         * @param docViewer - An instance of DocumentViewer.
         */
        class PolylineCreateTool extends Core.Tools.GenericAnnotationCreateTool {
            constructor(docViewer: Core.DocumentViewer);
            /**
             * Sets whether new annotations can be created by the tool when hovering over an existing annotation
             * @param val - Whether creation of annotation is allowed when hovering over another annotation
             */
            setAllowCreationOverAnnotation(val: boolean): void;
            /**
             * Allow the tool to create new annotations when hovering over an existing annotation
             */
            enableCreationOverAnnotation(): void;
            /**
             * Prevent the tool from creating new annotations when hovering over an existing annotation. The annotation will be selected instead.
             */
            disableCreationOverAnnotation(): void;
            /**
             * Set the snap mode that will be used to calculate the end point position
             * @param mode - Enum for a snapping mode for the snapping.
             */
            setSnapMode(mode: number): void;
            /**
             * Get the current snap mode that will be used to calculate the end point position
             * @returns Enum for a snapping mode for the snapping.
             */
            getSnapMode(): number;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
        }
        /**
         * Represents the tool for creating RadioButton Form Field Placeholders
         * @param docViewer - An instance of DocumentViewer.
         */
        class RadioButtonFormFieldCreateTool extends Core.Tools.EllipseCreateTool {
            constructor(docViewer: Core.DocumentViewer);
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
        }
        /**
         * Represents the tool for creating {@link Core.Annotations.RectangleAnnotations}.
         * @param docViewer - An instance of DocumentViewer.
         */
        class RectangleCreateTool extends Core.Tools.GenericAnnotationCreateTool {
            constructor(docViewer: Core.DocumentViewer);
            /**
             * Set the snap mode that will be used to calculate the end point position
             * @param mode - Enum for a snapping mode for the snapping.
             */
            setSnapMode(mode: number): void;
            /**
             * Set the snap mode that will be used to calculate the end point position
             * @param mode - Enum for a snapping mode for the snapping.
             */
            getSnapMode(mode: number): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
        }
        /**
         * Represents the tool for creating rectangular polygon annotations with a measure dictionary.
         * @param docViewer - An instance of DocumentViewer.
         */
        class RectangularAreaMeasurementTool extends Core.Tools.AreaMeasurementCreateTool {
            constructor(docViewer: Core.DocumentViewer);
            /**
             * Sets the draw mode for the tool.
             * @param drawMode - One of the available draw modes.
             */
            setDrawMode(drawMode: Core.Tools.RectangularAreaMeasurementTool.DrawModes): void;
            /**
             * Gets the draw mode for the tool.
             * @returns The current draw mode of the tool.
             */
            getDrawMode(): Core.Tools.RectangularAreaMeasurementTool.DrawModes;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
        }
        /**
         * Represents the tool for creating {@link Core.Annotations.RedactionAnnotation}.
         * @param docViewer - An instance of DocumentViewer.
         */
        class RedactionCreateTool extends Core.Tools.TextAnnotationCreateTool {
            constructor(docViewer: Core.DocumentViewer);
            /**
             * Set if tool should automatically set font size based on the selected text (if redacting text)
             * @param enable - a boolean indicating whether overlay text font should be automatically set
             */
            setEnableTextAutoSize(enable: boolean): void;
            /**
             * Enable automatically setting the font size based on the selected text (if redacting text)
             */
            enableAutoSizedText(): void;
            /**
             * Disable automatically setting the font size based on the selected text (if redacting text)
             */
            disableAutoSizedText(): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
        }
        namespace RubberStampCreateTool {
            /**
             */
            type CustomStampData = {
                /**
                 * Custom stamp's main text
                 */
                title?: string;
                /**
                 * Time format text used as a custom timestamp, e.g. "DD-MM-YYYY"
                To render a plain-text string as a subtitle, place the desired string inside of square brackets
                e.g. "[This is a subtitle]".
                 */
                subtitle?: string;
                /**
                 * Background color value
                 */
                color?: Core.Annotations.Color;
                /**
                 * Font family to use for stamp text
                 */
                font?: string;
                /**
                 * Whether to use bold styling for the title or not
                 */
                bold?: boolean;
                /**
                 * Whether to use italic styling for the title or not
                 */
                italic?: boolean;
                /**
                 * Whether to underline the title or not
                 */
                underline?: boolean;
                /**
                 * Whether to strikeout the title or not
                 */
                strikeout?: boolean;
            };
        }
        /**
         * Represents the tool for creating {@link Core.Annotations.StampAnnotation}.
         * @param docViewer - An instance of DocumentViewer.
         */
        class RubberStampCreateTool extends Core.Tools.Tool {
            constructor(docViewer: Core.DocumentViewer);
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.StampAnnotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.StampAnnotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.StampAnnotation) => void): void;
            /**
             * Have this rubber stamp tool always create a single type of stamp with the specified icon value.
             * @param options - An object that can contain the following optional parameters
             * @param options.Icon - The name of the icon can be used, eg: 'SBRejected' | 'SHAccepted' | 'Dot'
             * @param [options.FillColor] - The color of the stamp. Defaults to black.
             * @param [options.Width] - The width of the stamp
             * @param [options.Height] - The Height of the stamp
             * @param [options.Opacity] - The Opacity of the stamp
             */
            useStamp(options: {
                Icon: string;
                FillColor?: Core.Annotations.Color;
                Width?: number;
                Height?: number;
                Opacity?: number;
            }): void;
            /**
             * Returns array of strings representing the standard stamps
             * @returns An array of objects representing the standard stamps
             */
            getStandardStamps(): string[];
            /**
             * Accepts and sets an array of objects representing standard stamps
             * @param stamps - An array of strings representing the standard stamps
             */
            setStandardStamps(stamps: string[]): void;
            /**
             * Returns array of objects representing the custom stamps
             * @returns An array of objects representing the custom stamps
             */
            getCustomStamps(): Core.Tools.RubberStampCreateTool.CustomStampData[];
            /**
             * Accepts and sets an array of objects representing custom stamps
             * @param stamps - An array of objects representing custom stamps
             * Example:
             * [
             *  {
             *    "title": "Sample Text",
             *    "subtitle": "DD-MM-YYYY",
             *    "color": window.Annotations.Color(0,0,0)
             *  }
             * ]
             */
            setCustomStamps(stamps: Core.Tools.RubberStampCreateTool.CustomStampData[]): void;
            /**
             * Sets the underlying annotation used by the tool
             * @param annotation - Annotation to set
             * @param text - Text to be set in the stamp
             */
            setRubberStamp(annotation: Core.Annotations.StampAnnotation, text: string): Promise<void>;
            /**
             * Sets a custom function to be used for drawing extra content on top of
             * custom stamps, enabling customization of the CanvasRenderingContext2D of
             * the Canvas element used for Rubber Stamps
             * @example
             * WebViewer(
             *  // ...
             * ).then(instance => {
             *   const { docViewer } = instance;
             *   const tool = docViewer.getTool('AnnotationCreateRubberStamp');
             *   tool.setCustomDrawFunction((ctx, annotation) => {
             *     const { Icon } = annotation;
             *     // `Icon` contains the text content of the stamp
             *     // This example conditionally renders custom content on the stamp only
             *     // if the contents of the stamp are in the approved list of stamps to
             *     // draw on
             *     const stampsToDrawOn = [
             *       'Approved',
             *       'Completed',
             *       'Final',
             *     ];
             *     if (stampsToDrawOn.includes(Icon)) {
             *       // Arbitrary example where an image is available in the DOM
             *       const img = document.getElementById('my-company-logo');
             *       ctx.drawImage(
             *         img, // The image to render
             *         0, // The X coordinate of where to place the image
             *         0, // The Y coordinate of where the place the image
             *         25, // The width of the image in pixels
             *         25, // The height of the image in pixels
             *       );
             *     }
             *   });
             * });
             * @param callback - A callback side effect function that takes a
             * two parameters. The first is assumed to be the type
             * CanvasRenderingContext2D, and modifies the parameter for the purposes of
             * custom drawing behavior on top of the default stamp behavior. The second
             * parameter is optional, and is assumed to be an instance of the
             * Core.Annotations.Annotation class, wherein custom behavior for the stamp
             * annotation being modified can be added (i.e. conditionally apply custom
             * drawing on certain annotations only)
             */
            setCustomDrawFunction(callback: (...params: any[]) => any): void;
            /**
             * Add the stamp to the document.
             */
            addStamp(): Promise<void>;
            /**
             * Gets the preview about how the annot will be drawn on the document
             * @param annotation - annotation to get the preview for.
             * @param parameters - canvas parameters and optional text for annotation, e.g. translated text.
             *  e.g. { canvasHeight: number, canvasWidth: number, text: string }
             * @returns Returns a promise that resolves a base64 string of the preview image
             */
            getPreview(annotation: Core.Annotations.StampAnnotation, parameters: any): Promise<string>;
            /**
             * Shows the preview about how the underlying annot looks like if it's drawn.
             */
            showPreview(): void;
            /**
             * Hide the preview element
             */
            hidePreview(): void;
            /**
             * Checks if the underlying annotation is empty.
             * If the underlying annotation is a StampAnnotation type return true.
             */
            isEmptyStamp(): boolean;
            /**
             * Get array of standard stamp annotations.
             */
            getStandardStampAnnotations(): Promise<Core.Annotations.StampAnnotation[]>;
            /**
             * Add a single custom stamp to tool's list
             * @param options - The custom stamp data
             */
            addCustomStamp(options: Core.Tools.RubberStampCreateTool.CustomStampData): void;
            /**
             * Draw custom stamp annotation onto a canvas
             * @param options - An object that can contain the following optional parameters
             * @param [options.title] - Custom stamp's main text
             * @param [options.subtitle] - Time format text used as a custom timestamp, e.g. "DD-MM-YYYY"
             * To render a plain-text string as a subtitle, place the desired string inside of square brackets
             * e.g. "[This is a subtitle]".
             * @param [options.color] - Fill color value, see Annotation.Color
             * @param [options.textColor] - Text color value, see Annotation.Color
             * @param [options.canvas] - Canvas to draw this annotation
             * @param [options.width] - Default width of stamp
             * @param [options.height] - Default height of stamp
             * @param [options.canvasParent] - Parent DOM element of canvas
             * @param [options.font] - Font family to use for stamp text
             * @param [options.bold] - Whether to use bold styling for the title or not
             * @param [options.italic] - Whether to use italic styling for the title or not
             * @param [options.underline] - Whether to underline the title or not
             * @param [options.strikeout] - Whether to strikeout the title or not
             */
            drawCustomStamp(options: {
                title?: string;
                subtitle?: string;
                color?: string;
                textColor?: string;
                canvas?: string;
                width?: string;
                height?: string;
                canvasParent?: string;
                font?: string;
                bold?: boolean;
                italic?: boolean;
                underline?: boolean;
                strikeout?: boolean;
            }): void;
            /**
             * Get array of custom annotations.
             */
            getCustomStampAnnotations(): Promise<Core.Annotations.StampAnnotation[]>;
        }
        /**
         * Creates a new instance of the SignatureCreateTool.
         * @property ctx - The signature canvas context
         * @property annot - The underlying annotation used by the tool
         * @property ACCEPTED_FILE_SIZE - A number specifying the accepted file size in bytes (exclusive). A null, undefined, or value zero and below means no limit.
         * @param docViewer - an instance of DocumentViewer.
         */
        class SignatureCreateTool extends Core.Tools.Tool {
            constructor(docViewer: Core.DocumentViewer);
            /**
             * Triggered when a page location has been clicked on by the tool
             * @param pageCoordinates - Indicates where the tool clicked
             * @param [signatureWidget] - The signature widget that was clicked to trigger the event
             */
            on(event: 'locationSelected', callback: (pageCoordinates: Core.Tools.PageCoordinate, signatureWidget?: Core.Annotations.SignatureWidgetAnnotation) => void): void;
            /**
             * Triggered when a page location has been clicked on by the tool
             * @param pageCoordinates - Indicates where the tool clicked
             * @param [signatureWidget] - The signature widget that was clicked to trigger the event
             */
            one(event: 'locationSelected', callback: (pageCoordinates: Core.Tools.PageCoordinate, signatureWidget?: Core.Annotations.SignatureWidgetAnnotation) => void): void;
            off(event?: 'locationSelected', callback?: (pageCoordinates: Core.Tools.PageCoordinate, signatureWidget?: Core.Annotations.SignatureWidgetAnnotation) => void): void;
            /**
             * Triggered when the tool saves a signature
             * @param annotation - The annotation that was saved
             */
            on(event: 'signatureSaved', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when the tool saves a signature
             * @param annotation - The annotation that was saved
             */
            one(event: 'signatureSaved', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'signatureSaved', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when the tool deletes a signature
             * @param annotation - The annotation that was deleted
             * @param index - The index of the annotation in the list
             */
            on(event: 'signatureDeleted', callback: (annotation: Core.Annotations.Annotation, index: number) => void): void;
            /**
             * Triggered when the tool deletes a signature
             * @param annotation - The annotation that was deleted
             * @param index - The index of the annotation in the list
             */
            one(event: 'signatureDeleted', callback: (annotation: Core.Annotations.Annotation, index: number) => void): void;
            off(event?: 'signatureDeleted', callback?: (annotation: Core.Annotations.Annotation, index: number) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when a file has been rejected because of exceeding file size limit
             * @param reasons - The rejection reasons object
             * @param reasons.reason - Reason why the file was rejected
             * @param reasons.maxSize - Maximum accpted file size in bytes
             * @param reasons.size - Uploaded file size in bytes
             */
            on(event: 'fileRejected', callback: (reasons: {
                reason: string;
                maxSize: number;
                size: number;
            }) => void): void;
            /**
             * Triggered when a file has been rejected because of exceeding file size limit
             * @param reasons - The rejection reasons object
             * @param reasons.reason - Reason why the file was rejected
             * @param reasons.maxSize - Maximum accpted file size in bytes
             * @param reasons.size - Uploaded file size in bytes
             */
            one(event: 'fileRejected', callback: (reasons: {
                reason: string;
                maxSize: number;
                size: number;
            }) => void): void;
            off(event?: 'fileRejected', callback?: (reasons: {
                reason: string;
                maxSize: number;
                size: number;
            }) => void): void;
            /**
             * @param textHandler - A function that should return a string that will be used as the "sign here" text
             */
            static setTextHandler(textHandler: (...params: any[]) => any): void;
            /**
             * Clears the signature canvas and the underlying annotation
             */
            clearSignatureCanvas(): void;
            /**
             * Resize the current signature canvas
             */
            resizeCanvas(): void;
            /**
             * Save an array of freehand or stamp annotations to the signature tool
             * @param annotations - Annotations to be saved to the signature tool
             */
            saveSignatures(annotations: Core.Annotations.FreeHandAnnotation | Core.Annotations.StampAnnotation): void;
            /**
             * Returns the array of saved annotations
             * @returns an array of annotations
             */
            getSavedSignatures(): (Core.Annotations.FreeHandAnnotation | Core.Annotations.StampAnnotation)[];
            /**
             * Delete an annotation in the tool
             * @param index - The index of the saved annotation to be deleted
             */
            deleteSavedSignature(index: number): void;
            /**
             * Loads signature data into the signature tool
             * @param signatureData - An array contains arrays of path points or base64 image data
             * If the element is a string, a stamp annotation will be saved and the string will be the value of its ImageData property
             * If the element is an array of objects, a freehand annotation will be saved and the array will be its paths
             * @returns Promise<void>
             */
            importSignatures(signatureData: (string | Core.Math.Point[][])[]): any;
            /**
             * Exports all saved signatures as an array
             * The array can be stringified using JSON.stringify and saved for later use
             * @returns Returns a promise that resolves an array that contains arrays of path points or a base64 image data
             */
            exportSignatures(): Promise<(string | Core.Math.Point[][])[]>;
            /**
             * Sets the underlying annotation used by the tool
             * If a base64 string is passed, the underlying annotation will be a stamp annotation with the string being its ImageData
             * @param annotation - Annotation to set
             * @param [fileSize] - A number specifying the size in bytes of the signature file which will be compared with 'ACCEPTED_FILE_SIZE'.
             * @returns Promise<void>
             */
            setSignature(annotation: Core.Annotations.FreeHandAnnotation | Core.Annotations.StampAnnotation | string | object[], fileSize?: number): any;
            /**
             * Clear the location which is set when a mouse click is performed
             */
            clearLocation(): void;
            /**
             * Returns if the signature tool has any location to draw the signature
             */
            hasLocation(): boolean;
            /**
             * Gets the preview about how the annot will be drawn on the document
             * @returns A promise that resolves with a base64 string of the preview image
             */
            getPreview(annotation: Core.Annotations.FreeHandAnnotation | Core.Annotations.StampAnnotation): Promise<string>;
            /**
             * Shows the preview about how the underlying annot looks like if it's drawn.
             */
            showPreview(): void;
            /**
             * Hide the preview element
             */
            hidePreview(): void;
            /**
             * Add the signature to the document.
             * @returns A promise that resolves when the signature is added
             */
            addSignature(): Promise<void>;
            /**
             * Checks if the underlying annotation is empty.
             * If the underlying annotation is a freehand, it's empty if it doesn't have any paths
             * If the underlying annotation is a stamp, it's empty if its ImageData property has a falsy value
             * @returns If number of drawn paths is 0.
             */
            isEmptySignature(): Promise<boolean>;
            /**
             * Sets the canvas to be used by the signature tool.
             * @param canvas - The canvas that the signature tool uses to draw on.
             */
            setSignatureCanvas(canvas: HTMLCanvasElement): void;
            /**
             * Sets the default options for signatures created with the signature tool.
             * @param options - Signature options that should become the default
             * @param options.maximumDimensionSize - The maximum size of the signature's largest dimension. Default is 200.
             */
            setDefaultSignatureOptions(options: {
                maximumDimensionSize: number;
            }): void;
            /**
             * The signature canvas context
            */
            ctx: CanvasRenderingContext2D;
            /**
             * The underlying annotation used by the tool
            */
            annot: Core.Annotations.FreeHandAnnotation | Core.Annotations.StampAnnotation;
            /**
             * A number specifying the accepted file size in bytes (exclusive). A null, undefined, or value zero and below means no limit.
            */
            ACCEPTED_FILE_SIZE: number;
        }
        /**
         * Represents the tool for creating {@link Core.Annotations.StampAnnotation}.
         * @property ACCEPTED_IMAGE_TYPES - A string specifying the accepted image types to be opened by the file picker default is image/*
         * @property ACCEPTED_FILE_SIZE - A number specifying the accepted file size in bytes (exclusive). A null, undefined, or value zero and below means no limit.
         * @param docViewer - An instance of DocumentViewer.
         */
        class StampCreateTool extends Core.Tools.Tool {
            constructor(docViewer: Core.DocumentViewer);
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when a file has been rejected because of exceeding file size limit
             * @param reasons - The rejection reasons object
             * @param reasons.reason - Reason why the file was rejected
             * @param reasons.maxSize - Maximum accpted file size in bytes
             * @param reasons.size - Uploaded file size in bytes
             */
            on(event: 'fileRejected', callback: (reasons: {
                reason: string;
                maxSize: number;
                size: number;
            }) => void): void;
            /**
             * Triggered when a file has been rejected because of exceeding file size limit
             * @param reasons - The rejection reasons object
             * @param reasons.reason - Reason why the file was rejected
             * @param reasons.maxSize - Maximum accpted file size in bytes
             * @param reasons.size - Uploaded file size in bytes
             */
            one(event: 'fileRejected', callback: (reasons: {
                reason: string;
                maxSize: number;
                size: number;
            }) => void): void;
            off(event?: 'fileRejected', callback?: (reasons: {
                reason: string;
                maxSize: number;
                size: number;
            }) => void): void;
            /**
             * A string specifying the accepted image types to be opened by the file picker default is image/*
            */
            ACCEPTED_IMAGE_TYPES: string;
            /**
             * A number specifying the accepted file size in bytes (exclusive). A null, undefined, or value zero and below means no limit.
            */
            ACCEPTED_FILE_SIZE: number;
        }
        /**
         * Represents the tool for creating {@link Core.Annotations.StickyAnnotation}.
         * @param docViewer - An instance of DocumentViewer.
         */
        class StickyCreateTool extends Core.Tools.Tool {
            constructor(docViewer: Core.DocumentViewer);
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Sets whether new annotations can be created by the tool when hovering over an existing annotation
             * @param val - Whether creation of annotation is allowed when hovering over another annotation
             */
            setAllowCreationOverAnnotation(val: boolean): void;
            /**
             * Allow the tool to create new annotations when hovering over an existing annotation
             */
            enableCreationOverAnnotation(): void;
            /**
             * Prevent the tool from creating new annotations when hovering over an existing annotation. The annotation will be selected instead.
             */
            disableCreationOverAnnotation(): void;
            /**
             * Sets whether new annotations have a ViewState applied to them.
             * ViewState is the state of the viewer when the annotation is created.
             * When the annotation is double clicked and ViewState exists, the viewer state will
             * be set to the ViewState
             */
            setSaveViewState(val: boolean): void;
            /**
             * When enabled, new annotations will have a ViewState applied to them.
             * ViewState is the state of the viewer when the annotation is created.
             * When the annotation is double clicked and ViewState exists, the viewer state will
             * be set to the ViewState
             */
            enableViewStateSaving(): void;
            /**
             * When called new annotations will not have a ViewState applied to them. By default no ViewState is applied.
             * ViewState is the state of the viewer when the annotation is created.
             * When the annotation is double clicked and ViewState exists, the viewer state will
             * be set to the ViewState
             */
            disableViewStateSaving(): void;
        }
        /**
         * This class should not be instantiated.
         * @property defaults - The default styles of the tool
         * @property defaults.StrokeColor - The stroke color of the tool
         * @property defaults.Opacity - The opacity of the tool
         * @param docViewer - An instance of DocumentViewer.
         * @param textAnnotationPrototype - The prototype the text-based annotation to create.
         */
        class TextAnnotationCreateTool extends Core.Tools.TextTool {
            constructor(docViewer: Core.DocumentViewer, textAnnotationPrototype: (...params: any[]) => any);
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Toggle whether selected text should be set as annotation note contents. False by default.
             */
            static AUTO_SET_TEXT: boolean;
            /**
             * The default styles of the tool
            */
            defaults: {
                StrokeColor: Core.Annotations.Color;
                Opacity: number;
            };
        }
        /**
         * Represents the tool for creating Text Form Field Placeholders
         * @param docViewer - An instance of DocumentViewer.
         */
        class TextFormFieldCreateTool extends Core.Tools.RectangleCreateTool {
            constructor(docViewer: Core.DocumentViewer);
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
        }
        /**
         * Represents the tool for creating {@link Core.Annotations.TextHighlightAnnotation}.
         * @param docViewer - An instance of DocumentViewer.
         */
        class TextHighlightCreateTool extends Core.Tools.TextAnnotationCreateTool {
            constructor(docViewer: Core.DocumentViewer);
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
        }
        /**
         * Represents a tool for DocumentViewer's built-in text selection.
         * @param docViewer - An instance of DocumentViewer.
         */
        class TextSelectTool extends Core.Tools.TextTool {
            constructor(docViewer: Core.DocumentViewer);
            /**
             * Triggered when the user has released the mouse after selecting text
             * @param startLocation - An object with keys "quad" and "pageNumber" which is the starting quad and page number of the text selection
             * @param allQuads - An object with keys being the page numbers and values being an array of quads for the selected text on that page
             */
            on(event: 'selectionComplete', callback: (startLocation: any, allQuads: any) => void): void;
            /**
             * Triggered when the user has released the mouse after selecting text
             * @param startLocation - An object with keys "quad" and "pageNumber" which is the starting quad and page number of the text selection
             * @param allQuads - An object with keys being the page numbers and values being an array of quads for the selected text on that page
             */
            one(event: 'selectionComplete', callback: (startLocation: any, allQuads: any) => void): void;
            off(event?: 'selectionComplete', callback?: (startLocation: any, allQuads: any) => void): void;
        }
        /**
         * Represents the tool for creating {@link Core.Annotations.TextSquigglyAnnotation}.
         * @param docViewer - An instance of DocumentViewer.
         */
        class TextSquigglyCreateTool extends Core.Tools.TextAnnotationCreateTool {
            constructor(docViewer: Core.DocumentViewer);
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
        }
        /**
         * Represents the tool for creating {@link Core.Annotations.TextStrikeoutAnnotation}.
         * @param docViewer - An instance of DocumentViewer.
         */
        class TextStrikeoutCreateTool extends Core.Tools.TextAnnotationCreateTool {
            constructor(docViewer: Core.DocumentViewer);
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
        }
        /**
         * Represents an extendable class for text-based tool.
         * @property SELECTION_MODE - Selection mode used by text tools ('structural' or 'rectangular')
         * @param docViewer - An instance of DocumentViewer.
         */
        class TextTool extends Core.Tools.AnnotationSelectTool {
            constructor(docViewer: Core.DocumentViewer);
            /**
             * Select text based on two points
             * @param pagePt1 - The start point to select from. Is an object with pageIndex, x and y properties.
             * @param pagePt2 - The end point to select to. Is an object with pageIndex, x and y properties.
             */
            select(pagePt1: any, pagePt2: any): void;
            /**
             * The function called when a text region is selected.
             * @param quads - The array of quad coordinates for the selected text.
             * @param text - The text selected.
             */
            textSelected(pageNumber: number, quads: Core.Math.Quad[], text: string): void;
            /**
             * Selection mode used by text tools ('structural' or 'rectangular')
            */
            SELECTION_MODE: string;
        }
        /**
         * Represents the tool for creating {@link Core.Annotations.TextUnderlineAnnotation}.
         * @param docViewer - An instance of DocumentViewer.
         */
        class TextUnderlineCreateTool extends Core.Tools.TextAnnotationCreateTool {
            constructor(docViewer: Core.DocumentViewer);
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            on(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been created by the tool
             * @param annotations - The annotation that was created
             */
            one(event: 'annotationCreated', callback: (annotations: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationCreated', callback?: (annotations: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            on(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            /**
             * Triggered when an annotation has been added to the document by the tool
             * @param annotation - The annotation that was added
             */
            one(event: 'annotationAdded', callback: (annotation: Core.Annotations.Annotation) => void): void;
            off(event?: 'annotationAdded', callback?: (annotation: Core.Annotations.Annotation) => void): void;
        }
        /**
         * Represents the base class for DocumentViewer UI tools.
         * @property docViewer - the reference to the current DocumentViewer instance
         * @property pageCoordinates - an array of page coordinates this tool currently holds. The default is index 0 for the mouse left down and index 1 for mouse left up.
         * @property [name] - The name of the tool
         * @property cursor - The name of the default mouse cursor used when the tool is active
         * @param docViewer - An instance of DocumentViewer.
         */
        class Tool extends Core.EventHandler {
            constructor(docViewer: Core.DocumentViewer);
            /**
             * A boolean indicating whether text selection is enabled
             */
            static ENABLE_TEXT_SELECTION: boolean;
            /**
             * A boolean indicating whether the text select tool should automatically switch if the cursor is hovering over text or not
             */
            static ENABLE_AUTO_SWITCH: boolean;
            /**
             * A boolean indicating whether the cursor should change when hovering over annotations. Default is true.
             */
            static ENABLE_ANNOTATION_HOVER_CURSORS: boolean;
            /**
             * A boolean indicating whether annotations can be dragged outside of the page boundaries. Default is false.
             */
            static ALLOW_ANNOTS_OUTSIDE_PAGE: boolean;
            /**
             * Enable text selection.
             */
            static enableTextSelection(): void;
            /**
             * Disable text selection.
             */
            static disableTextSelection(): void;
            /**
             * The text select tool will automatically switch if the cursor is hovering over text.
             */
            static enableAutoSwitch(): void;
            /**
             * The text select tool will not automatically switch if the cursor is hovering over text.
             */
            static disableAutoSwitch(): void;
            /**
             * The cursor will change when hovering over annotations.
             */
            static enableAnnotationHoverCursors(): void;
            /**
             * The cursor will not change when hovering over annotations.
             */
            static disableAnnotationHoverCursors(): void;
            /**
             * Annotations will be allowed to be dragged outside of the page boundaries.
             */
            static allowAnnotationsOutsidePage(): void;
            /**
             * Annotations will not be allowed to be dragged outside of the page boundaries.
             */
            static disallowAnnotationsOutsidePage(): void;
            /**
             * Takes an event object from a mouse event and converts the location into window coordinates
             * @param e - The event object containing mouse coordinates
             * @returns Returns an object with x and y coordinates of the mouse cursor in the viewer
             */
            getMouseLocation(e: any): Core.Math.Point;
            /**
             * The function called when the left mouse button is down
             * @param e - The event object containing mouse coordinates.
             */
            mouseLeftDown(e: any): void;
            /**
             * The function called when the left mouse button is up.
             * Typically, annotations are created and added to the annotation manager at this point.
             * @param e - The event object containing mouse coordinates.
             */
            mouseLeftUp(e: any): void;
            /**
             * The function called when the right mouse button is down.
             * @param e - The event object containing mouse coordinates.
             */
            mouseRightDown(e: any): void;
            /**
             * The function called when the mouse moves.
             * @param e - The event object containing mouse coordinates.
             */
            mouseMove(e: any): void;
            /**
             * The function is called when the mouse left button is double clicked.
             * @param e - The event object containing mouse coordinates.
             */
            mouseDoubleClick(e: any): void;
            /**
             * The function is called when a keyboard key is down.
             * @param e - The event object containing keyboard key data.
             */
            keyDown(e: any): void;
            /**
             * The function is called when a context menu should be shown.
             * Use e.preventDefault to disable the default browser context menu.
             * @param e - The event object
             */
            contextMenu(e: any): void;
            /**
             * The function is called when this tool is selected.
             * Typically use for changing mouse cursors, and initializing states for the tool.
             * @param oldTool - The Tool class that was previously selected.
             */
            switchIn(oldTool: Core.Tools.Tool): void;
            /**
             * The function is called when this tool is deselected.
             * Typically use for changing mouse cursors, and cleaning up states for the tool.
             * @param newTool - The Tool class that was newly selected.
             */
            switchOut(newTool: Core.Tools.Tool): void;
            /**
             * Returns the instance of DocumentViewer for this tool.
             * @returns The instance of DocumentViewer for this tool.
             */
            getDocumentViewer(): Core.DocumentViewer;
            /**
             * Set the style for the tool, which will be applied to annotations drawn afterwards
             * @param newStyles - if an object is used, it should contain properties of the new styles.
             * If a function is used, the current styles will be passed as its argument and the function should return an object which contains properties of the new styles.
             * Example of valid properties: StrokeColor, TextColor, FillColor, FontSize, Opacity, StrokeThickness, Precision, Scale, OverlayText, Style and Dashes.
             */
            setStyles(newStyles: any | ((...params: any[]) => any)): void;
            /**
             * Set the name of the tool, which can be accessed by toolObject.name
             * @param name - Name of the tool
             */
            setName(name: string): void;
            /**
             * the reference to the current DocumentViewer instance
            */
            docViewer: Core.DocumentViewer;
            /**
             * an array of page coordinates this tool currently holds. The default is index 0 for the mouse left down and index 1 for mouse left up.
            */
            pageCoordinates: Core.Tools.PageCoordinate[];
            /**
             * The name of the tool
            */
            name?: string;
            /**
             * The name of the default mouse cursor used when the tool is active
            */
            cursor: string;
        }
        namespace LineCreateTool {
            /**
             * An enum representing the draw modes available for creating annotations.
             */
            enum DrawModes {
                HOLD_TO_DRAW,
                TWO_CLICKS,
                TWO_CLICKS_HOLD_TO_DRAW_HYBRID
            }
        }
        namespace EllipseCreateTool {
            /**
             * An enum representing the draw modes available for creating annotations.
             */
            enum DrawModes {
                HOLD_TO_DRAW,
                TWO_CLICKS
            }
        }
        namespace RectangularAreaMeasurementTool {
            /**
             * An enum representing the draw modes available for creating annotations.
             */
            enum DrawModes {
                HOLD_TO_DRAW,
                TWO_CLICKS
            }
        }
        /**
         * Enum for snap mode name and values. Snap modes control which point within the page is considered as the queried point.
         */
        enum SnapModes {
            DEFAULT,
            POINT_ON_LINE,
            LINE_MID_POINT,
            LINE_INTERSECTION,
            PATH_ENDPOINT
        }
        /**
         * Represents the names for the built-in tools
         */
        enum ToolNames {
            ARROW,
            ARROW2,
            ARROW3,
            ARROW4,
            CALLOUT,
            CALLOUT2,
            CALLOUT3,
            CALLOUT4,
            ELLIPSE,
            ELLIPSE2,
            ELLIPSE3,
            ELLIPSE4,
            FREEHAND,
            FREEHAND2,
            FREEHAND3,
            FREEHAND4,
            FREEHAND_HIGHLIGHT,
            FREEHAND_HIGHLIGHT2,
            FREEHAND_HIGHLIGHT3,
            FREEHAND_HIGHLIGHT4,
            FREETEXT,
            FREETEXT2,
            FREETEXT3,
            FREETEXT4,
            FORM_FILL_CROSS,
            FORM_FILL_CHECKMARK,
            FORM_FILL_DOT,
            LINE,
            LINE2,
            LINE3,
            LINE4,
            POLYGON,
            POLYGON2,
            POLYGON3,
            POLYGON4,
            POLYGON_CLOUD,
            POLYGON_CLOUD2,
            POLYGON_CLOUD3,
            POLYGON_CLOUD4,
            POLYLINE,
            POLYLINE2,
            POLYLINE3,
            POLYLINE4,
            RECTANGLE,
            RECTANGLE2,
            RECTANGLE3,
            RECTANGLE4,
            DISTANCE_MEASUREMENT,
            DISTANCE_MEASUREMENT2,
            DISTANCE_MEASUREMENT3,
            DISTANCE_MEASUREMENT4,
            PERIMETER_MEASUREMENT,
            PERIMETER_MEASUREMENT2,
            PERIMETER_MEASUREMENT3,
            PERIMETER_MEASUREMENT4,
            AREA_MEASUREMENT,
            AREA_MEASUREMENT2,
            AREA_MEASUREMENT3,
            AREA_MEASUREMENT4,
            CLOUDY_RECTANGULAR_AREA_MEASUREMENT,
            CLOUDY_RECTANGULAR_AREA_MEASUREMENT2,
            CLOUDY_RECTANGULAR_AREA_MEASUREMENT3,
            CLOUDY_RECTANGULAR_AREA_MEASUREMENT4,
            COUNT_MEASUREMENT,
            COUNT_MEASUREMENT2,
            COUNT_MEASUREMENT3,
            COUNT_MEASUREMENT4,
            SIGNATURE,
            STAMP,
            FILEATTACHMENT,
            STICKY,
            STICKY2,
            STICKY3,
            STICKY4,
            HIGHLIGHT,
            HIGHLIGHT2,
            HIGHLIGHT3,
            HIGHLIGHT4,
            SQUIGGLY,
            SQUIGGLY2,
            SQUIGGLY3,
            SQUIGGLY4,
            STRIKEOUT,
            STRIKEOUT2,
            STRIKEOUT3,
            STRIKEOUT4,
            UNDERLINE,
            UNDERLINE2,
            UNDERLINE3,
            UNDERLINE4,
            REDACTION,
            REDACTION2,
            REDACTION3,
            REDACTION4,
            TEXT_SELECT,
            EDIT,
            PAN,
            CROP,
            MARQUEE,
            ERASER,
            CONTENT_EDIT,
            TEXT_FORM_FIELD,
            TEXT_FORM_FIELD2,
            TEXT_FORM_FIELD3,
            TEXT_FORM_FIELD4,
            SIG_FORM_FIELD,
            SIG_FORM_FIELD2,
            SIG_FORM_FIELD3,
            SIG_FORM_FIELD4,
            CHECK_BOX_FIELD,
            RADIO_FORM_FIELD,
            LIST_BOX_FIELD,
            LIST_BOX_FIELD2,
            LIST_BOX_FIELD3,
            LIST_BOX_FIELD4,
            COMBO_BOX_FIELD,
            COMBO_BOX_FIELD2,
            COMBO_BOX_FIELD3,
            COMBO_BOX_FIELD4
        }
    }
    /**
     * Sets the path to the resources folder.
     * @param path - Path to the resources folder relative to the HTML file
     */
    function setResourcesPath(path: string): void;
    /**
     * Gets the path to the resources folder
     * @returns The path to the resources folder
     */
    function getResourcesPath(): string;
    /**
     * Set default backend type. This method can be used for forced backend type for
     * specific workers, for example, "ems" for Emscripten worker type
     * @param backendType - Value for default backend type, e.g. asm, ems, wasm-threads, jsworker.
     */
    function forceBackendType(backendType: string): void;
    /**
     * Gets the default pdf backend type that should be used for this browser.
     * @returns Returns a promise that resolve to a string. "ems" if Emscripten should be used, and "wasm-threads" if threaded Wasm should be used
     */
    function getDefaultBackendType(): Promise<string>;
    /**
     * Gets the current backend type loaded or being loaded
     * @returns Returns "asm" if ASM.js is being forced, "ems" if Emscripten is being used or "wasm-threads" if threaded Wasm is being used
     */
    function getCurrentPDFBackendType(): Promise<string>;
    /**
     * Set flag to indicate that the optimized workers can be used. These workers require some wasm features,
     * e.g. Fixed-Width SIMD, Exception Handling, Bulk Memory Operations. If the browser doesn't support
     * these features, this will have no effect.
     */
    function enableOptimizedWorkers(): void;
    /**
     * Set flag to indicate that the optimized workers can not be used.
     */
    function disableOptimizedWorkers(): void;
    /**
     * Enable or disable use of the full version of PDFNetJS.
     * the parameter is deprecated since version 8.0
     */
    function enableFullPDF(): void;
    /**
     * Disable the use of the full version of the PDFNetJS if it had been previously enabled.
     */
    function disableFullPDF(): void;
    /**
     * Returns whether the full version of PDFNetJS is enabled or not.
     * @returns returns true if the full version is enabled and false otherwise.
     */
    function isFullPDFEnabled(): boolean;
    /**
     * Set the location of the PDF worker. This will override the location specified by Core.setWorkerPath for PDF worker files.
     * @param workerPath - the prefix url for PDFworker.js
     */
    function setPDFWorkerPath(workerPath: string): void;
    /**
     * Get the location of the PDF asm.js file PDFNetC.gz.js.
     * @returns the prefix url for PDFNetC.gz.js.
     */
    function getPDFAsmPath(): string;
    /**
     * Set the location of the PDF worker. This will override the location specified by Core.setWorkerPath for PDF worker files.
     * @param workerPath - the prefix url for PDFNetC.gz.js.
     */
    function setPDFAsmPath(workerPath: string): void;
    /**
     * Get the location of the PDF worker.
     * @returns the prefix url for PDFworker.js
     */
    function getPDFWorkerPath(): string;
    /**
     * Set the location of PDF resources. This will override the location specified by Core.setWorkerPath for PDF resource files.
     * @param resourcePath - the prefix url for PDFNetC.js.mem and PDFNet.res.
     */
    function setPDFResourcePath(resourcePath: string): void;
    /**
     * Get the location of PDF resources.
     * @returns the prefix url for PDFNetC.js.mem and PDFNet.res.
     */
    function getPDFResourcePath(): string;
    /**
     * Sets the location of the local worker files CORSWorker.js/CoreWorker.js which will be different when setting the main worker path to another domain.
     * Note that this path should be on the same domain as WebViewer is being loaded.
     * @param workerPath - The path to the local worker files
     * @param isExact - By default this function will add a trailing slash if it wasn't added but in rare cases you may not want this behavior and can pass true for isExact
     */
    function setLocalWorkerPath(workerPath: string, isExact: boolean): void;
    /**
     * Get the location of the local worker files.
     * @returns the path to CORSWorker.js/CoreWorker.js
     */
    function getLocalWorkerPath(): string;
    /**
     * Set the location of external scripts.
     */
    function setExternalPath(): void;
    /**
     * Get the location of external scripts.
     * @returns the prefix url external scripts.
     */
    function getExternalPath(): string;
    /**
     * Resets the worker so that the next time initPDFWorkerTransports is called it will set up the worker transports.
     */
    function resetWorker(): void;
    /**
     * Set the URL at which PDFNetJS backend will request font resources for the purposes
     * of font substitution. By default they are retrieved from the pdftron website.
     * @param url - The url at which font resources should be requested.
     */
    function setCustomFontURL(url: string): void;
    /**
     * Enables or color management for PDFNetJS backend. Color management is off by default.
     * Enabling color management will better reflect correct color conversions but has a performance penalty.
     * @param [boolean] - value if true enable color management. Otherwise disable it.
     */
    function setColorManagement(boolean?: any): void;
    /**
     * Adjusts the up front heap size used by Emscripten. This method must be called before the worker is
     * initialized to change heap allocation behaviour. By default the heap size is set to 50331648 bytes.
     * Note that decreasing the heap size very low or running complex operations may require a resize.
     * @param The - number of bytes to allocate for the Emscripten heap.
     */
    function setEmscriptenHeapSize(The: number): void;
    /**
     * Begins setup of PDF Worker Object. This can be used to load the workers before a license key has been loaded.
     * @param pdfBackendType - object representing a PDF backend type ("asm", "ems" or "wasm-threads")
     * @param workerHandlers - object holding event and error handlers for the worker (workerLoadingProgress).
     * @returns The worker object
     */
    function preloadPDFWorker(pdfBackendType: string, workerHandlers: any): any;
    /**
     * Begins setup of PDF Worker Object.
     * @param pdfBackendType - object representing an PDF backend type ("asm", "ems" or "wasm-threads")
     * @param workerHandlers - object holding event and error handlers for the worker (workerLoadingProgress, emsWorkerError).
     * @param l - The license key to use for this worker. If undefined PDFNet will be initialized in demo mode.
     * @returns a promise that will be resolved when worker transport initialization is complete.
     */
    function initPDFWorkerTransports(pdfBackendType: string, workerHandlers: any, l: string): any;
    /**
     * Gets the path to the Web Worker JavaScript file
     * @returns The path to the worker
     */
    function getWorkerPath(): string;
    /**
     * Sets the path to the Web Worker JavaScript file.
     * By default the file is expected to be in the same directory as the html file of the viewer
     * and the path should be specified relative to the html file
     * @param path - Path to the Web Worker JS file relative to the html file of the viewer
     */
    function setWorkerPath(path: string): void;
    /**
     * Returns whether demo mode is active or not. Must be called after the document is loaded
     * or after the call to Core.initPDFWorkerTransports if you're calling it directly.
     * @returns true or false depending on whether the viewer is in demo mode or not
     */
    function isDemoMode(): boolean;
    /**
     * Returns the WebViewer version.
     * @returns WebViewer version
     */
    function getVersion(): string;
    /**
     * Returns the specific hashed commit id that is used to build the current WebViewer version.
     * @returns A hashed commit id
     */
    function getBuild(): string;
    /**
     * Set the location of the Office worker. This will override the location specified by Core.setWorkerPath for Office worker files.
     */
    var setOfficeWorkerPath: any;
    /**
     * Get the location of the Office worker.
     */
    var getOfficeWorkerPath: any;
    /**
     * Set the location of the Office asm worker. This will override the location specified by Core.setWorkerPath for Office worker files.
     * @param workerPath - the prefix url for WebOfficeWorker.br.js.mem.
     */
    function setOfficeAsmPath(workerPath: string): void;
    /**
     * Get the location of the Office asm worker.
     * @returns the prefix url for WebOfficeWorker.br.js.mem.
     */
    function getOfficeAsmPath(): string;
    /**
     * Gets the current backend type being used.
     * @returns Returns "asm" if ASM.js is being forced, "ems" if Emscripten is being used, "wasm-threads" if threaded Wasm is being used and undefined if nothing is being used yet
     */
    function getCurrentOfficeBackendType(): string;
    /**
     * Begins setup of Office Worker Object. This can be used to load the workers before a license key has been loaded.
     * @param officeBackendType - object representing an Office backend type ("asm", "ems" or "wasm-threads")
     * @param workerHandlers - object holding event and error handlers for the worker (workerLoadingProgress).
     * @returns The worker object
     */
    function preloadOfficeWorker(officeBackendType: string, workerHandlers: any): any;
    /**
     * Resets the worker so that the next time initOfficeWorkerTransports is called it will set up the worker transports with the specified worker.
     * @param worker - The new worker to use the next time initOfficeWorkerTransports is called
     */
    function resetOfficeWorker(worker: any): void;
    /**
     * Begins setup of Office Worker Object.
     * @param officeType - object representing an Office backend type ("ems" or "wasm-threads")
     * @param workerHandlers - object holding event and error handlers for the worker (workerLoadingProgress, emsWorkerError).
     * @param l - The license key to use for this worker. If undefined, initialization will be done in demo mode.
     * @returns a promise that will be resolved when worker transport initialization is complete.
     */
    function initOfficeWorkerTransports(officeType: string, workerHandlers: any, l: string): any;
    /**
     * Set the location of the Office resource worker. This will override the
     * location specified by Core.setWorkerPath for Office worker files
     * This new officeResourcePath will be used in very specific situations where
     * worker files are located in different locations.
     * @param workerPath - the prefix url for WebOfficeWorker.js and .mem files
     */
    function setOfficeResourcePath(workerPath: string): void;
    /**
     * Get the location of the Office worker.
     * @returns the prefix url for OfficeWorker.js
     */
    function getOfficeResourcePath(): string;
    /**
     * Set the location of the Legacy Office resource worker. This will override the
     * location specified by Core.setWorkerPath for Legacy Office worker files
     * This new legacyOfficeResourcePath will be used in very specific situations where
     * worker files are located in different locations.
     * @param workerPath - the prefix url for WebB2XOfficeWorker.js and .mem files
     */
    function setLegacyOfficeResourcePath(workerPath: string): void;
    /**
     * Get the location of the Legacy Office resource worker.
     * @returns the prefix url for WebB2XOfficeWorker.js
     */
    function getLegacyOfficeResourcePath(): string;
    /**
     * Set the location of the Legacy Office worker (WebB2XOfficeWorker). This will override the location specified by Core.setWorkerPath for Legacy Office worker files.
     */
    var setLegacyOfficeWorkerPath: any;
    /**
     * Get the location of the Legacy Office worker (WebB2XOfficeWorker).
     */
    var getLegacyOfficeWorkerPath: any;
    /**
     * Set the location of the LegacyOffice asm worker. This will override the location specified by Core.setWorkerPath for Office worker files.
     * @param workerPath - the prefix url for WebB2XOfficeWorker.br.js.mem.
     */
    function setLegacyOfficeAsmPath(workerPath: string): void;
    /**
     * Get the location of the LegacyOffice asm worker.
     * @returns the prefix url for WebB2XOfficeWorker.br.js.mem.
     */
    function getLegacyOfficeAsmPath(): string;
    /**
     * Begins setup of Legacy Office Worker Object. This can be used to load the workers before a license key has been loaded.
     * @param officeBackendType - object representing an Office backend type ("ems" or "wasm-threads")
     * @param workerHandlers - object holding event and error handlers for the worker (workerLoadingProgress).
     * @returns The worker object
     */
    function preloadLegacyOfficeWorker(officeBackendType: string, workerHandlers: any): any;
    /**
     * Resets the worker so that the next time initLegacyOfficeWorkerTransports is called it will set up the worker transports with the specified worker.
     * @param worker - The new worker to use the next time initLegacyOfficeWorkerTransports is called
     */
    function resetLegacyOfficeWorker(worker: any): void;
    /**
     * Begins setup of Legacy Office Worker Object.
     * @param officeType - object representing an Office backend type ("ems" or "wasm-threads")
     * @param workerHandlers - object holding event and error handlers for the worker (workerLoadingProgress, emsWorkerError).
     * @returns a promise that will be resolved when worker transport initialization is complete.
     */
    function initLegacyOfficeWorkerTransports(officeType: string, workerHandlers: any): any;
    /**
     * The namespace for anything to do with Part Retrievers
     */
    namespace PartRetrievers {
        /**
         * The base class for PartRetrievers
         */
        class PartRetriever {
            /**
             * Sets a function to be called if there is an error loading the document or retrieving a part.
             * @param callback - The callback to handle the error
             */
            setErrorCallback(callback: (...params: any[]) => any): void;
            /**
             * Sets custom HTTP headers that will be sent with XOD part requests.
             * @param headers - An object with the properties and values being the header names and values that will be set.
             * e.g. { 'MyCustomHeader': 'MyCustomValue'}
             */
            setCustomHeaders(headers: any): void;
            /**
             * Sets withCredentials on xhr requests for the document.
             */
            setWithCredentials(withCredentials: boolean): void;
        }
        /**
         * An object containing all the possible types of part retrievers. Use in conjunction with getPartRetriever
         * @example
         * const partRetriever = await getPartRetriever(PartRetrievers.Types.LocalPdfPartRetriever, file, options);
         */
        enum Types {
            AndroidContentPartRetriever,
            ArrayBufferPdfPartRetriever,
            AzurePartRetriever,
            ExternalPdfPartRetriever,
            HttpPartRetriever,
            IOSPartRetriever,
            LocalPartRetriever,
            LocalPdfPartRetriever,
            StreamingPartRetriever,
            WinRTPartRetriever,
            WebViewerServerPartRetriever,
            WebDBPartRetriever
        }
        /**
         * The type of hint to provide to browsers for caching the document. The part retriever may use query parameters
         * to influence browser caching behavior.
         * @example
         * NEVER_CACHE: A unique ID is appended to the document URL.
         * CACHE: The range of bytes requested is appended to the document URL.
         * This should be used in most cases.
         * NO_HINT: Nothing is appended to the document URL.
         * Useful if you require that the document URL never changes.
         */
        enum CacheHinting {
        }
        /**
         * @param type - The type of retriever you want to use.
         * @param file - The file to open with the part retriever
         * @param [options] - Options to pass to the selected part retriever
         * @param [options.decrypt] - Function to be called to decrypt a part of the file
         * @param [options.decryptOptions] - An object with options for the decryption e.g. {p: "pass", type: "aes"} where is p is the password
         * @param [options.cacheHint] - The type of cache hinting to use
         * @param [options.useDownloader] - Whether to use Downloader, defaults to false.
         * @param [options.filename] - A filename that is only useful when the type is ExternalPdfPartRetriever. Use this option when the filename can't be determined from file(the second argument).
         * @param [options.withCredentials] - Whether to set the withCredentials property on the XMLHttpRequest
         * @param [options.serverOptions] - Options to pass to the server. e.g {serverRoot: "http://your-server-domain.com"}
         */
        function getPartRetriever(type: Core.PartRetrievers.Types, file: File | Blob | string | ArrayBuffer, options?: {
            decrypt?: (...params: any[]) => any;
            decryptOptions?: (...params: any[]) => any;
            cacheHint?: Core.PartRetrievers.CacheHinting;
            useDownloader?: boolean;
            filename?: string;
            withCredentials?: boolean;
            serverOptions?: any;
        }): Promise<Core.PartRetrievers.PartRetriever>;
    }
    /**
     * Creates a new instance of WebViewerServerAnnotationManager.
     *  * <b>Note</b>: As of version 6.3, directly constructing a WebViewerServerAnnotationManager is deprecated and the capability will be removed in a future version. Please use the {@link Core.getWebViewerServerAnnotationManager} function instead.
     */
    class WebViewerServerAnnotationManager {
        /**
         * Preloads existing annotations made without realtime collaboration enabled,
         * will only trigger once on initial collaboration enabling event.
         * @param An - array of annotation objects.
         */
        preloadAnnotations(An: Core.Annotations.Annotation[]): void;
        /**
         * Opens a connection to the annotation server and sets up collaboration.
         * @param docId - The document ID of the object to intiate annotation collaboration on.
         * @param serverRoot - The webViewerServer annotation server to contact for annot storing.
         * @param docViewer - An instance of DocumentViewer.
         */
        initiateCollaboration(docId: string, serverRoot: string, docViewer: Core.DocumentViewer): void;
        /**
         * Disables collaboration by closing the annotation server connection.
         */
        disableCollaboration(): void;
        /**
         * Triggered when collaboration is enabled for webViewerServer.
         * Attach like webViewerServerAnnotManager.addEventListener('webViewerServerAnnotationsEnabled', callback)
         * @param username - user name as specified by webViewerServer collaboration.
         * @param userId - user ID as specified by webViewerServer collaboration.
         */
        on(event: 'webViewerServerAnnotationsEnabled', callback: (username: string, userId: string) => void): void;
        /**
         * Triggered when collaboration is enabled for webViewerServer.
         * Attach like webViewerServerAnnotManager.addEventListener('webViewerServerAnnotationsEnabled', callback)
         * @param username - user name as specified by webViewerServer collaboration.
         * @param userId - user ID as specified by webViewerServer collaboration.
         */
        one(event: 'webViewerServerAnnotationsEnabled', callback: (username: string, userId: string) => void): void;
        off(event?: 'webViewerServerAnnotationsEnabled', callback?: (username: string, userId: string) => void): void;
        /**
         * Triggered when collaboration has abruptly closed or been disabled.
         * Attach like webViewerServerAnnotManager.addEventListener('webViewerServerAnnotationsDisabled', callback)
         */
        on(event: 'webViewerServerAnnotationsDisabled', callback: () => void): void;
        /**
         * Triggered when collaboration has abruptly closed or been disabled.
         * Attach like webViewerServerAnnotManager.addEventListener('webViewerServerAnnotationsDisabled', callback)
         */
        one(event: 'webViewerServerAnnotationsDisabled', callback: () => void): void;
        off(event?: 'webViewerServerAnnotationsDisabled', callback?: () => void): void;
    }
    /**
     * Gets an instance of WebViewerServerAnnotationManager
     * @returns Resolves with a new instance of WebViewerServerAnnotationManager
     */
    function getWebViewerServerAnnotationManager(): Promise<Core.WebViewerServerAnnotationManager>;
    /**
     * Check if a composite operation is supported
     * @param type - Composite operation to check
     * @returns True if if the input composite operation is supported, false otherwise
     */
    function isBlendModeSupported(type: string): boolean;
    /**
     * Represents the different page rotation values that you can apply to pages.
     */
    enum PageRotation {
        E_0,
        E_90,
        E_180,
        E_270
    }
    /**
     * Represents the different review state values that you can apply to annotation status.
     */
    enum ReviewStates {
        Accepted,
        Rejected,
        Cancelled,
        Completed,
        None
    }
    /**
     * Represents the different Marked state values that you can apply to annotation status.
     */
    enum MarkedStates {
        Marked,
        Unmarked
    }
    /**
     * Represents the different state models that you can apply to annotation.
     */
    enum StateModel {
        Marked,
        Review
    }
    /**
     * Represents the font style for the watermark text
     * @property BOLD - specifies that the text should be bolded
     * @property ITALIC - specifies that the text should be italicized
     * @property UNDERLINE - specifies that the text should be underlined
     */
    var FONT_STYLES: {
        /**
         * specifies that the text should be bolded
         */
        BOLD: string;
        /**
         * specifies that the text should be italicized
         */
        ITALIC: string;
        /**
         * specifies that the text should be underlined
         */
        UNDERLINE: string;
    };
    /**
     * Represents all the supported file formats in WebViewer
     * @property CLIENT - Supported file formats when using WebViewer client side rendering
     * @property SERVER - Supported file formats when using WebViewer with WebViewer Server
     */
    var SupportedFileFormats: {
        /**
         * Supported file formats when using WebViewer client side rendering
         */
        CLIENT: string[];
        /**
         * Supported file formats when using WebViewer with WebViewer Server
         */
        SERVER: string[];
    };
    /**
     * Gets the scrollLeft value for the element. Takes into account right to left scrolling direction if applicable.
     * @param ele - An HTML element to retrieve the scrollLeft value from
     * @returns The scrollLeft value of the element
     */
    function getScrollLeft(ele: Element): number;
    class EventHandler {
        /**
         * Add a handler to the given event name
         * @example
         * annotManager.addEventListener('annotationChanged', (annotations, action) => {
         *   ...
         * });
         * @param type - The name of the event to listen to
         * @param fn - The handler to be called when the event is triggered
         * @param [options] - Optional options object for addEventListener
         * @param options.once - If true then the handler will be called only once
         * @returns Returns the object that 'addEventListener' is being called on
         */
        addEventListener(type: string | number, fn: (...params: any[]) => any, options?: {
            once: boolean;
        }): any;
        /**
         * Add a handler to the given event name
         * @example
         * annotManager.on('annotationChanged', (annotations, action) => {
         *   ...
         * });
         * @param type - The name of the event to listen to
         * @param fn - The handler to be called when the event is triggered
         * @returns Returns the object that 'on' is being called on
         */
        on(type: string | number, fn: (...params: any[]) => any): any;
        /**
         * Remove a handler of the given event name
         * @example
         * annotManager.removeEventListener();
         * annotManager.removeEventListener('annotationChanged');
         * annotManager.removeEventListener('annotationChanged', fn);
         * @param [type] - The name of the event to remove the handler of.
         * If type is undefined, all the handlers of the object will be removed
         * @param [fn] - The handler associated with this event to be removed.
         * If fn is undefined, all the handlers of the given event name will be removed
         * @returns Returns the object that 'removeEventListener' is being called on
         */
        removeEventListener(type?: string | number, fn?: (...params: any[]) => any): any;
        /**
         * Remove a handler of the given event name
         * @example
         * annotManager.off();
         * annotManager.off('annotationChanged');
         * annotManager.off('annotationChanged', fn);
         * @param [type] - The name of the event to remove the handler of.
         * If type is undefined, all the handlers of the object will be removed
         * @param [fn] - The handler associated with this event to be removed.
         * If fn is undefined, all the handlers of the given event name will be removed
         * @returns Returns the object that 'off' is being called on
         */
        off(type?: string | number, fn?: (...params: any[]) => any): any;
        /**
         * Calls the handlers of the event name with given data
         * @example
         * annotManager.trigger('annotationChanged');
         * annotManager.trigger('annotationChanged', [[annotation], 'add', {}]);
         * @param type - event name of which the handlers will be called.
         * @param [data] - data that will be passed to the handlers.
         * If data is an array, it will be spread and then passed to the handlers
         * @returns Returns the object that 'trigger' is being called on
         */
        trigger(type: string | number, data?: any): any;
        /**
         * Same as 'on' except the handler will be called only once
         * @example
         * annotManager.one('annotationChanged', (annotations, action) => {
         *  ...
         * });
         * @param type - The name of the event to listen to
         * @param fn - The handler to be called when the event is triggered
         * @returns Returns the object that 'one' is being called on
         */
        one(type: string | number, fn: (...params: any[]) => any): any;
    }
    /**
     * Gets the value of the specified hash parameter from the window URL
     * @param property - The property key from hash parameter
     * @param defaultValue - Default return value
     * @returns A value of the hash parameter
     */
    function getHashParam<T>(property: string, defaultValue: T): T;
    /**
     * Gets the value of the specified hash parameter from the window URL
     * @param property - The property key from hash parameter
     * @param defaultValue - Default return value
     * @returns A value of the hash parameter
     */
    function getHashParameter<T>(property: string, defaultValue: T): T;
    /**
     * Sets whether WebViewer is running inside a Windows App and should automatically use the WinRTPartRetriever for loading local XOD files
     * @param isWindowsApp - Whether WebViewer is running inside a Windows app or not
     */
    function setIsWindowsApp(isWindowsApp: boolean): void;
    /**
     * Flag WebViewer as running inside a Windows App so that it automatically uses the WinRTPartRetriever for loading local XOD files
     */
    function setAsWindowsApp(): void;
    /**
     * Unflag WebViewer as running inside a Windows App so that it doesn't automatically use the WinRTPartRetriever for loading local XOD files. This is unset by default.
     */
    function unsetAsWindowsApp(): void;
    /**
     * Gets the default multiplier used for rendering pages with document.loadCanvas.
     * Higher multipliers mean that pages will be rendered at higher resolutions.
     * The default value is the browser's {@link https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio|devicePixelRatio}
     * @returns The current value of the canvas multiplier
     */
    function getCanvasMultiplier(): number;
    /**
     * Sets the default multiplier used for rendering pages with document.loadCanvas.
     * Higher multipliers mean that pages will be rendered at higher resolutions.
     * The default value is the browser's {@link https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio|devicePixelRatio}
     * @param value - The value of multiplier to be set
     */
    function setCanvasMultiplier(value: number): void;
    /**
     * Unsets the multiplier that was set using the setCanvasMultiplier function.
     * The multiplier will default back to the browser's {@link https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio|devicePixelRatio}
     */
    function unsetCanvasMultiplier(): void;
    /**
     * Converts hexadecimal string to a number array.
     * @param hexString - String of hexadecimal characters
     */
    function hexStringToNumberArray(hexString: string): void;
    /**
     * Enables or disables all logs coming from WebViewer.
     * @param disabled - Whether or not to disable all WebViewer logs. Defaults to true
     */
    function disableLogs(disabled: boolean): void;
    /**
     * Enables or disables logs from the PDF worker.
     * @param enabled - Whether or not to enable PDF worker logs. Defaults to false.
     */
    function enableWorkerLogs(enabled: boolean): void;
    /**
     * The namespace containing constants for search related APIs.
     */
    namespace Search {
        /**
         * Search result code that indicates the search status.
         * @property DONE - Search has been completed
         * @property PAGE - Search on a page has been completed
         * @property FOUND - A search result has been found
         */
        var ResultCode: {
            /**
             * Search has been completed
             */
            DONE: number;
            /**
             * Search on a page has been completed
             */
            PAGE: number;
            /**
             * A search result has been found
             */
            FOUND: number;
        };
        /**
         * Search modes that control how searching is conducted.
         * @property CASE_SENSITIVE - If set, the found text must match the case of the search term.
         * @property WHOLE_WORD - If set, the found text must be a whole word (preceeded and followed by a non-alphabetical character, or in the case of a number, a non-numerical character.
         * @property REGEX - If set, the search term will be treated as a regular expression and the results will be text in the document matching that regular expression.
         * @property SEARCH_UP - If set, the document pages will be searched in descending order, from bottom to top.
         * @property PAGE_STOP - If set, the search will return with a result code of Page at the end of every page. Useful for updating the UI.
         * @property HIGHLIGHT - If set, the bounding box the found term will be included. Useful for highlighting text and positioning the page.
         * @property AMBIENT_STRING - If set, the characters surrounding the found term will be included. This gives context to the search result may be useful when providing a list of search results.
         * @property WILD_CARD - If set, you can use the wildcard character (*) as part of the pattern.
         */
        var Mode: {
            /**
             * If set, the found text must match the case of the search term.
             */
            CASE_SENSITIVE: number;
            /**
             * If set, the found text must be a whole word (preceeded and followed by a non-alphabetical character, or in the case of a number, a non-numerical character.
             */
            WHOLE_WORD: number;
            /**
             * If set, the search term will be treated as a regular expression and the results will be text in the document matching that regular expression.
             */
            REGEX: number;
            /**
             * If set, the document pages will be searched in descending order, from bottom to top.
             */
            SEARCH_UP: number;
            /**
             * If set, the search will return with a result code of Page at the end of every page. Useful for updating the UI.
             */
            PAGE_STOP: number;
            /**
             * If set, the bounding box the found term will be included. Useful for highlighting text and positioning the page.
             */
            HIGHLIGHT: number;
            /**
             * If set, the characters surrounding the found term will be included. This gives context to the search result may be useful when providing a list of search results.
             */
            AMBIENT_STRING: number;
            /**
             * If set, you can use the wildcard character (*) as part of the pattern.
             */
            WILD_CARD: number;
        };
    }
    /**
     * The namespace for APIs dealing with document content editing
     */
    namespace ContentEdit {
        /**
         * Content Edit types.
         * @property TEXT - Text type content.
         * @property OBJECT - Object type content.
         */
        var Types: {
            /**
             * Text type content.
             */
            TEXT: string;
            /**
             * Object type content.
             */
            OBJECT: string;
        };
        /**
         * Preloads the content editing worker. If this function isn't called then the worker will be loaded when the content editing tool is enabled.
         * @param documentViewer - The DocumentViewer to use as context for the page editing
         * @returns Resolves after the worker has been loaded
         */
        function preloadWorker(documentViewer: Core.DocumentViewer): Promise<void>;
        /**
         * Update the document with new content
         * @example
         * instance.Core.ContentEdit.updateDocumentContent(contentEditPlaceholderAnnotation, 'New content');
         * @param content - The new content
         * @returns Resolves after the content has been updated
         */
        function updateDocumentContent(contentEditPlaceholderAnnotation: Core.Annotations.RectangleAnnotation, content: string): Promise<void>;
        /**
         * Gets the content box data for the passed in annotation.
         * The passed in annotation must be a content edit placeholder annotation.
         * @example
         * const content = await instance.Core.ContentEdit.getDocumentContent(contentEditPlaceholderAnnotation);
         * @returns content The document content associated with this content edit placeholder annotation
         */
        function getDocumentContent(contentEditPlaceholderAnnotation: Core.Annotations.RectangleAnnotation): Promise<string>;
    }
    /**
     * The types of backend workers.
     * @property ASM - 'asm' Use of ASM.js worker.
     * @property WASM - 'ems' Use of the WebAssembly worker (or ASM.js on non-wasm browsers).
     * @property THREADED_WASM - 'wasm-threads' Use of threaded WebAssembly worker.
     */
    var BackendTypes: {
        /**
         * 'asm' Use of ASM.js worker.
         */
        ASM: string;
        /**
         * 'ems' Use of the WebAssembly worker (or ASM.js on non-wasm browsers).
         */
        WASM: string;
        /**
         * 'wasm-threads' Use of threaded WebAssembly worker.
         */
        THREADED_WASM: string;
    };
    /**
     * AnnotationManager instance
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     const annotationManager = instance.Core.annotationManager;
     *   });
     */
    var annotationManager: Core.AnnotationManager;
    /**
     * DocumentViewer instance
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     const documentViewer = instance.Core.documentViewer;
     *   });
     */
    var documentViewer: Core.DocumentViewer;
}

/**
 * WebViewer Instance UI namespace.
 * Contains functions and properties related to UI related parts of WebViewer
 * @example
 * webViewerInstance.UI.someProperty
 * webViewerInstance.UI.someAPI()
 */
declare namespace UI {
    /**
     * An instance of TabManager that can be used to edit the open document Tabs **Only Multi-Tab Mode**.
     * @example
     * WebViewer(...)
     *  .then(function (instance) {
     *     instance.UI.TabManager.setActiveTab(0);
     *   })
     */
    namespace TabManager {
        /**
         * Set the currently open tab in the UI
         * @example
         * WebViewer(...).then(function(instance) {
         *   instance.UI.TabManager.setActiveTab(0, false); // Set to tab id 0 discarding current tab state
         * });
         * @param tabId - The tab id to set as the current tab
         * @param [saveCurrentActiveTabState] - Whether to save the current tab annotations, scroll position, and zoom level before switching to the new tab (default: true)
         * @returns Resolves when the tab is loaded
         */
        function setActiveTab(tabId: number, saveCurrentActiveTabState?: boolean): Promise<void>;
        /**
         * Delete a tab by id in the UI
         * @example
         * WebViewer(...).then(function(instance) {
         *   instance.UI.TabManager.deleteTab(0); // Delete tab id 0
         * });
         * @param tabId - The tab id to be deleted from the tab header
         */
        function deleteTab(tabId: number): void;
        /**
         * Add a new tab to the UI
         * @example
         * WebViewer(...).then(function(instance) {
         *   instance.UI.TabManager.addTab('http://www.example.com/pdf', {extension: "pdf", setActive: true, saveCurrentActiveTabState: true}); // Add a new tab with the URL http://www.example.com
         * });
         * @param src - The source of the tab to be added (e.g. a URL, a blob, ArrayBuffer, or a File)
         * @param [options] - The options for the tab to be added
         * @returns Resolves to the tab id of the newly added tab
         */
        function addTab(src: string | File | Blob | Core.Document | Core.PDFNet.PDFDoc, options?: UI.addTabOptions): Promise<number>;
        /**
         * Get the currently active tab id
         * @returns The current tab with the following properties: { id: Number, options: Object, src: string|Blob|File|ArrayBuffer }
         */
        function getActiveTab(): any;
        /**
         * Get all the tabs from the UI
         * @returns Array of tab objects containing the following properties: { id: Number, options: Object, src: string|Blob|File|ArrayBuffer }
         */
        function getAllTabs(): object[];
    }
    /**
     */
    type addTabOptions = {
        /**
         * The document loading options
         */
        loadDocumentOptions?: UI.loadDocumentOptions;
        /**
         * Whether to set the new tab as active immediately after adding it (default: true)
         */
        setActive?: boolean;
        /**
         * Whether to save the current tab annotations, scroll position, and zoom level before adding the new tab (only used when setActive=true) (default: true)
         */
        saveCurrentActiveTabState?: boolean;
    };
    /**
     * Adds a date and time format for the UI date and time dropdowns.
     * List of formats can be found here: {@link https://github.com/iamkun/dayjs/blob/v1.11.1/docs/en/API-reference.md#format-formatstringwithtokens-string dayjs API}.
     * @example
     * WebViewer(...)
     *  .then(function(instance) {
     *     instance.UI.addDateTimeFormat({
     *         date: 'MM/DD/YYYY',
     *         time: 'HH:mm:ss',
     *         timeFirst: true
     *       });
     *   });
     * @param dateTimeFormat - An object containing the date and time formats with the respective keys. At least one of the date or time keys must be present.
     * @param [dateTimeFormat.date] - String of date format
     * @param [dateTimeFormat.time] - String of time format
     * @param [dateTimeFormat.timeFirst] - Boolean value to indicate if time should be before date in UI
     */
    function addDateTimeFormat(dateTimeFormat: {
        date?: string;
        time?: string;
        timeFirst?: boolean;
    }): void;
    /**
     * Add an event listener for the given WebViewer UI event.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     instance.UI.addEventListener(instance.UI.Events.ANNOTATION_FILTER_CHANGED, e => {
     *       const { types, authors, colors } = e.detail;
     *       console.log(types, authors, colors);
     *     });
     *   });
     * @param eventName - UI event name.
     * @param listener - Callback function that will be invoked when the event is dispatched.
     */
    function addEventListener(eventName: string, listener: (...params: any[]) => any): void;
    /**
     */
    type RedactionSearchPattern = {
        /**
         * The label to be used for the search pattern in the UI
         */
        label: string;
        /**
         * A string representing the type of item being searched for. For example, if searching for postal codes, this could be 'postalCode'. This is used
        to determine which icon will be used to render the result in the search panel.
         */
        type: string;
        /**
         * The icon to be used for the search pattern in the search dropdown for the UI and the redaction panel for this type of search. Can be an inline SVG, or the name of an icon included in the WebViewer UI icon set.
        If no icon is passed, the default icon for text searches will be used.
         */
        icon?: string;
        /**
         * The regex to be used for the search pattern
         */
        regex: RegExp;
    };
    /**
     * Adds a new search pattern to the redaction search panel
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     instance.UI.addRedactionSearchPattern(
     *       {
     *         label: 'Social Security Number',
     *         icon: '<svg xmlns="http://www.w3.org/2000/svg" height="24" width="24" viewBox="0 0 30 30"><path d="M0 0h24v24H0z" fill="none"/><path d="M17 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V7l-4-4zm-5 16c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm3-10H5V5h10v4z"/></svg>',
     *         type: 'socialSecurityNumber',
     *         regex: /\b\d{3}-?\d{2}-?\d{4}\b/,
     *       }
     *     );
     *   });
     *
     * // Or to search kewyord(s):
     * WebViewer(...)
     * .then(function(instance) {
     *   instance.UI.addRedactionSearchPattern(
     *     {
     *       label: 'Confidential Information',
     *       type: 'confidentialInformation',
     *       regex: /confidential information/i, //Regex based search for text, case insensitive
     *     }
     *   );
     * });
     * @param searchPattern - A search pattern to add to the redaction search panel
     */
    function addRedactionSearchPattern(searchPattern: UI.RedactionSearchPattern): void;
    /**
     * Adds a listener function to be called when search is completed.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     function searchListener(searchValue, options, results) {
     *       console.log(searchValue, options, results);
     *     };
     *
     *     instance.UI.addSearchListener(searchListener);
     *   });
     * @param searchListener - Callback function that will be triggered when search completed
     */
    function addSearchListener(searchListener: UI.searchListener): void;
    /**
     * Callback that gets passed to {@link UI.addSearchListener addSearchListener}.
     * @param searchValue - Search value
     * @param options - Search options object, which includes 'caseSensitive', 'wholeWord', 'wildcard' and 'regex'
     * @param results - Search results
     */
    type searchListener = (searchValue: string, options: any, results: object[]) => void;
    /**
     * Adds a sorting strategy in notes panel.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     var mySortStrategy = {
     *       name: 'annotationType',
     *       getSortedNotes: function(notes) {
     *         return notes.sort(function(a ,b) {
     *           if (a.Subject < b.Subject) return -1;
     *           if (a.Subject > b.Subject) return 1;
     *           if (a.Subject === b.Subject) return 0;
     *         });
     *       },
     *       shouldRenderSeparator: function(prevNote, currNote) {
     *         return prevNote.Subject !== currNote.Subject;
     *       },
     *       getSeparatorContent: function(prevNote, currNote) {
     *         return currNote.Subject;
     *       }
     *     };
     *
     *     instance.UI.addSortStrategy(mySortStrategy);
     *   });
     * @param sortStrategy - Sorting strategy that will be used to sort notes
     * @param sortStrategy.name - Name of the strategy, which will be shown in notes panel's dropdown
     * @param sortStrategy.getSortedNotes - Function that takes unsorted notes (annotations) and returns them sorted
     * @param sortStrategy.shouldRenderSeparator - Function that returns when a separator should be rendered
     * @param sortStrategy.getSeparatorContent - Function that returns the content of a separator
     */
    function addSortStrategy(sortStrategy: {
        name: string;
        getSortedNotes: UI.getSortedNotes;
        shouldRenderSeparator: UI.shouldRenderSeparator;
        getSeparatorContent: UI.getSeparatorContent;
    }): void;
    /**
     * Callback that gets passed to `sortStrategy.getSortedNotes` in {@link UI.addSortStrategy addSortStrategy}.
     * @param notes - List of unsorted notes (annotations)
     */
    type getSortedNotes = (notes: Core.Annotations.Annotation[]) => Core.Annotations.Annotation[];
    /**
     * Callback that gets passed to `sortStrategy.shouldRenderSeparator` in {@link UI.addSortStrategy addSortStrategy}.
     * @param prevNote - Previous note (annotation)
     * @param currNote - Current note (annotation)
     */
    type shouldRenderSeparator = (prevNote: Core.Annotations.Annotation, currNote: Core.Annotations.Annotation) => boolean;
    /**
     * Callback that gets passed to `sortStrategy.getSeparatorContent` in {@link UI.addSortStrategy addSortStrategy}.
     * @param prevNote - Previous note (annotation)
     * @param currNote - Current note (annotation)
     * @param options - Optional values
     * @param options.pageLabels - List of page label
     */
    type getSeparatorContent = (prevNote: Core.Annotations.Annotation, currNote: Core.Annotations.Annotation, options: {
        pageLabels: string[];
    }) => string | number;
    /**
     * An instance of Popup that can be used to edit items in the annotation popup component
     * @example
     * WebViewer(...)
     *   .then(function (instance) {
     *     instance.UI.annotationPopup.someAPI();
     *   });
     */
    var annotationPopup: UI.Popup;
    /**
     * Stops on-going page processing to cancel a print job.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     var docViewer = instance.Core.documentViewer;
     *     // you must have a document loaded when calling this api
     *     docViewer.addEventListener('documentLoaded', function() {
     *       instance.UI.print();
     *       instance.UI.cancelPrint();
     *     });
     *   });
     */
    function cancelPrint(): void;
    /**
     * Closes the document that's currently opened.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     const docViewer = instance.Core.documentViewer;
     *
     *     // you must have a document loaded when calling this api
     *     docViewer.addEventListener('documentLoaded', function() {
     *       setTimeout(function() {
     *         instance.UI.closeDocument().then(function() {
     *           console.log('Document is closed');
     *         });
     *       }, 3000);
     *     });
     *   });
     * @returns A promise resolved after document is closed.
     */
    function closeDocument(): Promise<void>;
    /**
     * Sets visibility states of the elements to be hidden. Note that closeElements works only for panel/overlay/popup/modal elements.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     // closes (hides) text popup and left panel in the UI
     *     instance.UI.closeElements([ 'menuOverlay', 'leftPanel' ]);
     *   });
     * @param dataElements - Array of data-element attribute values for DOM elements. To find data-element of a DOM element, refer to <a href='https://www.pdftron.com/documentation/web/guides/hiding-elements/#finding-dataelement-attribute-values' target='_blank'>Finding data-element attribute values</a>.
     */
    function closeElements(dataElements: string[]): void;
    /**
     * An instance of Popup that can be used to edit items in the context menu popup component
     * @example
     * WebViewer(...)
     *   .then(function (instance) {
     *     instance.UI.contextMenuPopup.someAPI();
     *   });
     */
    var contextMenuPopup: UI.Popup;
    /**
     * Creates a new Toolbar group (Ribbon)
     * @example
     * WebViewer(...)
     *    .then(function(instance) {
     *     const { annotationManager, documentViewer } = instance.Core;
     *     const annotHistoryManager = documentViewer.getAnnotationHistoryManager();
     *
     *     // In case you want to use the Toolbar Group label with translation, you can
     *     // set the values with the setTranslations API and use the translation key
     *     // as the name parameter
     *
     *     instance.UI.setTranslations('en',
     *      {
     *         'option.toolbarGroup.draw': 'Draw'
     *       }
     *     );
     *
     *     instance.UI.createToolbarGroup(
     *     {
     *       name: 'option.toolbarGroup.draw',
     *       dataElementSuffix: 'Draw',
     *       useDefaultElements: false,
     *       children: [
     *         { type: 'spacer' },
     *         {
     *           type: 'toolGroupButton',
     *           toolGroup: 'freeHandTools',
     *           dataElement: 'freeHandToolGroupButton',
     *           title: 'annotation.freehand'
     *         },
     *         {
     *           type: 'toolGroupButton',
     *           toolGroup: 'ellipseAreaTools',
     *           dataElement: 'ellipseAreaToolGroupButton',
     *           title: 'annotation.areaMeasurement'
     *         },
     *         {
     *           type: 'toolGroupButton',
     *           toolGroup: 'rectangleTools',
     *           dataElement: 'shapeToolGroupButton',
     *           title: 'annotation.rectangle'
     *         },
     *         { type: 'divider'},
     *         // Undo Button
     *         {
     *           type: 'actionButton',
     *           style: { 'marginLeft': '0px' },
     *           dataElement: 'undoButton',
     *           title: 'action.undo',
     *           img: 'icon-operation-undo',
     *           onClick: () => {
     *             annotHistoryManager.undo();
     *           },
     *           isNotClickableSelector: () => !annotHistoryManager.canUndo()
     *         },
     *         // Redo Button
     *         {
     *           type: 'actionButton',
     *           dataElement: 'redoButton',
     *           title: 'action.redo',
     *           img: 'icon-operation-redo',
     *           onClick: () => {
     *             annotHistoryManager.redo();
     *           },
     *           isNotClickableSelector: () => !annotHistoryManager.canRedo()
     *         },
     *         { type: 'toolButton', toolName: 'AnnotationEraserTool' },
     *         { type: 'spacer', hidden: ['tablet', 'mobile', 'small-mobile'] }
     *       ]
     *     })
     *   }
     * })
     * @param toolbarGroup.name - The label for the new Toolbar Group or the key value to get the label from translation files.
     * <p>Refer to the lib/ui/i18n folder to find the existing keys in the translation files</p>
     * @param toolbarGroup.dataElementSuffix - <p>The suffix value you want to use to select your Toolbar group by data element.
     * All toolbar groups have the data element in this format <strong>toolbarGroup-&#60;dataElementSuffix&#62</strong>.</p> <p>For example, if you set the dataElementSuffix as 'Draw',
     * the dataElement of your ribbon will be <strong>toolbarGroup-Draw</strong></p>
     * @param toolbarGroup.children - A list of elements to be added on the toolbar group header.
     * Check [this guide]{@link https://www.pdftron.com/documentation/web/guides/customizing-header/#header-items} to see the available options to be used as a toolbar group child.
     * @param [toolbarGroup.useDefaultElements] - <p>If true, the common elements used in most toolbar groups will be added to the children list.</p>
     * <p>These elements are a spacer in the beginning and at the end of the header, the undo and redo buttons, and the eraser button.</p>
     * <p>In the example below you can see these elements being added. By default, the value will be false and these elements will not be added.</p>
     */
    function createToolbarGroup(toolbarGroup: {
        name: string;
        dataElementSuffix: string;
        children: any[];
        useDefaultElements?: boolean;
    }): void;
    /**
     * Disable clearing search results when user closes search panel. When disabled, search results are kept even if user
     * closes and reopens search panel.
     *
     * Note, mobile devices never clear search results even if this setting is enabled. This is because the panel needs to be closed to view the search results on the document.
     * @example
     * WebViewer(...)
     *  .then(function(instance) {
     *     instance.UI.disableClearSearchOnPanelClose();
     *   });
     */
    function disableClearSearchOnPanelClose(): void;
    /**
     * Disables desktop only mode on WebViewer UI.
     * This means that at small browser width/height, mobile/tablet CSS styling will be applied.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     instance.UI.disableDesktopOnlyMode();
     *   });
     */
    function disableDesktopOnlyMode(): void;
    /**
     * Unmount multiple elements in the DOM. Note that this ONLY removes the DOM elements without disabling related features.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     // remove left panel and left panel button from the DOM
     *     instance.UI.disableElements([ 'leftPanel', 'leftPanelButton' ]);
     *   });
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     // remove the 'Edit' toolbar group
     *     instance.UI.disableElements(['toolbarGroup-Edit']);
     *   });
     * @param dataElements - Array of data-element attribute values for DOM elements. To find data-element of a DOM element, refer to <a href='https://www.pdftron.com/documentation/web/guides/hiding-elements/#finding-dataelement-attribute-values' target='_blank'>Finding data-element attribute values</a>.
     */
    function disableElements(dataElements: string[]): void;
    /**
     * Always keep the Page Navigation Component on screen. Default behaviour is to fade it after certain period of inactivity.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     // Keeps the page navigation component on screen all the time
     *     instance.UI.disableFadePageNavigationComponent();
     *   });
     */
    function disableFadePageNavigationComponent(): void;
    /**
     * Disable certain features in the WebViewer UI.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     instance.UI.disableFeatures(instance.Feature.Measurement);
     *   });
     * @param features - Array of features to disable.
     */
    function disableFeatures(features: string[]): void;
    /**
     * Turns high contrast mode off.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     instance.UI.disableHighContrastMode();
     *   });
     */
    function disableHighContrastMode(): void;
    /**
     * Disable native mobile device scrolling behavior if it had previously been enabled. Note that native mobile device scrolling behavior is off by default.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     UI.disableNativeScrolling();
     *   });
     */
    function disableNativeScrolling(): void;
    /**
     * Disable the ability to submit notes by only pressing Enter if it had previously been enabled.
     * This will revert note submission to the default which is Ctrl/Cmd + Enter.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     instance.UI.disableNoteSubmissionWithEnter();
     *   });
     */
    function disableNoteSubmissionWithEnter(): void;
    /**
     * Disable the confirmation modal when deleting a page from the thumbnail view
     * @example
     * WebViewer(...)
     *  .then(function(instance) {
     *     instance.UI.disablePageDeletionConfirmationModal();
     *   });
     */
    function disablePageDeletionConfirmationModal(): void;
    /**
     * Disable reply for annotations if the callback function returns true. The callback function gets evaluated when the Comments panel is open, an annotation is selected, and the selected annotation has a comment.
     * Only one callback function will be stored and invoked. If multiple criteria is needed to disable replies you must write them in a single callback function.
     * @example
     * WebViewer(...)
     *   .then(instance => {
     *
     *     // disable reply for Freehand annotations
     *     instance.UI.disableReplyForAnnotations((annotation) => {
     *       return annotation instanceof instance.Annotations.FreeHandAnnotation;
     *     });
     *
     *     // disable reply for annotations authored by Guest
     *     instance.UI.disableReplyForAnnotations((annotation) => {
     *       return annotation['Author'] === 'Guest';
     *     });
     *
     *     // disable reply for annotations created more than 10 seconds ago
     *     instance.UI.disableReplyForAnnotations((annotation) => {
     *       const createdDate = new Date(annotation['DateCreated']);
     *       const todayDate = new Date();
     *       return (todayDate - createdDate) > 10000;
     *     });
     *   });
     * @param isReplyDisabledCallback - Callback function that returns true if reply will be disabled for the annotation passed in. False otherwise.
     */
    function disableReplyForAnnotations(isReplyDisabledCallback: UI.disableReplyForAnnotationsCallback): void;
    /**
     * Callback that gets passed to {@link UI.disableReplyForAnnotations disableReplyForAnnotations}.
     * @param annotation - Annotation object
     */
    type disableReplyForAnnotationsCallback = (annotation: Core.Annotations.Annotation) => boolean;
    /**
     * Disable multiple tools. This API uses disableElements internally to remove tool buttons from the DOM, and also disable the corresponding hotkeys.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     const { Tools } = instance.Core;
     *     // disable sticky annotation tool and free text tool
     *     instance.UI.disableTools([Tools.ToolNames.STICKY, Tools.ToolNames.FREETEXT]);
     *   });
     * @param [toolNames = all tools] - Array of name of the tools, either from tool names list or the name you registered your custom tool with. If nothing is passed, all tools will be disabled.
     */
    function disableTools(toolNames?: string[] | Core.Tools.ToolNames[]): void;
    /**
     * Displays the custom error message
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     instance.UI.displayErrorMessage('My error message');
     *   });
     * @param message - An error message
     */
    function displayErrorMessage(message: string): void;
    /**
     * Downloads the pdf document with or without annotations added by WebViewer UI.
     * @example
     * WebViewer(...)
     *   .then(async function(instance) {
     *     const docViewer = instance.Core.documentViewer;
     *     const annotManager = instance.Core.annotationManager;
     *
     *     // you must have a document loaded when calling this api
     *     docViewer.addEventListener('documentLoaded', async function() {
     *       // download pdf without annotations added by WebViewer UI
     *       await instance.UI.downloadPdf({
     *         includeAnnotations: false,
     *       });
     *
     *       console.log('Downloaded the first time!')
     *
     *       // download pdf with all annotations flattened
     *       await instance.UI.downloadPdf({
     *         includeAnnotations: true,
     *         flatten: true,
     *       });
     *
     *       console.log('Downloaded a second time!')
     *
     *       // download pdf without links
     *       const xfdfString = await annotManager.exportAnnotations({ links: false });
     *       await instance.UI.downloadPdf({
     *         xfdfString: xfdfString,
     *       });
     *
     *       console.log('Downloaded a third time!')
     *     });
     *   });
     * @param [options] - An object that contains the following download options.
     * @param [options.filename] - The filename of the downloaded document.
     * @param [options.downloadType = 'pdf'] - The type to download the file as, by default this is "pdf". PDF and image files can only be downloaded as PDFs, but office files can be downloaded as "pdf" or as "office" if you want to get the original file without annotations.
     * @param [options.xfdfString] - An xfdf string containing annotation data to be used when downloading. Use this option instead of `includeAnnotations` if not all annotations need to be contained in the downloaded file.
     * @param [options.includeAnnotations = true] - Whether or not to include annotations added by WebViewer UI.
     * @param [options.flatten] - Whether or not to flatten all the annotations in the downloaded document. Only useful fullAPI is enabled and either `xfdfString` or `includeAnnotations` is used.
     * @param [options.documentToBeDownloaded] - A document to be download instead of the one loaded by Document Viewer.
     * @param [options.useDisplayAuthor] - Whether to export annotations with the Display Author name from annotationManager.getDisplayAuthor()
     * @param [options.flags = Core.SaveOptions.REMOVE_UNUSED] - The flags with which to save the document. Possible values include `Core.SaveOptions.REMOVE_UNUSED` (remove unused objects during save) and `Core.SaveOptions.LINEARIZED` (optimize the document for fast web view and remove unused objects).
     * @returns A promise that is resolved once the document is downloaded.
     */
    function downloadPdf(options?: {
        filename?: string;
        downloadType?: string;
        xfdfString?: string;
        includeAnnotations?: boolean;
        flatten?: boolean;
        documentToBeDownloaded?: Core.Document;
        useDisplayAuthor?: boolean;
        flags?: number;
    }): Promise<any>;
    /**
     * Enable clearing search results when user closes search panel. When this is enabled and user closes search panel
     * all search results are cleared.
     *
     * Note, mobile devices never clear search results even if this setting is enabled. This is because the panel needs to be closed to view the search results on the document.
     * @example
     * WebViewer(...)
     *  .then(function(instance) {
     *     // Will not affect on mobile devices
     *     instance.UI.enableClearSearchOnPanelClose();
     *   });
     */
    function enableClearSearchOnPanelClose(): void;
    /**
     * Enables desktop only mode on WebViewer UI.
     * This means that at small browser width/height, mobile/tablet CSS styling will not be applied.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     instance.UI.enableDesktopOnlyMode();
     *   });
     */
    function enableDesktopOnlyMode(): void;
    /**
     * Remount the hidden elements in the DOM.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     // remove left panel and left panel button from the DOM
     *     instance.UI.enableElements([ 'leftPanel', 'leftPanelButton' ]);
     *   });
     * @param dataElements - Array of data-element attribute values for DOM elements. To find data-element of a DOM element, refer to <a href='https://www.pdftron.com/documentation/web/guides/hiding-elements/#finding-dataelement-attribute-values' target='_blank'>Finding data-element attribute values</a>.
     */
    function enableElements(dataElements: string[]): void;
    /**
     * Fade the Page Navigation Component after it has not been interacted with. Reappears whenever the document is scrolled.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     // Sets behaviour to fade the page navigation component.
     *     // enabled by default
     *     instance.UI.enableFadePageNavigationComponent();
     *   });
     */
    function enableFadePageNavigationComponent(): void;
    /**
     * Enable certain features in the WebViewer UI.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     instance.UI.enableFeatures(instance.Feature.Measurement);
     *   });
     * @param features - Array of features to enable.
     */
    function enableFeatures(features: string[]): void;
    /**
     * Turns high contrast mode on to help with accessibility.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     instance.UI.enableHighContrastMode();
     *   });
     */
    function enableHighContrastMode(): void;
    /**
     * Enable native mobile device scrolling behavior. By default custom behavior is used to handle vertical and horizontal scroll locking.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     instance.UI.enableNativeScrolling();
     *   });
     */
    function enableNativeScrolling(): void;
    /**
     * Enable the ability to submit notes by only pressing Enter. Default mode is Ctrl/Cmd + Enter.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     instance.UI.enableNoteSubmissionWithEnter();
     *   });
     */
    function enableNoteSubmissionWithEnter(): void;
    /**
     * Enable the confirmation modal when deleting a page from the thumbnail view
     * @example
     * WebViewer(...)
     *  .then(function(instance) {
     *     instance.UI.enablePageDeletionConfirmationModal();
     *   });
     */
    function enablePageDeletionConfirmationModal(): void;
    /**
     * Enable multiple tools.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     // enable sticky annotation tool and free text tool
     *     instance.UI.enableTools([ 'AnnotationCreateSticky', 'AnnotationCreateFreeText' ]);
     *   });
     * @param [toolNames = all tools] - Array of name of the tools, either from tool names list or the name you registered your custom tool with. If nothing is passed, all tools will be enabled.
     */
    function enableTools(toolNames?: string[]): void;
    /**
     * Returns a dictionary with page indices as keys and the bookmark text as the values
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     // Save the annotation data for doc123
     *     const bookmarks = instance.UI.exportBookmarks();
     *     const bookmarksString = JSON.stringify(bookmarks);
     *     fetch('/server/bookmarksHandler.js?documentId=doc123', {
     *       method: 'POST',
     *       body: bookmarksString // written into a json file on server
     *     });
     *   });
     * @returns A dictionary with page indices as keys and the bookmark text as the values. ex: {"0":"Bookmark 1","2":"Bookmark 2"}
     */
    function exportBookmarks(): any;
    /**
     * Extract pages from the current document
     * @example
     * // 6.0 and after
     * WebViewer(...)
     *   .then(function(instance) {
     *     instance.UI.extractPagesWithAnnotations ([1,2,3]).then(function(fileData){
     *     });
     *   });
     * @param pageNumbersToExtract - An array of pages to extract from the document. Annotations on the pages are included
     * @returns A promise that resolve to a <a href='https://developer.mozilla.org/en-US/docs/Web/API/File' target='_blank'>File object</a>
     */
    function extractPagesWithAnnotations(pageNumbersToExtract: number[]): Promise<File>;
    /**
     * Focuses a note input field for the annotation. If the notes panel is closed, it is automatically opened before focusing.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     var annotManager = instance.Core.annotationManager;
     *
     *     annotManager.addEventListener('annotationChanged', function(annotations, action) {
     *       annotations.forEach(function(annotation) {
     *         // Focus the note when annotation is created
     *         if (action === 'add' && annotation.Listable) {
     *           instance.UI.focusNote(annotation.Id); // note it is a capital i
     *         }
     *       });
     *     });
     *   });
     * @param annotationId - Id of an annotation.
     */
    function focusNote(annotationId: string): void;
    /**
     * A namespace which contains Font APIs for the UI. <br/><br/>
     * @example
     * WebViewer(...)
     * .then(function (instance) {
     *   instance.UI.Fonts.getFonts();
     * });
     */
    namespace Fonts {
        /**
         * Return the currently available fonts in the UI to be used for Annotations.
         * @example
         * WebViewer(...)
         *    .then(function(instance) {
         *     instance.UI.Fonts.getAnnotationFonts();
         *   });
         * @returns Fonts avaialable in the UI.
         */
        function getAnnotationFonts(): String[];
        /**
         * Add a font to be available in the UI for Annotation font pickers.
         * @example
         * WebViewer(...)
         *    .then(function(instance) {
         *     instance.UI.Fonts.addAnnotationFont("Arial");
         *   });
         * @param font - The font to be added.
         */
        function addAnnotationFont(font: string): void;
        /**
         * Remove a font from the UI's Annotation font pickers.
         * @example
         * WebViewer(...)
         *    .then(function(instance) {
         *     instance.UI.Fonts.removeAnnotationFont("Arial");
         *   });
         * @param font - The font to be removed.
         */
        function removeAnnotationFont(font: string): void;
        /**
         * Set the fonts available in the UI's Annotation font pickers.
         * @example
         * WebViewer(...)
         *    .then(function(instance) {
         *     instance.UI.Fonts.setAnnotationFonts(["Arial", "Times New Roman"]);
         *   });
         * @param fonts - The fonts to be set.
         */
        function setAnnotationFonts(fonts: String[]): void;
        /**
         * Returns the currently available fonts to be used when typing a signature in the signature dialog
         * @returns Fonts avaialable in the UI.
         */
        function getSignatureFonts(): String[];
        /**
         * Add a font to be available in the UI for Signature font pickers.
         * @example
         * WebViewer(...)
         *    .then(function(instance) {
         *     instance.UI.Fonts.addSignatureFont("Arial");
         *   });
         * @param font - The font to be added.
         */
        function addSignatureFont(font: string): void;
        /**
         * Remove a font from the UI's Signature font pickers.
         * @example
         * WebViewer(...)
         *    .then(function(instance) {
         *     instance.UI.Fonts.removeSignatureFont("Arial");
         *   });
         * @param font - The font to be removed.
         */
        function removeSignatureFont(font: string): void;
        /**
         * Set the fonts available in the UI's Signature font pickers.
         * @example
         * WebViewer(...)
         *    .then(function(instance) {
         *     instance.UI.Fonts.setSignatureFonts(["Arial", "Times New Roman"]);
         *   });
         * @param fonts - The fonts to be set.
         */
        function setSignatureFonts(fonts: String[]): void;
    }
    /**
     * Return the read/unread state of an annotation. True for read, false for unread.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     const isAnnotationRead = instance.UI.getAnnotationReadState('test-annotation-id');
     * @param annotationId - Id of the annotation.
     * @returns Whether the annotation is read.
     */
    function getAnnotationReadState(annotationId: string): boolean;
    /**
     * Returns all available languages as a list.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     console.log(instance.UI.getAvailableLanguages());
     *   });
     * @returns All available languages
     */
    function getAvailableLanguages(): string[];
    /**
     * A getter that returns a stringified version of the 'custom' property that is passed to the WebViewer constructor
     * <a href='https://www.pdftron.com/documentation/web/guides/config-files/#passing-custom-data' target='_blank'>Refer to the passing custom data section</a>.
     * @returns returns a stringified version of the 'custom' property that is passed to the WebViewer constructor
     */
    function getCustomData(): string;
    /**
     * Return the current fit mode of the WebViewerInstance UI.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     var docViewer = instance.Core.documentViewer;
     *
     *     // you must have a document loaded when calling this api
     *     docViewer.addEventListener('documentLoaded', function() {
     *       console.log(instance.UI.getFitMode());
     *     });
     *   });
     * @returns Current fit mode
     */
    function getFitMode(): string;
    /**
     * Check whether high contrast mode is enabled or not.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     instance.UI.getIsHighContrastMode();
     *   });
     */
    function getIsHighContrastMode(): void;
    /**
     * Return the current layout mode of the WebViewerInstance.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     var docViewer = instance.Core.documentViewer;
     *
     *     // you must have a document loaded when calling this api
     *     docViewer.addEventListener('documentLoaded', function() {
     *       console.log(instance.UI.getLayoutMode());
     *     });
     *   });
     * @returns Current layout mode
     */
    function getLayoutMode(): string;
    /**
     * Return the max zoom level
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     const docViewer = instance.Core.documentViewer;
     *
     *     // you must have a document loaded when calling this api
     *     docViewer.addEventListener('documentLoaded', function() {
     *       console.log(instance.UI.getMaxZoomLevel());
     *     });
     *   });
     * @returns max zoom level
     */
    function getMaxZoomLevel(): number;
    /**
     * Return the min zoom level
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     const docViewer = instance.Core.documentViewer;
     *
     *     // you must have a document loaded when calling this api
     *     docViewer.addEventListener('documentLoaded', function() {
     *       console.log(instance.UI.getMinZoomLevel());
     *     });
     *   });
     * @returns min zoom level
     */
    function getMinZoomLevel(): number;
    /**
     * Get the currently selected pages
     * @example
     * // 6.0 and after
     * WebViewer(...)
     *   .then(function(instance) {
     *     instance.UI.getSelectedThumbnailPageNumbers();
     *   });
     * @returns an array of select page numbers
     */
    function getSelectedThumbnailPageNumbers(): number[];
    /**
     * Return the current tool object.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     console.log(instance.UI.getToolMode().name, instance.UI.getToolMode());
     *   });
     * @returns Instance of the current tool
     */
    function getToolMode(): Core.Tools.Tool;
    /**
     * Gets the watermark options created in print modal.
     * @returns Returns the watermark options created in print modal.
     */
    function getWatermarkModalOptions(): any;
    /**
     * Return the current zoom level
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     const docViewer = instance.Core.documentViewer;
     *
     *     // you must have a document loaded when calling this api
     *     docViewer.addEventListener('documentLoaded', function() {
     *       console.log(instance.UI.getZoomLevel());
     *     });
     *   });
     * @returns Zoom level (0 ~ 1)
     */
    function getZoomLevel(): number;
    /**
     * hide outline control
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     instance.UI.hideOutlineControl();
     *   });
     */
    function hideOutlineControl(): void;
    /**
     * An instance of Hotkeys that can be used to enable, disable or register custom hotkeys in the viewer
     */
    var hotkeys: typeof UI.Hotkeys;
    /**
     * Imports user bookmarks
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     // load the user bookmarks data for id 'doc123'
     *     fetch('/server/bookmarksHandler.js?documentId=doc123', {
     *       method: 'GET'
     *     }).then(function(response) {
     *       if (response.status === 200) {
     *         response.text().then(function(bookmarksString) {
     *           // {"0":"Bookmark 1","2":"Bookmark 2"}
     *           const bookmarks = JSON.parse(bookmarksString);
     *           instance.UI.importBookmarks(bookmarks);
     *         });
     *       }
     *     });
     *   });
     * @param bookmarks - A dictionary with page indices as keys and the bookmark text as the values. ex: {"0":"Bookmark 1","2":"Bookmark 2"}. Behaviour is undefined otherwise.
     */
    function importBookmarks(bookmarks: any): void;
    /**
     * Returns whether the element is disabled.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     console.log(instance.UI.isElementDisabled('leftPanel'));
     *   });
     * @param dataElement - data-element attribute value for a DOM element. To find data-element of a DOM element, refer to <a href='https://www.pdftron.com/documentation/web/guides/hiding-elements/#finding-dataelement-attribute-values' target='_blank'>Finding data-element attribute values</a>.
     * @returns Whether the element is disabled.
     */
    function isElementDisabled(dataElement: string): boolean;
    /**
     * Returns whether the element is open.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     console.log(instance.UI.isElementOpen('leftPanel'));
     *   });
     * @param dataElement - data-element attribute value for a DOM element. To find data-element of a DOM element, refer to <a href='https://www.pdftron.com/documentation/web/guides/hiding-elements/#finding-dataelement-attribute-values' target='_blank'>Finding data-element attribute values</a>.
     * @returns Whether the element is open.
     */
    function isElementOpen(dataElement: string): boolean;
    /**
     * Returns whether in fullscreen mode.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     console.log(instance.UI.isFullscreen());
     *   });
     * @returns Whether in fullscreen mode.
     */
    function isFullscreen(): boolean;
    /**
     * Check whether high contrast mode is enabled or not.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     instance.UI.isHighContrastModeEnabled();
     *   });
     */
    function isHighContrastModeEnabled(): void;
    /**
     * Returns a boolean to denote if the UI is in desktop only mode.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     instance.UI.isInDesktopOnlyMode();
     *   });
     * @returns boolean to denote if the UI is in desktop only mode
     */
    function isInDesktopOnlyMode(): boolean;
    /**
     * Returns whether the tool is disabled.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     console.log(instance.UI.isToolDisabled());
     *   });
     * @param toolName - Name of the tool, either from <a href='https://www.pdftron.com/documentation/web/guides/annotations-and-tools/#list-of-tool-names' target='_blank'>tool names list</a> or the name you registered your custom tool with.
     * @returns Whether the tool is disabled.
     */
    function isToolDisabled(toolName: string): boolean;
    /**
     */
    type loadDocumentOptions = {
        /**
         * The extension of the file. If file is a blob/file object or a URL without an extension then this is necessary so that WebViewer knows what type of file to load.
         */
        extension?: string;
        /**
         * Filename of the document, which is used when downloading the PDF.
         */
        filename?: string;
        /**
         * An object of custom HTTP headers to use when retrieving the document from the specified url.
         */
        customHeaders?: any;
        /**
         * An object of custom query propertyeters to be appended to every WebViewer Server request.
         */
        webViewerServerCustomQuerypropertyeters?: any;
        /**
         * Unique id of the document.
         */
        documentId?: string;
        /**
         * Whether or not cross-site requests should be made using credentials.
         */
        withCredentials?: boolean;
        /**
         * A key that will be used for caching the document on WebViewer Server.
         */
        cacheKey?: string;
        /**
         * An object that contains the options for an Office document.
         */
        officeOptions?: {
            templateValues?: Core.TemplateData;
            doTemplatePrep?: boolean;
            disableBrowserFontSubstitution?: boolean;
            formatOptions?: {
                applyPageBreaksToSheet?: boolean;
                displayChangeTracking?: boolean;
                excelDefaultCellBorderWidth?: number;
                excelMaxAllowedCellCount?: number;
                locale?: string;
            };
        };
        /**
         * A string that will be used to as the password to load a password protected document.
         */
        password?: string;
        /**
         * A callback function that will be called when error occurs in the process of loading a document. The function signature is `function(e) {}`
         */
        onError?: (...params: any[]) => any;
        /**
         * An object that contains the options for a XOD document.
         */
        xodOptions?: any;
        /**
         * Function to be called to decrypt a part of the XOD file. For default XOD AES encryption pass Core.Encryption.decrypt.
         */
        xoddecrypt?: boolean;
        /**
         * An object with options for the decryption e.g. {p: "pass", type: "aes"} where is p is the password.
         */
        xoddecryptOptions?: boolean;
        /**
         * A boolean indicating whether to use http or streaming PartRetriever, it is recommended to keep streaming false for better performance. https://www.pdftron.com/documentation/web/guides/streaming-option.
         */
        xodstreaming?: boolean;
        /**
         * Whether or not to workaround the issue of Azure not accepting range requests of a certain type. Enabling the workaround will add an extra HTTP request of overhead but will still allow documents to be loaded from other locations.
         */
        xodazureWorkaround?: boolean;
        /**
         * Whether to start loading the document in offline mode or not. This can be set to true if the document had previously been saved to an offline database using WebViewer APIs. You'll need to use this option to load from a completely offline state.
         */
        xodstartOffline?: boolean;
    };
    /**
     * Load a document inside WebViewer UI.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     instance.UI.loadDocument('https://www.pdftron.com/downloads/pl/test.pdf', {
     *       documentId: '1',
     *       filename: 'sample-1.pdf'
     *     });
     *   });
     * @param documentPath - Path to the document OR <a href='https://developer.mozilla.org/en-US/docs/Web/API/File' target='_blank'>File object</a> if opening local file.
     * @param [options] - Additional options
     */
    function loadDocument(documentPath: string | File | Blob | Core.Document | Core.PDFNet.PDFDoc, options?: UI.loadDocumentOptions): void;
    /**
     * An instance of MentionsManager that can be used to allow mentioning people in a textarea in the notes panel.
     */
    var mentions: UI.MentionsManager;
    /**
     * An instance of MenuOverlay that can be used to edit items in the settings menu overlay component.
     * @example
     * WebViewer(...)
     *   .then(function (instance) {
     *     instance.UI.settingsMenuOverlay.someAPI();
     *   });
     */
    var settingsMenuOverlay: UI.MenuOverlay;
    /**
     * A class which contains MenuOverlay APIs.<br/><br/>
    <span style="color: red; font-size: 1.2em; font-weight: bold"></span> If you want to remove an item in a MenuOverlay, use {@link UI.disableElements disableElements}.
     */
    interface MenuOverlay {
        /**
         * Add an array of Actions Buttons after the item that has the given data element.
         * @example
         * WebViewer(...)
         *   .then(function(instance) {
         *     instance.UI.settingsMenuOverlay.add({
         *       type: 'actionButton',
         *       className:"row",
         *       img: 'icon-header-print-line',
         *       onClick: () => {
         *         alert('Printing...');
         *       },
         *       dataElement: 'alertButton',
         *       label:'print button'
         *     });
         *   });
         * @param items - Same as <a href='https://www.pdftron.com/documentation/web/guides/customizing-header#actionbutton' target='_blank'>ActionButton</a>
         * @param [dataElement] - An optional string. If not given, items will be added in the beginning
         * @returns The instance itself
         */
        add(items: object[], dataElement?: string): this;
        /**
         * Update all the items in the menuOverlay dropdown.
        To update an individual item, use {@link UI.updateElement updateElement}
         * @example
         * WebViewer(...)
         *   .then(function(instance) {
         *     // replace existing items with a new array of items
         *     instance.UI.settingsMenuOverlay.update([
         *       {
         *         type: 'actionButton',
         *         className:"row",
         *         img: 'icon-header-print-line',
         *         onClick: () => {
         *           alert('Hello world!');
         *         },
         *         dataElement: 'alertButton',
         *         label:'test button',
         *         role:"option"
         *       },
         *       {
         *         type: 'actionButton',
         *         className:"row",
         *         img: 'icon-header-print-line',
         *         onClick: () => {
         *           alert('Hello world!');
         *         },
         *         dataElement: 'alertButton2',
         *         label:'test button 2',
         *         role:"option"
         *       },
         *     ]);
         *   });
         * @param [items] - the items that will be rendered in the menuOverlay dropdown
         * @returns The instance itself
         */
        update(items?: object[]): this;
        /**
         * Return the array of items in the menuOverlay dropdown.
         * @example
         * WebViewer(...)
         *   .then(function(instance) {
         *     instance.UI.settingsMenuOverlay.getItems();
         *   });
         * @returns Current items in the menuOverlay dropdown.
         */
        getItems(): object[];
    }
    namespace NotesPanel {
        /**
         * Enables the collapsing of the annotation's text in the Notes Panel.
         * @example
         * WebViewer(...).then(async function(instance) {
         *
         *   instance.UI.NotesPanel.enableTextCollapse()
         *
         * });
         */
        function enableTextCollapse(): void;
        /**
         * Disables the collapsing of the annotation's text in the Notes Panel.
         * @example
         * WebViewer(...).then(async function(instance) {
         *
         *   instance.UI.NotesPanel.disableTextCollapse()
         * });
         */
        function disableTextCollapse(): void;
        /**
         * Enables the collapsing of the replies in the Notes Panel.
         * @example
         * WebViewer(...).then(async function(instance) {
         *
         *   instance.UI.NotesPanel.enableReplyCollapse()
         * });
         */
        function enableReplyCollapse(): void;
        /**
         * Disables the collapsing of the replies in the Notes Panel.
         * @example
         * WebViewer(...).then(async function(instance) {
         *
         *   instance.UI.NotesPanel.disableReplyCollapse()
         * });
         */
        function disableReplyCollapse(): void;
        /**
         * Disables the automatic expansion of all the comments threads in the Notes Panel.
         * @example
         * WebViewer(...).then(async function(instance) {
         *
         *   instance.UI.NotesPanel.disableAutoExpandCommentThread()
         * });
         */
        function disableAutoExpandCommentThread(): void;
        /**
         * Enables the automatic expansion of the comments threads in the Notes Panel.
         * @example
         * WebViewer(...).then(async function(instance) {
         *
         *   instance.UI.NotesPanel.enableAutoExpandCommentThread()
         * });
         */
        function enableAutoExpandCommentThread(): void;
    }
    /**
     * Sets visibility states of the elements to be visible. Note that openElements works only for panel/overlay/popup/modal elements.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     // opens (shows) text popup and annotation popup in the UI
     *     instance.UI.openElements([ 'menuOverlay', 'leftPanel' ]);
     *   });
     * @param dataElements - Array of data-element attribute values for DOM elements. To find data-element of a DOM element, refer to <a href='https://www.pdftron.com/documentation/web/guides/hiding-elements/#finding-dataelement-attribute-values' target='_blank'>Finding data-element attribute values</a>.
     */
    function openElements(dataElements: string[]): void;
    /**
     * Add custom override function for default search on UI.
     * overrideSearchExecutionCallback function will be executed with search value and search options
     * when user executes search from UI. This function won't be executed when search is triggered through programmatic searches.
     * @example
     * WebViewer(...)
     *  .then(function(instance) {
     *     function searchFn(searchValue, options) {
     *       console.log(searchValue, options);
     *     };
     *
     *     instance.UI.overrideSearchExecution(searchFn);
     *   });
     * @param overrideSearchExecutionCallback - Function that will executed instead of default search functionality.
     */
    function overrideSearchExecution(overrideSearchExecutionCallback: (...params: any[]) => any): void;
    /**
     * An  instance of PageManipulationsOverlay that can be used to edit the items included in the overlay
     * @example
     * WebViewer(...)
     *   .then(function (instance) {
     *     instance.UI.pageManipulationOverlay.someAPI();
     *   })
     */
    var pageManipulationsOverlay: UI.PageManipulationOverlay;
    namespace PageManipulationOverlay {
        /**
         */
        type PageManipulationSection = {
            /**
             * Required type of 'customPageOperation'
             */
            type: string;
            /**
             * Header to be displayed in the UI for this section
             */
            header: string;
            /**
             * Unique dataElement
             */
            dataElement: string;
            /**
             * the operations that will be available under this section
             */
            operations: UI.PageManipulationOverlay.PageOperation[];
        };
        /**
         */
        type PageOperation = {
            /**
             * Title to be displayed for the operation
             */
            title: string;
            /**
             * path to imge to be used as an icon for the operation
             */
            img: string;
            /**
             * onClick handler, which takes as a parameter an array of selected page numbers
             */
            onClick: (...params: any[]) => any;
            /**
             * Unique dataElement for this operation
             */
            dataElement: string;
        };
    }
    /**
     * A class which contains PageManipulationOverlay APIs. <br/><br/>
     * <span style="color: red; font-size: 1.2em; font-weight: bold"></span> If you want to remove an item in the PageManipulationOverlay, use {@link UI.disableElements disableElements}.
     */
    interface PageManipulationOverlay {
        /**
         * Adds an array of page manipulation operations to the default operations. If passed a dataElement parameter, it will
         * add the new operations after this element. Otherwise, they will be appended to the start of the existing list
         * of operations.
         * @example
         * // Each object in the operations array shall consist of the following:
         *     {
         *       type: 'customPageOperation', // Required type of 'customPageOperation'
         *       header: 'Custom options', // Header to be displayed in the UI
         *       dataElement: 'customPageOperations', // Unique dataElement
         *       // Each new section can have one more more operations.
         *       // The onClick handler for each operation gets passed an array of the currently selected
         *       // thumbnail page numbers.
         *       operations: [
         *         {
         *           title: 'Alert me of selected thumbnail page numbers',
         *           img: '/path-to-image',
         *           onClick: (selectedPageNumbers) => {
         *             alert(`Selected thumbnail pages: ${selectedPageNumbers}`);
         *           },
         *           dataElement: 'customPageOperationButton', // Each operation must have a dataElement
         *         }
         *       ]
         *     }
         *      // Additionally, to add dividers you can include this in the operations array:
         *     { type: 'divider' }
         *     // Example:
         *     WebViewer(...)
         *       .then(function (instance) {
         *         instance.UI.pageManipulationOverlay.add([
         *           {
         *             type: 'customPageOperation',
         *             header: 'Custom options',
         *             dataElement: 'customPageOperations',
         *             operations: [
         *               {
         *                 title: 'Alert me',
         *                 img: '/path-to-image',
         *                 onClick: (selectedPageNumbers) => {
         *                   alert(`Selected thumbnail pages: ${selectedPageNumbers}`);
         *                 },
         *                 dataElement: 'customPageOperationButton',
         *               }
         *             ]
         *           },
         *           { type: 'divider' }
         *         ]);
         *       });
         * @param PageManipulationSection - Array of sections to be added, each with its individual operations. See example below.
         * @param [dataElementToInsertAfter] - An optional string that determines where in the overlay the new section will be added. If not included, the new page manipulation section will be added at the top.
         * You can call {@link UI.PageManipulationOverlay#getItems getItems} to get existing items and their dataElements.
         * @returns The instance itself
         */
        add(PageManipulationSection: UI.PageManipulationOverlay.PageManipulationSection[], dataElementToInsertAfter?: 'pageRotationControls' | 'pageInsertionControls' | 'pageManipulationControls'): UI.PageManipulationOverlay;
        /**
         * Update all the operations in the PageManipulationOverlay, essentially replacing them with
         * a new list of operations.
         * To update an individual item, use {@link UI.updateElement updateElement}
         * @example
         * WebViewer(...)
         *       .then(function (instance) {
         *         instance.UI.pageManipulationOverlay.update([
         *           {
         *             type: 'customPageOperation',
         *             header: 'Print Operations',
         *             dataElement: 'customPageOperations',
         *             operations: [
         *               {
         *                 title: 'Print page',
         *                 img: 'icon-header-print-line',
         *                 onClick: (selectedPageNumbers) => {
         *                   alert(`Selected thumbnail pages: ${selectedPageNumbers}`);
         *                 },
         *                 dataElement: 'printThumbnailPage',
         *               }
         *             ]
         *           },
         *           { type: 'divider' },
         *           {
         *             type: 'customPageOperation',
         *             header: 'Alert Operations',
         *             dataElement: 'customPageOperations-2',
         *             operations: [
         *               {
         *                 title: 'Alert me',
         *                 img: 'icon-header-print-line',
         *                 onClick: (selectedPageNumbers) => {
         *                   alert(`Selected thumbnail pages: ${selectedPageNumbers}`);
         *                 },
         *                 dataElement: 'alertPage',
         *               }
         *             ]
         *           }
         *         ]);
         *       });
         * @param PageManipulationSection - The list of PageManipulationSections that will be rendered in the PageManipulation overlay. See the add documentation for an example.
         * @returns The instance of itself
         */
        update(PageManipulationSection: UI.PageManipulationOverlay.PageManipulationSection[]): UI.PageManipulationOverlay;
        /**
         * Return the array of items in the PageManipulationOverlay.
         * @example
         * WebViewer(...)
         *   .then(function(instance) {
         *     instance.UI.pageManipulationOverlay.getItems();
         *   });
         * @returns Current items in the PageManipulationOverlay.
         */
        getItems(): UI.PageManipulationOverlay.PageManipulationSection[];
    }
    /**
     * Print the current document.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     const docViewer = instance.Core.documentViewer;
     *     // you must have a document loaded when calling this api
     *     docViewer.addEventListener('documentLoaded', function() {
     *       instance.UI.print();
     *     });
     *   });
     */
    function print(): void;
    /**
     * Programmatically print the document without opening a modal with the print options provided. Not supported by legacy-ui
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     const docViewer = instance.Core.documentViewer;
     *
     *     // you must have a document loaded when calling this api
     *     docViewer.addEventListener('documentLoaded', function() {
     *       instance.UI.printInBackground({
     *         includeComments:true,
     *         includeAnnotations: true,
     *         maintainPageOrientation: true,
     *         onProgress: function(pageNumber, htmlElement) {},
     *       });
     *     });
     *   });
     * @param [options] - Options for the printing.
     * @param [options.pagesToPrint] - Optionally pass in the pages you want to print. By default, all pages will be printed.
     * @param [options.includeAnnotations = false] - If true, will print the documents with the annotations
     * @param [options.includeComments = false] - If true, will append comments to the document printed
     * @param [options.isPrintCurrentView] - If true, will print the current viewport view of the current page
     * @param [options.maintainPageOrientation] - If true, will maintain the pages orientation as set in the webviewer during printing
     * @param [options.onProgress] - A callback function that is executed on each page processed
     */
    function printInBackground(options?: {
        pagesToPrint?: number[];
        includeAnnotations?: boolean;
        includeComments?: boolean;
        isPrintCurrentView?: boolean;
        maintainPageOrientation?: boolean;
        onProgress?: (...params: any[]) => any;
    }): void;
    /**
     * Registers tool in the document viewer tool mode map, and adds a button object to be used in the header. See <a href='https://www.pdftron.com/documentation/web/guides/customizing-tools' target='_blank'>Customizing tools</a> to learn how to make a tool.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     // assume myCustomTool and myCustomAnnotation are already defined
     *     const myTool = {
     *       toolName: 'MyTool',
     *       toolObject: myCustomTool,
     *       buttonImage: 'path/to/image',
     *       buttonName: 'myToolButton',
     *       buttonGroup: 'miscTools',
     *       tooltip: 'MyTooltip'
     *     };
     *
     *     instance.UI.registerTool(myTool, undefined, annot => annot && annot.isCustomAnnot);
     *   });
     * @param properties - Tool properties.
     * @param properties.toolName - Name of the tool.
     * @param properties.toolObject - Instance of the tool.
     * @param properties.buttonImage - Path to an image or base64 data for the tool button.
     * @param [properties.buttonName] - Name of the tool button that will be used in data-element.
     * @param [properties.buttonGroup] - Group of the tool button belongs to.
     * @param [properties.tooltip] - Tooltip of the tool button.
     * @param [properties.showColor] - Controls when the tool button should show the color.
     * @param [properties.showPresets] - Option to whether show or hide preset styles. Default is true.
     * @param [annotationConstructor] - Deprecated Please use customAnnotationCheckFunc instead. Will be removed in the future.
     * @param [customAnnotationCheckFunc] - Function that takes in a parameter of an annotation. Returns a boolean if the specified annotation is a certain type of annotation. This function is used by the viewer to check if the annotation passed in is associated(created) with the registered tool.
     */
    function registerTool(properties: {
        toolName: string;
        toolObject: Core.Tools.Tool;
        buttonImage: string;
        buttonName?: string;
        buttonGroup?: string;
        tooltip?: string;
        showColor?: 'always' | 'active' | 'never';
        showPresets?: boolean;
    }, annotationConstructor?: (...params: any[]) => any, customAnnotationCheckFunc?: (...params: any[]) => any): void;
    /**
     * Reloads the Bookmark Outline in the WebViewer UI.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     const { documentViewer } = instance.Core;
     *
     *     // you must have a document loaded when calling this api
     *     documentViewer.addEventListener('documentLoaded', async () => {
     *       const doc = documentViewer.getDocument();
     *       const pdfDoc = await doc.getPDFDoc();
     *       const firstBookmark = await doc.getFirstBookmark();
     *
     *       const bookmarkToDelete = await firstBookmark.find('bookmark-to-delete');
     *       if (bookmarkToDelete !== null && await bookmarkToDelete.isValid()) {
     *         await bookmarkToDelete.delete();
     *         instance.UI.reloadOutline();
     *       }
     *     });
     *   });
     */
    function reloadOutline(): void;
    /**
     * "Remove an event listener for the given WebViewer UI event.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     const listener = e => {
     *       const { types, authors, colors } = e.detail;
     *       console.log(types, authors, colors);
     *
     *       instance.UI.removeEventListener(instance.UI.Events.ANNOTATION_FILTER_CHANGED, listener);
     *     };
     *     instance.UI.addEventListener(instance.UI.Events.ANNOTATION_FILTER_CHANGED, listener);
     *   });
     * @param eventName - UI event name.
     * @param listener - Event handler function that should no longer be bound to the event.
     */
    function removeEventListener(eventName: string, listener: (...params: any[]) => any): void;
    /**
     * Removes a search pattern from the redaction search panel
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     instance.UI.removeRedactionSearchPattern(instance.UI.RedactionSearchPatterns.EMAILS);
     *   });
     *
     * // If you added a custom search pattern for Social Security Number where the type is 'socialSecurityNumber'.
     * WebViewer(...)
     * .then(function(instance) {
     *   instance.UI.removeRedactionSearchPattern('socialSecurityNumber');
     * });
     * @param searchPattern - A search pattern to remove from the redaction search panel. If you added a custom search pattern with {@link UI.addRedactionSearchPattern}, you must pass the type of the search pattern you added.
     */
    function removeRedactionSearchPattern(searchPattern: UI.RedactionSearchPatterns | string): void;
    /**
     * Removes the search listener function.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     function searchListener(searchValue, options, results) {
     *       console.log(searchValue, options, results);
     *     };
     *
     *     instance.UI.addSearchListener(searchListener);
     *     instance.UI.removeSearchListener(searchListener);
     *   });
     * @param listener - Search listener function that was added.
     */
    function removeSearchListener(listener: UI.searchListener): void;
    /**
     * Sets a specific regex to be used when searching for one of the supported patterns in the redaction search panel
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     instance.UI.replaceRedactionSearchPattern(instance.UI.RedactionSearchPatterns.EMAILS, /\w+@\w+\.\w+/);
     *   });
     * @param searchPattern - A search pattern for which the regex should be replaced
     * @param regex - The regex to be used for the search pattern
     */
    function replaceRedactionSearchPattern(searchPattern: UI.RedactionSearchPatterns, regex: string): void;
    /**
     * Searches the document one by one for the text matching searchValue. To go to the next result this
     * function must be called again. Once document end is reach it will jump back to the first found result.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     const docViewer = instance.Core.documentViewer;
     *
     *     // you must have a document loaded when calling this api
     *     docViewer.addEventListener('documentLoaded', function() {
     *       instance.UI.searchText('test', {
     *         caseSensitive: true,
     *         wholeWord: true
     *       });
     *     });
     *   });
     * @param searchValue - The text value to look for.
     * @param [options] - Search options.
     * @param [options.caseSensitive = false] - Search with matching cases.
     * @param [options.wholeWord = false] - Search whole words only.
     * @param [options.wildcard = false] - Search a string with a wildcard *. For example, *viewer.
     * @param [options.regex = false] - Search for a regex string. For example, www(.*)com.
     * @param [options.searchUp = false] - Search up the document (backwards).
     * @param [options.ambientString = false] - Get the ambient string in the result.
     */
    function searchText(searchValue: string, options?: {
        caseSensitive?: boolean;
        wholeWord?: boolean;
        wildcard?: boolean;
        regex?: boolean;
        searchUp?: boolean;
        ambientString?: boolean;
    }): void;
    /**
     * Searches the full document for the texts matching searchValue.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     const docViewer = instance.Core.documentViewer;
     *
     *     // you must have a document loaded when calling this api
     *     docViewer.addEventListener('documentLoaded', function() {
     *       instance.UI.searchTextFull('test', {
     *         wholeWord: true
     *       });
     *     });
     *   });
     * @param searchValue - The text value to look for.
     * @param [options] - Search options.
     * @param [options.caseSensitive = false] - Search with matching cases.
     * @param [options.wholeWord = false] - Search whole words only.
     * @param [options.wildcard = false] - Search a string with a wildcard *. For example, *viewer.
     * @param [options.regex = false] - Search for a regex string. For example, www(.*)com.
     */
    function searchTextFull(searchValue: string, options?: {
        caseSensitive?: boolean;
        wholeWord?: boolean;
        wildcard?: boolean;
        regex?: boolean;
    }): void;
    /**
     * Select thumbnails in the thumbnail panel. This requires the "ThumbnailMultiselect" feature to be enabled
     * @example
     * // 6.1 and after
     * WebViewer(...)
     *   .then(function(instance) {
     *     instance.UI.enableFeatures(['ThumbnailMultiselect']);
     *
     *     const pageNumbersToSelect = [1, 2, 3];
     *     instance.UI.selectThumbnailPages(pageNumbersToSelect);
     *   });
     * @param pageNumbers - array of page numbers to select
     */
    function selectThumbnailPages(pageNumbers: number[]): void;
    /**
     * Sets a header group to be rendered in the Header element. This API comes useful when replacing the entire header items in small screens.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     instance.UI.setActiveHeaderGroup('toolbarGroup-Annotate'); // switch to 'Annotate' group header
     *   });
     * @param headerGroup - Name of the header group to be rendered. Default WebViewer UI has eight header groups: 'default', 'small-mobile-more-buttons', 'toolbarGroup-View', 'toolbarGroup-Annotate', 'toolbarGroup-Shapes', 'toolbarGroup-Insert', 'toolbarGroup-Measure', and 'toolbarGroup-Edit'.
     */
    function setActiveHeaderGroup(headerGroup: string): void;
    /**
     * Sets a panel to be active in the leftPanel element. Note that this API does not include opening the leftPanel.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     // open left panel
     *     instance.UI.openElements([ 'leftPanel' ]);
     *     // view outlines panel
     *     instance.UI.setActiveLeftPanel('outlinesPanel');
     * @param dataElement - Name of the panel to be active in leftPanel. Default WebViewer UI has three panel options: thumbnailsPanel, outlinesPanel and notesPanel.
     */
    function setActiveLeftPanel(dataElement: string): void;
    /**
     * Sets the active color palette of a tool and its associated annotation
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     instance.UI.setActivePalette('AnnotationCreateFreeText', 'fill')
     *   });
     * @param toolName - Name of the tool, either from <a href='https://www.pdftron.com/documentation/web/guides/annotations-and-tools/#list-of-tool-names' target='_blank'>tool names list</a> or the name you registered your custom tool with.
     * @param colorPalette - The palette to be activated. One of 'text', 'border' and 'fill'.
     */
    function setActivePalette(toolName: string, colorPalette: 'text' | 'border' | 'fill'): void;
    /**
     * Adds a custom overlay to annotations on mouseHover, overriding the existing overlay.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     instance.UI.setAnnotationContentOverlayHandler(annotation => {
     *         const div = document.createElement('div');
     *         div.appendChild(document.createTextNode(`Created by: ${annotation.Author}`));
     *         div.appendChild(document.createElement('br'));
     *         div.appendChild(document.createTextNode(`Created on ${annotation.DateCreated}`));
     *         return div;
     *     });
     *   });
     * @param customOverlayHandler - A function that takes an annotation and returns a DOM Element, which is rendered as a tooltip when hovering over the annotation. Returning null or false will render nothing. Returning 'undefined' will use default behavior.
     */
    function setAnnotationContentOverlayHandler(customOverlayHandler: (...params: any[]) => any): void;
    /**
     * Set the read/unread state of an annotation. The default state of annotations is read.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     instance.UI.setAnnotationReadState({ isRead: true, annotationId: 'test-annotation-id' });
     *   });
     * @param options.isRead - whether setting the annotation to read state; false for setting it as unread.
     * @param options.annotationId - Id of the annotation to be set.
     */
    function setAnnotationReadState(options: {
        isRead: boolean;
        annotationId: string;
    }): void;
    /**
     */
    type PaletteOption = {
        /**
         * Tools that will have the same colors in the palette.
         */
        toolNames: string[];
        /**
         * An array of hex colors. Use 'transparency' for a transparent color.
         */
        colors: string[];
    };
    /**
     * Sets the colors in the palette globally or for specific tools and their associated annotations
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     // this sets the palette globally. All the tools will use these colors. Can use empty string for blank spaces and 'transparency' for a transparent color.
     *     instance.UI.setColorPalette(['#FFFFFF', '', '#DDDDDD', 'transparency']);
     *
     *     // use a different set of colors for the freetext and rectangle tool.
     *     instance.UI.setColorPalette({
     *       toolNames: ['AnnotationCreateFreeText', 'AnnotationCreateRectangle'],
     *       colors: ['#333333'],
     *     })
     *   });
     * @param An - array of hex colors that will override the default colors for every tool.
    An object can be passed to specify colors for particular tools.
     */
    function setColorPalette(An: string[] | UI.PaletteOption): void;
    /**
     * @param originalApplyRedactionsFunction - The original applyRedactions function
     */
    type CustomApplyRedactionsHandler = (annotations: Core.Annotations.Annotation[], originalApplyRedactionsFunction: (...params: any[]) => any) => void;
    /**
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     instance.UI.setCustomApplyRedactionsHandler((annotationsToRedact, originalApplyRedactionsFunction) => {
     *       // custom code
     *       ...
     *       originalApplyRedactionsFunction();
     *     })
     *   });
     * @param customApplyRedactionsHandler - The function that will be invoked when clicking on the 'Redact All' button.
     */
    function setCustomApplyRedactionsHandler(customApplyRedactionsHandler: UI.CustomApplyRedactionsHandler): void;
    /**
     * Adds a custom overlay to annotations if that annotation currently support it. Currently only the Ellipsis annotation supports it.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *       instance.UI.setCustomMeasurementOverlayInfo([
     *       {
     *         title: "Radius Measurement", //Title for overlay
     *         label: "Radius", // Label to be shown for the value
     *         // Validate is a function to validate the annotation is valid for the current custom overlay
     *         validate: annotation => annotation instanceof instance.Annotations.EllipseAnnotation,
     *         // The value to be shown in the custom overlay
     *         value: annotation => annotation.Width / 2,
     *         // onChange will be called whenever the value in the overlay changes from user input
     *         onChange: (e, annotation) => {
     *           // Do something with the annot like resize/redraw
     *           instance.Core.annotationManager.redrawAnnotation(annotation);
     *         }
     *       }
     *     ])
     *   });
     * @param customOverlayInfo - an array of customOverlay configurations. The configuration object has five properties: title, label, validate, value, and onChange
     */
    function setCustomMeasurementOverlay(customOverlayInfo: any[]): void;
    /**
     * Add custom modal element to WebViewer.
     * <br /><br />
     * Controlling custom modals is done using element API for example {@link UI.openElements openElements}, {@link UI.closeElements closeElements}, {@link UI.toggleElement toggleElement}, and {@link UI.disableElements disableElements}.
     * dateElement string passed on these function should be same as you set in options.dataElement.
     * <br /><br />
     * Every custom modal will add new &lt;div&gt; element with <b>CustomModal</b> and <b>&lt;options.dataElement string&gt;</b> set as class attribute
     * Modal with identical <em>options.dataElement</em> will get replaced by the latest modal options.
     * <br /><br />
     * For styling these components, see <a href="https://www.pdftron.com/documentation/web/guides/customizing-styles/" target="_blank">Customizing WebViewer UI Styles</a>
     * <br /><br />
     * Note that in most cases WebViewer is ran in iframe and making <i>options.disableEscapeKeyDown</i> automatically work, iframe must be the
     * active element. This can be done by setting focus to iframe programmatically.
     * @example
     * WebViewer(...).then(function(instance) {
     *   var modal = {
     *     dataElement: 'meanwhileInFinlandModal',
     *     render: function renderCustomModal(){
     *       var div = document.createElement("div");
     *       div.style.color = 'white';
     *       div.style.backgroundColor = 'hotpink';
     *       div.style.padding = '20px 40px';
     *       div.style.borderRadius = '5px';
     *       div.innerText = 'Meanwhile in Finland';
     *       return div
     *     }
     *   }
     *   instance.UI.setCustomModal(modal);
     *   instance.UI.openElements([modal.dataElement]);
     *   });
     * @param options.dataElement - Unique name of custom modal.
     * @param [options.disableBackdropClick = false] - Disable closing modal when user clicks outside of content area
     * @param [options.disableEscapeKeyDown = false] - Disable closing modal when user hit escape from keyboard
     * @param options.render - Function rendering custom model contents
     */
    function setCustomModal(options: {
        dataElement: string;
        disableBackdropClick?: boolean;
        disableEscapeKeyDown?: boolean;
        render: UI.renderCustomModal;
    }): void;
    /**
     * Callback that gets passed to `options.render` in {@link UI.setCustomModal setCustomModal}.
     */
    type renderCustomModal = () => HTMLElement | string;
    /**
     * Filter the annotations shown in the notes panel
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     // only show annotations that are created by John
     *     instance.UI.setCustomNoteFilter(function(annotation) {
     *       return annotation.Author === 'John';
     *     });
     *   });
     * @param filterAnnotation - Function that takes an annotation and returns if the annotation(note) should be shown in the notes panel.
     */
    function setCustomNoteFilter(filterAnnotation: UI.filterAnnotation): void;
    /**
     * Callback that gets passed to {@link UI.setCustomNoteFilter setCustomNoteFilter}.
     * @param annotation - Annotation object
     */
    type filterAnnotation = (annotation: Core.Annotations.Annotation) => boolean;
    /**
     * @param annotation - A reference to the annotation object associated with the note
     */
    type CustomNoteSelectionFunction = (annotation: Core.Annotations.Annotation) => void;
    /**
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     instance.UI.setCustomNoteSelectionFunction(annotation => {
     *       // some code
     *     })
     *   });
     * @param customNoteSelectionFunction - The function that will be invoked when clicking on a note in notes panel.
     * The function will only be invoked when the underlying annotation is not already selected.
     */
    function setCustomNoteSelectionFunction(customNoteSelectionFunction: UI.CustomNoteSelectionFunction): void;
    /**
     * Adds a custom panel in left panel
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     var myCustomPanel = {
     *       tab:{
     *         dataElement: 'customPanelTab',
     *         title: 'customPanelTab',
     *         img: 'https://www.pdftron.com/favicon-32x32.png',
     *       },
     *       panel: {
     *         dataElement: 'customPanel',
     *         render: function() {
     *           var div = document.createElement('div');
     *           div.innerHTML = 'Hello World';
     *           return div;
     *         }
     *       }
     *     };
     *
     *     instance.UI.setCustomPanel(myCustomPanel);
     *   });
     * @param options.tab - Tab options.
     * @param options.tab.dataElement - data-element for tab.
     * @param options.tab.title - Tooltip for tab.
     * @param options.tab.img - Url for an image.
     * @param options.panel - Panel options.
     * @param options.panel.dataElement - data-element for panel.
     * @param options.panel.render - Function that returns panel element.
     */
    function setCustomPanel(options: {
        tab: {
            dataElement: string;
            title: string;
            img: string;
        };
        panel: {
            dataElement: string;
            render: UI.renderCustomPanel;
        };
    }): void;
    /**
     * Callback that gets passed to `options.panel.render` in {@link UI.setCustomPanel setCustomPanel}.
     */
    type renderCustomPanel = () => HTMLElement;
    /**
     * Sets the default print options.
     * @example
     * WebViewer(...) .then(function(instance) {
     *   instance.UI.setDefaultPrintOptions({ includeComments: true, includeAnnotations: true });
     * });
     * @param options - The default print options of the document to print. Must be an object.
     * @param [options.includeComments] - Whether or not will print the documents with the comments
     * @param [options.includeAnnotations] - Whether or not will print the documents with the annotations
     * @param [options.maintainPageOrientation] - Whether or not will maintain the pages orientation as set in the webviewer
     */
    function setDefaultPrintOptions(options: {
        includeComments?: boolean;
        includeAnnotations?: boolean;
        maintainPageOrientation?: boolean;
    }): void;
    /**
     * @param annotation - A signature annotation found in the SignatureCreateTool saved signatures list
     * @param index - An optional parameter for the index of the annotaiton parameter within the SignatureCreateTool saved signatures list
     */
    type SignatureFilterFunction = (annotation: Core.Annotations.Annotation, index: number) => boolean;
    /**
     * Accepts a function that filters what saved signatures will be displayed in the signature annotation preset. Changing this function will instantly changes signatures displayed in the preset.
     * @example
     * Webviewer(...)
     *   .then(instance => {
     *     // Only signatures that have a value set for the 'isInitial' custom data property will display in the preset
     *     instance.UI.setDisplayedSignaturesFilter((a) => a.getCustomData('isInitial'));
     *   });
     * @param filterFunction - The function that will be used to filter signatrues displayed in the preset
     */
    function setDisplayedSignaturesFilter(filterFunction: UI.SignatureFilterFunction): void;
    /**
     * Sets the fit mode of the viewer.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     var docViewer = instance.Core.documentViewer;
     *     var FitMode = instance.UI.FitMode;
     *
     *     // you must have a document loaded when calling this api
     *     docViewer.addEventListener('documentLoaded', function() {
     *       instance.UI.setFitMode(FitMode.FitWidth);
     *     });
     *   });
     * @param fitMode - Fit mode of WebViewer.
     */
    function setFitMode(fitMode: string): void;
    /**
     * Customize header. Refer to <a href='https://www.pdftron.com/documentation/web/guides/customizing-header' target='_blank'>Customizing header</a> for details.
     * @example
     * // Adding save annotations button to the end of the top header
     * WebViewer(...)
     *   .then(function(instance) {
     *     instance.UI.setHeaderItems(function(header) {
     *       var myCustomButton = {
     *         type: 'actionButton',
     *         img: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M17 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V7l-4-4zm-5 16c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm3-10H5V5h10v4z"/></svg>',
     *         onClick: function() {
     *
     *         }
     *       }
     *
     *       header.push(myCustomButton);
     *     });
     *   });
     * @example
     * // Removing existing buttons from the top header
     * WebViewer(...)
     *   .then(function(instance) {
     *     instance.UI.setHeaderItems(function(header) {
     *       header.update([]);
     *     });
     *   });
     * @example
     * // Appending logo to the 'Annotate' toolbar group and shifting existing buttons to the right
     * WebViewer(...)
     *   .then(function(instance) {
     *     instance.UI.setHeaderItems(function(header) {
     *       header.getHeader('toolbarGroup-Annotate').unshift({
     *         type: 'customElement',
     *         render: function() {
     *           var logo = document.createElement('img');
     *           logo.src = 'https://www.pdftron.com/downloads/logo.svg';
     *           logo.style.width = '200px';
     *           logo.style.marginLeft = '10px';
     *           logo.style.cursor = 'pointer';
     *           logo.onclick = function() {
     *             window.open('https://www.pdftron.com', '_blank');
     *           }
     *           return logo;
     *         }
     *       }, {
     *         type: 'spacer'
     *       });
     *     });
     *   });
     * @example
     * // Moving the line tool from the 'Shapes' toolbar group to the 'Annotate' toolbar group
     * WebViewer(...)
     *   .then(function(instance) {
     *     instance.UI.setHeaderItems(function(header) {
     *       header.getHeader('toolbarGroup-Annotate').push({ type: 'toolGroupButton', toolGroup: 'lineTools', dataElement: 'lineToolGroupButton', title: 'annotation.line' });
     *       header.getHeader('toolbarGroup-Shapes').delete(6);
     *     });
     *   });
     * @param headerCallback - Callback function to perform different operations on the header.
     */
    function setHeaderItems(headerCallback: UI.headerCallback): void;
    /**
     * Callback that gets passed to {@link UI.setHeaderItems setHeaderItems}.
     * @param header - Header instance with helper functions
     */
    type headerCallback = (header: UI.Header) => void;
    /**
     * A class which contains header APIs.<br/><br/>
     * <span style="color: red; font-size: 1.2em; font-weight: bold"></span> You must NOT instantiate this yourself. Access the header instance in {@link UI.setHeaderItems setHeaderItems} as follows:
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     instance.UI.setHeaderItems(function(header) {
     *       // instance of Header is passed to the callback
     *     });
     *   });
     */
    class Header {
        /**
         * Select a button from header to edit.
         * @param dataElement - data-element of the button.
         * @returns Header object for chaining. You can call {@link UI.Header#insertBefore insertBefore}, {@link UI.Header#insertAfter insertAfter} and {@link UI.Header#delete delete} to perform an operation on the button.
         */
        get(dataElement: string): UI.Header;
        /**
         * Get all list of header items from a group selected from {@link UI.Header#getHeader getHeader}. By default, it returns the items from 'default' group.
         * @returns List of header item objects. You can edit it using normal array operations and update the whole header by passing it to {@link UI.Header#update update}.
         */
        getItems(): object[];
        /**
         * Select a header group to edit.
         * @param headerGroup - Name of the header group. Possible options are 'default', 'small-mobile-more-buttons', 'toolbarGroup-View', 'toolbarGroup-Annotate', 'toolbarGroup-Shapes', 'toolbarGroup-Insert', 'toolbarGroup-Measure', and 'toolbarGroup-Edit'
         * @returns Header object for chaining. You can call {@link UI.Header#get get}, {@link UI.Header#getItems getItems}, {@link UI.Header#shift shift}, {@link UI.Header#unshift unshift}, {@link UI.Header#push push}, {@link UI.Header#pop pop} and {@link UI.Header#update update}.
         */
        getHeader(headerGroup: string): UI.Header;
        /**
         * Insert a button before the selected button from {@link UI.Header#get get}.
         * @param obj - A header object. See <a href='https://www.pdftron.com/documentation/web/guides/customizing-header#header-items' target='_blank'>Header items</a> for details.
         * @returns Header object for chaining. You can call {@link UI.Header#get get}, {@link UI.Header#getItems getItems}, {@link UI.Header#shift shift}, {@link UI.Header#unshift unshift}, {@link UI.Header#push push}, {@link UI.Header#pop pop} and {@link UI.Header#update update}.
         */
        insertBefore(obj: any): UI.Header;
        /**
         * Insert a button after the selected button from {@link UI.Header#get get}.
         * @param obj - A header object. See <a href='https://www.pdftron.com/documentation/web/guides/customizing-header#header-items' target='_blank'>Header items</a> for details.
         * @returns Header object for chaining. You can call {@link UI.Header#get get}, {@link UI.Header#getItems getItems}, {@link UI.Header#shift shift}, {@link UI.Header#unshift unshift}, {@link UI.Header#push push}, {@link UI.Header#pop pop} and {@link UI.Header#update update}.
         */
        insertAfter(obj: any): UI.Header;
        /**
         * Delete a button.
         * @param [id] - You can either pass an index or `data-element` of the button to delete. If you already selected a button from {@link UI.Header#get get}, passing null would delete the selected button.
         * @returns Header object for chaining. You can call {@link UI.Header#get get}, {@link UI.Header#getItems getItems}, {@link UI.Header#shift shift}, {@link UI.Header#unshift unshift}, {@link UI.Header#push push}, {@link UI.Header#pop pop} and {@link UI.Header#update update}.
         */
        delete(id?: number | string): UI.Header;
        /**
         * Removes the first button in the header.
         * @returns Header object for chaining. You can call {@link UI.Header#get get}, {@link UI.Header#getItems getItems}, {@link UI.Header#shift shift}, {@link UI.Header#unshift unshift}, {@link UI.Header#push push}, {@link UI.Header#pop pop} and {@link UI.Header#update update}.
         */
        shift(): UI.Header;
        /**
         * Adds a button (or buttons) to the beginning of the header.
         * @param obj - Either one or array of header objects. See <a href='https://www.pdftron.com/documentation/web/guides/customizing-header#header-items' target='_blank'>Header items</a> for details.
         * @returns Header object for chaining. You can call {@link UI.Header#get get}, {@link UI.Header#getItems getItems}, {@link UI.Header#shift shift}, {@link UI.Header#unshift unshift}, {@link UI.Header#push push}, {@link UI.Header#pop pop} and {@link UI.Header#update update}.
         */
        unshift(obj: any | object[]): UI.Header;
        /**
         * Adds a button (or buttons) to the end of the header.
         * @param obj - Either one or array of header objects. See <a href='https://www.pdftron.com/documentation/web/guides/customizing-header#header-items' target='_blank'>Header items</a> for details.
         * @returns Header object for chaining. You can call {@link UI.Header#get get}, {@link UI.Header#getItems getItems}, {@link UI.Header#shift shift}, {@link UI.Header#unshift unshift}, {@link UI.Header#push push}, {@link UI.Header#pop pop} and {@link UI.Header#update update}.
         */
        push(obj: any | object[]): UI.Header;
        /**
         * Removes the last button in the header.
         * @returns Header object for chaining. You can call {@link UI.Header#get get}, {@link UI.Header#getItems getItems}, {@link UI.Header#shift shift}, {@link UI.Header#unshift unshift}, {@link UI.Header#push push}, {@link UI.Header#pop pop} and {@link UI.Header#update update}.
         */
        pop(): UI.Header;
        /**
         * Updates the header with new list of header items.
         * @param headerObjects - List of header objects to replace the exising header. You can use {@link UI.Header#getItems getItems} to refer to existing header objects.
         * @returns Header object for chaining. You can call {@link UI.Header#get get}, {@link UI.Header#getItems getItems}, {@link UI.Header#shift shift}, {@link UI.Header#unshift unshift}, {@link UI.Header#push push}, {@link UI.Header#pop pop} and {@link UI.Header#update update}.
         */
        update(headerObjects: object[]): UI.Header;
    }
    /**
     * Turns high contrast mode on or off to help with accessibility.
     * @example
     * // Using predefined string
     * WebViewer(...)
     *   .then(function(instance) {
     *     instance.UI.setHighContrastMode(true);
     *   });
     * @param useHighContrastMode - If true then the UI will use high contrast colors to help with accessibility.
     */
    function setHighContrastMode(useHighContrastMode: boolean): void;
    /**
     * Sets the color palette that will be used as a tool button's icon color.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     // sets the color in fill palette to be used as freetext tool button's icon color
     *     // by default freetext tool button will use the color in text palette as its icon color
     *     instance.UI.setIconColor('AnnotationCreateFreeText', 'fill')
     *   });
     * @param toolName - Name of the tool, either from <a href='https://www.pdftron.com/documentation/web/guides/annotations-and-tools/#list-of-tool-names' target='_blank'>tool names list</a> or the name you registered your custom tool with.
     * @param colorPalette - The palette which will be used as a tool button's icon color. One of 'text', 'border' and 'fill'.
     */
    function setIconColor(toolName: string, colorPalette: string): void;
    /**
     * Set the language of WebViewer UI.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     instance.UI.setLanguage('fr'); // set the language to French
     *   });
     * @param language - The language WebViewer UI will use. By default, following languages are supported: en, zh_cn, fr.
     */
    function setLanguage(language: string): void;
    /**
     * Sets the layout mode of the viewer.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     const docViewer = instance.Core.documentViewer;
     *     const LayoutMode = instance.UI.LayoutMode;
     *
     *     // you must have a document loaded when calling this api
     *     docViewer.addEventListener('documentLoaded', function() {
     *       instance.UI.setLayoutMode(LayoutMode.FacingContinuous);
     *     });
     *   });
     * @param layoutMode - Layout mode of WebViewerInstance UI.
     */
    function setLayoutMode(layoutMode: string): void;
    /**
     * Set the number of signatures that can be stored in the WebViewer (default is 2)
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     instance.UI.setMaxSignaturesCount(5); // allow up to 5 stored signatures
     *   });
     * @param [maxSignaturesCount = 2] - Number of signature webViewer can store
     */
    function setMaxSignaturesCount(maxSignaturesCount?: number): void;
    /**
     * Sets the maximum zoom level allowed by the UI. Default is 9999%.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     instance.UI.setMaxZoomLevel('150%'); // or setMaxZoomLevel(1.5)
     *   });
     * @param zoomLevel - Zoom level in either number or percentage.
     */
    function setMaxZoomLevel(zoomLevel: string | number): void;
    /**
     * Sets the units that will be displayed in the measurement tools' styles popup
     * Valid units are: 'mm', 'cm', 'm', 'km', 'mi', 'yd', 'ft', 'in', 'pt'
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     instance.UI.setMeasurementUnits({
     *       from: ['in', 'cm', 'm'],
     *       to: ['cm', 'm', 'km']
     *     });
     *   });
     * @param units - an object which contains the from units and to units
     */
    function setMeasurementUnits(units: any): void;
    /**
     * Sets the minimum zoom level allowed by the UI. Default is 5%.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     instance.UI.setMinZoomLevel('10%'); // or setMinZoomLevel(0.1)
     *   });
     * @param zoomLevel - Zoom level in either number or percentage.
     */
    function setMinZoomLevel(zoomLevel: string | number): void;
    /**
     * Sets the format for displaying the date when a note is create/modified. A list of formats can be found {@link https://github.com/iamkun/dayjs/blob/master/docs/en/API-reference.md#format-formatstringwithtokens-string dayjs API}.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     instance.UI.setNoteDateFormat('DD.MM.YYYY HH:MM');
     *   });
     * @param format - The format of date to display
     */
    function setNoteDateFormat(format: string): void;
    /**
     * @param wrapperElement - A reference to the DOM node that wraps the note. You can use this to query select child elements to mutate (see the examples below)
     * @param state - The state of the note. Contains two properties, 'annotation' and 'isSelected'
     * @param state.annotation - A reference to the annotation object associated with the note
     * @param state.isSelected - whether or not the note is currently expanded
     * @param createElement - A utility function that should be used when creating DOM nodes. This is a replacement for `document.createElement`.
     * Accepts the same parameters as `document.createElement`. Using document.createElement instead of this function will cause your DOM nodes to not be cleaned up on subsequent renders.
     */
    type NoteTransformFunction = (wrapperElement: HTMLElement, state: {
        annotation: Core.Annotations.Annotation;
        isSelected: boolean;
    }, createElement: (...params: any[]) => any) => void;
    /**
     * Accepts a function that will be called every time a note in the left panel is rendered.
     * This function can be used to add, edit or hide the contents of the note.
     * <br><br>
     * <span style='font-size: 18px'><b>Please carefully read the documentation and the notes below before using this API</b></span><br><br>
     *
     * <b>This API is experimental and should be used sparingly.</b> If you find you are heavily relying on this function,
     *  it is recommended that you <a href='https://www.pdftron.com/documentation/web/guides/advanced-customization/'>fork the UI repo</a> and make the changes directly in the source code (Note.js).
     * <br><br>
     *
     *
     * The structure of the HTML that is passed into this function may change may change without notice in any release. <b>Please make sure
     * to test this function thoroughly when upgrading WebViewer versions.</b>
     * <br><br>
     *
     *
     *  There may be unexpected behaviour when using this API. The HTML that is provided is controlled by React, and sometimes React will override any changes you make.
     *  If you find any unexpected behaviour when using this API, then this API probably won't work for your use case and you will have to make the changes directly in the source code.
     * <br><br>
     *
     *  <b>Do not use document.createElement to create DOM elements</b>. Instead, use the provided `createElement` utility function provided as the third parameter.
     *
     *  <b>Do not use HTMLElement.removeChild or any other APIs that remove elements from the DOM.</b> Doing so will cause React to lose reference to this node, and will crash.
     *  If you need to hide an HTML element, set the style to `display: none` instead.
     * <br><br>
     * @example
     * Webviewer(...)
     *   .then(instance => {
     *     instance.UI.dangerouslySetNoteTransformFunction((wrapper, state, createElement) => {
     *       // Change the title of every note
     *       wrapper.querySelector('.author-and-time>span').innerHTML = 'My custom note title';
     *
     *       // Add a button that alerts the user when clicked
     *       const button = createElement('button');
     *       button.onmousedown = (e) => {
     *         if(state.isSelected) {
     *           alert('Hello world!');
     *         } else {
     *           alert('Goodbye world!');
     *         }
     *       };
     *       button.innerHTML = 'Alert me'
     *       wrapper.appendChild(button);
     *
     *       // Add a button that makes the annotation blue
     *       const button = createElement('button');
     *       button.onmousedown = (e) => {
     *         state.annotation.StrokeColor = new instance.Annotations.Color(0, 0, 255);
     *         instance.UI.annotManager.redrawAnnotation(state.annotation)
     *       };
     *       button.innerHTML = 'Make me blue'
     *       wrapper.appendChild(button);
     *     })
     *   });
     * @param noteTransformFunction - The function that will be used to transform notes in the left panel
     */
    function dangerouslySetNoteTransformFunction(noteTransformFunction: UI.NoteTransformFunction): void;
    /**
     * Sets a sorting algorithm for the Notes Panel.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     const sortStrategy = instance.UI.NotesPanelSortStrategy;
     *     instance.UI.setNotesPanelSortStrategy(sortStrategy.TYPE); // sort notes by type
     *   });
     * @param sortStrategy - Name of the sort strategy algorithm. Check [UI.NotesPanelSortStrategy]{@link UI.NotesPanelSortStrategy} for the options or use your own strategy.
     */
    function setNotesPanelSortStrategy(sortStrategy: string): void;
    /**
     * Sets page labels that will be displayed in UI. You may want to use this API if the document's page labels start with characters/numbers other than 1.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     var docViewer = instance.Core.documentViewer;
     *
     *     // you must have a document loaded when calling this api
     *     docViewer.addEventListener('documentLoaded', function() {
     *       instance.UI.setPageLabels(['i', 'ii', 'iii', '4', '5']); // assume a document has 5 pages
     *     });
     *   });
     * @param pageLabels - Page labels that will be displayed in UI.
     */
    function setPageLabels(pageLabels: string[]): void;
    /**
     * Add a list of documents to the dropdown element of Page Replacement modal and provide a
     * way to retreive document for displaying Page Replacement modal.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     const list = [
     *       {id: '12', filename: 'file-one.pdf'},
     *       {id: '13', filename: 'file-two.pdf'},
     *       {id: '14', filename: 'foobar.pdf'}
     *     ];
     *
     *     const options = list.map(item => {
     *       // Add "onSelect" method to each item, and return Document instance
     *       item.onSelect = () => instance.Core.createDocument('https://localhost/files/webviewer-demo.pdf');
     *       return item;
     *     });
     *
     *     instance.UI.setPageReplacementModalFileList(options);
     *   });
     * @param list - An array of object for selection element. Object must have "id", "filename" properties and "onSelect" method.
     */
    function setPageReplacementModalFileList(list: any[]): void;
    /**
     * Sets the print quality. Higher values are higher quality but takes longer to complete and use more memory. The viewer's default quality is 1.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     instance.UI.setPrintQuality(2);
     *   });
     * @param quality - The quality of the document to print. Must be a positive number.
     */
    function setPrintQuality(quality: number): void;
    /**
     * Sets the format for displaying the date when a note is printed. A list of formats can be found {@link https://github.com/iamkun/dayjs/blob/master/docs/en/API-reference.md#format-formatstringwithtokens-string dayjs API}.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     instance.UI.setPrintedNoteDateFormat('DD.MM.YYYY HH:MM');
     *   });
     * @param format - The format of date to display
     */
    function setPrintedNoteDateFormat(format: string): void;
    /**
     * Sets the currently selected tab of a Tabs component.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     // Set the currently selected tab of 'signatureModal' to be the 'Type' panel.
     *     instance.UI.setSelectedTab('signatureModal', 'textSignaturePanelButton'); //'inkSignaturePanelButton', 'imageSignaturePanelButton'
     *     // Set the currently selected tab of 'linkModal' to be the 'Page' panel.
     *     instance.UI.setSelectedTab('linkModal', 'PageNumberPanelButton'); //'URLPanelButton'
     *     // Set the currently selected tab of 'rubberStampTab' to be the 'Custom' panel.
     *     instance.UI.setSelectedTab('rubberStampTab', 'customStampPanelButton'); //'standardStampPanelButton'
     *   });
     * @param id - The id of the Tabs component to set.
     * @param dataElement - The 'dataElement' attribute of the TabPanel component to select.
     */
    function setSelectedTab(id: string, dataElement: string): void;
    /**
     * Set the fonts that are used when typing a signature in the signature dialog.
     * @example
     * // 6.1
     * WebViewer(...)
     *   .then(function(instance) {
     *     instance.UI.setSignatureFonts(['GreatVibes-Regular']);
     *     instance.UI.setSignatureFonts(currentFonts => [
     *       ...currentFonts,
     *       'sans-serif',
     *     ]);
     *   });
     * @param fonts - An array of font families.
     */
    function setSignatureFonts(fonts: string[] | UI.setSignatureFontsCallback): void;
    /**
     * @param fonts - current font families
     */
    type setSignatureFontsCallback = (fonts: string[]) => string[];
    /**
     * Sets the swipe orientation between pages of WebViewer UI on mobile devices. Default is horizontal.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     instance.UI.setSwipeOrientation('vertical'); // set the swipe orientation to vertical.
     *   });
     * @param swipeOrientation - The swipe orientation to navigate between pages. Available orientations are: horizontal, vertical and both.
     */
    function setSwipeOrientation(swipeOrientation: string): void;
    /**
     * Sets the theme of WebViewer UI. Please note that this does not work in IE11.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     const theme = instance.UI.Theme;
     *     instance.UI.setTheme(theme.DARK);
     *   });
     * @param theme - Theme of WebViewerInstance UI.
     */
    function setTheme(theme: string): void;
    /**
     * Sets tool mode.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     instance.UI.setToolMode('AnnotationEdit');
     *   });
     * @param toolName - Name of the tool, either from <a href='https://www.pdftron.com/documentation/web/guides/annotations-and-tools/#list-of-tool-names' target='_blank'>tool names list</a> or the name you registered your custom tool with.
     */
    function setToolMode(toolName: string | Core.Tools.ToolNames): void;
    /**
     * Sets the current active toolbar group.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     // Change the toolbar group to the `Shapes` group
     *     instance.UI.setToolbarGroup('toolbarGroup-Shapes');
     * @param groupDataElement - The groups dataElement. Default values are: toolbarGroup-View, toolbarGroup-Annotate,
     * toolbarGroup-Shapes, toolbarGroup-Insert, toolbarGroup-Measure, toolbarGroup-Edit, toolbarGroup-Forms
     * @param [pickTool] - If true, after setting the toolbar group, the last picked tool for the group will be set as the current tool. Defaults to true.
     */
    function setToolbarGroup(groupDataElement: string, pickTool?: boolean): void;
    /**
     * Add/Edit translations data for a specific language
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     instance.UI.setTranslations('es',
     *     {
     *       'option.colorPalette.colorLabel': 'Etiqueta de color', //updates a pre-existing translation data
     *       'action.newButton': 'Nuevo botn' // adds a new translation data
     *     });
     *   });
     * @param language - The language code for which you want to add/edit translation data
     * @param translationObject - A key/value object with the new/updated translations
     * @param translationObject.key - A key value for the new/updated translation.
     * Refer to the lib/ui/i18n folder to find the existing keys in the translation files
     * @param translationObject.value - A value of the new/updated translation
     */
    function setTranslations(language: string, translationObject: {
        key: string;
        value: string;
    }): void;
    /**
     * Sets zoom level.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     var docViewer = instance.Core.documentViewer;
     *
     *     // you must have a document loaded when calling this api
     *     docViewer.addEventListener('documentLoaded', function() {
     *       instance.UI.setZoomLevel('150%'); // or setZoomLevel(1.5)
     *     });
     *   });
     * @param zoomLevel - Zoom level in either number or percentage.
     */
    function setZoomLevel(zoomLevel: string | number): void;
    /**
     * Displays the custom error message
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     instance.UI.showErrorMessage('My error message');
     *   });
     * @param message - An error message
     */
    function showErrorMessage(message: string): void;
    /**
     * Show outline control
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     instance.UI.showOutlineControl();
     *   });
     */
    function showOutlineControl(): void;
    /**
     * Displays the custom error message
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     instance.UI.showWarningMessage({
     *       title: 'This is my warning modal title',
     *       message: 'This is the body of my modal',
     *       confirmBtnText: 'Okay!',
     *       onConfirm: () => {
     *         console.log('The user clicked the confirm button');
     *         return Promise.resolve();
     *       },
     *       onCancel: () => {
     *         console.log('The user clicked the cancel button');
     *         return Promise.resolve();
     *       },
     *     });
     *   });
     * @param options - Warning string message to display or an object for controlling the warning popup
     * @param options.confirmBtnText - The text that will be rendered in the confirm button
     * @param options.title - The title of the modal
     * @param options.message - The text that will rendered in the body of the modal
     * @param options.onConfirm - The callback function that will be invoked when the user clicks the Confirm button. The callback must return a Promise that resolves.
     * @param options.onCancel - The callback function that will be invoked when the user clicks the Cancel button. The callback must return a Promise that resolves.
     */
    function showWarningMessage(options: {
        confirmBtnText: string;
        title: string;
        message: string;
        onConfirm: (...params: any[]) => any;
        onCancel: (...params: any[]) => any;
    }): void;
    /**
     * Syncs the namespaces under the Core namespace for the window, this instance, as well as others instances.
     * <br/><br/>
     * This is required for interoperability between multiple instances of WebViewer since each loaded instance ends up with different class references despite sharing the same name.
     * @example
     * // Loaded PDFNet directly
     * const Core = window.Core;
     * const PDFNet = Core.PDFNet;
     * Core.setWorkerPath('../../../lib/core');
     * Core.enableFullPDF();
     * ...
     * WebViewer(...)
     *   .then(function(instance) {
     *     // Force this instance to use the loaded PDFNet instead of the one loaded specific to this instance
     *     instance.UI.syncNamespaces({ PDFNet });
     *     // instance.UI.syncNamespaces({ PDFNet }, instance2, instance3);  // Alternative; instance, instance2, and instance3 will share the same PDFNet namespace.
     *     ...
     *   });
     * @param namespaces - The object containing the namespaces that will be used for all instances. This can be a WebViewer instance or an object with the namespaces inside.
     * @param [namespaces.PDFNet] - The PDFNet namespace. This is probably the most common that needs to be synced.
     * @param [namespaces.Actions] - The Actions namespace.
     * @param [namespaces.Annotations] - The Annotations namespace.
     * @param [namespaces.Math] - The Math namespace.
     * @param [namespaces.Tools] - The Tools namespace.
     * @param otherInstances - Other instances that will share the same namespaces.
     */
    function syncNamespaces(namespaces: {
        PDFNet?: any;
        Actions?: any;
        Annotations?: any;
        Math?: any;
        Tools?: any;
    }, ...otherInstances: WebViewerInstance[]): void;
    /**
     * An instance of Popup that can be used to edit items in the text popup component
     * @example
     * WebViewer(...)
     *   .then(function (instance) {
     *     instance.UI.textPopup.someAPI();
     *   });
     */
    var textPopup: UI.Popup;
    /**
     * An  instance of ThumbnailControlMenu that can be used to edit the items included in the thumbnail menu overlay
     * @example
     * WebViewer(...)
     *   .then(function (instance) {
     *     instance.UI.thumbnailControlMenu.someAPI();
     *   })
     */
    var thumbnailControlMenu: UI.ThumbnailControlMenu;
    namespace ThumbnailControlMenu {
        /**
         */
        type MenuItem = {
            /**
             * Title to be displayed for the operation
             */
            title: string;
            /**
             * path to image to be used as an icon for the operation
             */
            img: string;
            /**
             * onClick handler, which takes as a parameter an array of selected page numbers
             */
            onClick: (...params: any[]) => any;
            /**
             * Unique dataElement for this operation
             */
            dataElement: string;
        };
    }
    /**
     * A class which contains ThumbnailControlMenu APIs. <br/><br/>
     * <span style="color: red; font-size: 1.2em; font-weight: bold"></span> If you want to remove an item in the ThumbnailControlMenu, use {@link UI.disableElements disableElements}.
     */
    interface ThumbnailControlMenu {
        /**
         * Adds an array of thumbnail menu buttons to the default menu. If passed a dataElement parameter, it will
         * add the new menu buttons after this element. Otherwise, they will be appended to the start of the existing list
         * of buttons.
         * @example
         * WebViewer(...)
         *       .then(function (instance) {
         *         instance.UI.thumbnailControlMenu.add([
         *           {
         *             title: 'alertme',
         *             img: 'data:image/png;base64,...',
         *             onClick: (selectedPageNumbers) => {
         *               alert(`Selected thumbnail: ${selectedPageNumbers}`);
         *             },
         *             dataElement: 'alertMeDataElement',
         *           },
         *         ]);
         *       })
         * @param MenuItem - Array of buttons to be added, each with its individual operations. See example below.
         * @param [dataElementToInsertAfter] - An optional string that determines where in the overlay the new section will be added. If not included, the new page manipulation section will be added at the top.
         * You can call {@link UI.ThumbnailControlMenu#getItems getItems} to get existing items and their dataElements.
         * @returns The instance itself
         */
        add(MenuItem: UI.ThumbnailControlMenu.MenuItem[], dataElementToInsertAfter?: 'thumbRotateClockwise' | 'thumbDelete'): UI.ThumbnailControlMenu;
        /**
         * Update all the buttons in the ThumbnailControlMenu, essentially replacing them with
         * a new list of buttons.
         * To update an individual item, use {@link UI.updateElement updateElement}
         * @example
         * WebViewer(...)
         *       .then(function (instance) {
         *         instance.UI.thumbnailControlMenu.update([
         *           {
         *             title: 'alertme',
         *             img: 'data:image/png;base64,...',
         *             onClick: (selectedPageNumbers) => {
         *               alert(`Selected thumbnail: ${selectedPageNumbers}`);
         *             },
         *             dataElement: 'alertMeDataElement',
         *           },
         *         ]);
         *       })
         * @param MenuItem - The list of MenuItems that will be rendered in the thumbnail menu overlay. See the add documentation for an example.
         * @returns The instance of itself
         */
        update(MenuItem: UI.ThumbnailControlMenu.MenuItem[]): UI.ThumbnailControlMenu;
        /**
         * Return the array of items in the ThumbnailControlMenu.
         * @example
         * WebViewer(...)
         *       .then(function(instance) {
         *         instance.UI.ThumbnailControlMenu.getItems();
         *       });
         * @returns Current items in the ThumbnailControlMenu.
         */
        getItems(): UI.ThumbnailControlMenu.MenuItem[];
    }
    namespace ThumbnailsPanel {
        /**
         * Enable multi select in the left thumbnail panel
         * @example
         * WebViewer(...)
         *   .then(function(instance) {
         *     instance.UI.ThumbnailsPanel.enableMultiselect();
         *   });
         */
        function enableMultiselect(): void;
        /**
         * Disable multi select in the left thumbnail panel
         * @example
         * WebViewer(...)
         *   .then(function(instance) {
         *     instance.UI.ThumbnailsPanel.disableMultiselect();
         *   });
         */
        function disableMultiselect(): void;
        /**
         * Select thumbnails in the thumbnail panel. This requires the "ThumbnailMultiselect" feature to be enabled
         * @example
         * WebViewer(...)
         *   .then(function(instance) {
         *     instance.UI.enableFeatures(['ThumbnailMultiselect']);
         *
         *     const pageNumbersToSelect = [1, 2, 3];
         *     instance.UI.ThumbnailsPanel.selectPages(pageNumbersToSelect);
         *   });
         * @param pageNumbers - array of page numbers to select
         */
        function selectPages(pageNumbers: number[]): void;
        /**
         * Unselect selected thumbnails
         * @example
         * WebViewer(...)
         *   .then(function(instance) {
         *     const pageNumbersToUnselect = [1, 2];
         *     instance.UI.ThumbnailsPanel.unselectPages(pageNumbersToUnselect);
         *   });
         * @param pageNumbers - array of page numbers to unselect
         */
        function unselectPages(pageNumbers: number[]): void;
        /**
         * Get the currently selected pages
         * @example
         * WebViewer(...)
         *   .then(function(instance) {
         *     instance.UI.ThumbnailsPanel.getSelectedPageNumbers();
         *   });
         * @returns an array of select page numbers
         */
        function getSelectedPageNumbers(): number[];
        /**
         * Sets thumbnail selection mode.
         * @example
         * WebViewer(...)
         *   .then(function(instance) {
         *     instance.UI.ThumbnailsPanel.setThumbnailSelectionMode('thumbnail');
         *   });
         * @param thumbnailSelectionMode - Thumbnail selection mode to set
         * @param thumbnailSelectionMode.thumbnail - Set selection mode to use entire thumbnail to select a page
         * @param thumbnailSelectionMode.checkbox - (default) Set selection mode to use only checkbox to select a page
         */
        function setThumbnailSelectionMode(thumbnailSelectionMode: {
            thumbnail: string;
            checkbox: string;
        }): void;
    }
    /**
     * Toggles a visibility state of the element to be visible/hidden. Note that toggleElement works only for panel/overlay/popup/modal elements.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     instance.UI.toggleElement('leftPanel'); // open LeftPanel if it is closed, or vice versa
     *   });
     * @param dataElement - data-element attribute value for a DOM element. To find data-element of a DOM element, refer to <a href='https://www.pdftron.com/documentation/web/guides/hiding-elements/#finding-dataelement-attribute-values' target='_blank'>Finding data-element attribute values</a>.
     */
    function toggleElement(dataElement: string): void;
    /**
     * Toggles the visibility of the element to be visible/hidden. Note that toggleElementVisibility works only for panel/overlay/popup/modal elements.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     instance.UI.toggleElementVisibility('leftPanel'); // open LeftPanel if it is closed, or vice versa
     *   });
     * @param dataElement - data-element attribute value for a DOM element. To find data-element of a DOM element, refer to <a href='https://www.pdftron.com/documentation/web/guides/hiding-elements/#finding-dataelement-attribute-values' target='_blank'>Finding data-element attribute values</a>.
     */
    function toggleElementVisibility(dataElement: string): void;
    /**
     * Toggles full scree mode of the browser.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     instance.UI.toggleFullScreen();
     *   });
     */
    function toggleFullScreen(): void;
    /**
     * Toggles Reader mode of the viewer.
     * Note that Reader mode only works with fullAPI enabled.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     instance.UI.toggleReaderMode();
     *   });
     */
    function toggleReaderMode(): void;
    /**
     * Enables syncing of annotation style updates to the associated tool that created the annotation.
     * Note that this is enabled by default.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     instance.UI.enableToolDefaultStyleUpdateFromAnnotationPopup();
     *   });
     */
    function enableToolDefaultStyleUpdateFromAnnotationPopup(): void;
    /**
     * Disables syncing of annotation style updates to the associated tool that created the annotation.
     * So if an annotation's style is changed the tool default styles will not be updated.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     instance.UI.disableToolDefaultStyleUpdateFromAnnotationPopup();
     *   });
     */
    function disableToolDefaultStyleUpdateFromAnnotationPopup(): void;
    /**
     * Unregisters tool in the document viewer tool mode map, and removes the button object.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     instance.UI.unregisterTool('MyTool');
     *   });
     * @param toolName - Name of the tool, either from <a href='https://www.pdftron.com/documentation/web/guides/annotations-and-tools/#list-of-tool-names' target='_blank'>tool names list</a> or the name you registered your custom tool with.
     */
    function unregisterTool(toolName: string): void;
    /**
     * Unselect selected thumbnails
     * @example
     * // 6.1 and after
     * WebViewer(...)
     *   .then(function(instance) {
     *     const pageNumbersToUnselect = [1, 2];
     *     instance.UI.unselectThumbnailPages(pageNumbersToUnselect);
     *   });
     * @param pageNumbers - array of page numbers to unselect
     */
    function unselectThumbnailPages(pageNumbers: number[]): void;
    /**
     * Update an element in the viewer.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     instance.UI.updateElement('thumbnailsPanelButton', {
     *       img: 'path/to/image',
     *       title: 'new_tooltip',
     *     })
     *   });
     * @param dataElement - the data element of the element that will be updated. Only the data element of HTML elements that have 'Button' in the class name will work.
     * @param props - An object that is used to override an existing item's properties.
     */
    function updateElement(dataElement: string, props: any): void;
    /**
     * Update existing tool's properties.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     instance.UI.updateTool('AnnotationCreateSticky', {
     *       buttonImage: 'https://www.pdftron.com/favicon-32x32.png'
     *     });
     *   });
     * @param toolName - Name of the tool, either from <a href='https://www.pdftron.com/documentation/web/guides/annotations-and-tools/#list-of-tool-names' target='_blank'>tool names list</a> or the name you registered your custom tool with.
     * @param [properties] - Tool properties
     * @param [properties.buttonImage] - Path to an image or base64 data for the tool button
     * @param [properties.buttonName] - Name of the tool button that will be used in data-element
     * @param [properties.buttonGroup] - Group of the tool button belongs to
     * @param [properties.tooltip] - Tooltip of the tool button
     */
    function updateTool(toolName: string, properties?: {
        buttonImage?: string;
        buttonName?: string;
        buttonGroup?: string;
        tooltip?: string;
    }): void;
    /**
     * Use/not use embedded printing. Only applicable to Chrome.
     * The printing process will be faster and the quality might be higher when using Chrome's native printing.
     * You may not want to use embedded printing if there are custom annotations in your document.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     instance.UI.useEmbeddedPrint(false); // disable embedded printing
     *   });
     * @param [use = true] - Whether or not to use embedded printing
     */
    function useEmbeddedPrint(use?: boolean): void;
    /**
     * NOTE: Digital Signature Verification requires the WebViewer Full API
     */
    namespace VerificationOptions {
        /**
         * Loads the Public Key Certificates to be used for Digital Signature
         * Verification.
         *
         * The contents of the X.509 Public Key Certificate need to encoded in a binary
         * Distinguished Encoding Rules (DER) format, or in the plaintext
         * Privacy-Enhanced Mail (PEM) format, which includes an appropriate header,
         * Base64 encoded DER representing the public key certificate, and appropriate
         * footer.
         * @example
         * WebViewer(...).then(async function(instance) {
         *   const response = await fetch(
         *     'https://mydomain.com/api/returns/certificate/as/arraybuffer'
         *   );
         *   const certificateAsArrayBuffer = await response.arrayBuffer();
         *   instance.UI.VerificationOptions.addTrustedCertificates([
         *      certificateAsArrayBuffer,
         *     'https://mydomain.com/path/to/certificate1.cer',
         *     'https://mydomain.com/path/to/certificate2.crt',
         *   ])
         * });
         * @param certificates - An array of URLs, and/or instance of the File type, and/or
         * a Binary Array datatype that contain the X.509 Public Key Certificates to be
         * used for validating Digital Signatures on a document.
         */
        function addTrustedCertificates(certificates: (string | File | ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray)[]): void;
        /**
         * Loads a Trust List to be used for Digital Signature Verification.
         *
         * The Trust List is structured in Acrobat's FDF Data/Cert Exchange format into
         * the VerificationOptions certificate store.
         *
         * Certificates inside the FDF trust list that cannot be decoded and loaded,
         * will be skipped.
         * @example
         * WebViewer(...).then(async function(instance) {
         *   const response = await fetch(
         *     'https://mydomain.com/api/returns/trustList/'
         *   );
         *   const trustListAsArrayBuffer = await response.arrayBuffer();
         *   instance.UI.VerificationOptions.loadTrustList(trustListAsArrayBuffer);
         * });
         * @param TrustList - A buffer representation of FDF Certificate Exchange Data
         */
        function loadTrustList(TrustList: Blob | ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray): void;
    }
    /**
     * Returns whether Webviewer will use/not use embedded printing.
     * Will return false if the browser doesn't support embedded printing or if UI.useEmbeddedPrint is set to false.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     instance.UI.willUseEmbeddedPrinting(); // Returns true/false if embedded printing is supported and enabled
     *   });
     */
    function willUseEmbeddedPrinting(): void;
    /**
     * Contains string enums for WebViewer UI events.
     * @example
     * WebViewer(...).then(function(instance) {
     *     const UIEvents = instance.UI.Events;
     *     instance.UI.addEventListener(UIEvents.ANNOTATION_FILTER_CHANGED, e => {
     *       const { types, authors, colors } = e.detail;
     *       console.log(types, authors, colors);
     *     });
     *   });
     * @property ANNOTATION_FILTER_CHANGED - {@link UI#event:annotationFilterChanged UI.Events.annotationFilterChanged}
     * @property DOCUMENT_LOADED - {@link UI#event:documentLoaded UI.Events.documentLoaded}
     * @property DOCUMENT_MERGED - {@link UI#event:documentMerged UI.Events.documentMerged}
     * @property FILE_DOWNLOADED - {@link UI#event:fileDownloaded UI.Events.fileDownloaded}
     * @property FINISHED_SAVING_PDF - {@link UI#event:finishedSavingPDF UI.Events.finishedSavingPDF}
     * @property LOAD_ERROR - {@link UI#event:loaderror UI.Events.loaderror}
     * @property DRAG_OUTLINE - {@link UI#event:dragOutline UI.Events.dragOutline}
     * @property DROP_OUTLINE - {@link UI#event:dragOutline UI.Events.dragOutline}
     * @property PANEL_RESIZED - {@link UI#event:panelResized UI.Events.panelResized}
     * @property THEME_CHANGED - {@link UI#event:themeChanged UI.Events.themeChanged}
     * @property TOOLBAR_GROUP_CHANGED - {@link UI#event:toolbarGroupChanged UI.Events.toolbarGroupChanged}
     * @property SELECTED_THUMBNAIL_CHANGED - {@link UI#event:selectedThumbnailChanged UI.Events.selectedThumbnailChanged}
     * @property THUMBNAIL_DRAGGED - {@link UI#event:thumbnailDragged UI.Events.thumbnailDragged}
     * @property THUMBNAIL_DROPPED - {@link UI#event:thumbnailDropped UI.Events.thumbnailDropped}
     * @property USER_BOOKMARKS_CHANGED - {@link UI#event:userBookmarksChanged UI.Events.userBookmarksChanged}
     * @property OUTLINE_BOOKMARKS_CHANGED - {@link UI#event:outlineBookmarksChanged UI.Events.outlineBookmarksChanged}
     * @property VIEWER_LOADED - {@link UI#event:viewerLoaded UI.Events.viewerLoaded}
     * @property VISIBILITY_CHANGED - {@link UI#event:visibilityChanged UI.Events.visibilityChanged}
     * @property FULLSCREEN_MODE_TOGGLED - {@link UI#event:fullscreenModeToggled UI.Events.fullscreenModeToggled}
     * @property BEFORE_TAB_CHANGED - {@link UI#event:beforeTabChanged UI.Events.beforeTabChanged}
     * @property TAB_DELETED - {@link UI#event:tabDeleted UI.Events.tabDeleted}
     * @property TAB_ADDED - {@link UI#event:tabAdded UI.Events.tabAdded}
     * @property TAB_MOVED - {@link UI#event:tabMoved UI.Events.tabMoved}
     */
    var Events: {
        /**
         * {@link UI#event:annotationFilterChanged UI.Events.annotationFilterChanged}
         */
        ANNOTATION_FILTER_CHANGED: string;
        /**
         * {@link UI#event:documentLoaded UI.Events.documentLoaded}
         */
        DOCUMENT_LOADED: string;
        /**
         * {@link UI#event:documentMerged UI.Events.documentMerged}
         */
        DOCUMENT_MERGED: string;
        /**
         * {@link UI#event:fileDownloaded UI.Events.fileDownloaded}
         */
        FILE_DOWNLOADED: string;
        /**
         * {@link UI#event:finishedSavingPDF UI.Events.finishedSavingPDF}
         */
        FINISHED_SAVING_PDF: string;
        /**
         * {@link UI#event:loaderror UI.Events.loaderror}
         */
        LOAD_ERROR: string;
        /**
         * {@link UI#event:dragOutline UI.Events.dragOutline}
         */
        DRAG_OUTLINE: string;
        /**
         * {@link UI#event:dragOutline UI.Events.dragOutline}
         */
        DROP_OUTLINE: string;
        /**
         * {@link UI#event:panelResized UI.Events.panelResized}
         */
        PANEL_RESIZED: string;
        /**
         * {@link UI#event:themeChanged UI.Events.themeChanged}
         */
        THEME_CHANGED: string;
        /**
         * {@link UI#event:toolbarGroupChanged UI.Events.toolbarGroupChanged}
         */
        TOOLBAR_GROUP_CHANGED: string;
        /**
         * {@link UI#event:selectedThumbnailChanged UI.Events.selectedThumbnailChanged}
         */
        SELECTED_THUMBNAIL_CHANGED: string;
        /**
         * {@link UI#event:thumbnailDragged UI.Events.thumbnailDragged}
         */
        THUMBNAIL_DRAGGED: string;
        /**
         * {@link UI#event:thumbnailDropped UI.Events.thumbnailDropped}
         */
        THUMBNAIL_DROPPED: string;
        /**
         * {@link UI#event:userBookmarksChanged UI.Events.userBookmarksChanged}
         */
        USER_BOOKMARKS_CHANGED: string;
        /**
         * {@link UI#event:outlineBookmarksChanged UI.Events.outlineBookmarksChanged}
         */
        OUTLINE_BOOKMARKS_CHANGED: string;
        /**
         * {@link UI#event:viewerLoaded UI.Events.viewerLoaded}
         */
        VIEWER_LOADED: string;
        /**
         * {@link UI#event:visibilityChanged UI.Events.visibilityChanged}
         */
        VISIBILITY_CHANGED: string;
        /**
         * {@link UI#event:fullscreenModeToggled UI.Events.fullscreenModeToggled}
         */
        FULLSCREEN_MODE_TOGGLED: string;
        /**
         * {@link UI#event:beforeTabChanged UI.Events.beforeTabChanged}
         */
        BEFORE_TAB_CHANGED: string;
        /**
         * {@link UI#event:tabDeleted UI.Events.tabDeleted}
         */
        TAB_DELETED: string;
        /**
         * {@link UI#event:tabAdded UI.Events.tabAdded}
         */
        TAB_ADDED: string;
        /**
         * {@link UI#event:tabMoved UI.Events.tabMoved}
         */
        TAB_MOVED: string;
    };
    /**
     * Contains string enums for all features for WebViewer UI
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     var Feature = instance.UI.Feature;
     *     instance.UI.enableFeatures([Feature.Measurement]);
     *     instance.UI.disableFeatures([Feature.Copy]);
     *   });
     * @property Measurement - Measurement tools that can create annotations to measure distance, perimeter and area.
     * @property Ribbons - A collection of toolbar groups to switch between.
     * @property Annotations - Render annotations in the document and be able to edit them.
     * @property Download - A download button to download the current document.
     * @property FilePicker - Ctrl/Cmd + O hotkey and a open file button that can be clicked to load local files.
     * @property LocalStorage - Store and retrieve tool styles from window.localStorage.
     * @property NotesPanel - A panel that displays information of listable annotations.
     * @property Print - Ctrl/Cmd + P hotkey and a print button that can be clicked to print the current document.
     * @property Redaction - Redaction tools that can redact text or areas. Need fullAPI to be on to use this feature.
     * @property TextSelection - Ability to select text in a document.
     * @property TouchScrollLock - Lock document scrolling in one direction in mobile devices.
     * @property Copy - Ability to copy text or annotations use Ctrl/Cmd + C hotkeys or the copy button.
     * @property MultipleViewerMerging - Ability to drag and drop pages from one instance of WebViewer into another
     * @property ThumbnailMerging - Ability to drag and drop a file into the thumbnail panel to merge
     * @property ThumbnailReordering - Ability to reorder pages using the thumbnail panel
     * @property PageNavigation - Ability to navigate through pages using mouse wheel, arrow up/down keys and the swipe gesture.
     * @property MouseWheelZoom - Ability to zoom when holding ctrl/cmd + mouse wheel.
     * @property Search - Ctrl/Cmd + F hotkey and a search button that can be clicked to search the current document.
     * @property MathSymbols - Ability to add math symbols in free text editor
     * @property OutlineEditing - Ability to add, move and delete outlines in the outlines panel. This feature is only available when `fullAPI: true` is used.
     * @property NotesPanelVirtualizedList - Ability to use a virtualized list in the note panel. Will limit the number of notes rendered on the DOM
     * @property NotesShowLastUpdatedDate - Show last updated date in notes panel instead of created date
     * @property MultiTab - toggle feature to open multiple documents in the same viewer instance
     */
    var Feature: {
        /**
         * Measurement tools that can create annotations to measure distance, perimeter and area.
         */
        Measurement: string;
        /**
         * A collection of toolbar groups to switch between.
         */
        Ribbons: string;
        /**
         * Render annotations in the document and be able to edit them.
         */
        Annotations: string;
        /**
         * A download button to download the current document.
         */
        Download: string;
        /**
         * Ctrl/Cmd + O hotkey and a open file button that can be clicked to load local files.
         */
        FilePicker: string;
        /**
         * Store and retrieve tool styles from window.localStorage.
         */
        LocalStorage: string;
        /**
         * A panel that displays information of listable annotations.
         */
        NotesPanel: string;
        /**
         * Ctrl/Cmd + P hotkey and a print button that can be clicked to print the current document.
         */
        Print: string;
        /**
         * Redaction tools that can redact text or areas. Need fullAPI to be on to use this feature.
         */
        Redaction: string;
        /**
         * Ability to select text in a document.
         */
        TextSelection: string;
        /**
         * Lock document scrolling in one direction in mobile devices.
         */
        TouchScrollLock: string;
        /**
         * Ability to copy text or annotations use Ctrl/Cmd + C hotkeys or the copy button.
         */
        Copy: string;
        /**
         * Ability to drag and drop pages from one instance of WebViewer into another
         */
        MultipleViewerMerging: string;
        /**
         * Ability to drag and drop a file into the thumbnail panel to merge
         */
        ThumbnailMerging: string;
        /**
         * Ability to reorder pages using the thumbnail panel
         */
        ThumbnailReordering: string;
        /**
         * Ability to navigate through pages using mouse wheel, arrow up/down keys and the swipe gesture.
         */
        PageNavigation: string;
        /**
         * Ability to zoom when holding ctrl/cmd + mouse wheel.
         */
        MouseWheelZoom: string;
        /**
         * Ctrl/Cmd + F hotkey and a search button that can be clicked to search the current document.
         */
        Search: string;
        /**
         * Ability to add math symbols in free text editor
         */
        MathSymbols: string;
        /**
         * Ability to add, move and delete outlines in the outlines panel. This feature is only available when `fullAPI: true` is used.
         */
        OutlineEditing: string;
        /**
         * Ability to use a virtualized list in the note panel. Will limit the number of notes rendered on the DOM
         */
        NotesPanelVirtualizedList: string;
        /**
         * Show last updated date in notes panel instead of created date
         */
        NotesShowLastUpdatedDate: string;
        /**
         * toggle feature to open multiple documents in the same viewer instance
         */
        MultiTab: string;
    };
    /**
     * Contains all possible modes for fitting/zooming pages to the viewer. The behavior may vary depending on the LayoutMode.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     var FitMode = instance.UI.FitMode;
     *     instance.UI.setFitMode(FitMode.FitWidth);
     *   });
     * @property FitPage - A fit mode where the zoom level is fixed to the width or height of the page, whichever is smaller.
     * @property FitWidth - A fit mode where the zoom level is fixed to the width of the page.
     * @property Zoom - A fit mode where the zoom level is not fixed.
     */
    var FitMode: {
        /**
         * A fit mode where the zoom level is fixed to the width or height of the page, whichever is smaller.
         */
        FitPage: string;
        /**
         * A fit mode where the zoom level is fixed to the width of the page.
         */
        FitWidth: string;
        /**
         * A fit mode where the zoom level is not fixed.
         */
        Zoom: string;
    };
    /**
     * Contains string enums for all layouts for WebViewer. They are used to dictate how pages are placed within the viewer.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     const LayoutMode = instance.UI.LayoutMode;
     *     instance.UI.setLayoutMode(LayoutMode.Single);
     *   });
     * @property Single - Only the current page will be visible.
     * @property Continuous - All pages are visible in one column.
     * @property Facing - Up to two pages will be visible.
     * @property FacingContinuous - All pages visible in two columns.
     * @property FacingCover - All pages visible in two columns, with an even numbered page rendered first. (i.e. The first page of the document is rendered by itself on the right side of the viewer to simulate a book cover.)
     * @property FacingCoverContinuous - All pages visible, with an even numbered page rendered first. (i.e. The first page of the document is rendered by itself on the right side of the viewer to simulate a book cover.)
     */
    var LayoutMode: {
        /**
         * Only the current page will be visible.
         */
        Single: string;
        /**
         * All pages are visible in one column.
         */
        Continuous: string;
        /**
         * Up to two pages will be visible.
         */
        Facing: string;
        /**
         * All pages visible in two columns.
         */
        FacingContinuous: string;
        /**
         * All pages visible in two columns, with an even numbered page rendered first. (i.e. The first page of the document is rendered by itself on the right side of the viewer to simulate a book cover.)
         */
        FacingCover: string;
        /**
         * All pages visible, with an even numbered page rendered first. (i.e. The first page of the document is rendered by itself on the right side of the viewer to simulate a book cover.)
         */
        FacingCoverContinuous: string;
    };
    /**
     * Available search patterns that can be passed to {@link UI.replaceRedactionSearchPattern UI.replaceRedactionSearchPattern}. <br/><br/>
     */
    enum RedactionSearchPatterns {
        EMAILS,
        CREDIT_CARDS,
        PHONE_NUMBERS
    }
    /**
     * Contains string enums for all the possible sorting algorithms available in NotesPanel.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     const sortStrategy = instance.UI.NotesPanelSortStrategy;
     *     instance.UI.setNotesPanelSortStrategy(sortStrategy.AUTHOR);
     *   });
     * @property POSITION - Sort notes by position.
     * @property CREATED_DATE - Sort notes by creation date.
     * @property MODIFIED_DATE - Sort notes by last modification date.
     * @property STATUS - Sort notes by status.
     * @property AUTHOR - Sort notes by the author.
     * @property TYPE - Sort notes by type.
     * @property COLOR - Sort notes by color.
     */
    var NotesPanelSortStrategy: {
        /**
         * Sort notes by position.
         */
        POSITION: string;
        /**
         * Sort notes by creation date.
         */
        CREATED_DATE: string;
        /**
         * Sort notes by last modification date.
         */
        MODIFIED_DATE: string;
        /**
         * Sort notes by status.
         */
        STATUS: string;
        /**
         * Sort notes by the author.
         */
        AUTHOR: string;
        /**
         * Sort notes by type.
         */
        TYPE: string;
        /**
         * Sort notes by color.
         */
        COLOR: string;
    };
    /**
     * Contains string enumeration for all themes for WebViewer. They are used to set the viewer theme.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     const theme = instance.UI.Theme;
     *     instance.UI.setTheme(theme.DARK);
     *   });
     */
    type Theme = {
        /**
         * The theme where the WebViewer will be dark.
         */
        DARK: string;
        /**
         * The theme where the WebViewer will be light.
         */
        LIGHT: string;
    };
    /**
     * Contains string enums for all toolbar options for WebViewer.
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     instance.UI.setToolbarGroup(instance.UI.ToolbarGroup.VIEW);
     *   });
     * @property VIEW - Sets the current toolbar as the view group.
     * @property ANNOTATE - Sets the current toolbar as the annotate group.
     * @property SHAPES - Sets the current toolbar as the shapes group.
     * @property INSERT - Sets the current toolbar as the insert group.
     * @property MEASURE - Sets the current toolbar as the measure group.
     * @property EDIT - Sets the current toolbar as the edit group.
     * @property FILL_AND_SIGN - Sets the current toolbar as the fill and sign group.
     * @property FORMS - Sets the current toolbar as the forms group.
     */
    var ToolbarGroup: {
        /**
         * Sets the current toolbar as the view group.
         */
        VIEW: string;
        /**
         * Sets the current toolbar as the annotate group.
         */
        ANNOTATE: string;
        /**
         * Sets the current toolbar as the shapes group.
         */
        SHAPES: string;
        /**
         * Sets the current toolbar as the insert group.
         */
        INSERT: string;
        /**
         * Sets the current toolbar as the measure group.
         */
        MEASURE: string;
        /**
         * Sets the current toolbar as the edit group.
         */
        EDIT: string;
        /**
         * Sets the current toolbar as the fill and sign group.
         */
        FILL_AND_SIGN: string;
        /**
         * Sets the current toolbar as the forms group.
         */
        FORMS: string;
    };
    namespace MentionsManager {
        /**
         */
        type Mention = {
            /**
             * The email of the mentioned person. This is passed from setUserData.
             */
            email: string;
            /**
             * The value(display name) of the mentioned person. This is passed from setUserData.
             */
            value: string;
            /**
             * The type of the mentioned person. This is passed from setUserData.
             */
            type: string;
            /**
             * The id of the mentioned person. This is passed from setUserData.
             */
            id: string;
            /**
             * The id of the annotation in which the contents contain the mentions.
             */
            annotId: string;
        };
        /**
         */
        type UserData = {
            [key: string]: string;
        };
    }
    class MentionsManager extends Core.EventHandler {
        /**
         * Sets the user data that will be displayed in the suggestions overlay when an @ is entered in the textarea.
         * @example
         * WebViewer(...)
         *   .then(function(instance) {
         *     instance.mentions.setUserData([
         *       {
         *         value: 'John Doe',
         *       },
         *       {
         *         value: 'Jane Doe',
         *         email: 'jDoe@gmail.com'
         *       }
         *     ]);
         *   });
         * @param userData - An array of user data
         */
        setUserData(userData: UI.MentionsManager.UserData[]): void;
        /**
         * Gets the user data
         * @returns An array of user data
         */
        getUserData(): UI.MentionsManager.UserData[];
        /**
         * Sets the characters that can follow a mention, while not invalidating it
         * By default, a mention can only be followed by a space, or is located at the end of the string
         * @example
         * WebViewer(...)
         *   .then(function(instance) {
         *     instance.mentions.setUserData([
         *       {
         *         value: 'John Doe',
         *       },
         *     ]);
         *      // this is considered as a mention, because `@John Doe` is at the end of the string
         *     'Hello, @John Doe'
         *      // this is considered as a mention, because `@John Doe` is followed by a space
         *     'Hello, @John Doe How are you?'
         *      // this is NOT considered as a mention, because `@John Doe` is followed by a comma
         *     '@John Doe, Hello!'
         *      instance.mentions.setAllowedTrailingCharacters([' ', ',']);
         *      // this is now considered as a mention, because comma is an allowed trailing character
         *     '@John Doe, Hello!'
         *   });
         * @param chars - An array of characters. If `*` is passed, then a mention can be followed by any characters
         */
        setAllowedTrailingCharacters(chars: string[] | '*'): void;
        /**
         * Gets the allowed trailing characters
         * @returns An array of trailing characters, or '*'
         */
        getAllowedTrailingCharacters(): string[] | '*';
        /**
         * Triggered when a mention or mentions have been changed (added, deleted, modified).
         * Attach like instance.mentions.on('mentionChanged', callback)
         * @param mentions - The mentions that were changed
         * @param action - The action that occurred (add, delete, modify)
         */
        on(event: 'mentionChanged', callback: (mentions: UI.MentionsManager.Mention, action: 'add' | 'modify' | 'delete') => void): void;
        /**
         * Triggered when a mention or mentions have been changed (added, deleted, modified).
         * Attach like instance.mentions.on('mentionChanged', callback)
         * @param mentions - The mentions that were changed
         * @param action - The action that occurred (add, delete, modify)
         */
        one(event: 'mentionChanged', callback: (mentions: UI.MentionsManager.Mention, action: 'add' | 'modify' | 'delete') => void): void;
        off(event?: 'mentionChanged', callback?: (mentions: UI.MentionsManager.Mention, action: 'add' | 'modify' | 'delete') => void): void;
    }
    /**
     * A class which contains popup APIs.<br/><br/>
     * <span style="color: red; font-size: 1.2em; font-weight: bold"></span> If you want to remove an item in a popup, use {@link WebViewerInstance#disableElements disableElements}.
     */
    interface Popup {
        /**
         * Add an array of items after the item that has the given data element.
         * @example
         * WebViewer(...)
         *   .then(function(instance) {
         *     instance.contextMenuPopup.add({
         *       type: 'actionButton',
         *       img: 'path/to/image',
         *       onClick: instance.downloadPdf,
         *     });
         *   });
         * @param items - Same as <a href='https://www.pdftron.com/documentation/web/guides/customizing-header#header-items' target='_blank'>header items</a>
         * @param [dataElement] - An optional string. If not given, items will be added in the beginning
         * @returns The instance itself
         */
        add(items: object[], dataElement?: string): this;
        /**
         * Update all the items in the popup.
         * To update an individual item, use {@link UI.updateElement updateElement}
         * @example
         * WebViewer(...)
         *   .then(function(instance) {
         *     // replace existing items with a new array of items
         *     instance.contextMenuPopup.update([
         *       {
         *         type: 'actionButton',
         *         img: 'path/to/image',
         *         onClick: instance.downloadPdf,
         *       },
         *       {
         *         type: 'actionButton',
         *         img: 'path/to/image',
         *         onClick: instance.print,
         *       },
         *     ]);
         *   });
         * @param [items] - the items that will be rendered in the popup
         * @returns The instance itself
         */
        update(items?: object[]): this;
        /**
         * Return the array of items in the popup.
         * @example
         * WebViewer(...)
         *   .then(function(instance) {
         *     instance.annotationPopup.getItems();
         *   });
         * @returns Current items in the popup.
         */
        getItems(): object[];
    }
    /**
     * A class which contains hotkeys APIs.<br/><br/>
     * <span style="color: red; font-size: 1.2em; font-weight: bold"></span> You must NOT instantiate this yourself. Access instances of this class using {@link UI.hotkeys instance.UI.hotkeys}
     */
    namespace Hotkeys {
        /**
         * Available hotkeys that can be passed to {@link UI.Hotkeys#on instance.UI.hotkeys.on} or {@link UI.Hotkeys#off instance.UI.hotkeys.off}. <br/><br/>
         */
        enum Keys {
            CTRL_SHIFT_EQUAL,
            COMMAND_SHIFT_EQUAL,
            CTRL_SHIFT_MINUS,
            COMMAND_SHIFT_MINUS,
            CTRL_C,
            COMMAND_C,
            CTRL_V,
            COMMAND_V,
            CTRL_Z,
            COMMAND_Z,
            CTRL_Y,
            COMMAND_SHIFT_Z,
            CTRL_O,
            COMMAND_O,
            CTRL_F,
            COMMAND_F,
            CTRL_EQUAL,
            COMMAND_EQUAL,
            CTRL_MINUS,
            COMMAND_MINUS,
            CTRL_0,
            COMMAND_0,
            CTRL_P,
            COMMAND_P,
            PAGE_UP,
            PAGE_DOWN,
            UP,
            DOWN,
            SPACE,
            ESCAPE,
            P,
            A,
            C,
            E,
            F,
            I,
            L,
            N,
            O,
            R,
            T,
            S,
            G,
            H,
            K,
            U
        }
        /**
         * Add an event handler for the given hotkey
         * @example
         * WebViewer(...)
         *   .then(function(instance) {
         *     const { UI } = instance;
         *       // this will register the default zoom in handler
         *       UI.hotkeys.on(UI.hotkeys.Keys.CTRL_EQUAL);
         *       UI.hotkeys.on(UI.hotkeys.Keys.COMMAND_EQUAL);
         *        // this will be called on keydown
         *       UI.hotkeys.on('ctrl+d, command+d', e => {
         *         e.preventDefault();
         *         instance.Core.documentViewer.closeDocument();
         *       });
         *        UI.hotkeys.on('ctrl+g', {
         *         keydown: e => {
         *           console.log('ctrl+g is pressed!');
         *         },
         *         keyup: e => {
         *           console.log('ctrl+g is released!')
         *         },
         *       });
         *   });
         * @param key - A keyboard key <br/>
         * If a hotkey is consisted of more than one key. Those keys should be connected using '+'.
         * @param [handler] - An optional argument <br/>
         * If it is undefined, the default handler of the given key will be registered <br/>
         * If it is an function, it will be called on key down <br/>
         * If it is an object, it should have the shape of { keydown: func1, keyup: func2 }. Func1 will be called on keydown while func2 will be called on keyup
         */
        function on(key: string | UI.Hotkeys.Keys, handler?: ((...params: any[]) => any) | any): void;
        /**
         * Remove an event handler for the given hotkey
         * @example
         * WebViewer(...)
         *   .then(function(instance) {
         *       // this will remove all handlers for ctrl = and command =
         *       instance.UI.hotkeys.off(instance.UI.hotkeys.Keys.CTRL_EQUAL);
         *       instance.UI.hotkeys.off(instance.UI.hotkeys.Keys.COMMAND_EQUAL);
         *   });
         * @param [key] - An optional keyboard key. If not passed, all handlers will be removed
         * @param [handler] - An optional function. If not passed, all handlers of the given key will be removed
         */
        function off(key?: string | UI.Hotkeys.Keys, handler?: (...params: any[]) => any): void;
    }
    /**
     * Cleans up listeners and data from the WebViewer instance. Should be called when removing the WebViewer instance from the DOM.
     * @example
     * webViewerInstance.UI.dispose()
     */
    function dispose(): void;
    /**
     * WebViewer iframe window object
     * @example
     * WebViewer(...)
     *   .then(function(instance) {
     *     const iframeWindow = instance.UI.iframeWindow;
     *     // iframeWindow.SomeNamespace
     *     // iframeWindow.document.querySelector('.some-element');
     *   });
     */
    var iframeWindow: Window;
}

/**
 * A single instance of webviewer. Can be retrieved from the
 * global WebViewer function.
 *
 * This class is not instantiable.
 */
declare class WebViewerInstance {
    /**
     * Core namespace on WebViewer instance
     * @example
     * WebViewer({...options}, document.getElementById('viewer'))
     *  .then(webviewerInstance => {
     *    webViewerInstance.Core
     *  })
     */
    Core: typeof Core;
    /**
     * UI namespace on WebViewer instance
     * @example
     * WebViewer({...options}, document.getElementById('viewer'))
     *  .then(webviewerInstance => {
     *    webViewerInstance.UI
     *  })
     */
    UI: typeof UI;
}

/**
 * @param [options.fallbackToClientSide] - A boolean indicating whether to fall back to client side rendering when WebViewer server fails
 */
declare type WebViewerOptions = {
    /**
     * Path to the WebViewer lib folder
     */
    path: string;
    /**
     * Name of the user for annotations
     * @defaultValue Guest
     */
    annotationUser?: string;
    /**
     * URL path to a custom JavaScript for customizations
     */
    config?: string;
    /**
     * A serialized data object that will be passed into the iframe. The data can be accessed in the config file after deserializing. https://www.pdftron.com/documentation/web/guides/config-files/#passing-custom-data
     */
    custom?: string;
    /**
     * URL path to a custom CSS file for customizations
     */
    css?: string;
    /**
     * List of data-elements to be disabled in UI
     */
    disabledElements?: string[];
    /**
     * Enables auto focus of input in notes panel on selection of annotation
     * @defaultValue true
     */
    autoFocusNoteOnAnnotationSelection?: boolean;
    /**
     * Enable accessibility features. E.g tab page selection and page text in the DOM
     */
    accessibleMode?: boolean;
    /**
     * Enable annotations feature
     * @defaultValue true
     */
    enableAnnotations?: boolean;
    /**
     * Enable workaround of the issue in Azure related to range requests
     */
    enableAzureWorkaround?: boolean;
    /**
     * If true, WebViewer will use optimized workers if possible. Otherwise, it will use regular workers
     * @defaultValue true
     */
    enableOptimizedWorkers?: boolean;
    /**
     * Enable file picker feature
     */
    enableFilePicker?: boolean;
    /**
     * Enable measurement tools
     */
    enableMeasurement?: boolean;
    /**
     * Enable redaction tool
     */
    enableRedaction?: boolean;
    /**
     * Disable virtual display mode for pages. The virtual display mode allows documents with many pages to be loaded efficiently in continuous scrolling mode. If disabled then single page mode will be used for documents with many pages.
     */
    disableVirtualDisplayMode?: boolean;
    /**
     * Extension of the document to be loaded. **Multi-tab** must be an array of documents ex: Webviewer({ initialDoc: ['pdf_doc', 'word_doc'], extension: ['pdf', 'docx'] }) OR Webviewer({ initialDoc: ['pdf_doc1', 'pdf_doc2'], extension: ['pdf'] })
     */
    extension?: string | string[];
    /**
     * The name of the file that will be used when downloading the document. The extension in the filename will be used as the document type to be loaded (e.g. myfile.docx will treat the file as docx) if no extension option is passed.
     */
    filename?: string;
    /**
     * If set to true then when loading a document using WebViewer Server the document will always switch to client only rendering allowing page manipulation and the full API to be used.
     */
    forceClientSideInit?: boolean;
    /**
     * If set to true then when loading an office document, it'll be converted to a PDF file. This allow page manipulation and other features to be used
     */
    loadAsPDF?: boolean;
    /**
     * Enable PDFNet.js library functions
     */
    fullAPI?: boolean;
    /**
     * URL path to a document to load on startup. If an array of 2 or more documents is passed, webviewer will enable multi-tab mode.
     */
    initialDoc?: string | string[];
    /**
     * Set user permission to admin
     */
    isAdminUser?: boolean;
    /**
     * Set user permission to read-only
     */
    isReadOnly?: boolean;
    /**
     * License key for viewing documents. If not set then WebViewer will be in demo mode.
     */
    licenseKey?: string;
    /**
     * Whether the viewer should redirect to a new window or not when loaded on a mobile device
     */
    mobileRedirect?: boolean;
    /**
     * Type of workers to be preloaded. See {@link WorkerTypes WorkerTypes} to see all available options. You can also include multiple types comma separated e.g. `${Webviewer.WorkerTypes.PDF},${Webviewer.WorkerTypes.OFFICE}`
     */
    preloadWorker?: string;
    /**
     * A string representing the "backend type" for rendering PDF and Office documents. Pass "asm" to force the use of the ASM.js worker, "ems" to force the use of the WebAssembly worker (or ASM.js on non-wasm browsers) or "wasm-threads" to use threaded WebAssembly.
     */
    backendType?: string;
    /**
     * A boolean indicating whether Downloader should be used on urls (PDF only). https://www.pdftron.com/documentation/web/guides/usedownloader-option/.
     */
    useDownloader?: boolean;
    workerTransportPromise?: {
        pdf?: (...params: any[]) => any;
        office?: (...params: any[]) => any;
    };
    /**
     * The URL path to the hosted WebViewer Server
     */
    webviewerServerURL?: string;
    /**
     * Set server to ignore health failures. For usage with setups using a single server
     */
    singleServerMode?: boolean;
    /**
     * Disables console logs coming from WebViewer, including the version and build numbers
     */
    disableLogs?: boolean;
    /**
     * Enables view state annotations (double clicking a sticky annotation will reset the viewer to the state it was in when the annotation was created)
     */
    enableViewStateAnnotations?: boolean;
    /**
     * Path to UI folder to use a different UI or customized UI. Default is'./ui/index.html'.
     */
    uiPath?: string;
    /**
     * If true then it moves the notes panel into a tab inside the left panel
     */
    notesInLeftPanel?: boolean;
    /**
     * If true then newly added annotations will be selected automatically
     */
    selectAnnotationOnCreation?: boolean;
    /**
     * If true then the UI will use high contrast colors to help with accessibility.
     */
    highContrastMode?: boolean;
    /**
     * The XFDF retriever that will be called when a document is being loaded. The retriever should return a Promise which should resolve to the XFDF string that is going to merged into the document
     */
    documentXFDFRetriever?: Core.DocumentViewer.DocumentXFDFRetriever;
    /**
     * A boolean indicating whether to use http or streaming PartRetriever, it is recommended to keep streaming false for better performance. https://www.pdftron.com/documentation/web/guides/streaming-option.
     */
    streaming?: boolean;
    /**
     * An object to add/edit additional translations data for a specific language
     */
    additionalTranslations?: {
        language: string;
        translations: {
            key: string;
            value: string;
        };
    };
    /**
     * If true than the usage of indexedDB will be disabled for webviewer **Multi-tab Only**.
     */
    disableIndexedDB?: boolean;
};

/**
 * A function that creates an instance of WebViewer, and embeds it on the HTML page
 * @example
 * WebViewer({
 *       licenseKey: 'Insert commercial license key here after purchase'
 *     }, document.getElementById('viewer'))
 *       .then(function(instance) {
 *         const documentViewer = instance.Core.documentViewer;
 *         const annotationManager = instance.Core.annotationManager;
 *         // call methods from instance, documentViewer and annotationManager as needed
 *
 *         // you can also access major namespaces from the instances as follows:
 *         // const Tools = instance.Core.Tools;
 *         // const Annotations = instance.Core.Annotations;
 *       });
 * @property WorkerTypes - The types of workers that can be preloaded in WebViewer
 * @property BackendTypes - The types of backend workers.
 * @returns A promise resolved with WebViewer instance.
 */
declare function WebViewer(options: WebViewerOptions, viewerElement: HTMLElement): Promise<WebViewerInstance>;

/**
 * Used to preload workers before a document has been loaded.
 * @example
 * WebViewer({
 *    preloadWorker: `${WebViewer.WorkerTypes.PDF},${WebViewer.WorkerTypes.OFFICE}`
 *  })
 *  .then(function(instance) {
 *     ...
 *   });
 */
declare type WorkerTypes = {
    /**
     * To preload the PDF worker object
     */
    PDF: string;
    /**
     * To preload the Office worker object
     */
    OFFICE: string;
    /**
     * To preload the Legacy Office worker object
     */
    LEGACY_OFFICE: string;
    /**
     * To preload the content edit worker object
     */
    CONTENT_EDIT: string;
    /**
     * To preload all the workers objects
     */
    ALL: string;
};

/**
 * The types of backend workers.
 * Pass "asm" to force the use of the ASM.js worker, "ems" to force the use of the WebAssembly worker (or ASM.js on non-wasm browsers) or "wasm-threads" to use threaded WebAssembly.
 */
declare type BackendTypes = {
    /**
     * 'asm' Use of ASM.js worker.
     */
    ASM: string;
    /**
     * 'ems' Use of the WebAssembly worker (or ASM.js on non-wasm browsers).
     */
    WASM: string;
    /**
     * 'wasm-threads' Use of threaded WebAssembly worker.
     */
    THREADED_WASM: string;
};

/**
 * Gets an already existing instance of WebViewer. If only one instance of WebViewer exists on the page,
 * then 'element' is not required, and the function will return the instance of WebViewer.
 * If more than one instance of WebViewer exists, you must pass in the DOM element containing the
 * instance of WebViewer you want to retrieve. This function can be imported directly as a module as well.
 * @example
 * import { getInstance } from '@pdftron/webviewer'
 *
 * // After WebViewer has already been constructed
 * const instance = getInstance();
 * @param [element] - The DOM element containing the instance of WebViewer you want to retrieve
 * @returns Returns an instance of WebViewer. Returns null if no instances are available.
 */
declare function getInstance(element?: HTMLElement): WebViewerInstance;


  